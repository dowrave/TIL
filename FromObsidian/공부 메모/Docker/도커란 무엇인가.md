- 서버 관리는 복잡하고 어려우며 고급 개발자들의 섬세한 작업이 필요한 영역이다.
- DevOps의 등장으로 개발주기가 짧아지고 배포는 더 자주 이뤄졌다. 마이크로서비스 아키텍쳐가 등장하면서 관리는 더 복잡해졌고, 새로운 툴은 나오고, 클라우드도 발전해서 설치해야 할 서버가 수백 ~ 수천 대에 이를 지경에 도달했다. 그리고 **도커가 나오면서 서버 관리 방식이 완전히 바뀌었다.**
- 도커는 2013년에 Pycon 컨퍼런스에서 처음 알려졌다.

### 도커란?
- `컨테이너` 기반의 오픈소스 `가상화 플랫폼`이다.

##### 컨테이너
- 화물선에 들어가는 화물 그 **내용물이 무엇이든 `컨테이너`라는 덩어리로 표준화되어 관리되고 있고**, 이 때문에 다양한 운송수단으로 쉽게 옮길 수 있다.
- 서버에서 얘기하는 컨테이너 또한 **다양한 프로그램, 실행 환경을 컨테이너로 추상화하고 동일한 인터페이스를 제공해 프로그램의 배포 및 관리를 단순하게 해준다.**
- 백엔드 프로그램, DB 서버, 메시지 큐 등 어떤 프로그램도 추상화할 수 있고, 조립PC, 클라우드(AWS, Google Cloud, Azure) 어디에서든 실행할 수 있다.

##### 컨테이너의 가상화 방식
- 이전의 가상화방식은 OS를 가상화하는 방식이었다 
	- `VMWare`나 `VirtualBox` 등의 가상 머신은 Host OS 위에 Guest OS 전체를 가상화하여 사용하는 방식이었다.
	- 이는 여러 OS를 가상화할 수 있고, 사용법이 간단하나 무겁고 느려 운영 환경에선 사용할 수 없었다.
- 이를 개선하기 위해 CPU의 가상화 기술을 이용하거나, 반가상화 방식도 등장했다.
	- 게스트 OS가 필요하지만 전체 OS를 가상화하는 방식은 아니어서, 호스트형 가상화 방식보다 성능이 향상되었다.
	- 이러한 기술들은 `Openstack`, `AWS`, `Rackspace` 같은 클라우드 서비스에서 가상 컴퓨터 기술의 기반이 되었다.
- 위의 추가적인 OS를 설치하여 가상화하는 방법은 성능 문제가 있었다.

- 그래서 아예 **프로세스를 격리**하는 방식이 등장했다.
- 리눅스에선 이를 `리눅스 컨테이너`라고 하고, `프로세스`만을 격리하므로 가볍고 빠르게 동작했다. CPU, 메모리는 프로세스가 필요한 만큼만 추가로 사용했고, 성능적으로도 거의 손실이 없었다.
	- 도커의 기본 네트워크 모드는 `Bridge`로, 약간의 성능 손실이 있다.
	- 네트워크 손실이 중요하다면 `--net=host` 옵션이 필요하다.
- 따라서, 하나의 서버에 여러 컨테이너를 실행하면 서로 독립적으로 실행되어 가벼운 Virtrual Machine을 사용하는 느낌을 준다. 

##### 이미지
- **컨테이너 실행에 필요한 파일과 설정값 등을 포함하고 있는 것**으로, 상태값을 갖지 않고 변하지 않는다. 
	- `컨테이너는 이미지를 실행한 상태`라고 볼 수 있고, 추가되거나 변하는 값은 컨테이너에 저장된다.
	- 같은 이미지에서 여러 컨테이너를 생성할 수 있고, 컨테이너의 상태가 바뀌거나 삭제되더라도 이미지는 그대로 남아있다.
	- 우분투 이미지는 우분투를 실행하기 위한 모든 파일을 가지고 있음
	- MySQL 이미지는 MySQL을 실행하는데 필요한 파일, 명령어, 포트 정보를 가짐
- **이미지는 컨테이너를 실행하기 위한 모든 정보를 가지고 있음** 
	- 즉, 더 이상 의존성 파일을 컴파일하고 이것저것 설치할 필요가 없음
	- 새로운 서버가 추가되면, 미리 만들어 놓은 이미지를 다운 받고 컨테이너를 생성하기만 하면 됨.
- 도커 이미지는 `Docker Hub`에 등록하거나, `Docker Registry` 저장소를 직접 만들어 관리할 수 있다.

#### 이미지
- 도커 이미지는 컨테이너를 실행하기 위한 모든 정보를 가지고 있어 용량이 수백 메가바이트에 이른다. 
	- 이미지에 사소한 변경이 있다고 수백 메가바이트를 다시 다운 받아야 한다면 비효율적일 것임
- 이를 위해 도커엔 `레이어` 라는 개념이 있고, `유니온 파일 시스템`을 이용해 여러 레이어를 하나의 파일 시스템으로 사용할 수 있게 한다.
	- 이미지는 여러 개의 읽기 전용 레이어로 구성되어 있고, 파일이 추가되거나 수정되면 새로운 레이어가 생성된다.
	- 예시
		- 우분투 : A + B + C
		- 우분투 기반 nginx : A + B +C + Nginx
		- Nginx 기분 웹앱 : A + B+ C + Nginx + 웹앱
		- 웹앱 소스 수정 : A + B+ C + Nginx + 웹앱(수정Ver)
	- 위의 예시처럼 웹앱을 수정한다면 기존 Nginx까지의 레이어는 유지한 채 새로운 웹앱 레이어만 다운받으면 되므로 효율적이다.
	- 컨테이너 생성 시에도 레이어 방식을 사용, 기존 이미지 레이어 위에 `읽기 / 쓰기` 레이어를 추가한다. 컨테이너가 실행 중에 생성되는 파일, 변경되는 내용은 이 `읽기 / 쓰기`레이어에 저장되므로 여러 컨테이너가 생겨도 최소한의 용량만을 쓴다.

##### 이미지 경로
- 이미지는 url 형식으로 관리되며 태그를 붙일 수 있다.
	- ubuntu 14.04 : `docker.io/library/ubuntu:14.04` or ` docker.io/library/ubuntu:trusty` or 'ubuntu:14.04'
- 태그 기능을 잘 이용하면 테스트, 롤백도 쉽게 할 수 있다.

#### Dockerfile
- 도커는 이미지를 만들기 위해 `Dockerfile`이라는 파일에 자체 `DSL:Domain-Specific Language` 언어를 이용해 이미지 생성 과정을 적는다
```dsl
FROM subicura/vertx3:3.3.1

MAINTAINER chungsub.kim@purpleworks.co.kr

ADD build/distributions/app-3.3.1.tar /

ADD config.template.json /app-3.3.1/bin/config.json

ADD docker/script/start.sh /usr/local/bin/

RUN ln -s /usr/local/bin/start.sh /start.sh

EXPOSE 8080

EXPOSE 7000

CMD ["start.sh"]
```
- 서버에 어떤 프로그램을 설치하기 위해 의존성 패키지 설치 + 설정 파일을 만들었다면, 이를 블로깅하거나 메모장에 적지 않고 그냥 `Dockerfile`로 관리하면 된다.
- 이 파일은 소스와 함께 버전이 관리되고 누구나 이미지 생성과정을 보고 수정할 수 있다.