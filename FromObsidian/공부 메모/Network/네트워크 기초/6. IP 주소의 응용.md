## 1. IP 주소와 서브넷
- IP주소도 있고 MAC 주소도 있고~
- IP 주소는 IP 프로토콜에서 사용하는 주소, 즉 **인터넷에서 사용하는 주소**이다.
	- 네트워크 주소를 통해 **송신자와 수신자를 구별**할 수 있음
	> 유사) `PSTN(전화네트워크)`의 전화기를 식별하기 위해 전화번호가 있다
	> 전화번호엔 국번 + 가입자 번호 + 지역 번호 + 국가 코드 등이 존재함

- 인터넷에 연결된 시스템을 구분하기 위해 **32비트 주소**를 쓴다.
	- 국내에선 `한국인터넷진흥원 KISA` 에서 관리 중
- IP 주소는 연결주소
	- `연결주소` : 시스템의 연결 당 하나 씩 할당되는 주소
![[Pasted image 20221222192921.png]]
- 1바이트 단위로 10진수 표기를 하며 바이트 경계는 .을 찍어 구분함
	- 10진수를 쓰기 떄문에 `DDN : Dotted-Decimal Notation`이라고도 함(안중요)

### 클래스 구분 주소
- 옛날에 많이 썼는데 지금도 개념 자체는 많이 얘기됨
- IP주소가 A,B,C,D,E 5개의 클래스로 구분됨
![[Pasted image 20221222193137.png]]
> 각 네트워크는 규모가 다름
> 규모가 큰 곳엔 클래스 A를 할당하고, 규모가 작은 곳엔 클래스 C를 할당함
- 이 클래스를 구분하는 방법: 가장 앞의 비트
	- 0으로 시작하면 클래스A
	- 10으로 시작하면 클래스B
	- 110으로 시작하면 클래스C ...
- 그리고 이에 따라 네트워크 부분이 1byte인지 2byte인지 3byte인지 구분함
- 클래스D는 `멀티캐스트`에서 사용함
- 클래스 A,B,C는 `유니캐스트`
- 클래스 E는 예비
![[Pasted image 20221222193437.png]]
> 클래스A는 나눠주는 입장에서, 규모가 크기 때문에 많이 나눠줄 수 없음(1byte로 명시되니까 2^8) / 한편 받은 입장에서는 많이 나눠줄 수 있음
> 클래스C는 많이 나눠줄 수 있으나, 받은 입장에서는 최대 256개를 할당해줄 수 있는 구조

#### Netid와 Hostid
- `Netid` : 각 네트워크를 구분하는 네트워크 식별자
- `Hostid` : 네트워크 내의 호스트를 구분하는 호스트 식별자
![[Pasted image 20221222193719.png]]

- 특별한 용도로 사용되는 주소는 시스템에 할당되지 않음
	- `netid.255, hostid.255.255.255.255`와 같이 `hostid` 부분이 모두 1인 주소
	- `netid.0`와 같이 `hostid` = 0인 주소는 해당 네트워크를 의미함
	- Class A : `netid`가 127인 경우 loopback을 의미함 : 특정 네트워크에 할당되지 않음

  예시)
  ![[Pasted image 20221222194013.png]]
  - `160.6`이란 주소를 받았다면
	  1. `160.6.0.0` 인 시작 주소는 특정 컴퓨터에 할당되지 않음
	  2. `160.6.255.255`인 마지막 주소도 브로드캐스팅 용도라 할당되지 않음
		  - 브로드캐스팅은 해당 LAN까지만 전달되고 라우터를 넘어서 전송되지는 못한다. `Limited Broadcasting`이라고 함
- 즉 시작 주소와 마지막 주소를 제외한 나머지 주소를 할당할 수 있다

- IP주소는 이렇게 `netid + hostid`로 구분된 주소 구조를 가졌고, 기관 외부에서는 `netid`만으로 라우팅을 수행했음
- 근데 기관 내부가 여러 개의 서브 네트워크로 구성된 경우, 이 **서브 네트워크들을 구분할 방법**이 필요함

### 서브넷 주소설정(Subnetting)
- `서브넷팅(Subnetting)` : `hostid`의 일부를 사용해 네트워크를 `서브넷(Subnet)`으로 구분하고, 각 서브넷에 서브넷 식별자를 할당함
- 예시) `134.75`라는 B 클래스 주소를 받았다고 하자
	- 기존엔 `134.75.0.1 ~ 134.75.255.254`를 모두 할당 대상에 넣었음
	- 그 대신
		- `134.75.1`은 부서A
		- `134.75.2`는 부서B
		- `134.75.3`은 부서C
	- 라는 식으로 `hostid` 일부를 `subnet id`로 사용할 수 있음 
	- 이렇게 하면 어떤 네트워크에 문제가 생겼는지 손쉽게 파악할 수 있음
- 즉 Hostid의 일부를 내부 네트워크의 식별자로 사용해 관리의 효율을 늘릴 수 있음
![[Pasted image 20221222194846.png]]

#### 마스크(Mask)
- 서브넷팅이 호스트의 일부를 사용하기 때문에, 어디까지가 네트워크 부분인지 애매해짐
- 네트워크 부분을 구분하기 위해 `서브넷 마스크(Subnet Mask)`라는 개념이 생김

> 기존 클래스 구분 
>> **1번째 바이트**로 `netid`와 `hostid`가 구분되는데, 이를 `기본 마스크`라고 함

라우팅은 외부에서는 `netid`를 기반으로, 내부에서는 `netid`와 `subnet 식별자`를 기반으로 하게 됨 

- 마스크는 DDN으로 표기
	- 사선(Slash)이나 CIDR 표기를 사용
		- 이 둘은 netid, subnet id 위치를 '1'비트 수로 표기함
		- Hostid는 0비트로 표기함
![[Pasted image 20221222195241.png]]
- 전부 마스크를 표기하는 방식임
- **마스킹은 들어오는 IP주소와 AND연산을 통해 진행**하며 이 **결과로 나오는 게 네트워크 주소**임

>예시
>>134.75.0.0 의 B 클래스 주소를 모든 시스템에 할당 가능
>>실제 기업의 네트워크가 하나의 LAN으로 구성되지 않았기 때문에 부서별로 `134.75.1`, `134.75.2` 등 `hostid`의 일부를 `subnet id`로 사용할 수 있다.


## 2. 가변길이 주소

### 가변길이 주소지정(Classless addressing)

- 클래스 구분 IP 주소의 문제점
	- 할당받는 IP주소는 항상 클래스를 기반으로 정확한 양의 IP주소를 받을 수 없음

> 예를 들면 벤처 기업에서 사용하는 컴퓨터가 10대임
>> 근데 클래스의 최소 단위는 256임
> 이렇게 필요한 양만큼 주소를 받지 못하는 문제가 있다는 거임

- 가변길이 주소지정은
	- 클래스 구분이 필요 없어짐
	- 32비트 전체 공간에 대한 효율적인 주소 지정이 가능

#### 가변길이 주소할당 규칙
- 할당 주소 수는 $2^n$ 이어야 함
- 할당 주소는 연속적이어야 함
- 시작 주소는 할당하는 주소의 수로 나눠떨어짐

	> 뭔소린가용?
	>> `240.20.35.32 ~ 240.20.35.47` 이라는 IP를 할당받았다고 하자
	>> 16개를 할당 받은 거죠? 시작 주소는 `32`임
	>> `32`는 16으로 나눠떨어지죠? ㅇㅋ

![[Pasted image 20221222200240.png]]
- 이진법에서 가장 끝의 4개 비트를 보자
	- 0010 + `0000` ~ 0010 + `1111`
	- 여기서 앞의 28개의 비트는 `네트워크 부분`
	- 뒤의 4개의 비트는 특정 컴퓨터에 할당하는 주소임
- 물론 앞에서 다뤘던 **맨 처음 주소와 마지막 주소를 할당할 수 없다는 점은 동일**함
- 따라서 실제 할당할 수 있는 IP주소는 14개

- 따라서 `Class Full`에 비해 필요한 대수만큼만 할당할 수 있는 구조가 생긴 것이다
- 이를 `Classless Addressing`이라고 함

##### Mask
- 마스크는 Slash로 표기
- **시작 주소와 마스크**가 주어져야 함
	- 주소 + 마스크가 주어지면 네트워크 주소를 구할 수 있다.
	- `240.2.35.36/28`로 주어진 주소와 마스크가 있다면
		- 네트워크 주소는 `240.20.35.32`
			- `/28`이 `28번째 비트`니까 28번째 비트까지가 네트워크 비트라는 얘기임
			- `xxxxxxxx xxxxxxxx xxxxxxxx xxxxOOOO`
			- `x`부분이 네트워크 비트
			- `O`부분이 호스트 비트

##### Subnetting
- 대규모 주소가 할당된 그룹에선 서브넷을 만들고, 다른 서브넷 간 주소를 나눌 수 있음
- 모든 메시지는 그룹을 인터넷 나머지 부분에 연결하는 라우팅 주소로 전송
	- 라우터는 해당 서브넷에 메시지를 라우팅

- 어떻게 서브넷팅해야 함?
	- 그룹에 부여된 총 주소의 수가 $N$
	- 접두사 길이를 $n$
	- 각 하위 네트워크에 할당된 주소 수를 $N_{sub}$
	- 각 하위 네트워크의 접두사 길이를 $n_{sub}$ 라고 하자
$$
n_{sub} = 32 - log_2N_{sub}
$$
>예시
> 그룹에 64개의 주소를 포함하는 블록 `24.36.15.0/26`이 있다고 가정하자
> 이 64개의 주소를 `32, 16, 16`으로 3개로 나눈다면
> $n_1 = 32-log_2N_{sub1} = 32-log_2(32) = 32 - 5 = 27$
> $n_2 = 32-log_2N_{sub2} = 32 - 4 = 28$ ($n_3$도 동일)
> 따라서 사용되는 마스크는 $27, 28, 28$이 됨

- 비트를 생각하면 그렇게 어려운 개념은 아닐 것임

