1. 선택 정렬 $O(n^2)$
```python
for i in range(len(arr)): # 기준 인덱스
	min_idx = i
	for j in range(i+1, len(array)):
		if array[min_idx] > array[j]:
			min_idx = j

	arr[i], arr[min_idx] = arr[min_idx], arr[i]
print(arr)
```
> `5 4 3 2 1`
> `min_idx = 0, 값은 5`
> 4와 비교 : `min_idx = 1`
> ... 결국 1로 도달한 다음 가장 작은 값과 현재 인덱스를 교환

2. 삽입 정렬 $O(n^2)$
- 정렬이 거의 되어 있다면 $O(n)$ 에 가까워짐
```python
for i in range(1, len(arr)):
	for j in range(i, 0, -1):
		if arr[j] < arr[j-1]:
			arr[j-1], arr[j] = arr[j], arr[j-1]
		else:
			break
```


3. 퀵 정렬$O(Nlog(N))$
- 이미 정렬되어 있다면 $O(N^2)$
```python
def quick_sort(arr, start, end):
	if start >= end:
		return
	pivot = start
	left = start + 1
	right = end

	while left <= right:
		while left <= end and arr[left] <= arr[pivot]:
			left += 1
		while right > start and arr[right] >= arr[pivot]:
			right -= 1
		if left > right:
			arr[pivot], arr[right] = arr[right], arr[pivot]
		else:
			arr[left], arr[right] = arr[right], arr[left]

	# 재귀
	quick_sort(arr, start, right - 1)
	quick_sort(arr, right + 1, end)
```
- `pivot` 값을 설정하고 나머지 값들에 대해 `pivot`값과 비교함
- `left` : `pivot`값보다 작은 경우 계속 1씩 증가
- `right` : `pivot`값보다 큰 경우 계속 1씩 감소
- 두 while문이 멈추는 지점 : `left` 인덱스의 값이 `pivot`보다 크고, `right` 인덱스의 값이 `pivot`보다 작은 지점
- 그 곳에서 `인덱스 : left > right`라면 `right`의 값을 `pivot`값과 교환
- 그게 아니면 `left`와 `right`의 값을 교환 
- `pivot` 값이 `right`로 갔기 떄문에, 이후 재귀함수에서는 `right-1`까지와 `right+1`부터 다시 정렬을 시행한다.


4. 계수정렬

```python
count = [0] * (max(arr) + 1)

for i in range(len(arr)):
	count[arr[i]] += 1

for i in range(len(count)):
	for j in range(count[i]):
		print(i, end= " ")

```
