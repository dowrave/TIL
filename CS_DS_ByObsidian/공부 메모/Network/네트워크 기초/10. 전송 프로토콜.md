## 1. 전송 프로토콜과 UDP

- 데이터링크 계층은 이웃한 두 노드 사이의 프레임 전달에 관여한다.
- 네트워크 계층은 여러 노드를 거친 최종 목적지와 처음 송신자 사이에 정보를 교환하는 관점이다. `Host to Host Delivery`라고도 함.
- 전송 계층은 **프로세스 - 프로세스 간의 통신을 관장하는 계층**이다.
	- `프로세스` : 실행 중인 프로그램
	- 프로세스 간의 전달에 사용되는 게 `포트 번호`이다.

![[Pasted image 20221223173022.png]]
- 여기서 각 점이 `노드`임
	- 즉 데이터링크 계층은 **이웃한** 두 노드 사이의 전송을 관장함
		- **에러 제어**, 흐름 제어, 접근 제어
	- 네트워크 계층은 시작 컴퓨터 ~ 끝 컴퓨터까지의 전송을 관장함
		- **라우팅** : 어떤 경로를 갖는 것이 가장 좋을까?

- 전송 계층 : 
 ![[Pasted image 20221223173327.png]]
 - 송신자의 컴퓨터 내의 어플리케이션과 수신자의 컴퓨터 내의 어플리케이션 간의 정보 교환에 관련한 계층이 수송 계층이 된다.

#### 클라이언트 / 서버 구성
- 프로세스 간의 통신은 클라이언트 / 서버 구성을 통해 이루어짐
	- `서버` : 서비스를 제공함. 요청을 기다림
	- `클라이언트` : 프로그램을 실행시켜 서비스를 받고 싶은 서버에 접속해서 서비스를 제공받음

	>웹 브라우저는 프로세스이자 클라이언트 프로그램
	   마찬가지로 어떤 웹 페이지에 접속해 정보를 제공받는다고 할 때 웹 서버도 프로세스를 돌리고 있음
- 이 때, 컴퓨터 1대에는 여러 개의 프로세스가 돌아가고 있기 때문에 **어떤 프로세스에 정보를 전달할지 구분이 필요**하다. 여기서 등장하는 게 **포트 번호**이다.

#### 포트 번호
- 여기서 말하는 포트 번호는 컴퓨터에 꼽는 물리적인 포트 번호가 아닌, `논리적인 포트 번호`이다.
- 즉, **컴퓨터 내부에서 프로세스들을 구분하는 구분자**가 포트 번호인 것
- 수송 계층에서 사용하는 주소
- 16비트 정수로, 0 ~ 65535 사이의 값을 갖는다.
	- TCP나 UDP 포트번호 필드의 크기가 16비트이므로 0 ~ 65535번의 포트 번호가 가능함

- 클라이언트 / 서버 에 따라 포트 번호도 나뉘게 된다. 
	- `클라이언트 프로그램` : 포트 번호가 일시적으로 할당되고 사라지는데, `임시 포트 번호Ephemeral Port Number`라고 한다.
	- `서버 프로그램` : 인터넷에서 식별을 위해 동일한 포트 번호를 갖는다.  `알려진 포트 번호Well-Known Port Number`

- 예시
![[Pasted image 20221223174316.png]]
 >클라이언트가 프로그램을 실행시킴 : 52000번 포트를 사용함
 >서버의 포트 번호에 요청이 들어감 : 이 때 클라이언트의 포트 번호도 명시됨
 >서버에서 요청을 받으면 데이터를 클라이언트로 보냄
 >참고) 저 서버를 찾아가는 건 IP주소를 이용함
 
##### 포트 번호 지정
- IANA(Internet Assigned Numbers Authority)는 포트 번호를 3개의 영역으로 구분함
	- `Well-Known Ports` : `0 ~ 1023`이 할당, 인터넷 서비를 위해 사용됨
		- 전세계적 통용 & 표준, 엄격하게 관리됨 
	-  `Registered Ports` : `1024 ~ 49151` : 특정 응용을 위해 기업이 사용함 
		- 중복이 일어나지 않도록 등록해서 사용할 수 있는 여지가 있음
	- `Dynamic Ports`: `49152 ~ 65535` : 임시 포트로 사용됨(클라이언트)

### UDP(User Datagram Protocol)
- 비연결형, 비신뢰성 수송 프로토콜
	- `Unreliable` : 데이터가 가다가 사라질 수 있음
	- 흐름제어, 에러제어가 없음
		- UDP에서 에러 검출 시 단순히 폐기
	- 연결 설정, 종료 과정 없음
	- 데이터그램 사이에 관련이 없고 번호가 붙지 않음
	- 각 UDP 데이터그램은 서로 다른 경로로 전달됨
		- 수신 메시지가 오버플로우될 수 있음
		- 송신자는 메시지의 유실/중복 여부를 알 수 없음

- 이럼에도 UDP는 효율성이 굉장히 좋음
	- 수시로 없어지는 구조가 아님
	- 오버헤드가 작작은 단순한 프로토콜에 이용함
![[Pasted image 20221223175017.png]]
> `DNS`
>>도메인 주소(www.~~~)와 IP주소를 변환해주는 인터넷 서비스
>> UDP 53번을 할당 받음
>> 즉 DNS = UDP 포트번호 53번
>> DNS 서버에 저장되기도 하지만 로컬 캐시에 저장하기도 하며, DNS 서버에 도달하는 쿼리의 수가 많이 감소함.
>: `SNMP`
>>여러 개의 통신 장치를 관리하기 위한 인터넷 표준 프로토콜

#### User Datagram
![[Pasted image 20221223175326.png]]
- 헤더의 크기 : 8바이트(고정)
- 체크섬 계산은 선택사항
	- `체크섬` : 데이터에 에러가 있는지를 검사
	- 계산되지 않으면 해당 필드 값은 0

- 체크섬 방법
	- IP나 ICMP와 달리 가상헤더를 만들어서 계산함
		- 가상 헤더는 IP 패킷의 헤더에서 가져온 정보로 구성함
		- 송신자 IP 주소, 목적지 IP 주소, 프로토콜 필드, 전체 길이 필드로 구성
	- IP 헤더가 잘못되면 잘못된 호스트나 잘못된 수송 계층 프로토콜로 전달되므로 한번 더 검사함 

#### UDP 사용
- 간단한 요청 & 응답 서비스에 적합함 
	- 간단하게 메시지 1개를 주고 받는 수준이라면 "요청을 주고 응답을 받은 다음에 데이터를 교환"하는 것보다 훨씬 빠름
	- 이를 연결설정 / 해제 과정의 **오버헤드가 없다**고 표현함
- 프로세스에서 내부 흐름제어와 에러제어를 갖는 경우에 적합함
	- 응용 프로그램이 자체적으로 갖는 기능을 중복해서 가질 필요가 없으니까
- 멀티캐스팅에 적합함
	- 연결 설정할 필요가 없으니까
- SNMP처럼 망을 관리할 때 UDP를 사용함


## 2. TCP 프로토콜
- 프로세스 간 통신, 스트림 전달 서비스, 전이중 통신, 연결 지향 서비스, 신뢰성 있는 서비스를 제공함
	- `전이중 통신Full Duplex` : 데이터 송수신을 동시에 할 수 있음
	- 연결 설정 & 해제 과정이 존재
	- `ACKnowledgment`을 확인함
		- 대화에서 듣고 있다는 신호로 ㅇ ㅇ 보내는 것과 동일
- 수송 계층 밑의 네트워크 계층에서 쓰는 IP 자체는 Unreliable함
	- 패킷 손실, fragmentation 발생 등 여러 문제가 발생할 수 있는데, 이를 TCP에서 복구해줌
		- 손실된 패킷을 다시 보내게 하거나
		- 순서가 바뀌어서 와도 맞춰 주거나 등등

- **TCP는 프로세스 간 통신을 위해 포트 번호를 사용**함
![[Pasted image 20221223180220.png]]
> FTP : 파일 송신 프로토콜
> TELNET : Remote Login 기능 
> SMTP : 이메일 프로토콜
> DNS : UDP를 먼저 써본 다음 안되면 TCP를 사용함

등등 순서대로 가야되고 분실되면 안되고 하는 것들은 모두 TCP를 사용한다.

#### 스트림 전달 서비스
- TCP는 데이터를 **바이트의 나열**로 전달함
	- 여러 바이트를 블록으로 구성된 세그먼트로 나눠 전송함

#### TCP의 특징
- 모든 바이트에 번호를 부여함
	- 시작 번호는 0 ~ 232 - 1 사이의 임의의 번호를 가짐
	- 번호는 흐름제어 & 에러제어에 사용됨
	- 세그먼트의 순서 번호는 세그먼트가 나르는 데이터의 1번째 바이트 번호
- ACK 번호는 수신해야 할 다음 바이트 번호
	- ACK 번호는 누적값 : 해당 번호 이전의 모든 바이트를 안전하게 받았음을 의미
		- EX) 1234라면 1233바이트까지는 모두 받았음을 의미함

#### 세그먼트 형태
- 세그먼트 : TCP 메시지 전체
![[Pasted image 20221223180707.png]]
- 왼쪽 위부터 송신자 주소, 수신자 주소, 순서 번호, ACK 번호, 헤더 길이, 여유 공간
- `제어 필드 : URG/ACK/PSH/RST/SYN/FIN` : 이 TCP 세그먼트가 어떤 세그먼트인지 나타냄(`1비트`)
	- 중복이 가능함(그래서 6비트 남겨놓은 듯? 각각이 1비트니까)
	- `URG` : URGent pointer is valid : 급한 데이터 
		- 이게 1이라면 `Urgent Pointer` 필드에 숫자가 들어가게 되고, 해당 숫자의 의미는 데이터부분에서 제일 앞부분에 Urgent Data가 들어가게 됨
		- 어디까지가 Urgent Data인지 모르기 때문에 필드가 따로 존재함
	- `ACK` : ACKnowledgment is valid
	- `PSH` : request for PuSH
		- 원래 TCP는 버퍼가 꽉 차야 TCP 세그먼트를 전송함
		- 버퍼가 꽉 차지 않더라도 바로 데이터를 보내라고 하는게 `PSH`
		- 바로바로 데이터를 주고 받아야 하는 `telnet` 등이 이용함
	- `RST` : ReSeT the connection
		- 비정상적 상황 & 오랫동안 통신이 없으면 현재 연결을 끊음
	- `SYN` : SYNchronize sequence numbers
	- `FIN` : Terminate the connection

- `Window Size` : 버퍼의 크기 표시
- `Checksum` : TCP에선 필수
	- UDP처럼 가상 헤더를 포함해서 계산함

- 헤더는 최소 20바이트, 옵션이 있으면 60바이트까지 존재함
	- 4바이트 단위로 표시함

### TCP 연결 설정과 해제
-  **`3단계 메시지 교환(Three-way handshake)`을 통해 연결 설정**
![[Pasted image 20221223181949.png]]
1. 클라이언트는 연결을 요청하는 `SYN` 세그먼트 전송 (->`SYN`)
2. 서버는 `SYN`과 `ACK`를 포함하는 세그먼트로 응답 (<-`SYN`+`ACK`)
		- `SYN`은 상호 교환이 일어나야 하는 것 같다
3. 클라이언트는 ACK를 보냄(->`ACK`)

- **연결 해제**
- 3단계와 4단계로 나뉨

- 3단계는 연결을 바로 끊음
![[Pasted image 20221223182129.png]]


- 4단계는 한쪽만 연결을 해제하고 다른 쪽은 연결이 남은 상태가 될 수 있음`Half-Close`
![[Pasted image 20221223182206.png]]
- **처음 응답**에 ACK + FIN을 보내는 게 아니라 **FIN만 보내줌**
- 이렇게 되면 클라이언트 -> 서버는 마무리가 되었으나, 서버 -> 클라이언트 연결은 살아있는 상태
- 서버가 클라이언트에 데이터를 다 보내주고 나면 그 때 `FIN`을 보냄

#### 흐름 제어 
- 송신 TCP가 목적지로부터 ACK를 수신하기 전에 보낼 수 있는 데이터의 양을 정함
	- TCP는 `슬라이딩 윈도우 프로토콜`을 이용함
		- `슬라이딩` : TCP는 바이트 순서 번호를 갖는데, 받을 수 있는 번호가 계속 증가하는 모습이 번호가 이동하는 것처럼 보여서 슬라이딩 윈도우라고 부른다
	- TCP는 바이트 단위로 윈도우 크기(수신 가능한 데이터 양)를 표시
	- 윈도우 크기는 시간에 따라 변할 수 있음
![[Pasted image 20221223182413.png]]
> 수신자가 자신의 버퍼 용량을 살핀 뒤, 수신자에게 얼마만큼 더 보내라고 요청을 날림
> 이전에 배웠던 것과 큰 맥락에서의 개념은 동일함


