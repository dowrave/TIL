- DP 사용 시 지나치게 많은 일을 한다는 것에 착안하여 고안됨
	- DP를 대체하진 않고 서로 보완적임

- 미래를 생각하지 않고 **각 단계에서 가장 최선의 선택**을 한다
- 결과적으로 항상 최선의 경우를 얻지는 못한다.

### 그리디 알고리즘을 쓰는 경우

1. 활동선택 문제
- 한 강의실에서 여러 수업을 하려 할 때, 한 번에 가장 많은 수업을 하는 경우의 수는?
	- `DP`로 풀 수도 있으나, 모든 경우를 고려해야 한다
	- `그리디 알고리즘`을 쓴다면, **가장 빨리 끝나는 활동**을 고르면 된다. 그 과정에서 겹치는 활동들은 걸러지고, 그 다음 고를 수 있는 것들 중 가장 빨리 끝나는 다음 활동을 또 고르는 방식으로 이뤄진다.

2. 분할 가능 배낭 문제 
- `냅색 문제`와 달리, 물건이 무겁다면 쪼갤 수 있다
- 그리디 알고리즘을 쓴다면,`쪼갠다 -> 무게 대비 가치가 높은 것부터 배낭에 넣는다` 식으로 구현하면 됨.