- 부등호와 start, end 갱신 조건을  주의하자
- 반복문과 재귀함수 모두 구현 가능하며, 여기선 반복문만 다룸
- **정렬된 배열**에서만 사용할 수 있다.
```python
def binary_search(arr, target):
	start = 0
	end = len(arr) - 1
	
	while start <= end: # 유의 1. <가 아니다
		mid = (start + end) // 2
		if arr[mid] == target:
			return mid
		elif arr[mid] > target:
			start = mid + 1
		else:
			end = mid - 1
```

- 그런데 주어진 배열에 **찾고자 하는 값이 1개라는 보장이 없다.** 
- 여러 개의 `target` 값을 가진 배열이 있을 때, 가장 왼쪽 인덱스`lowerbound`와 가장 오른쪽 인덱스`upperbound`를 찾을 수 있다.

- `lower_bound`
```python
def lower_bound(arr, target):
	start = 0
	end = len(arr) - 1
	ans = 0

	while start <= end: 
		mid = (start + end) // 2

		if arr[mid] >= target: 
			ans = mid
			end = mid - 1 
		else:
			start = mid + 1
	return ans
```

- `upper_bound`
```python
def upper_bound(arr, target):
	start = 0
	end = len(arr) - 1
	ans = 0 
	while start <= end: 
		mid = (start + end) // 2

		if arr[mid] <= target: 
			ans = mid
			start = mid + 1  
		else:
			end = mid - 1 
	return ans
```

-  일관성을 유지하고자 `ans`라는 변수를 만들어 넣었다.
- `ans`를 쓰고 싶지 않으면 
	- `lower_bound`에서는 `end = mid`로 갱신,  
	- `upper_bound`에서는 `start = mid`로 갱신
	- 한 다음 `end`값을 리턴하면 될 거임

---
### `bisect`
```python
from bisect import bisect_left, bisect_right
arr = [1, 2, 2, 2, 3]
print(bisect_left(arr, 2)) # 1
print(bisect_right(arr, 2)) # 4
```
- 정의 : 순서를 해치지 않으면서 `target` 값을 넣을 수 있는 인덱스
	- `bisect_left(arr, target)`은 `target` 값 중 제일 앞에 있는 인덱스를 반환한다.
	- **반면**, `bisect_right()`은 `target` 값의 `마지막 인덱스 + 1`를 반환한다.
