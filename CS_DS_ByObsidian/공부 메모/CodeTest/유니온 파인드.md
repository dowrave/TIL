- **두 노드가 같은 그래프에 속했는가**를 알아볼 때 사용함
- 동의어 : 서로소 집합, 상호 배타적 집합(Disjoint-Set)
- 노드를 합치는 Union 연산 + 루트 노드를 찾는 Find 연산
- 트리 구조로 이뤄진 자료 구조 중 하나로 생각되기도 한다.

---
### 실사용
```python
def find_parent(x):
	if parent[x] != x:
		parent[x] = find_parent(parent[x])
	return parent[x]
	# return x

def union(a, b):
	a = find_parent(a)
	b = find_parent(b)
	if a < b:
		parent[b] = a
	else:
		parent[a] = b

# 그래프에서 간선의 수 = union의 수가 됨
v, e = map(int, input().split())
parent = [i for i in range(v + 1)]

# 그 다음부터는 뭐 알아서 하세용
```
- `find_parent` : `return x` 도 가능한데 위처럼 구현하는 걸 경로 압축이라고 하나봄
- 보통 두 노드를 연결할 때, **큰 값에서 작은 값으로 향하게(즉 루트 노드는 연결된 그래프 중 가장 작은 값이 되게) 한다.**
- `union` 연산에서 `a=b` 조건은 필요 없음
---
### 알고리즘 설명

- 자기 자신을 값으로 갖는 8개의 독립된 노드를 생각해보자
```python
arr = [0, 1, 2, 3, 4, 5, 6, 7, 8]
```
- 이 중 어떤 노드들을 합치고 싶다면, 한 노드의 값을 연결된 노드의 값으로 바꿔주면 된다. ex) 1-2번을 합치고 싶다면, 2번 노드의 값을 1번으로 바꾼다
```python
arr[2] = 1
arr[5] = 4
arr[6] = 5
```

- 이런 식으로 설정되어 있다고 했을 때, 두 노드가 연결된 노드인가를 판별하는 방법은
> 각각의 노드를 쭉 따라가다 보면 결국 자기 자신을 값으로 갖는 노드를 만나게 될 것이다.
> 주어진 두 노드에서 출발해서 마지막에 도달한 루트 노드가 같다면 두 노드는 연결된 것이고, 아니라면 연결되지 않은 것이다.

- 그런데 자식이 한쪽으로만 몰려 있다면, 탐색에 시간이 오래 걸리게 된다. 이를 위해 **각각의 노드에는 그 노드의 루트 노드를 저장**한다.

