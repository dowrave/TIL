- 9장인 파이프라이닝은 7장에서 다뤘기 때문에 패스함


## CPU의 청동기 - 어셈블러

- 프로그램을 만들 때, 함수 외에도 변수가 필요했음
- 변수는 "`상태State`값을 정의하는 공간으로, 이 **상태값**이 **입력**과 함께 **프로그램**의 적절한 **출력**을 만들어낸다"
	- `(3 + 4) * 5`라는 연산을 앞에서 배운 컴퓨터의 구조와 연결해보면, ALU에서는 한 번에 한 가지 연산밖에 할 수 없으므로 3 + 4을 수행한 다음 레지스터 / 메모리에 저장하고 다시 이 결과값을 5로 곱하는 식으로 진행됐음을 알 수 있음
	- 이 때 **중간에 저장되는 저장공간이 변수**가 되는 것이다.

- **입력** : CPU 입장에서 외부로부터 받아들여지는 모든 값들. 
- **출력** : 말 그대로 CPU의 출력값. 모니터의 화면, 음악, 글자 등등이지만, CPU 입장에서는 단순한 전기적 신호를 출력 핀으로 내보낸 것 뿐이고 다른 디바이스들이 전기적 신호를 다른 신호로 변환해준 것 뿐이다.

- 순차 논리회로란, 입력 + 상태값으로 출력을 만들어내는 것이었음
- **CPU는 순차 논리회로 중 하나**임
	- CPU는 메모리에 저장된 값을 입력과 함께 받아, 내부 레지스터의 상태값에 따라 출력을 결정하도록 하는 순차 논리회로임.
	- 이 때, 메모리에서 가는 입력값 = 순차 논리회로가 해야 할 일을 지정하는 `명령 = 인스트럭션`이 되는 것이었다.
	- 즉 인스트럭션도 순차 논리회로의 입력 중 하나인데, IO 장치 같이 외부로부터 데이터가 발생할 때마다 들어가는 비동기적 입력이 아니라, **메모리처럼 저장장치에 미리 입력값을 저장해놓고 입력값을 순차적으로 적용시킬 수 있기 때문에 프로그래밍이라는 개념이 생겼다.** 
		- 초창기 컴퓨터에서는 인스트럭션에 해당하는 입력을 사람이 외부에서 파이프를 조작해서 구성했다.

- CPU는 유연한 논리회로이기 때문에, 회로를 손보지 않고도 프로그래밍 만으로 다양한 프로그램을 만들 수 있었음

- 그러면 인스트럭션의 유연한 구성 + CPU 만으로 오늘날의 프로그래밍이 가능했는가?
- 인스트럭션은 0과 1로 이뤄진 숫자이므로, 가독성이 매우 부족했음
- 그래서 인간이 알아보기 쉬운 기호, 단어 형태로 바꾼 **어셈블리**라는 언어를 사용했다.

- `어셈블러Assembler` : 인스트럭션을 1:1로 맵핑해서 어셈블리로 작성할 수 있게 하는 프로그램 
```
[MIPS 인스트럭션]
00000 01000 01001 10000 00000 100000

[어셈블리어]
add $r16, $r8, $r9
```
이것만으로 인스트럭션을 바로 쓰는 것보다 훨씬 프로그램을 편리하게 만들 수 있게 되었다. 점프 주소를 직접 계산할 필요도 없어짐.

CPU라는 형태의 논리 회로 개발이 석기 시대라면  
어셈블리어를 사용한 건 청동기 시대에 비유할 수 있음.

하지만 단순히 인스트럭션을 인간의 눈에 보기 편하게 만든 어셈블리어로는 한계가 있었다.

## CPU의 철기 - 고급 언어
어셈블리어는 인스트럭션을 단순히 인간이 보기 편하게 만든 것이기 때문에, 필요한 지식 수준은 동일했다. 즉, **CPU에 대한 이해도, 내부 레지스터의 종류 파악, 각 인스트럭션의 동작 파악** 등등을 완전히 똑같이 이해하고 있었어야 했다.

따라서 **어셈블리어는 CPU 종속적일 수밖에 없다.** 사용되는 기기를 갈아엎어야 하는 일은 개발 상황에서 흔히 발생하는 일이다. 예를 들면 오락실의 보드와 가정의 PC는 완전히 다른 CPU를 쓰는데, 어셈블리어로 같은 게임을 다른 CPU에서 만든다면 완전히 다른 문법으로 작성해야 함. 

물론 어셈블리어는 꼭 나쁘진 않다. CPU에 종속적이기 떄문에, 그만큼 CPU를 세밀하게 제어할 수 있는 언어이기도 하며, 아주 적은 사이즈로 효율적인 프로그램을 개발할 수도 있다. (개발자가 컴파일러보다 똑똑해야 하지만) 따라서 매우 치밀한 속도를 요하는 핵심 알고리즘, CPU의 기능을 십분 활용해서 세밀한 조작을 해야 하는 경우는 여전히 어셈블리어를 활용한다.

하지만 **대다수의 프로그램은 CPU와는 거의 무관하게 이뤄져 있다.** 3D 프로그램의 행렬의 곱셈, 키보드 조작에 반응하는 캐릭터 동작, 자동으로 방해물을 피해 이동하는 인공지능 등은 CPU와는 아무 상관이 없는 순수한 알고리즘에 가깝기 때문에, **기기에 종속되지 않고 코드의 재사용이 가능한 표준 언어**를 찾기 시작했고, 이게 **고급 언어**이다.

고급 언어의 특징은
- CPU에 의존적이지 않음
- 인간의 입장에서 언어를 기술해도 인스트럭션으로 바꿔줌. 정확히는 컴파일러로 어셈블리로 바꾸고, 어셈블러로 인스트럭션으로 다시 바꾸는 셈이지만.

따라서 고급 언어는 1:1 변환이 아니라 통역가에 가까움. 

오락실 게임이든 콘솔 게임이든 핸드폰이나 냉장고에 들어가는 프로그램까지도 대부분 PC를 이용해서 개발된다. 대부분 C로 작성하고, 이를 컴파일하는 컴파일러를 해당 CPU에 맞는 것을 사용하는 것이다. 대부분 C나 C++로 작성하고 단순히 컴파일러만 바꾸면 된다.

- `크로스 컴파일러Cross Complier` : 다른 플랫폼의 인스트럭션을 생성해내는 컴파일러.

그러면, 단순히 고급 언어로 작성하고 컴파일러만 바꾸면 다른 플랫폼에서 동작하는 프로그램을 만들 수 있는 것일까? 답은 그럴 수도 있고 아닐 수도 있다이다.

단순한 계산 정도면 상관이 없지만, 이를 출력하는 경우를 가정해보자. PC에서 잘 작동했던 코드라고 가정하고, 이를 모바일로 옮기면 어떻게 될까? 컴파일러가 알아서 액정 내에 출력되도록 조절해줄까? 개발자가 그것까지 신경써서 만들어야 할까?

CPU 제조 회사에서 컴파일러가 함께 제공되는데, 이런 컴파일러는 CPU마다 하나이다. 삼성에서 핸드폰을 2개를 만들었고, 같은 CPU를 썼지만 디스플레이 사양은 다르다고 가정하자. 이런 경우까지도 컴파일러가 결과를 어떤 액정에 출력시킬지를 결정할 수 있을까? 

따라서, **다른 플랫폼에 대한 프로그램을 만들 때에는 컴파일러만 바꾸면 된다! 가 아니라, 하드웨어의 차이 등을 고려한 소스 수정들이 불가피하다.** 처음부터 여러 플랫폼에서 동작할 것을 고려해 하드웨어 의존적인 부분과 알고리즘 파트 등을 잘 구분해서 정의했다면, 알고리즘 파트를 새로 만들 필요 없이 하드웨어 의존적인 부분만 수정해서 다른 플랫폼에서 동작하는 프로그램 개발 기간을 줄일 수 있다.

이런 걸 가능하게 해주는 것이 고급 언어이다. 어셈블리어로 작성했다면, CPU가 바뀔 경우 전부 뜯어고쳐야 한다.

