## 용어 정리

- `명령어 메모리Instruction Memory`
	- **역할 :** **실행할 프로그램의 기계어 명령어를 저장하고 있는 메모리 공간.** CPU는 프로그램을 실행하기 위해 이 메모리에서 명령어를 순차적으로 가져온다.
	- **입력 :** 프로그램 카운터로부터 명령어 주소를 입력받는다.
	- **출력 :** 입력받은 주소의 32비트 명령어를 출력해 CPU의 다른 부분으로 보낸다.
	- **특징**
		- 데이터 메모리와 구분 : `MIPS`와 같은 하버드 아키텍처에서는 명령어를 저장하는 메모리와 데이터를 저장하는 메모리가 물리 / 논리적으로 구분되어 있을 수 있다. 이는 명령어 인출과 데이터 로드 / 저장이 동시에 일어날 때의 구조적 해저드를 방지할 수 있다. 폰 노이만 아키텍처에서는 구분될 수 있다.
		- 읽기 중심 : 프로그램 실행 중에는 명령어 메모리에서 명령어를 읽기만 한다. 

- `제어 유닛Control Unit`
	- 역할 : **CPU의 중앙 지휘소, 혹은 두뇌 같은 역할을 한다.** 명령어 메모리에서 가져온 명령어를 `해석Decode`하고, 그 명령어의 종류에 따라 데이터 경로의 다른 모든 구성 요소 `Register File, ALU, 데이터 메모리, 멀티플렉서 등`이 어떻게 동작해야 하는지를 지시하는 `제어 신호`를 생성해서 보낸다.
	- 입력 : 현재 실행할 명령어의 일부 (`OpCode 필드`, R 타입의 경우 `Funct` 필드까지)
	- 출력 : 데이터 경로의 각 부분에 필요한 다양한 제어 신호들을 출력
	- 동작 방식 : 제어 유닛 내부는 보통 조합 논리 회로로 구현된다. 입력된 명령어 코드에 따라 미리 정의된 규칙에 의해 해당 제어 신호들을 즉시 생성한다. 
	- 데이터 경로에서의 위치 : `ID` 단계에서 명령어를 해석하고 제어 신호들을 생성한다. 이 신호들은 EX, MEM, WB 단계에 걸쳐 데이터 경로의 각 요소를 제어한다.

- `레지스터 파일Regsiter File` : **개별 레지스터들의 집합을 묶어서 하나의 하드웨어 단위로 지칭하는 용어.**
	- MIPS의 경우 32개의 범용 레지스터를 포함하는 단일 블록
	- 주소 지정 가능
	- 다중 읽기 포트 : 동시에 2개의 다른 레지스터값을 읽을 수 있는 2개의 읽기 포트를 가진다. `rs` 필드와 `rt` 필드에 있는 레지스터 번호가 각각 주소 입력으로 사용됨.
	- 단일 쓰기 포트 : 레지스터 파일은 하나의 레지스터에 값을 쓸 수 있는, 하나의 쓰기 포트를 가진다.
	- 쓰기 제어 신호 : `RegWrite`라는 제어 신호가 있다. 이 신호가 활성화될 때만 지정된 레지스터에 새로운 값이 쓰여진다. 
# R타입 인스트럭션 수행 과정

1. `IF : Instruction Fetch - 명령어 인출`
	- 프로그램 카운터에 저장된 주소를 `Instruction Memory`에 보낸다.
	- `Instruction Memory`는 해당 주소의 32비트 명령어를 읽어온다.
	- 동시에 PC는 다음 명령어 주소를 가리키도록 4 증가한다. 

2. `ID : Instruction Decode & Register Fetch : 명령어 해독 및 레지스터 읽기`
	- 읽어온 명령어 비트들을 `Control Unit`으로 보낸다.
	- `Control Unit`은 `OPCode(R의 경우 0`과 `Funct 필드`를 보고 필요한 제어 신호를 생성한다.
	- 명령어에서 소스 레지스터 번호 `rs`와 `rt`를 추출해 `register file`에 보낸다.
	- `register file`은 `rs`와 `rt` 번호에 해당하는 레지스터들의 값을 읽어 출력한다.
	- 명령어에서 목적지 레지스터 번호 `rd`도 추출해둔다.

3. `EX : Exctute - 실행`
	- `Register File`에서 읽어온 두 값을 ALU의 입력으로 보낸다
	- `Control Unit`은 ALU에게 연산을 수행하라는 제어 신호`ALUOp`을 보낸다.
	- `ALU`는 두 입력값에 연산을 수행해 32비트 결과값을 출력한다. 

4. `MEM : Memory Access`
	- R타입 산술/논리 연산은 데이터 메모리를 사용하지 않기 떄문에, 아무런 작업도 하지 않는다.
	- `Control Unit`의 제어 신호 `MemRead = 0, MemWrite = 0`에 따라 메모리 접근이 비활성화된다.

5. `WB : Write Back - 결과 저장`
	- `ALU`의 결과값을 `Register File`의 데이터 입력으로 보낸다.
	- 명령어에서 추출한 `rd`를 `Register File`의 쓰기 주소로 보낸다.
	- `Control Unit`은 `Register File`에 쓰기를 활성화하는 제어 신호 `RegWrite = 1`를 보낸다.
	- 결과값이 `$rd`에 저장된다.

# I타입 인스트럭션 수행 과정
- I타입은 즉치값(Immediate)을 사용하며, 연산, 메모리 접근, 분기 등 다양한 용도로 쓰인다.

**(A) 즉치값 연산 (예: `addi $rt, $rs, imm`)**

1. **IF:** `addi` 명령어 인출, `PC = PC + 4`.
2. **ID:** 명령어 해독. `rs` 번호 레지스터 값을 **Register File**에서 읽음. 명령어의 16비트 즉치값 `imm`을 **Sign Extender**로 보내 32비트로 부호 확장. Control Unit 신호 생성.
3. **EX:** Register File에서 읽은 `$rs` 값과 Sign Extender에서 나온 32비트 `imm` 값을 **ALU** 입력으로 보냄. Control Unit은 ALU에 '덧셈' 신호 보냄. ALU가 덧셈 결과 출력.
4. **MEM:** 사용 안 함 (MemRead=0, MemWrite=0).
5. **WB:** ALU 결과를 목적지 레지스터 `$rt`에 저장 (RegWrite=1).

**(B) 메모리 로드 (예: `lw $rt, imm($rs)`)**

1. **IF:** `lw` 명령어 인출, `PC = PC + 4`.
2. **ID:** 명령어 해독. `rs` 번호 레지스터 값을 **Register File**에서 읽음. 16비트 `imm`을 **Sign Extender**에서 32비트로 확장. Control Unit 신호 생성 (ALU는 덧셈, MemRead=1, MemWrite=0, RegWrite=1).
3. **EX:** Register File에서 읽은 `$rs` 값(베이스 주소)과 확장된 `imm` 값(오프셋)을 **ALU**로 보내 더하여 유효 메모리 주소 계산.
4. **MEM:** ALU에서 계산된 주소를 **Data Memory**의 주소 입력으로 보냄. Control Unit의 MemRead=1 신호에 따라 Data Memory는 해당 주소의 데이터를 읽어서 출력.
5. **WB:** Data Memory에서 읽어온 데이터를 목적지 레지스터 `$rt`에 저장.

**(C) 메모리 스토어 (예: `sw $rt, imm($rs)`)**

1. **IF:** `sw` 명령어 인출, `PC = PC + 4`.
2. **ID:** 명령어 해독. `rs` 번호 레지스터 값(베이스 주소)과 **`$rt` 번호 레지스터 값(저장할 데이터)**을 **Register File**에서 읽음. 16비트 `imm`을 **Sign Extender**에서 32비트로 확장. Control Unit 신호 생성 (ALU는 덧셈, MemRead=0, MemWrite=1, RegWrite=0 - 레지스터에 쓰는 것이 아님).
3. **EX:** Register File에서 읽은 `$rs` 값과 확장된 `imm` 값을 **ALU**로 보내 더하여 유효 메모리 주소 계산.
4. **MEM:** ALU에서 계산된 주소를 **Data Memory**의 주소 입력으로 보냄. Register File에서 읽은 `$rt` 값을 Data Memory의 쓰기 데이터(Write Data) 입력으로 보냄. Control Unit의 MemWrite=1 신호에 따라 `$rt` 값이 해당 메모리 주소에 저장됨.
5. **WB:** 레지스터 파일에 쓰는 작업이 없으므로 이 단계는 비활성 상태.

**(D) 조건부 분기 (예: `beq $rs, $rt, label`)**

1. **IF:** `beq` 명령어 인출, `PC = PC + 4` (일단 다음 명령어로).
2. **ID:** 명령어 해독. `rs`와 `rt` 번호 레지스터 값을 **Register File**에서 읽음. 16비트 `label` (오프셋)을 **Sign Extender**에서 32비트로 확장하고 2비트 왼쪽 시프트(곱하기 4)하여 바이트 오프셋으로 만듦. Control Unit 신호 생성 (ALU는 뺄셈, Branch 신호 활성). **동시에** 분기 목표 주소 계산: `(PC + 4) + (Shift된 오프셋)`.
3. **EX:** Register File에서 읽은 `$rs` 값과 `$rt` 값을 **ALU**로 보내 뺄셈 연산 수행. ALU는 결과가 0인지 아닌지를 나타내는 'Zero' 신호를 출력.
4. **MEM:** Control Unit은 ALU의 'Zero' 신호와 명령어 종류(`beq`)를 보고 분기 여부를 결정.
    - **분기 조건 충족 (`$rs == $rt`, 즉 Zero=1):** ID 단계에서 미리 계산해 둔 분기 목표 주소를 PC에 써서 다음 명령어 주소를 변경.
    - **분기 조건 불충족 (`$rs != $rt`, 즉 Zero=0):** 아무것도 안 함. PC는 그대로 `PC + 4` 유지.
5. **WB:** 사용 안 함.
# 3. J-타입 명령어 수행 과정

J-타입은 무조건 점프를 수행함.

1. **IF:** `j` 명령어 인출, `PC = PC + 4` (일단).
2. **ID:** 명령어 해독. 명령어의 26비트 `address` 필드를 추출하여 2비트 왼쪽 시프트(곱하기 4). Control Unit 신호 생성 (Jump 신호 활성).
3. **EX:** ALU는 사용하지 않음.
4. **MEM:** 점프 목표 주소 계산: `(PC + 4)`의 상위 4비트와 ID 단계에서 만든 28비트 주소를 합쳐서 32비트 점프 목표 주소를 만듦. Control Unit의 Jump 신호에 따라 이 목표 주소를 PC에 써서 다음 명령어 주소를 변경.
5. **WB:** 사용 안 함.