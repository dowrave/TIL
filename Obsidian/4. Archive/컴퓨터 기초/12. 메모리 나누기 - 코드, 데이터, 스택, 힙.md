> 이 파트는 이해하기 쉽다. 기존에 알던 내용도 있어서 그런가?
# 1. 코드 및 데이터 세그먼트
- 변수 선언이란, 메모리의 특정 부분을 컴파일러가 기억해서 다른 용도로 사용치 않게 하고, 해당 변수 이름이 나올 때마다 그 기억된 메모리로 액세스하는 것
- 변수에 값을 대입하는 초기화 과정이 없다면, 그 곳에 어떤 값이 있는지 모르기 때문에 **일반적으로 초기화도 함께 한다.**

```c
int global = 1;
int main(int argc, char* argv[])
{
	int local = 2;
	return 0;
}
```

- `local`로 선언된 변수는 `move byte ptr [ebp-4], 2`로 번역되어 있으나, `global` 선언 변수는 보이지 않음.

```c
int global = 1;
int main(int argc, char* argv[])
{
	int local = global;
	return 0;
}
```

이렇게 바꾸고 `main` 첫 줄에 브레이크 포인트를 걸면 `global`이라는 변수는 `ebp`라는 레지스터를 매개로 하지 않고 직접 `0x00...`주소로 맵핑된다. 그리고 이를 `eax` 레지스터로 옮긴 뒤, 다시 `ebp - 4`, 즉 `local` 변수에 해당하는 메모리 공간에 저장한다. 
- 왜 `ebp - 4`에 `local`이 저장되는지는 나중에 다룸.

`global` 변수에 해당하는 해당 메모리 공간을 띄워 보면 `01 00 00 00`이 저장되어 있다. 80x80 계열 CPU에서는 리틀 엔디안 방식이라는 것을 사용해서 거꾸로 들어간다.

특이한 건, 컴파일된 어셈블리 코드를 찾아도 1로 초기화하는 부분이 없다는 것이다. `local` 변수를 초기화할 때는 `mov` 라는 인스트럭션을 통해 명시적으로 값을 대입했는데도 말이다.

우선 파악해야 할 건, CPU의 전원을 켰을 때 PC 레지스터가 어디로 설정되는지, 즉 **최초 시작 어드레스의 위치를 파악**해야 하고, 어셈블리로 만든 **프로그램이 그 시작 어드레스에 정확히 위치하도록 메모리에 기록해주는 것**이다. 
> 메모리에 어떻게 프로그램을 기억시키는지도 큰 이슈이지만 여기선 넘어감

- 예를 들어 메모리의 `0x100` 번지에 프로그램 시작 위치가 있다고 한다.

프로그램을 작성하다보면 기억해야 할 여러 값이 필요하다. 루프문을 쓴다면 몇 번 돌았는지에 대한 `i`값이 필요하고, 이외에도 영구적으로 기억해야 할 다른 값들이 있다. 처음에는 레지스터에 기억시켜 사용하지만, 레지스터 수가 제한되어 있다면 **메모리의 어느 공간에 써두고 필요할 때마다 다시 읽는 방법**을 취해야 한다.

그렇다면 메모리의 어디에 그 값을 써둬야 할까? 프로그램 시작 위치 주소인 `0x100`?

만약 `0x100`에 `0`을 저장하고, 이를 읽어들여 1을 증가하고 다시 저장하는 코드가 있다고 하자. 그런데 이 코드가 실행되면 `0x100`에는 원래 있던 인스트럭션 코드인 `mov r0, 0` 대신 `1`이 들어 있게 된다. 이 자체로는 문제가 안되지만, 나중에 `0x100`에 접근할 일이 생길 경우, `1`을 인스트럭션으로 취급해서 해석하려 하고, 이는 정상적인 프로그램의 진행을 아예 막게 된다.

따라서, 일반적으로는 **메모리의 코드 영역과 데이터(변수) 영역을 구분해서 사용**한다.

이러한 영역 구분을 `세그먼테이션Segmentation`이라고 하며, 코드 영역을 `코드 세그먼트`, 데이터 영역을 `데이터 세그먼트`라고 부른다. 

> 다시 원래의 내용으로 돌아와, 왜 `main`의 `local`은 초기화 인스트럭션이 존재하는데 `global`은 초기화 코드가 없는데도 초기화 값 1이 들어가 있을까?

- 왜냐하면 `global` 변수가 여기서 보는 `데이터 세그먼트`에 해당되는 변수이기 떄문이다. 

세그먼테이션의 개념은 프로그래머가 개념적으로 나눠놓은 것일 뿐, CPU나 메모리 등에서는 이를 구분하지 않는다. CPU는 단순히 최초의 시작 어드레스부터 값을 읽어 코드로 해석해서 실행해나가고, 이 과정에서 어느 메모리 영역을 읽기도 하고 쓰기도 하는 것이다.

**메모리의 구성은 CPU가 프로그램을 수행하기 전에 개발자가 이미 결정해서 기록해둬야 하는 것**이다. 여기에는 코드 세그먼트, 데이터 세그먼트의 초기값 결정도 포함되어 있다.

구체적으로 보면, `0x100 ~ 0x4FF`까지는 코드 세그먼트, `0x500 ~ 0x9FF`는 데이터 세그먼트라고 하자. 이 경우 CPU에 전원이 들어올 때, `0x100 ~ 0x9FF` 메모리 영역은 의도된 값으로 차 있어야 한다. 코드 세그먼트에는 인스트럭션이, `0x500` 이후는 변수의 초기값이 들어가 있어야 한다. 하지만 **일반적인 메모리인 RAM은 전원이 다시 들어오면 어떤 값이 들어올지 알 수 없으므로 이를 초기화하는 과정이 필요**하다.

이를 위해 **CPU가 가장 먼저 코드를 읽어들이는 주소의 일부 구간은 램이 아니라 롬`ROM`으로 구성**한다. 롬 부분에 간단한 **부트 프로그램을 작성해서 기록**해둔다. 롬은 기록을 하고 나면, 전원을 꺼도 지워지지 않는다. 
- 부트 프로그램은 **하드 디스크나 플래시 메모리 등 반영구 기록 장치에서 이미지를 읽어 램에 복사한다. `이미지`라는 것이 본격적으로 CPU가 시작되었을 때의 메모리 상태값을 지니는 것**이다.

CPU 전원이 들어오면, CPU가 인스트럭션 패치를 하며 0x100부터 PC가 셋팅된다. 일정 영역이 롬이므로, 롬이 수행되면서 저장 장치에서 램 영역에 복사할 이미지를 찾아 읽어오고, 이를 램으로 복사해 원하는 초기 상태를 만든다. 마지막으로 부트 프로그램은 램 상의 코드 세그먼트 중 한 곳으로 점프해 본격적인 프로그램을 시작하게 된다.
대부분의 컴퓨터가 이런 초기화 과정을 거치는데, **일반적인 PC의 경우 부트 프로그램의 복사된 `이미지`는 윈도우나 리눅스 같은 OS 프로그램이다.**
앱에서도 마찬가지로 이러한 일이 일어난다. `exe` 파일을 실행하면 `LoadLibrary`라는 윈도우 API 함수가 하드 디스크에서 해당 `exe` 이미지를 읽어 메모리에 로드한다. 코드와 데이터 세그먼트가 함께 로드됨.
- 물론 `exe`파일(이미지)는 데이터 세그먼트의 초기화를 위한 메모리 내용을 갖고 있어야 한다. 
	- `2gb`의 데이터 세그먼트를 갖는다면 `exe` 파일에도 `2gb`의 데이터가 있어야 하지만, 실제로 전체 데이터 세그먼트 영역이 모두 변수로 매핑되지도 않고, 초기화가 필요한 변수는 더 적다. 그래서 **데이터 세그먼트의 어느 부분을 어떤 값으로 초기화하라는 메타 데이터 형태로 값이 저장**되어 있다. 임베디드 형태라면 실제 데이터나 코드 세그먼트 전체를 나타내는 경우가 더 잦음.

> 따라서 결론은
> `global` 변수는 데이터 세그먼트로 매핑된 변수이므로, 코드를 통한 초기화가 이뤄지는 게 아니라 `이미지(.exe 등)`가 메모리로 로드되는 순간 `global`이라는 변수에 해당하는 메모리도 함께 초기화되는 것이다.


# 2. 스택 세그먼트
- 위의 예제에서, 왜 `local` 변수는 초기화 코드가 따로 있을까?
- 그리고 전역 변수 `global`은 변수에 해당하는 메모리 주소가 정확하게 들어가 있는데, `local` 변수는 왜 `ebp`라는 레지스터로 접근할까?

여기서 나오는 게 **전역 변수와 지역 변수 개념**이다. 정의는 아니까 패스.

**전역 변수는 데이터 세그먼트 안에 맵핑된다. 데이터 세그먼트의 각 변수는 모두 메모리 상에 그대로 맵핑되므로, 고정된 메모리 주소를 얻을 수 있다.**

지역변수도 위에 설명한 방식으로 쓸 수 있지만, **지역 변수는 각 함수만의 고유한 영역에 배치되도록 하는 게 좋다.** 각 **함수마다 고유한 데이터 세그먼트를 따로 만들어 할당**할 수 있다.

그런데 함수의 특성을 이용해서 함수의 데이터 세그먼트의 크기를 줄일 수 있다.

함수는 인풋에 대한 적절한 처리 후 아웃풋을 반환하는 행위다. 함수 내에서 사용되는 변수는 함수가 호출되는 동안에만 필요하다. 따라서 **호출되는 시점에서 메모리 공간을 할당하고, 호출 후에는 메모리 공간을 회수하면 메모리 공간을 절약**할 수 있다.  모든 함수가 항상 동시에 불리지 않기 때문이다. 함수마다 사용하는 변수 크기가 다르다면, 가장 많은 변수를 사용하는 함수를 기준으로 메모리 공간을 확보하고, **해당 공간**에 함수가 불릴 때마다 해당 함수의 변수들을 맵핑해서 사용한다.

 하지만 한 번에 하나의 함수만 불린다는 보장은 없다. 여러 함수가 동시에 호출될 수 있는 건 자명해서, 하나의 공간을 놓고 여러 함수가 사용하는 방식은 문제가 생긴다.  여기서 나오는 게 `스택Stack`을 활용해서 저장하는 방식이다. 

위에서 다룬 방식과 문제점은 아래와 같다.
1. 모든 함수에 대한 필요한 공간 맵핑 -> 모든 함수를 동시에 쓰지 않기 때문에 메모리 낭비
2. 한 공간에 함수가 불릴 때마다 변수를 맵핑 -> 여러 함수가 호출되면 같은 공간을 사용하려고 함

`스택`은 이 두 가지를 혼용한다.
- 우선, 메모리 공간에 지역 변수를 위한 공간을 할당한다. 하지만 어떤 함수의 변수도 맵핑되진 않는다. 
- 이 공간의 시작 어드레스는 `스택 포인터`라 불리는 특정 레지스터에 기록하도록 한다.
- 함수가 실제로 호출되면, 스택 포인터를 기준으로 함수에 필요한 변수만큼을 맵핑하고, `스택 포인터`를 조정한다.
- 1번째 함수가 끝나기 전에 2번째 함수가 호출된다면, 조정된 스택 포인터의 지점에서 다시 위 과정을 반복하면 된다.

함수의 구조에서, 다른 함수를 호출한 함수를 `콜러Caller`, 호출된 함수를 `콜리Callee`라고 한다. 중요한 특징은, **콜러는 콜리가 끝날 때까지 절대로 리턴되지 않는다**는 점이다. 그래서 콜리가 끝날 때에도 메모리 할당을 해제하고 스택 포인터만 조절해주면 됨. 

스택 구조의 장점으로는 위에서 말한 2가지 문제, 즉 `다른 함수가 사용할 공간을 침범하지 않음 + 상당한 메모리 절약이 가능함`도 있지만, 스택 구조만이 할 수 있는 것도 있다. **함수의 재귀호출을 쓸 수 있다는 것.**

- `스택 오버플로우` : 재귀호출이 반복, `스택 세그먼트`를 초과하는 영역에 지역 변수를 할당하게 되면 데이터 세그먼트 영역이 영향을 받게 된다. 이를 CPU나 OS 차원에서 감지하는 기능임.

> 일반적으로 코드 세그먼트와 데이터 세그먼트를 그릴 때, 세로 직사각형 내에 **데이터 세그먼트를 아래에, 코드 세그먼트를 위에 그린다.** 그리고 스택 세그먼트는 코드 세그먼트의 아랫쪽에 배치함.

재귀 함수는 잘 쓰면 편하니까.. 관련 설명도 다 아는 내용이니까 패스함.
장기 프로그램 같은 것도 평가 함수와 트리 탐색으로 구현함. 요즘은 딥러닝도 넣겠지만.

- 스택의 크기 설정 : 스택은 얼마의 크기로 설정해야 할까?

동시에 불리는 함수의 최대 갯수, 각 함수의 지역 변수 크기를 알면 최대 스택 사이즈를 계산할 수 있지만, 쉬운 문제는 아니다. 재귀 호출을 예로 들면 `링커`라는 개념을 알아야 하고, 컴파일러가 이해하기도 힘들다.
- 임베디드 시스템이라면 코드 세그먼트 + 데이터 세그먼트를 제외한 나머지 영역을 스택 세그먼트로 잡을 수 있다.
- 하지만 PC 등의 OS 환경은 다르다. 곧 다룰 `힙Heap` 영역도 고려해야 하고, `가상 메모리Virtual Memory`라는 걸 통해 물리적 메모리와는 다른 영역에서 프로그램이 실행되는 등의 다른 요인들이 있다.

그래서 스택은 다소 경험적이고 막연한 값으로 잡히는데, VC++에서는 기본 1mb 영역이 스택으로 잡힌다. 대부분의 프로그램에서는 충분히 크다.

> 위의 예제의 결론 : `ebp` 레지스터에 지역 변수가 지정되어 있는 이유는.. 
**`ebp` 레지스터가 스택 포인터이기 때문이다.**

프로그램이 수행되는 동안, 스택에 동적으로 할당된 변수들은 프로그램이 작성되고 컴파일되는 시점에서는 정확히 주소를 얻을 수 없다. 그때그때 할당되는 것이기 때문인데, **한 함수 내의 변수들은 순서가 정해져 있으므로 해당 변수가 맵핑된 시작 주소를 알 수 있다면 상대적인 순서로 위치를 계산**할 수 있다. 스택 포인터가 현재 가리키고 있는 주소가 시작 주소이고, `80x86` CPU에서는 `ebp`라는 레지스터를 스택 포인터로 삼았고, 이 레지스터 값을 기준으로 맵핑되어서 `ebp - x`의 형태로 변수들이 참조되게 된다.

> 참고) 용도에 따라 물리적으로 메모리를 다르게 설정하는 방법도 생각이 되었다 : 이 방법을 `하버드 아키텍처Havard Architecture`이라고 하며, 지금까지 배워온 건 `폰 노이만 아키텍쳐`임. 
> - 폰 노이만 아키텍쳐의 핵심
> - `프로그램 내 저장 구조`, 즉 데이터와 명령어(프로그램)을 같은 메모리에 저장한다.
> - 중앙 처리 장치(CPU)
> 	- ALU
> 	- 제어 장치
> - 메모리
> - 입출력 장치
> - 버스 시스템 : 구성 요소간 데이터 요소를 주고 받는 통신 경로

# 3. 힙 세그먼트
> 위 내용 요약
> - 전역 변수는 컴파일 시점에서 결정되는 정적 메모리
> - 스택은 실행 중에 결정되는 동적 메모리

> 워드 프로세서 예시
> 그러면 이런 것들을 바탕으로 **워드 프로세서**를 만든다고 할 때, 어떤 형태로 프로그램이 구성되어야 할까? 어떤 변수가 필요하고, 메모리 구조 중 어떤 형태를 활용해야 할까?
> 워드 프로세서의 기본은 글자를 입력해서 문장을 만들고, 이 문장 중간중간에 글자를 새로 삽입하거나 지우는 편집 기능이다. 이를 위해 몇 가지 구조체를 선언해야 하는데, 가장 기본은 글자 하나를 나타내는 구조체가 된다.
```c
typedf struct {
	char character;
	int LineNo;
	int ColNo;
}
```
> 즉 위치 정보와 글자다. 
> 그러면 이런 변수를 어떤 형태로 선언할 것인가? 
> - `지역 변수` :  특정 함수 내의 변수로서 다른 함수에서는 액세스할 수 없게 된다. 워드 프로세서의 가장 기본 데이터가 글자 변수이기 때문에 지역 변수는 아닌 듯.
> - `전역 변수` : 이런 관점에서라면 전역 변수가 맞다.

> 그 다음은 '어떻게' 선언할 것인가? 이다.
> 배열로 선언하는 게 가장 먼저 떠오를 생각일텐데, 이를 바탕으로 의사 코드를 구현하보면
```c
typedf struct {
	char character;
	int LineNo;
	int ColNo;
} OneCharacter;

OneCharacter g_chars[1000];
int g_nCursorPos = 0; // 커서 위치 인덱스

bool ProcessKeyboardInput() {
// ...
}

void Alignment(char newChar) {
	// ...
}

void Draw() {
	// ...
}

int main(int argc, char* argv[]) {
	// ...
	while (bQuit = false) {
		// 키보드 입력 처리
		inputChar = ProcessKeyboardInput();
		
		// 입력된 키에 따라 새롭게 라인과 글자를 정렬
		Alignment(inputChar);
		
		// 정렬된 라인에 따라 글자를 화면에 출력
		Draw();
	}
}
```
> 크게
> 1. 키보드로부터 글자를 받음
> 2. 입력된 키를 따라 글자를 추가하거나 삭제해서 라인 정렬
> 3. 정렬된 글자를 화면에 출력
을 프로그램 종료시까지 반복하게 된다. 

1. `ProcessKeyboardInput` : 키보드로부터 입력을 받는다. C의 `getch` 함수, OS가 없다면 직접 키보드에서 데이터 값을 스캔해서 가져온다.
2. `Alignment`  : 입력받은 키 값에 따라 글자를 추가하거나 삭제한다. 이렇게 추가되거나 삭제된 글자들은 메모리에 어떤 형태로든 저장되어야 하며, 이 글자를 저장하는 변수가 `g_chars`이다. 커서 위치에 추가해야 하므로, 위치를 나타내는 변수 `g_nCursorPos`도 있다. 글자를 0번 인덱스에 입력하면 `g_chars[0]`에 글자가 저장되고, `g_nCursorPos`은 증가해서 1이된다.

지금 상황에서 `Alignment`에는 2가지 문제가 있다. 
1. 배열 크기가 1000이므로, 1000글자 이상을 받을 수 없다. 크기를 늘린다고 해도, 데이터 세그먼트 전체를 이 배열을 위해 할당할 수 있을까? 다른 전역변수는 어떻게 처리해야 할까?
2. 글자를 삭제할 경우, 
	- 마지막 글자를 지운다면 `g_nCursorPos`을 `1` 감소시키고 마지막 글자를 공백 같은 다른 문자를 채울 수 있다. 
	- 중간에 있는 글자를 지운다면(100개의 글자를 작성하고, 99번째 글자를 지운다고 가정) `g_chars[98]`을 지우고 공백을 채운다면 `g_nCursorPos`는 99번째 글자를 가리키므로 이 상태에서 타이핑을 해나가면 100번째 글자는 사라지게 된다. 
		- Insert의 수정 모드가 이렇게 동작함
	- 이를 방지하려면, 100번째 글자를 101번째로 옮기고 새로 입력된 글자를 100번째 인덱스에 저장해야 한다. 이런 이슈는 **수정해야 하는 글자가 앞으로 올수록 더 심해지는데, 뒤의 모든 글자를 하나씩 뒤로 옮겨야 하기 때문이다.**
	- 하지만 실제로 작성되는 워드나 메모장에선 그런 느려지는 문제가 발생하지 않는다.

위에서 발생하는 문제의 원인은, **`g_chars`가 데이터 세그먼트에 정적으로 할당**되어 있기 때문이다.

컴퓨터의 메모리를 원하는 곳에서 원하는 만큼 마음대로 늘였다 줄였다 할 수 있으면 해결할 수 있는 문제다. 글자를 넣고자 하는 위치에 공간을 추가해서 넣으면 뒤의 글자를 미룰 필요가 없다. 

위의 문제는 실제로 많은 프로그램에서 발생한다. 
- 처음부터 입력받을 데이터의 양을 모른다든가, 
- 계속 데이터가 갱신되어서 한정된 메모리 내에서 새로운 데이터를 사라진 데이터가 차지한 공간에 맵핑시키는 작업 등이 많이 발생한다.

`힙Heap`은 이런 용도를 위해 마련된 공간이다.
- **데이터 세그먼트는 프로그램을 작성하고 컴파일하는 시점에 이미 결정난 변수들을 위한 공간**이다.
	- 이 시점을 `컴파일 타임`이라고 한다.
- 반면, **힙은 프로그램이 실행되면서 동적으로 메모리를 할당할 수 있는 공간**이다.

그럼 힙과 스택은 무슨 차이가 있는가?
- 스택은 함수 호출마다 함수 내부의 지역 변수들을 동적으로 할당해서 쓰는 공간이었다. **스택도 함수 호출에 따라 할당된다는 점에서 동적할당이라는 표현을 쓸 수는 있겠지만, 엄밀한 의미에서는 동적 할당이라고 할 수 없다.**
	1. 왜냐하면 프로그램 전체가 아닌, **함수 하나의 시점으로 국한한다면 함수 내의 지역 변수 역시 프로그램을 작성하고 컴파일하기 전에 이미 결정되는 하나의 변수로 볼 수 있기 때문**이다.
		- 예를 들어, C의 `main` 함수도 다른 함수들과 똑같은 함수인데, `main` 함수로만 이뤄진 프로그램을 생각해보자. 이런 경우 개발자 관점에서는 지역 변수와 전역 변수의 구분이 큰 의미는 없다. 모두 전역 변수로 선언해서 데이터 세그먼트에 맵핑되어도 똑같다. 
	2. 프로그램 전체 관점에서 각 함수의 지역변수는 동적으로 할당되지만, **함수 내부에서는 변수를 동적으로 할당할 수 없다.** 
		- 워드 프로세서의 예시처럼, 키보드 입력을 받아 그 때마다 새로운 글자를 위한 변수를 할당하려고 해도 스택 구조에서는 방법이 없다.

```c
int A;
int B;
int C;
A = 1;
B = 2;
C = 3;
// 각각은 모두 지역변수
```

이런 구조에서, 지역변수 A, B, C는 모드스택에 함수 호출과 함께 동적으로 할당된다. 그래서 레지스터의 상대 주소 값으로 액세스된다. 이 때 각각의 위치는 `ebp - x`로 결정되며, 이 **`ebp` 레지스터는 함수가 한 번 호출되면 머리 부분에서 값이 설정되고, 함수가 끝나기 전까지는 바뀌지 않는다.** 따라서, 함수 내부에서는 `ebp` 레지스터의 값이 바뀌지 않으므로 각 변수의 상대 오프셋 값들이 전역 변수의 절대주소와 같은 역할을 하게 된다.

또, 스택 포인터는 다음 호출을 대비해서 항상 스택이 증가하는 방향의 끝 부분을 가리킨다. 위에서 모든 위치가 `ebp - x`로 잡히는 걸 보면 이해할 수 있을 것이다. 근데 여기서 **프로그램 실행 중간에 변수가 더 필요해서 메모리를 스택에 할당하게 되면, 할당된 메모리만큼 스택 포인터가 증가**하게 된다. 근데 지역 변수는 `ebp - x`로 잡혀 있기 때문에, 같은 오프셋으로 액세스하면 엉뚱한 메모리에 접근하게 된다. 

그렇다면 힙은 어떻게 동적으로 메모리를 할당할까?

(OS나 컴파일러에 따라 얼마든지 바뀔 수도 있긴 하다)

1. 메모리 상에 힙으로 사용될 공간을 확보한다. `힙 세그먼트Heap Segment`, 혹은 `힙Heap`이라고 한다.
	- 프로그램 당 1개만 있을 수도, 시스템에 따라서는 여러 개를 만들 수도 있지만 기본 1개만으로 작업한다.
2. 프로그램에서 필요한 시점에 메모리를 할당하도록 적절한 함수를 불러준다.
	- `C`의 `malloc` 같은 함수. 
	- `malloc`가 불리면, 함수 내부에서는 힙 공간을 본다. 앞에서 **사용되고 남은 힙 공간 중, `malloc` 함수를 부를 때, 인자로 넘어오는 할당 크기만큼 연속된 공간이 존재하는지 확인**한다. 이러한 공간이 발견되면 이 공간의 **시작 주소를 리턴**한다.
	- 이후엔 리턴된 주소를 포인터로 선언된 변수에 저장해서 사용한다.

힙을 그림으로 묘사할 때는, 스택처럼 한쪽 방향으로 쭉 채워지는 게 아니라 띄엄띄엄 빈 공간이 있도록 묘사된다. **힙에서는 동적으로 메모리의 할당도 가능하지만 해제도 가능하기 때문이다.** 워드 프로세서를 예로 들면, 중간에 있는 글자를 지울 때 할당된 힙이 해제되지 않는다면 실제로 할당 가능한 공간보다 적은 구역만 사용할 수 있을 것이다. 글자를 지우지 않고 글을 처음부터 완벽하게 작성하는 게 불가능한데, 지운 영역을 해제하지 않으면 쓰지 않음에도 사용할 수 없는 공간이 생기는 거니까. 

C에서는 이러한 메모리 해제 작업을 `free` 함수로 작업한다.

C에서 사용하는 `malloc`나 `free` 함수를 쓸 때는 단순히 메모리 공간의 시작 주소만을 사용한다. 어떻게 이게 가능할까? `동적인 공간의 크기`라는 파라미터도 필요해 보이는데, 이 정보는 어디에 저장될까? 

힙을 관리하기 위한 정보는 일반 앱 개발자가 알 정보는 아니고, 플랫폼이나 컴파일러, OS에 따라서도 달라진다. 그 관리법 중 대표적인 형태가 **할당된 메모리 자체에 필요한 정보를 보관**하는 방법이다.

`malloc(100)`이라는 함수를 부르면, 실제로는 100바이트보다 **조금 더 큰 공간을 찾고, 확보된 공간의 가장 첫 부분에 할당된 메모리의 관리에 필요한 모든 정보를 보관**한다. 이를 `메모리 헤더Header`라고 부른다.
`조금 더 큰 공간`이라고 함은, `헤더 정보`가 들어가는 만큼이다. 
- 메모리 헤더에는 아래의 정보가 들어간다.
	- 정보가 할당되는 블록의 크기
	- 힙 세그먼트의 시작 주소
		- 하나의 프로그램에서는 하나의 기본 힙을 가지며, 이 기본 힙의 시작 주소는 프로그램 내부에 저장된다. 빈 공간 탐색은 힙의 시작 주소를 보면서 시작된다. 
		- **시작 주소에는 힙이 할당되든 아니든 헤더가 항상 존재**해야 한다. 이 헤더에는 다음 할당된 공간의 헤더 주소가 기록되어 있어서, `malloc` 함수는 다음 할당된 주소까지의 공간에 자신의 할당된 크기를 뺀 것이 빈 공간 크기라는 걸 알 수 있고, 새로 할당하려는 메모리 크기와 비교한다. 공간이 충분하다면 빈 공간에 헤더를 새로 작성하고 주소를 리턴한다. 그리고 두 헤더 사이의 빈 공간 크기를 계산, 그 크기와 할당하려는 크기를 다시 비교해 충분히 큰 공간인지 파악한다. 
			- 말이 좀 복잡한데, 
				1. **힙 세그먼트 전체의 시작 지점**에는 항상 헤더가 있음
				2. **동적으로 할당된 메모리 영역의 각 시작지점**에도 헤더가 있음
				3. 힙을 할당하려고 할 때, 우선 `힙 세그먼트 전체의 시작에 있는 헤더`를 봄
				4. 저 시작 헤더에는 다음에 할당된 메모리 공간의 위치가 적혀 있음. 그러면 `시작 지점 ~ 다음 메모리 공간` 사이의 공간의 크기를 알 수 있게 됨
					- 모든 할당된 메모리는 연속적이니까
				5. 만약 지금 들어가려는 메모리가 충분하다면 메모리를 할당하고, 모자르다면 다음 헤더로 넘어가서 그 다음 헤더에 대해 4번 과정을 반복함
	- 따라서 각 헤더에는 다음 헤더를 가리키는 포인터가 있고, 포인터를 따라가면 전체 할당된 메모리 블록을 다 탐색할 수 있다. 중간에 메모리가 해제된다면 단순히 해제될 메모리 전의 포인터로 수정해주면 된다. 메모리 할당 또한, 새로 할당된 메모리의 헤더 정보를 기록하고 바로 앞의 메모리 헤더 포인터를 새로 할당된 포인터로 조정하는 작업이 필요하다. 새로 할당된 헤더의 포인터도 다음 할당 공간으로 수정해야 한다.
	- 이게 `링크드 리스트Linked List`임. 
		- 실제로는 일방통행보다는 양방향`Double Linked List`로 사용함. 즉, 이전 헤더의 위치 정보와 다음 헤더의 위치 정보를 모두 헤더에 갖게 한다.

---
워드 프로세서 예제로 돌아가면, `OneCharacter`라는 구조체 형태의 배열은 정적인 변수이므로 비효율적임을 알았다. 이를 `힙`으로 사용하고 글자가 지워지면 메모리도 같이 해제된다고 하자. 그래도 하나의 문제가 발생한다. **새로운 메모리가 할당될 때마다 어떻게 관리할 것인가?**

예를 들어 `Draw` 함수는 모든 글자에 대해 루프를 돌고 현재 눈에 보이는 페이지에 속하면 그리는 방식이었다. 이렇게 모든 글자를 루프를 돌려면, 모든 할당된 메모리에 대한 포인터를 갖고 있어야 하는데, 포인터도 변수니까 글자 갯수에 따라 늘었다가 줄었다가 한다. 

여기서 사용할 방법이 링크드 리스트로, 다음 글자에 대한 포인터를 구조체가 갖게 한다.
```c
typedef struct {
	char Charcter;
	int LineNo;
	int ColNo;
	
	OneCharacter *pNext;
} OneCharacter;
```
포인터로 관리하게 되면 중간에 글자가 삽입되거나 사라져도 포인터가 가리키는 주소만 변경하는 것으로 작업이 끝난다.

예를 들어서
```
abc
```
가 있다고 하면, a의 다음 포인터는 b, b의 다음 포인터는 c가 되고 c의 다음 포인터는 null이다.

여기서 
```
axbc
```
로 수정하면, a의 다음 포인터를 x로 수정하고, x의 다음 포인터를 b로 수정하는 것만으로 끝난다. 

만약 이전의 배열 구조를 가졌다면, 다음 글자들인 b, c를 뒤로 한칸씩 물러야 했다. 

링크드 리스트가 이런 상황에서 좋은 건, 뒤에 있는 글자의 갯수가 몇 개나 있든 상관이 없다는 거다. 이전 글자의 포인터와 현재 글자의 포인터만 고쳐주면 된다. `Draw` 함수처럼 모든 글자를 도는 경우에도, 시작 포인터만 알면 차례대로 모든 글자를 탐색할 수 있다. **링크드 리스트는 힙과 궁합이라서 힙이 없다면 존재 의의가 많이 떨어진다.**

> 기타 정보 : 동적 메모리 할당 함수
> C++에서 `new`와 `malloc`의 차이는? 윈도우즈 프로그래밍의 `GlobalAlloc`이나 `HeapAlloc` 등은? 그렇다고 윈도우즈에서 C를 쓸 때 `malloc`을 쓸 수 없는 것도 아니다. **왜 동적 함수의 종류가 많을까?**

1. `HeapAlloc, new, malloc`은 사실 같은 함수라고 보면 된다. 

`new, malloc`은 앱 개발자가 가장 빈번히 사용하는 상위 수준의 힙 할당 함수이고, `HeapAlloc`과의 차이점은 어느 힙을 사용하는가 정도이다. `HeapAlloc`은 `Heap` 핸들 인자가 있는데, 힙 공간을 지정할 수 있다. 반면 `malloc`이나 `new`는 자체적으로 생성한 힙 공간을 활용한다.

위의 힙 관련 할당 함수는 **`단편화Fregmentation`** 라는 문제점을 가진다. 이전에 힙 관련 그림에서 중간중간 빈 공간들이 발생했던 게 있다. 메모리의 할당과 해제를 반복하면 그런 현상이 많이 발생하고, 이는 곧 **큰 메모리의 동적 할당을 힘들어지게 만들며 헤더 탐색도 많아지므로 할당 속도도 떨어지게 된다.** 

2. 그래서 `GlobalAlloc, LocalAlloc`이라는 함수가 있다.

프로그램이 실행되면서 받는 `기본 힙Default Heap`에만 할당하는데, `new, malloc`과는 달리 단편화 문제를 해결할 수 있다. `MSDN`을 찾아보면 리턴 형태가 다른데, `HeapAlloc`은 포인터를 리턴하고, `GlobalAlloc, LocalAlloc`은 핸들을 리턴한다. 
- `HeapAlloc`은 이미 고정된 메모리 주소라서 단편화가 생기지만
- `GlobalAlloc`은 OS의 관리를 한 번 받는다. 여기서 받는 핸들 자체를 사용할 수 없고, `GlobalLock` 같은 함수로 메모리를 고정시켜야 한다. 그렇지 않으면 OS에서는 단편화 방지를 위해 할당된 메모리 블록들을 옮기기 때문이다. 따라서 `GlobalLock` 함수로 OS가 단편화를 못하도록 막은 상태에서 작업한 뒤, 사용이 끝나면 `GlobalUnlock`을 불러 다시 단편화 작업을 하게 해주는 것이다.
- `LocalAlloc`은 16비트 환경과의 호환을 위한 API로, `GlobalAlloc`과 기능이 동일하다.

3. `VirtualAlloc`이란?

이후에 다룰 `가상 메모리, 페이징, 스와핑` 등의 개념이 나오는데, 여기선 간단히 설명한다.

책 작성 기준, 메모리는 1~2gb였지만 윈도우에서 돌아가는 각 프로그램은 실제로는 4gb 정도의 메모리를 할당받는다. 이게 가능한 이유는 **`가상 메모리`** 라는 개념을 통해 이뤄지는데, OS가 적절히 이러한 메모리를 하드 디스크나 실제 메모리로 맵핑하면서 눈속임을 하는 것이다.

물론 실제로 항상 4gb를 쓰는 건 아니다. 필요할 때마다 적절한 양만큼 할당하는 게 일반적인데, 이러한 용도로 힙 메모리 공간을 확보하고 그 안에서 적절히 메모리를 할당하는 것이다.

하지만 힙 공간에도 제약이 있다. 힙 공간 자체가 크지 않고, 단편화 문제도 있어 큰 용량의 메모리 할당이 힘들다. **힙 공간 자체가 크면 괜찮다고 할 수 있지만, 개발자나 프로그램 입장에서는 단순히 앞으로 할당받을 메모리이지만 OS 입장에서는 이미 확보되어 있어야 하는 메모리다.** 즉, 실제 공간이 얼마 안되는 상태에서 힙 공간이 너무 크면 OS가 실제 메모리와 하드를 오가며 눈속임하는 부담이 커지게 된다. 따라서 힙 공간은 일반적으로 수 mb 정도에 불과하다.

하지만 여전히 4gb 메모리 공간을 활용할 수 있어야 하는데, 이 때 쓰는 게 `VirtualAlloc`이다.

`VirtualAlloc`은 특정 힙에서 메모리를 할당받지 않고, 4gb 가상 메모리에서 확보한다. 프로그램에서 사용하는 가상 메모리는 OS의 관리 하에 있게 된다. 오래 사용하지 않은 부분은 저장 공간으로 돌아가고`스와핑`, 다시 사용되면 메모리로 로드되는 것이다. 큰 크기의 메모리를 앱에 요청해서 확보하고 있으면 스와핑이 빈번하게 일어나서 시스템 속도가 느려질 수 있다.

이런 책임을 프로그래머에게 넘기고자 만들어진 함수가 `VirtualAlloc`이다. **호출하면 실제 메모리 상에 공간을 확보하지 않고, 논리적으로 해당 크기만큼 주소 공간을 예약한다.** 즉, 다른 곳에서 메모리를 할당받아도 예약된 주소 공간은 이미 사용되는 것으로 간주한다. 이를 실제로 액세스하게 될 때는 다시 `VirtualAlloc`을 호출해서 `커밋Commit`이라는 동작을 한다. 예약한 메모리 영역 중, 액세스하고자 하는 크기만큼을 실제 메모리 상에 확보하라는 의미이다. 사용이 끝난 메모리는 `디커밋Decommit`해서 해지한 후 다른 곳에서 사용할 수 있다. 논리적으로 큰 메모리가 필요하지만, 실제 액세스는 좁은 영역에서 일어나는 경우에 유용하다. 
예를 들어 엑셀의 경우 논리적으로는 무한의 행렬을 갖지만, 실제 액세스하는 영역은 일부에 국한된다. 그래서 큰 메모리 영역을 `VirtualAlloc`으로 예약만 하고, 실제 액세스되는 행, 열에 해당하는 영역만 `Commit`해서 사용하면 효율적으로 메모리를 쓸 수 있다. 이게 OS가 획일된 정책(사용 빈도)로 스와핑하는 것보다 효율이 높다.

---
메모리 할당 함수는 계층 구조로 되어있다고 생각할 수 있다.
- `VirtualAlloc` < `HeapAlloc` < `new, malloc`

물론 실제로 코드를 짜면서 `new`나 `malloc` 이외의 함수를 쓸 일이 많지는 않다. 대용량의 메모리를 다루는 서버나 이미지 프로세싱 앱, 가상 메모리와 물리 메모리를 함께 활용하는 드라이버 개발자가 아니라면 말이다. 그리고 플랫폼 호환 면에서도 `new`나 `malloc`을 쓰는 게 훨씬 좋다.


