
1. [[#상속|상속]]
	1. [[#상속#상속의 한계|상속의 한계]]
2. [[#컴포넌트 패턴|컴포넌트 패턴]]
	4. [[#컴포넌트 패턴#게임 오브젝트와 컴포넌트의 특징|게임 오브젝트와 컴포넌트의 특징]]
	5. [[#컴포넌트 패턴#컴포넌트의 독립성|컴포넌트의 독립성]]
3. [[#유니티 에디터에서의 컴포넌트|유니티 에디터에서의 컴포넌트]]
4. [[#메시지와 브로드캐스팅|메시지와 브로드캐스팅]]
	1. [[#메시지와 브로드캐스팅#MonoBehaviour|MonoBehaviour]]
	2. [[#메시지와 브로드캐스팅#메시지 기반 방식|메시지 기반 방식]]
	3. [[#메시지와 브로드캐스팅#유니티 이벤트 메서드|유니티 이벤트 메서드]]

- 컴포넌트에 대한 설명 및 컴포넌트의 동작 확인

## 상속
- 상속에 대해선 이미 아는 이야기니까 그냥 넘깁니다?

### 상속의 한계
- 부모 클래스를 상속해서 자식 클래스의 기초 구현을 재현할 수 있지만, 너무 상속에 의존하면 코드를 재사용하기 오히려 힘들 수 있다.

- 예시) 사람 형태의 클래스를 Human으로 정의, `렌더(모습 그리기) 기능, 물리, 애니메이션, 체력, 기타 필수 기능`들이 들어가있다
	- Player는 Human을 상속 받고, 조작, 공격, 작업 기능을 추가한다.
	- NPC가 Human을 상속받을 경우, 물리, 체력 기능은 필요 없다 - NPC를 공격해 죽일 수 있으니까
		- 따라서 "기능을 제거"해야 하는 추가 작업이 발생하기도 한다
	- Monster 클래스에 대해, Human을 상속받는다면 렌더, 애니메이션, 물리 등의 기능을 다 갈아엎어야 한다.

- 즉, 부모 클래스는 자식 클래스에 공통적으로 필요한 기능을 구현한다. 
	- 그러나, 나중에 자식 클래스에 필요한 기능이 정확히 추측하는 건 힘들다.
	- 또, 기존 부모 클래스의 기능이 자식 클래스의 기능과 충돌할 수도 있다.
	- 업무적으로는 기획자가 새로운 오브젝트를 만들 때 매번 프로그래머에게 부탁해야 하는 문제도 있다. 상속 작업은 프로그래머만이 할 수 있기 때문.

- 이러한 문제를 해결하려면 **`컴포넌트 패턴`** 을 사용해야 한다.

## 컴포넌트 패턴
- 유니티는 게임 오브젝트를 컴포넌트 패턴을 사용해 만든다.

- `컴포넌트 패턴` : 미리 만들어진 부품을 조립해 완성된 오브젝트를 만드는 방식. 
- **게임 오브젝트는 컴포넌트 패턴에서 속이 빈 껍데기**로, 개발자는 빈 오브젝트에 컴포넌트를 조립해 새로운 기능을 추가할 수 있다. 

- **상속 패턴은 부모 클래스에 필수 기능을 다 몰아넣었다**면, **컴포넌트 패턴 부품을 모두 따로 만든 다음 게임 오브젝트마다 필요한 기능을 붙이는 방식**인 것이다.

### 게임 오브젝트와 컴포넌트의 특징
- **유연한 재사용 가능**
	- 위에서 설명했으니 생략
- **기획자의 프로그래머 의존도가 낮아진다**
	- 컴포넌트만 조립해도 되는 방식이므로, 프로그래머에게 덜 의존할 수 있다.
- **독립성 덕분에 기능 추가 및 삭제가 쉽다**
	- 간단한 수정으로도 코드 전체가 꼬일 수 있는 기존 방식과 달리, 여기서는 다른 기능이 망가지지 않음

### 컴포넌트의 독립성
- 2가지 특징에서 파생된다.
1. 게임 오브젝트는 단순한 빈 껍데기
2. 컴포넌트는 스스로 동작하는 독립적인 부품
	- 각 컴포넌트는 같은 오브젝트 내의 다른 컴포넌트의 영향을 받지 않는다. 
	- 기능 자체가 내부적으로 완성되어 있기 때문이다. 

## 유니티 에디터에서의 컴포넌트
- 1장에서 Cube에 중력을 적용했던 예제를 생각해보자
- 만약 `Cube` 게임 오브젝트의 `Box Collider` 컴포넌트를 제거하면, Cube 게임 오브젝트의 물리적인 표현이 사라진다. 따라서 큐브는 다른 물체와 충돌하지 않고 그대로 뚫고 지나감.
- 그러나 추가했던 `RigidBody`에는 영향이 없어서, 중력의 영향은 계속 받는다. 영원히 내려감.

## 메시지와 브로드캐스팅
- 컴포넌트 구조에서는 **전체 방송**을 통해 컴포넌트의 특정 기능을 간접적으로 실행할 수 있다. 이를 `브로드캐스팅BroadCasting`이라고 한다. 

### MonoBehaviour
- **유니티의 모든 컴포넌트가 상속 받는 클래스. 즉 모든 컴포넌트의 부모 클래스**
- 이를 상속받은 클래스는 게임 오브젝트에 컴포넌트로 추가될 수 있다.

### 메시지 기반 방식
- **유니티 엔진은 게임 오브젝트마다 존재하는 컴포넌트의 명단을 모조리 파악하지 않는다.**
- 대신, **컴포넌트의 어떤 기능을 실행하고 싶다**면 당사자를 찾는 게 아니라 **메시지를 날리는 방식을 쓴다.**
	- 발동시키고 싶은 기능의 이름을 메시지로 뿌리면, `모든` 오브젝트가 메시지를 받는다. 메시지에 명시된 기능이 있는 컴포넌트만 해당 기능을 실행한다.
> `모든` : 모두 뿌리면 성능에 문제가 생기니, 실제로는 제약을 건 다음 메시지를 뿌린다.

- 메시지 방식의 특징
	- 보내는 쪽은 누가 받을지 신경쓰지 않음
	- 받는 쪽은 누가 보냈는지 신경쓰지 않음
	- 받고 나서 기능이 있으면 실행, 아니면 무시

- 이런 식으로 무차별적으로 여러 오브젝트에 메시지를 뿌리는 방식을 `브로드캐스팅`이라고 한다.

- `게임 오브젝트` 내에는 여러 개의 `컴포넌트`가 들어갈 수 있고, 각 `컴포넌트`는 또 여러 개의 `메서드`를 가질 수 있다. 
- 만약  `Dance` 라는 명령어가 브로드캐스팅 됐다면,
	- 모든 게임 상의 오브젝트와 컴포넌트는 `Dance`라는 메시지를 듣게 된다.
	- 오브젝트들은 `Dance`를 갖고 있지 않다면 무시, 자신의 어떤 컴포넌트가 `Dance`를 갖고 있다면 실행시킨다.

### 유니티 이벤트 메서드
- 메시지, 브로드캐스팅은 `Start()`, `Update()`, `OnTriggerEnter()` 등의 유니티 이벤트 메서드가 동작하는 원리이다.
	- `Start()` : 게임 오브젝트가 처음 활성화될 때, 자동으로 1회 실행된다. 게임 오브젝트가 활성화 될 때, 유니티 엔진이 해당 게임 오브젝트에 `Start` 메시지를 브로드캐스팅하기 때문이다. 따라서 수동으로 실행할 필요 없다.
- 유니티에는 이런 식으로 **이름 철자만 구현해도 메시지에 의해 자동으로 실행되는 메서드**들이 있다. 이를 `유니티 이벤트 함수, 유니티 이벤트 메서드`라고 한다.