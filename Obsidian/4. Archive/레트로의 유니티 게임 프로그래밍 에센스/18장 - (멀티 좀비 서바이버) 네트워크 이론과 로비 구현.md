
1. [[#네트워크 동기화|네트워크 동기화]]
	2. [[#네트워크 동기화#로컬과 리모트|로컬과 리모트]]
	3. [[#네트워크 동기화#동기화|동기화]]
	4. [[#네트워크 동기화#로컬 권한 검사|로컬 권한 검사]]
2. [[#게임 서버의 종류|게임 서버의 종류]]
	1. [[#게임 서버의 종류#전용 서버|전용 서버]]
	2. [[#게임 서버의 종류#리슨 서버|리슨 서버]]
	3. [[#게임 서버의 종류#P2P|P2P]]
	4. [[#게임 서버의 종류#매치매이킹 서버|매치매이킹 서버]]
	5. [[#게임 서버의 종류#포톤 룸|포톤 룸]]
3. [[#네트워크 권한 분리|네트워크 권한 분리]]
	1. [[#네트워크 권한 분리#호스트에 위임|호스트에 위임]]
	2. [[#네트워크 권한 분리#RPC|RPC]]
4. [[#포톤 준비하기|포톤 준비하기]]
	1. [[#포톤 준비하기#포톤과 UNet|포톤과 UNet]]
	2. [[#포톤 준비하기#PUN 2|PUN 2]]
5. [[#로비 만들기|로비 만들기]]
	1. [[#로비 만들기#LobbyManager.cs|LobbyManager.cs]]
	2. [[#로비 만들기#Start() 메서드|Start() 메서드]]
	3. [[#로비 만들기#OnConnectedToMaster() 메서드|OnConnectedToMaster() 메서드]]
	4. [[#로비 만들기#OnDisconnected() 메서드|OnDisconnected() 메서드]]
	5. [[#로비 만들기#Connect() 메서드|Connect() 메서드]]
	6. [[#로비 만들기#OnJoinRandomFailed() 메서드|OnJoinRandomFailed() 메서드]]
	7. [[#로비 만들기#OnJoinedRoom() 메서드|OnJoinedRoom() 메서드]]



6부의 `Zombie` 프로젝트를 기반으로 한다.
기존 게임 오브젝트와 일부 코드를 멀티플레이어 용으로 재구성하고 변형한다. 

## 네트워크 동기화

여기서 설명하는 모든 네트워크 개념은 아래 문장을 제대로 이해해야 설명 가능하다.
> **4인 멀티 플레이어 게임에서 플레이어 캐릭터는 총 16명이다.**

네트워크 상에서 각 클라이언트의 게임 월드는 평행우주처럼 동작한다. **`클라이언트`란, 서버에 접속하여 서비스를 제공받는 단말기(컴퓨터), 프로그램, 사용자**를 뜻한다.

4인 멀티 플레이어에서 각 유저의 컴퓨터 상황을 생각해보자.
- A의 컴퓨터 - 게임 월드 > 플레이어 오브젝트 a, b, c, d
- 이 중 `a`가 A가 컨트롤하는 플레이어 캐릭터라고 가정한다.

1. 유저가 총 4명이므로, 각 클라이언트에 있는 플레이어의 캐릭터는 총 16명이다. 
2. 이 때, **클라이언트 A의 a와 클라이언트 B의 a는 서로 다른 게임 오브젝트**다. 
	- 평행우주 개념처럼 나와 같은 사람이 다른 우주에 다른 버전으로 존재하며, 이 둘은 서로 아무 상관없다.
3. 하지만 **네트워크 상에서 `A-a`와 `B-a`는 네트워크 관리자에 의해 동일한 식별자를 부여받는다.** 즉, **네트워크에 연결된 동안** `A-a`와 `B-a`이 동일한 상태로 **동기화**될 수 있다. 

### 로컬과 리모트
- `로컬` : 물리적으로 사용자의 위치에 존재하는 단말기나 프로그램, 오브젝트
- `리모트` : 원격 접속을 통해 접근할 수 있는 단말기, 프로그램, 오브젝트

네트워크 게임에서 씬에 존재하는 게임 오브젝트는 `로컬 오브젝트`와 `리모트 오브젝트`로 나눌 수 있다. 기준은 **그 게임 오브젝트의 주도권을 가진 사람**이다. 

`로컬 오브젝트`는 로컬 클라이언트의 게임 월드에서 생성되며, 주도권은 로컬 클라이언트에 있다.
`리모트 오브젝트`는 **타인의 게임 월드에서 생성**된 게임 오브젝트가 **네트워크를 통해 내 게임 월드에 같은 게임 오브젝트로 복제 생성**된 것이다.

리모트 오브젝트는 로컬 클라이언트에 주도권이 없기 때문에, 특별한 경우를 제외하면 로컬 클라이언트는 리모트 오브젝트를 임의로 삭제하거나 주요 상태를 변경할 수 없다. 

> 책에서 사용하는 용어 정리
> 사용자 = `플레이어, 클라이언트`
> 게임 속 캐릭터 = `플레이어 캐릭터, 플레이어 게임 오브젝트`


### 동기화

플레이어 A가 자신의 게임 월드에서 로컬 플레이어 캐릭터 a를 움직였다면, 나머지 사람들의 게임 월드에서도 움직여야 한다. 이 구현을 위해, 플레이어 A는 캐릭터 a를 움직인 다음, **변경된 a의 위치를 B, C, D의 게임 월드에 있는 a의 분신에 동기화 신호로 전달**해야 한다.

여기서 동기화 간격이 길거나 인터넷 속도가 느리면 4개의 게임 월드의 모습이 조금씩 달라질 수 있다. 또, 접속이 끊기면 서로 완전히 독립적으로 동작하게 된다.

### 로컬 권한 검사
로컬 플레이어 게임 오브젝트이든, 리모트 플레이어 게임 오브젝트이든 플레이어 게임 오브젝트의 컴포넌트 구성은 동일하다. 하지만 플레이어 A의 조작 입력이 리모트 플레이어 게임 오브젝트인 b, c, d에 반영되면 안 된다.

이를 구현하려면 오브젝트가 로컬 권한을 갖고 있는지 검사해야 한다. 코드마다 `if`문을 삽입하는 식으로 구현할 수 있다.
```cs
void Update() {
	if (!local) {
		return;
	}
	// 사용자 입력 감지
	// 움직임 적용
}
```
여기서 `local`은 로컬 오브젝트임을 나타내는 `bool` 변수이다.

## 게임 서버의 종류
기본적으로 네트워크 기반 게임은 대기 중인 서버에 클라이언트들이 참가하는 `서버-클라이언트` 방식으로 동작한다.

`서버`는 **클라이언트들이 참가할 수 있는 네트워크 공간**을 마련하는 컴퓨터이며, `호스트host`라고 부르기도 한다. 네트워크 공간 외에도, **게임 속 상호작용 연산**도 담당한다.
`클라이언트`는 서버에 참가하여 **게임을 플레이**하는 컴퓨터이다. 

대부분 아래의 방식으로 구현한다.
- `전용 서버Dedicated Server`
- `리슨 서버Listen Server`
- `P2P Peer-to-Peer`

### 전용 서버
**서버의 모든 자원이 온전히 네트워크 서비스를 유지하는 데 사용되며, 서버가 플레이어로서 게임에 직접 참가하지 않는 형태이다.** 

언제든지 참가 가능하고, 고정된 고성능 서버를 제공하므로 클라이언트는 쾌적한 환경에서 게임을 즐길 수 있다. 하지만 다른 방식에 비해 고정 비용이 많이 발생한다.

### 리슨 서버
전용 서버가 없는 대신, **클라이언트 중 하나가 서버 역할을 맡는다.**  리슨 서버는 게임에 플레이어로 참가하므로 `Play as Host`라고 부르기도 한다. 이 때 서버 역할을 맡은 클라이언트를 `방장, 호스트, 마스터 클라이언트` 등으로 부른다. 

전용 서버에 비해 **유지비용이 적고**, **물리적으로 가까운 플레이어끼리는 반응 속도가 전용 서버보다 빠를 수 있다.**

**호스트 플레이어의 컴퓨터 성능에 따라 네트워크 품질이 크게 달라진다.** 호스트가 게임을 종료할 경우, 진행 중인 게임을 일시 정지하고 남은 클라이언트 중에서 새로운 호스트를 선정하는 `절차Host Migration`가 필요하다.

### P2P
**게임에 참가한 클라이언트들 모두가 호스트 역할을 겸한다. 단일 호스트에 참가하는 방식이 아니라, 서로 직접 연결된 형태이다.** 

일반적으로 네트워크 게임에서 호스트의 연산 부담이 크다. 네트워크 룸 유지에 필요한 연산, 게임 속 중요한 연산 대부분을 수행하기 때문이다.  하지만 P2P 방식에서는 연산 대부분을 독점하는 호스트가 없다. **클라이언트가 각자 자신의 월드에서 담당 연산을 실행하고, 다른 클라이언트에 결과를 전파한다.**

호스트 교체 과정이 필요 없기 때문에 **클라이언트 수가 적다면 다른 방법보다 네트워크 반응 속도가 빠르다.** **개발자 입장에서는 프로그램의 처리 흐름을 직관적으로 설계**할 수도 있다.

하지만 **참가자가 증가할수록 반응 속도가 눈에 띄게 느려진다.** P2P 방식에서는 16명을 참가자 상한선으로 여긴다. 인원 수가 많아질수록 연결해야 하는 회선 수가 많아지기 때문이다.

호스트가 정해진 방식에서는 호스트를 통해 다른 클라이언트의 정보를 알 수 있다. 하지만 P2P 방식에서는 각 클라이언트가 자신을 제외한 모든 클라이언트와 연결되어 있어야 한다. 

**연결 수가 늘어날수록 각 클라이언트가 부담해야 하는 연산 수도 많아진다.**  서버 - 클라이언트에서 서버가 담당하는 연산보다 p2p의 각 클라이언트가 담당하는 연산 수가 많아질 수도 있다.

**수치 변조에 취약하다.** 호스트가 있으면 중요 연산, 데이터는 호스트에서 관리하고 클라이언트는 호스트의 실행 결과만 받는다. 이 경우 클라이언트가 중요한 연산과 수치를 위조하는 게 어려워진다. 하지만 P2P 방식에서는 각 클라이언트가 연산을 실행하고 동기화하므로 특정 수치를 위조하여 다른 클라이언트에 전파할 위험이 크다. 

이 프로젝트는 `리슨 서버` 방식으로 구현한다.

### 매치매이킹 서버
매치메이킹 과정에서는 `포톤Photon`에서 제공하는 전용 클라우드 서버를 사용한다.

리슨 서버나 p2p를 사용하더라도 참가할 클라이언트들이 서로를 찾아 방 하나에 모이는 과정에서 사용할 전용 서버가 필요하다. 이를 `매치메이킹 서버`라고 부른다.

MMORPG 게임에서는 대부분의 요소를 전용 서버로 처리한다. 반면, 플레이어들이 한 룸에 모여 레이드나 팀 데스매치를 진행하는 종류의 게임에서는 매치메이킹은 `전용 서버`를 사용하지만, 룸이 구성되고 라운드를 시작할 때는 `리슨 서버` 방식을 많이 사용한다.

### 포톤 룸
포톤은 여러 클라이언트가 모인 네트워크의 가상의 공간을 `룸`이라고 부른다. 

**포톤의 룸은 유니티의 씬이 아니다.** 유니티의 씬과 다른 계층에서 동작한다. 따라서 여러 플레이어가 같은 룸에 있더라도, 서로 다른 씬을 로드하는 것도 가능하다.

비유하면 여러 사람이 각자 무전기를 든 채 같은 주파수를 공유하고 있는 것으로 이해할 수 있다. `정보를 공유(같은 룸에 입장)`할 수는 있지만,` 물리적인 장소(씬)`사이에는 연관성이 없다.

## 네트워크 권한 분리
네트워크 게임은 공정한 결과를 보장하고 수치에 대한 위변조를 방지해야 한다. 

멀티 플레이어 게임에서 보안성을 높이는 방법이 많다. 하지만, 방법에 상관없이 서버와 클라이언트 사이의 권한을 분리하여 **"중요한 연산은 모두 서버(호스트)에 위임"하라는 규칙을 가능하면 지켜야 한다.**

이 방식에서 클라이언트는 서버 연산의 결과를 표시하는 화면일 뿐이다. 

### 호스트에 위임
왜 호스트에 위임하는가? 2가지 이유가 있다.
- **동기화에 오차가 존재할 경우 기준이 되는 월드를 정하기 위해**
- **클라이언트의 위변조를 막기 위해**

> 예시) **호스트에 중요한 연산을 위임하지 않는 방식으로 구현된 FPS 게임이 있다**고 하자
> - A가 호스트인 상황
> - 사용자 B가 클릭, b -> c를 향해 총을 쐈다 : B의 게임 월드에서 b -> c 가 쏘는 처리를 진행. **동시에** 다른 클라이언트의 리모트 플레이어 캐릭터 `b`에도 동기화된다.

총을 쏘고 맞는 처리는 게임 승패와 직결되므로 중요하다. **네트워크 동기화는 전송 속도나 패킷 손실이라는 문제 때문에 완벽하지 않다.** 즉, b의 위치, b가 조준한 방향 등은 클라이언트마다 오차가 존재할 수 있다. 이 오차 때문에 A, B월드에서는 맞췄는데 다른 월드에서는 맞추지 못한 경우가 생길 수도 있다. 
이런 상황에서 호스트라는 개념이 없으면, 어떤 결과를 따라야 하는지 결정하지 못하는 상황이 생길 수 있다. 

이런 상황도 있다 : B가 핵을 사용해 b가 1초에 수백 발씩 쏜다고 하자 - 동기화되므로 다른 월드에도 그대로 적용된다. 즉, **특정 클라이언트의 비정상적인 행위나 수치 변조가 다른 클라이언트에 그대로 적용되는 문제도 있다.**

---

위 2개의 문제(`오차에 의한 판정 결정 문제`, `핵 문제`)는 호스트를 정하면 해결할 수 있다. 중요한 연산을 호스트의 게임 월드에서 실행시키고, 다른 클라이언트는 이를 따르게 하면 된다.

> - 똑같이 B가 b->c를 쏜 상황
> - 클라이언트 B는 b->c 사격을 `실행하는 척`만 한다. 대신, **실제 사격 실행은 A에 맡긴다.** 
> - 호스트 A는 b->c 처리를 실행하고, 변경된 체력 수치 등을 B, C, D에 전파한다.
> - B, C, D는 변경된 수치를 받아들이고, 겉으로 보이는 효과음이나 파티클 이펙트 등의 처리만 직접 실행한다. 

즉 실제 사격은 호스트 A에서만 실행, B, C, D는 처리 결과를 받고 후속 효과만 재생한다.

이 방식으로 구현하면 호스트의 게임 월드가 모든 처리와 수치의 기준이 된다. 이처럼 게임 승패와 직결된 중요한 처리는 호스트에 위임해야 한다. 

한편 비주얼 이펙트, 효과음 재생, 애니메이션 재생 등은 승패에 관련된 중요한 처리가 아니므로 호스트에 위임할 필요가 없다. 오히려, 반응 속도를 높이고 대역폭을 줄이기 위해 중요하지 않은 처리는 클라이언트에서 수행하는 게 더 좋다.

### RPC
호스트에 처리를 위임하고 호스트의 처리 결과를 클라이언트에 전파하려면 `원격 프로시져 콜RPC : Remote Procedure Call`을 구현해야 한다. **어떤 메서드나 처리를, 네트워크를 넘어 다른 클라이언트에서 실행하는 것이다.** 대부분의 멀티 플레이어 API에는 RPC가 구현되어 있다.

- 사격 메서드를 `Shot()`, 사격 효과 재생 메서드를 `ShotEffect()` 이라고 해보자. 그러면
1. 사용자 B가 발사 버튼 누름
2. 클라이언트 B가 호스트 A로 RPC `b.Shot()` 전달
3. 호스트 A에서 `b.Shot()` 실행
4. 호스트 A에서 모든 클라이언트에 `b.ShotEffect()`를 실행하라는 신호를 전달한다.


## 포톤 준비하기

### 포톤과 UNet
집필 시점에 유니티 네트워크 게임을 개발하는 가장 대중적인 솔루션은 `포톤` 또는 `UNet`이다.

`UNet`은 유니티 기본 내장 공식 라이브러리지만, 2018.3 버전부터 `사용되지 않음Deprecated`로 선언되었다. 집필 시점에는 차세대 멀티플레이어 API의 모습이 공개되지는 않았다고 함
> 현재는 `NGO : NetCode for GameObjects`라는 유니티 공식 네트워킹 솔루션이 있는 듯

### PUN 2
포톤은 다양한 플랫폼과 게임 엔진을 지원하는 네트워크 종합 솔루션이다. 멀티 플레이어 게임에 필요한 `클라우드 서버 대여 서비스`, 실시간으로 게임 서버를 관리할 수 있는` 웹 서비스`, 여러 게임 엔진에 플러그인 형태로 삽입할 수 있는 `네트워크 엔진` 등을 제공한다.

`PUN Photon Unity Network`은 유니티용으로 제작된 포톤 네트워크 엔진이다. 본래 포톤의 여러 기능은 플랫폼과 상관없이 동작한다. PUN의 기능 중 하나는 `Photon Realtime` 등 포톤의 여러 API를 유니티 컴포넌트로 랩핑하여 제공하는 것이다. PUN을 사용해 포톤의 여러 기능을 게임 오브젝트에 컴포넌트로 추가할 수 있다.

여기서는 PUN 2를 사용한다. 유니티 에셋 스토어에 무료 버전과 전문가용 유료 버전이 함께 제공되는데, 무료 버전만으로 멀티플레이어 구현에 필요한 대부분의 기능을 사용할 수 있다.

- PUN2 임포트 : `예제 18 폴더 - Zombie MultiPlayer 프로젝트 유니티로 열기 - 에셋 스토어 창 열기 (Window > General > Asset Store) > PUN 2 - FREE 검색 > Download > Import`

실행 시 `AppID` 입력을 요구한다. `Pun Wizard` 가 실행되지 않은 상태라면 아래처럼 실행 후 `Project Setup` 탭으로 이동한다.

- PUN Wizard 열기 : `Window > Photon Unity Networking > PUN Wizard > Setup Project 클릭 > Appid or Email > Email 입력 시 Appid가 발급되어 자동으로 연동됨`

가끔 서버와의 접속이 불안정한 경우에는 포톤 공식 웹사이트에서 가입하고, 회원 정보 페이지에서 AppID를 복사해오는 게 더 빠르다.
## 로비 만들기
플레이어가 로비에서 참가 버튼을 누르면 참가 가능한 빈 룸이 있는지 검색한다. 빈 룸이 있다면 참가하고, 없다면 새로운 룸을 만들고 다른 플레이어들이 참가호도록 허용한다.

- 저자가 `Scenes/`에 `Lobby`라는 씬을 만들어뒀다. UI만 준비된 상태로, 코딩으로 로비를 완성한다.
![[Pasted image 20240625161951.png]]
`Panel` : 하얀 배경을 그리는 UI 이미지. 
`Title Text` : 제목을 띄우는 UI 텍스트. 
`LobbyManager` : `Lobby` 씬을 네트워크 로비로 동작하도록 구현하는 스크립트. 
`Connection Info Text, Join Button` : 실제로 사용할 UI 게임 오브젝트. 네트워크 관련 역할을 부여해 실제로 사용할 것이다. 
`Connection Info Text` : 텍스트 컴포넌트만 가진 UI 텍스트. `LobbyManager` 스크립트를 사용해 `Connection Info Text`에 현재 네트워크 접속 상태를 표시한다. 
`Join Button` : 버튼 컴포넌트를 가진 UI 버튼. 플레이어가 `Join Button`을 누르면 매치메이킹 서버를 통해 룸에 접속하고 메인 게임으로 이동한다.
- `OnClick()` 이벤트에 : `LobbyManager 오브젝트 - LobbyManager` 컴포넌트의 `Connect()` 메서드가 등록되어 있다. 룸에 접속을 시도하는 메서드이며, 직접 완성할 예정이다. 
- `Interactable`이 해제되어 있다 : 해당 버튼을 클릭할 수 없으며, 매치메이킹 서버에 정상적으로 접속된 상태에서만 `true`로 전환한다. 

### LobbyManager.cs
```cs
using Photon.Pun; // 유니티용 포톤 컴포넌트들
using Photon.Realtime; // 포톤 서비스 관련 라이브러리
using UnityEngine;
using UnityEngine.UI;

// 마스터(매치 메이킹) 서버와 룸 접속을 담당
public class LobbyManager : MonoBehaviourPunCallbacks {
    private string gameVersion = "1"; // 게임 버전

    public Text connectionInfoText; // 네트워크 정보를 표시할 텍스트
    public Button joinButton; // 룸 접속 버튼
```
`Photon.Realtime`은 포톤의 실시간 네트워크 게임 개발용 `C#` 라이브러리이다. `Photon.Run`은 여러 포톤 C# 라이브러리를 유니티 게임 오브젝트와 컴포넌트로 사용할 수 있게 하는 `PUN` 게임 라이브러리이다.

클래스 선언에는 `MonoBehaviourPunCallbacks`을 상속받는다. `Photon.Pun`에서 제공하는 `MonoBehaviour`를 상속한 클래스로, `MonoBehaviour`의 기능을 유지한 채 컴포넌트가 포톤 서비스에 의해 발생하는 콜백(이벤트, 메시지)을 감지할 수 있게 한다.

즉, `Update()`, `Start()` 등의 메시지 외에도 `OnConnectedToMaster()` 등의 포톤 이벤트까지 감지, 대응되는 메서드를 자동 실행한다. 단, PUN 구현 한계상 포톤 전용 이벤트는 `override`를 사용해서 구현해야 한다.

그 아래는 변수들이 선언되어 있다.
- `gameVersion`은 같은 버전끼리 매칭할 때 사용할 게임 버전이다. 같은 게임이라도 버전에 따라 콘텐츠, 밸런스가 달라지기 떄문에 같은 버전의 플레이어만 매칭되게 한다.
- `coonectionInfoText` : 현재 접속 정보를 표시할 때 사용할 텍스트 컴포넌트이다. 씬에 있는 `Connection Info Text` 게임 오브젝트의 텍스트 컴포넌트가 할당된다.
- `joinButton` : 접속에 사용할 버튼 컴포넌트이다. 씬의 `Join Button` 게임 오브젝트의 버튼 컴포넌트가 할당된다.

### Start() 메서드
```cs
    private void Start() {
        // 접속에 필요한 정보(버전) 설정 및 마스터 서버 접속 시도
        PhotonNetwork.GameVersion = gameVersion;
        PhotonNetwork.ConnectUsingSettings();

        // 룸 접속 버튼 잠시 비활성화
        joinButton.interactable = false;
        connectionInfoText.text = "마스터 서버에 접속 중....";
    }
```
`PhotonNetwork` 관련 설정할 수 있는 건 많지만, 여기선 `GameVersion`만 설정함.

### OnConnectedToMaster() 메서드
포톤 마스터 서버에 접속 성공한 경우 자동으로 실행된다. 여기선 접속에 성공했다는 메시지와, `Join Button`이 상호작용 가능하도록 바꾼다.
```cs
    // 마스터 서버 접속 성공시 자동 실행
    public override void OnConnectedToMaster() {
        joinButton.interactable = true;
        connectionInfoText.text = "온라인 : 마스터 서버와 연결됨";
    }
```

### OnDisconnected() 메서드
마스터 서버 접속에 실패했거나, 이미 접속된 상태에서 어떤 이유로 접속이 끊길 경우 실행된다. 그 원인에 대한 정보는 `DisconnectCause 타입`으로 메서드에 자동으로 입력된다.
여기선 접속이 끊겼을 때 끊긴 사실을 표시하고, 룸 접속 버튼을 비활성화한다. 그리고 재접속을 시도한다.
```cs
    public override void OnDisconnected(DisconnectCause cause) {
        joinButton.interactable = false;
        connectionInfoText.text = "오프라인 : 마스터 서버와 연결되지 않음\n접속 재시도 중..";
        // 재접속 시도
        PhotonNetwork.ConnectUsingSettings();
    }
```

### Connect() 메서드
`Join Button`을 클릭했을 때 실행할 메서드이다. 매치메이킹 서버를 통해 빈 무작위 룸에 접속을 시도한다.
```cs    
// 룸 접속 시도
    public void Connect() {
        // 중복 접속 시도를 막기 위한 버튼 비활성화
        joinButton.interactable = false;
        
        // 마스터 서버에 접속한 상황에서만 룸 접속을 시도해야 한다
        if (PhotonNetwork.IsConnected)
        {
            connectionInfoText.text = "룸에 접속...";
            PhotonNetwork.JoinRandomRoom();
        }
        else
        {
            // 접속 중이 아니라면 접속 시도
            connectionInfoText.text = "오프라인 : 마스터 서버와 연결되지 않음\n접속 재시도 중...";
            PhotonNetwork.ConnectUsingSettings();
        }
    }
```

### OnJoinRandomFailed() 메서드
랜덤 룸 접속에 실패한 경우 자동 실행된다. **마스터 서버와의 연결이 끊긴 게 아니다.** 예를 들면 참가 가능한 랜덤 룸이 없는 경우가 있다. 따라서, 이 경우에는 완전히 새로운 룸을 만들어 그곳에 접속하는 처리를 구현해야 한다.
```cs
    public override void OnJoinRandomFailed(short returnCode, string message) {
        connectionInfoText.text = "빈 방이 없음, 새로운 방 생성....";
        PhotonNetwork.CreateRoom(null, new RoomOptions { MaxPlayers = 4 });
    }
```
`PhotonNetwork.CreateRoom()` 은 생성할 룸의 이름(제목)을 `string` 타입으로 받고, 룸의 옵션을 `RoomOptions` 타입으로 받는다.
생성된 룸은 `리슨 서버` 방식으로 동작하며, 룸을 생성한 클라이언트가 호스트 역할을 맡는다.

### OnJoinedRoom() 메서드
룸 참가에 성공한 경우 자동 실행된다. 방을 직접 판 경우`PhotonNetwork.CreateRoom()`일 때도 자동 실행된다. 
대부분의 경우 준비가 될 때까지의 대기 시간을 제공하지만, 여기서는 룸에 접속하자마자 메인 게임을 시작하도록 구성한다. `Main` 씬을 로드한다.
```cs
    // 룸에 참가 완료된 경우 자동 실행
    public override void OnJoinedRoom() {
        connectionInfoText.text = "방 참가 성공";
        PhotonNetwork.LoadLevel("Main");
    }
```
여기서 `LoadScene`이 아니라 `LoadLevel`을 한다는 점에 주목한다.  
`LoadScene`은 **이전 씬의 모든 게임 오브젝트를 삭제하고 다음 씬을 로드하므로 로비 씬의 네트워크 정보가 유지되지 않는다.** 그리고 **각자 `Main` 씬을 동기화 없이 로드하므로 다른 사람의 캐릭터가 보이지 않는다.** 
`LoadLevel`은 어떤 씬은 로드하고, 해당 씬의 구성이 플레이어 사이에서 동기화되도록 유지한다.

> `LoadLevel()`의 동작
> - 룸의 플레이어들이 새로운 무대로 함께 이동하는 메서드이다. 방장이 `LoadLevel()` 메서드를 실행하면 다른 플레이어들의 컴퓨터에서도 같은 메서드가 실행되어 같은 씬을 로드한다.
> - 물론 각자 `LoadLevel()` 메서드를 실행하는 것도 가능하다. 단, 다른 플레이어들이 같은 씬을 로드하지는 않기 때문에 혼자만 다른 씬에 있는 상황이 생길 수 있다.
> - `LoadLevel()`은 뒤늦게 입장한 플레이어를 위한 별도의 작업을 구현할 필요가 없어 편리하다. 즉, 진행 중인 게임에 난입해도 같은 씬을 보여준다.
