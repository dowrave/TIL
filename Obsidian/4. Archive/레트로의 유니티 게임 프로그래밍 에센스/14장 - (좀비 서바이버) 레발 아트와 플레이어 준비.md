1. [[#프로젝트 구성|프로젝트 구성]]
2. [[#레벨 아트와 라이팅 설정|레벨 아트와 라이팅 설정]]
	1. [[#레벨 아트와 라이팅 설정#레벨 아트 추가하기|레벨 아트 추가하기]]
	2. [[#레벨 아트와 라이팅 설정#라이트 맵|라이트 맵]]
	3. [[#레벨 아트와 라이팅 설정#글로벌 일루미네이션|글로벌 일루미네이션]]
		1. [[#글로벌 일루미네이션#실시간 글로벌 일루미네이션|실시간 글로벌 일루미네이션]]
		2. [[#글로벌 일루미네이션#베이크된 글로벌 일루미네이션|베이크된 글로벌 일루미네이션]]
		3. [[#글로벌 일루미네이션#글로벌 일루미네이션 설정하기|글로벌 일루미네이션 설정하기]]
3. [[#플레이어 캐릭터와 애니메이션 구성|플레이어 캐릭터와 애니메이션 구성]]
	1. [[#플레이어 캐릭터와 애니메이션 구성#플레이어 캐릭터 준비하기|플레이어 캐릭터 준비하기]]
	2. [[#플레이어 캐릭터와 애니메이션 구성#애니메이터 설정|애니메이터 설정]]
	3. [[#플레이어 캐릭터와 애니메이션 구성#애니메이터 레이어|애니메이터 레이어]]
		1. [[#애니메이터 레이어#ShooterAnimator의 파라미터|ShooterAnimator의 파라미터]]
	4. [[#플레이어 캐릭터와 애니메이션 구성#Base Movement의 레이어|Base Movement의 레이어]]
	5. [[#플레이어 캐릭터와 애니메이션 구성#블렌드 트리|블렌드 트리]]
	6. [[#플레이어 캐릭터와 애니메이션 구성#Upper Body 레이어|Upper Body 레이어]]
	7. [[#플레이어 캐릭터와 애니메이션 구성#애니메이터 레이어 나누기|애니메이터 레이어 나누기]]
	8. [[#플레이어 캐릭터와 애니메이션 구성#아바타 마스크|아바타 마스크]]
		1. [[#아바타 마스크#휴머노이드 릭Humanoid Rig|휴머노이드 릭Humanoid Rig]]
		2. [[#아바타 마스크#아바타 마스크|아바타 마스크]]
4. [[#캐릭터 이동 구현|캐릭터 이동 구현]]
	1. [[#캐릭터 이동 구현#입력과 액터 나누기|입력과 액터 나누기]]
	2. [[#캐릭터 이동 구현#PlayerInput 스크립트|PlayerInput 스크립트]]
	3. [[#캐릭터 이동 구현#프로퍼티|프로퍼티]]
		1. [[#프로퍼티#자동 변환|자동 변환]]
		2. [[#프로퍼티#안전성 증가|안전성 증가]]
		3. [[#프로퍼티#접근자 개별 설정|접근자 개별 설정]]
		4. [[#프로퍼티#자동 구현 프로퍼티|자동 구현 프로퍼티]]
	4. [[#캐릭터 이동 구현#Update() 메서드|Update() 메서드]]
	5. [[#캐릭터 이동 구현#PlayerMovement 스크립트|PlayerMovement 스크립트]]
	6. [[#캐릭터 이동 구현#Start() 메서드|Start() 메서드]]
	7. [[#캐릭터 이동 구현#FixedUpdate() 메서드|FixedUpdate() 메서드]]
	8. [[#캐릭터 이동 구현#Move() 메서드|Move() 메서드]]
	9. [[#캐릭터 이동 구현#Rotate() 메서드|Rotate() 메서드]]
5. [[#시네머신 추적 카메라 구성하기|시네머신 추적 카메라 구성하기]]
	1. [[#시네머신 추적 카메라 구성하기#시네머신|시네머신]]
	2. [[#시네머신 추적 카메라 구성하기#시네머신의 원리|시네머신의 원리]]
	3. [[#시네머신 추적 카메라 구성하기#추적 카메라 만들기|추적 카메라 만들기]]
	4. [[#시네머신 추적 카메라 구성하기#데드존, 소프트존, 하드 리밋|데드존, 소프트존, 하드 리밋]]
	5. [[#시네머신 추적 카메라 구성하기#Body와 Aim 설정|Body와 Aim 설정]]



- 프로젝트의 씬, 플레이어 캐릭터를 만든다.

씬을 구성하는 레벨 아트를 준비, 라이팅을 설정한다. `글로벌 일루미네이션`과 `환경광`을 설정해 수준 높은 아트 분위기를 만들고, 플레이어 입력과 움직임, 애니메이션을 구현하고 애니메이션을 신체 부위 별로 나누어 적용하는 방법을 배운다. `시네머신`을 사용해 `자동 추적 카메라`를 쉽게 구현하는 방법도 배운다.

## 프로젝트 구성
- 유니티의 패키지 매니저를 사용하므로 프로젝트를 처음 열 때는 반드시 인터넷에 연결되어 있어야 한다

- 프로젝트의 폴더 설명
- `Assets/`
	- `Gizmos` : `시네머신`이 사용하는 기즈모 아이콘, 시네머신 패키지 추가 시 자동 생성된다.
	- `Models` : 3D 모델
	- `Post-Process Profile` : 후처리에 사용할 프로파일(프리셋)
	- `Sprites` : 2D 텍스쳐
	- `Textures` : 3D 텍스쳐 
- `Packages/` : 유니티의 패키지 매니저를 사용해 임포트한 패키지가 들어 있다.
	- `Cinemachine` : 스마트 추적 카메라, 복잡한 카메라 연출을 쉽게 구현한다.
	- `Package Manager UI` : 패키지 매니저의 UI창.
	- `Post-process` : `포스트 프로세싱 스택`으로, 후처리 효과를 구현한다. 

> `패키지 매니저` 설명
> - 유니티 2018부터 추가, **여러 유니티 프로젝트가 공유하는 패키지들을 한 곳에서 쉽게 관리**할 수 있다. 
> - 유니티 상단 메뉴의 `Window > Package Manager`로 열 수 있다.
> - `패키지`란 아트 에셋, 플러그인, 스크립트 등을 모아 압축한 파일이다. 
> - 전통적인 방식에서는 에셋 스토어 등에서 패키지를 다운로드하고, 프로젝트의 `Assets/` 폴더에 패키지의 압축을 풀어 에셋을 추가한다. 
> - 패키지 매니저를 사용하면 **에셋 스토어를 거치지 않고 패키지를 다운로드하며, 프로젝트의 `Assets/`에 에셋을 직접 추가하지 않고 사용**할 수 있다. 
> - 패키지 매니저를 사용해 다운로드한 패키지는 컴퓨터에 생성된 `글로벌 캐시` 폴더에 설치된다. 각 유니티 프로젝트는 패키지를 자신의 프로젝트 폴더에 직접 추가하지 않고, 글로벌 캐시의 패키지를 참조해서 사용한다. 그래서 프로젝트의 크기를 가볍게 한다.
> - 프로젝트를 협업자와 **공유할 때 패키지 파일을 함께 공유할 필요가 없다.** 유니티에서 필요한 패키지는 인터넷으로 다운로드하고 설치해준다.
> - 일부 유니티 공식 패키지는 여전히 에셋 스토어로 다운받아야 한다.

- 새로운 씬 만들기
`Projects/Assets에 Scenes/ 폴더 생성 > ctrl + s로 씬 저장 창 열기 > Main 이라는 이름으로 새 씬을 Scenes 폴더에 저장`

## 레벨 아트와 라이팅 설정
- 레벨 아트는 아티스트가 미리 만들어 둔 것을 사용하며, 이후 라이팅을 조정해 전반적인 아트 분위기를 조정한다.
### 레벨 아트 추가하기
- `Directional Light 삭제 > Prefabs/Level Art 프리팹을 Hierarchy 창으로 드래그 & 드롭`

> `Level Art` 프리팹에는 빛을 내는 라이트 오브젝트가 추가되어 있어서, 기존 라이트는 삭제한다.

`Level Art` 게임 오브젝트를 씬에서 살펴보면, 여러 사물과 울타리를 감싸도록 콜라이더가 추가되어 있음을 확인할 수 있다. 자세히 보면, **3D 모델을 감싸는 콜라이더 대부분은 간단한 큐브 형태**이다. 성능을 위해 `Level Art` 프리팹은 `기본Primitive 콜라이더`로 제작되었다. 
- `기본 콜라이더` : `박스Box`, `스피어Sphere` 등의 간단한 형태

`메시 콜라이더` 컴포넌트를 사용하면 3D 모델의 외형과 일치하는 콜라이더를 만들 수 있지만, 복잡한 형태 때문에 처리량이 크게 증가되므로 중요한 몇 가지 오브젝트에만 선택적으로 사용하는 게 좋다.

### 라이트 맵
`Level Art` 프리팹을 씬에 추가하면 유니티가 라이트맵과 여러 라이팅 정보를 포함한 `라이팅 데이터 에셋Lighting Data Asset`을 `굽게Bake` 된다. 이 때에는 유니티 에디터 우측 하단에 진행바가 표시된다.

**라이팅은 연산 비용이 비싸다.** 따라서 유니티는 라이팅 에디터 에셋을 사용, 라이팅 효과의 실시간 연산량을 줄이고 씬에 변화가 감지될 때마다 매번 새로운 라이팅 데이터 에셋을 생성한다.

라이팅 데이터 에셋의 주요 데이터 중 하나는 `라이트맵Lightmap`이다. 라이트맵은 **오브젝트가 빛을 받았을 때 어떻게 보일지 미리 그려둔 텍스쳐**로, 물체의 표면 위에 데칼을 입히는 것으로 이해할 수 있다. 라이트맵을 생성하는 것을 `라이트맵을 굽는다`고 표현한다. 라이트맵을 구워두면 **실시간 라이팅 연산 대신 오브젝트 표면에 라이트맵을 씌워 빛 효과를 표현**한다. 따라서, **`런타임`에 컴퓨터가 감당해야 할 라이팅 연산량이 크게 줄어든다.**  

> `런타임` : 프로그램이 실제로 실행되는 시간

하지만 라이트맵을 굽는 처리는 부하가 크고 시간이 오래 걸린다. 

- 따라서, 처음 1번만 씬의 라이트맵을 굽는다.

- `유니티 상단 메뉴 > Window > Rendering > Lighting Settings`
	- (책에는 없는 부분) `Lighting Settings`을 새로 만들어야 아래 부분이 진행되는 듯
	- `라이팅 창 하단 Auto Generate 해제` 
	- 환경광 설정 : `Environment Lighting - Source - Color`로 변경
		- `Ambient Color > (65, 23 ,12)로 컬러 변경`

> `환경광Environment Lighting`이란, 씬에 가장 기본으로 깔리는 빛이다. 모든 게임 오브젝트에 적용되며, 모든 방향에서 같은 세기로 들어오므로 **그림자나 명암을 만들지 않는다.** 전체적인 색 분위기를 조성함.

### 글로벌 일루미네이션
`글로벌 일루미네이션Global Illumination`이란, 물체의 표면에서 들어오는 빛 외에도 다른 물체의 표면에서 반사되어 들어온 간접광까지 표현한다. 

**매우 높은 처리량을 요구한다.** 오늘날 PC 성능으로도 완전한 글로벌 일루미네이션을 사용하기 힘들다. 실시간으로 사용해도 여러 제약과 대안을 함께 사용한다.

유니티는 글로벌 일루미네이션을 라이트맵 + 여러 대안을 함께 사용해 구현한다. 여기서는 글로벌 일루미네이션의 처리량을 줄이기 위한 정보가 포함된다.

라이팅 창에서는 2가지 종류의 글로벌 일루미네이션을 선택할 수 있다. 2개를 함께 쓰거나, 둘 중 하나만 쓴다.
- `실시간 글로벌 일루미네이션 Realtime GI`  (진짜 의미의 Realtime은 아님)
- `베이크된 글로벌 일루미네이션 Baked GI`

#### 실시간 글로벌 일루미네이션
빛의 세기와 방향 등이 달라졌을 때, 간접광에 실시간으로 반영한다.

**라이트 맵을 여러 방향에 대해 생성**한다. 그리고 **여러 경우에 대한 빛의 예상 반사 방향과 광원의 예상 이동 경로 등의 정보를 미리 계산하여 저장**한다. 게임 도중 물체 표면에 들어오는 빛의 방향이 달라져도 간접광이 어떤 방향이 어떤 세기로 반사되어야 하는지 적은 비용으로 추측할 수 있으며, 광원의 변화를 실시간으로 간접광에 반영할 수 있다.

`실시간`이더라도 미리 계산해야 하는 정보가 있으므로, 라이팅 데이터 에셋을 구워야 한다.

#### 베이크된 글로벌 일루미네이션
고정된 빛에 의한 간접광을 라이트맵으로 구운 다음, 게임 오브젝트 위에 미리 입힌다. 

간접광 효과는 게임 중에 실시간으로 변하지 않는다. 실시간 대비 표현의 질, 런타임 성능이 더 좋지만 게임 도중에 빛의 세기나 방향이 달라져도 간접광에 반영되지 않는다. 따라서 갑자기 밝아지거나 어두워지면 이질감을 느낄 수 있다.

#### 글로벌 일루미네이션 설정하기
- **실시간 글로벌 일루미네이션만 사용한다.** 베이크의 런타임 성능이 더 좋지만, 변화하는 빛을 감지하지 못하고 굽는 시간이 더 오래 걸린다는 단점이 있다.
- `Mixed Lighting > Baked Global Illumination 체크 해제 > Lightmapping Settings의 Indirect Resolution 0.5로 변경 > Generate Lighting 클릭`

> 라이트맵의 텍스쳐 해상도를 `0.5 texel`로 줄였다. 라이팅 효과의 정교함이 떨어지지만, 로우 폴리 스타일의 3D 모델을 사용하므로 티나지 않는다.
> - `texel` : 텍스쳐의 화소. 화면pic의 1화소 = 1픽셀인 것처럼 텍스쳐tex의 화소도 텍셀이란 단위를 쓴다

라이트맵을 얼마간 구운 다음 **굽기가 완료되면 `Main` 씬을 저장한 폴더에 씬과 같은 이름으로 라이팅 정보를 저장한 폴더가 생성**된다. 해당 폴더에서 `Main` 씬에 관한 라이팅 정보를 저장한 에셋들을 확인할 수 있다.

> 정적 게임 오브젝트
> 글로벌 일루미네이션은 `정적Static` 게임 오브젝트에만 적용된다. 체크박스는 인스펙터의 우측 상단에서 확인할 수 있다.
> `정적` 게임 오브젝트는 게임 중에 위치가 변경될 수 없지만, 유니티가 더 많은 성능 최적화를 적용한다.


## 플레이어 캐릭터와 애니메이션 구성

### 플레이어 캐릭터 준비하기
- `Models/Woman dnd > 이름 Player Character, 태그 Player로 변경 > 위치 0 0 0`

3D 모델 에셋 `FBX 파일`을 하이어라키 창으로 dnd 하여 해당 3D 모델을 사용하는 게임 오브젝트를 생성했다. 3D 모델에서 생성된 게임 오브젝트는 `애니메이터 컴포넌트`를 가지며, 3D 모델의 계층 구조나 본 구조가 유지되어 함께 추가된다.

- 리지드 바디 추가하기 : `Angular Drag : 20, Constraints - Freeze Rotation X, Z 체크`

`Angular Drag(각 항력)` : 회전에 대한 마찰력으로, 값을 높이면 잘 회전하지 않게 되거나 회전해도 금방 멈추게 된다. 벽이나 좀비에 부딪히고 밀려날 때 캐릭터가 미끄러지듯이 회전하는 상황을 막기 위해 값을 높인다.

`X, Z축 회전 고정` : 해당 방향으로 캐릭터가 넘어지지 않게 하기 위함

- **캡슐 콜라이더 컴포넌트 추가** : `Capsule Collider > Center (0, 0.75, 0) 및 Radius 0.2, Height 0.5`
- **오디오 소스 컴포넌트 추가** : `Audio Source > Play On Awake 해제`

### 애니메이터 설정
- 저자가 미리 `ShooterAnimator` 애니메이터 컨트롤러를 `Animations` 폴더에 넣어두었다. 캐릭터의 걷고 달리는 움직임, 재장전, 조준에 대한 애니메이션 상태로 구성되어 있다.

- `Player Character 오브젝트 > Animator 컴포넌트 > Controller > ShooterAnimator 애니메이터 컨트롤러 할당(필드의 선택 버튼 > 선택 > Shooter Animator 더블클릭) > Apply Root Motion 체크 해제`

> `Root Motion` : 게임 오브젝트의 위치, 회전을 애니메이션이 제어하도록 허용하는 옵션
> - 앞으로 움직이는 캐릭터 애니메이션이 있다고 가정하자.
> - 루트 모션 적용 : 게임 오브젝트의 실제 위치가 이전보다 앞쪽으로 변경됨
> - 루트 모션 적용 X : 제자리에서 걷는 애니메이션 재생

루트 모션 적용을 사용하면 아티스트의 의도를 반영한 움직임을 만들 수 있지만, 스크립트로 움직임을 제어하기는 힘들다. 스크립트로만 움직임을 제어하기 위해 루트 모션 적용을 사용하지 않는다.
### 애니메이터 레이어

- 애니메이터 컨트롤러 표시하기 : `Player Character 선택 > Animation > Animator 창 띄우기`

`Layers` 탭을 보면, `Base Movement` 및 `Upper Body`로 나뉘어 있다. 
**`유한 상태 머신`에서는 하나의 상태만 현재 상태**가 될 수 있지만, **여러 개의 유한 상태 머신을 병렬로 실행하는 방식으로 여러 상태가 동시에 현 상태로 중첩**되게 할 수 있다.  같은 원리로, 레이어를 여러 개 사용해서 여러 애니메이션 상태를 하나의 게임 오브젝트에 중첩되게 할 수 있다. 

`Base Movement`는 걷고 뛰는 기본 움직임에 관한 애니메이션을 재생한다.
`Upper Body`는 캐릭터 상체에만 적용할 조준, 재장전 애니메이션을 재생한다. 
- 더 자세한 내용은 `14.3.8 아바타 마스크`에서 설명한다.

#### ShooterAnimator의 파라미터
- `Move`, `Reload`, `Die`
- 애니메이터에 구성된 상태들 사이의 조건으로 사용된다. 각 파라미터에 할당할 값은 스크립트에서 결정한다.

### Base Movement의 레이어
![[Pasted image 20240620153924.png]]
- 복습 ) `Entry`와 이어진 `Movement` 상태가 가장 먼저 재생된다.
- 복습2) 어떤 상태에서든 `Die`트리거가 발동되면 `Any State -> Die` 전이가 실행되어 사망 애니메이션이 재생된다.

### 블렌드 트리
일반적으로 애니메이터의 상태에는 애니메이션 클립이 할당된다. 예를 들어, `Die` 에는 `Human Death` 애니메이션 클립이 할당되어 있다. 하지만 특수한 종류의 모션(움직임을 나타내는 에셋)을 상태에 할당하는 것도 가능하다. 

그 중 하나가 애니메이션 클립을 혼합하는 `블렌드 트리Blend Tree` 모션이다. 해당 상태는 `애니메이터 창 > 우클릭 > Create State > From New Blend Tree`로 만들 수 있다.

위의 `Movement` 상태는 `Movement Tree`라는 블렌드 트리가 할당되어 있다. 이를 더블 클릭하면 할당된 블렌드 트리의 그래프를 볼 수 있다.
![[Pasted image 20240620154315.png]]

블렌드 트리는 여러 애니메이션 클립을 파라미터 값에 따라 적절히 `혼합Blend`하는 모션이다. 여러 클립을 현재 상태에 맞게 섞어 사용할 수 있다.

위 그림에서 각각의 사각형을 `노드`라고 부른다. `Movement Tree` 노드를 보면 
![[Pasted image 20240620154421.png]]

- `Blend Type` : 파라미터를 1개만 사용하는 1D
- `Parameter` : Move
- `Motion` 리스트에는 사용할 애니메이션 클립이 나열된다. 
- 위에 할당된 리스트는 저자가 미리 애니메이션 클립 5개를 할당한 것이다. 아래 클립이 `Move` 값에 따라 서로 섞이게 된다.

| 순서 | 애니메이션 클립(Motion)  | 임곗값(Threshold) | 애니메이션 재생 속도(Animation Speed) |
| ---- | ------------------------ | ----------------- | ------------------------------------- |
| 1    | Humanoid Run(뒤로 뛰기)  | -1                | -1                                    |
| 2    | Humanoid Walk(뒤로 걷기) | -0.5              | -1                                    |
| 3    | Humanoid Idle(대기)      | 0                 | 1                                     |
| 4    | Humanoid Walk(걷기)      | 0.5               | 1                                     |
| 5    | Humanoid Run(뛰기)       | 1                 | 1                                      |

1. 1, 2번 클립의 재생 속도가 `-1`인 이유는, 기존의 **걷는 애니메이션과 뛰는 애니메이션 클립을 거꾸로 재생하는 방식**이기 때문이다.
2. `임곗값Threshold` : 애니메이션 클립이 100% 섞이는 지점. 예를 들어 `1`이면 5번 클립이 100% 사용되며, `0.75`라면 4와 5가 50%식 섞인다.

위처럼 블렌드 트리를 사용하는 `Movement` 상태는 `Move` 값에 따라 5가지 애니메이션 클립을 자연스럽게 섞어서 사용한다. 더 다양한 조건을 주고 싶다면 블렌드 타입을 `2D` 타입으로 바꿔 더 다양한 조건으로 섞는 것도 가능하다.

### Upper Body 레이어
![[Pasted image 20240620155013.png]]
1. `Any State -> Die` : `Conditions : Die`로 동일함. 대신 `Die` 상태는`Base Movement`와 달리 `Motion`이 할당되지 않았다. 이미 같은 트리거로 모션이 동작하도록 설정되어 있기 때문.
2. `Aim Idle` : 가장 먼저 재생되는 상태. 캐릭터가 총을 들고 조준하는 애니메이션 클립을 재생한다. 
	- `Reload`와 양방향 전이로 연결되어 있다. `Aim -> Reload`은 `Reload` 컨디션이 설정되어 있지만, 그 역방향 전이는 아무 컨디션도 설정되지 않는다.
	- `Reload 트리거`가 발동되면 `Reload 상태`로 현재 상태가 이동한다. 그리고 애니메이션이 끝나면 `Aim Idle` 상태로 돌아간다.

### 애니메이터 레이어 나누기
**애니메이터에 레이어를 2개 이상 만들면 위에서 아래 순서로 `덮어쓰기Override` 방식으로 적용된다.** 즉 `Basemovement`가 먼저 반영된 다음 `Upper body`가 `Base Movement` 레이어의 애니메이션을 덮어쓰기 하면서 반영된다. 

이렇게 레이어를 나누는 이유는 더 적은 애니메이션 클립으로 다양한 상황에 대응하기 위함이다.

예를 들어 달리면서 재장전이 필요한 경우, 레이어를 나누지 않으면 "뛰면서 재장전하는" 클립을 새로 만들어야 한다. 레이어를 나누면 `Base Movement`에서는 달리는 모션, `Upper Body`에서는 재장전하는 모션을 만들고 이 둘을 합쳐 쓸 수 있다.

### 아바타 마스크
레이어 별로 부위를 다르게 적용하려면 `아바타 마스크Avatar Mask`를 적용해야 한다.

#### 휴머노이드 릭Humanoid Rig
사람 형태의 3D 모델은 대부분 휴머노이드 타입으로 `리깅Rigging`된다. 이 프로젝트의 `Woman` 모델과 `Zombie` 모델은 휴머노이드 타입으로 리깅되어 있다.
> `리깅Rigging` : 3D 모델의 골격과 움직임을 정의하는 조인트 계층 구조를 만드는 것

유니티에서 **휴머노이드 타입으로 리깅된 3D 모델은 체형이 달라도 애니메이션 클립이 호환된다.** 신체 골격의 정보가 3D 모델에 포함되어 있기 때문에 애니메이션 클립을 특정 신체 부위에만 적용할 수도 있다. 

#### 아바타 마스크
특정 신체 부위에만 애니메이션을 적용하려면 `아바타 마스크`를 사용한다. `Project 창 > Create > Avatar Mask`로 만들 수 있다. 

이 프로젝트에서는 `Animations/Upper Body Mask`로 만들어뒀다. `Humanoid`를 클릭하면..
![[Pasted image 20240620160142.png]]
초록색은 애니메이션이 적용되는 부위, 빨간색은 적용되지 않는 부위이다.
단순히 **해당 부위를 클릭**하는 것만으로 부위별 애니메이션 적용 여부를 전환할 수 있다.

- Upper Body 레이어에 아바타 마스크 적용하기 : `Animator - Upper Body의 톱니바퀴 - Upper Body Mask 더블 클릭`

이러면 이제 `Upper Body`에서 재생되는 애니메이션은 3D 모델의 상체에만 적용된다. 

또 `IK Pass` 옵션이 활성화되어 있는데, `Inverse Kinematics`를 적용한다는 의미이다. 15장에서 설명함. 

## 캐릭터 이동 구현
- `Player Character`에 `PlayerInput.cs, PlayerMovement.cs`를 추가한다.
	- `Input` : 입력을 감지하고 다른 컴포넌트에 알려준다
	- `Movement` : 입력에 따라 캐릭터를 이동하거나 회전시킨다.

### 입력과 액터 나누기
이전에는 **하나의 스크립트에 입력 감지 + 움직이는 코드 모두를 구현**했다. 

여기서는 입력 / 동작 코드의 스크립트를 구분했다. `Input` 스크립트를 따로 구현해두고 다른 스크립트는 `Input` 컴포넌트에서 값을 받는 식으로 구현하면 전체적인 코드 양을 줄일 수 있다.
- 예를 들어 플랫폼을 PC -> 모바일 / 콘솔로 바꾸는 과정이라고 치면, `Input` 스크립트에 입력 감지 코드를 몰아뒀으니 해당 스크립트만 수정하는 방식이다.

### PlayerInput 스크립트
- 저자가 미리 완성해뒀단다.

```cs
    public string moveAxisName = "Vertical"; // 앞뒤 움직임을 위한 입력축 이름
    public string rotateAxisName = "Horizontal"; // 좌우 회전을 위한 입력축 이름
    public string fireButtonName = "Fire1"; // 발사를 위한 입력 버튼 이름
    public string reloadButtonName = "Reload"; // 재장전을 위한 입력 버튼 이름
```
여기서 할당된 입력 축, 입력 버튼은 입력 매니저 `Edit > Projects Settings > Input`에서 확인할 수 있다. `Horizontal, Vertical` 부분은 6장에서 나온 내용인 입력축이다. 이와 달리 `Fire1, Reload` 부분은 입력축이 아니라 입력 버튼이다. 

- 축과 달리 버튼은 눌렀을 때 `true`, 아닐 때 `false`가 반환된다.
- `Fire1`은 입력 매니저에 기본 추가된 입력 버튼이다. 사용할 버튼으로 왼쪽 `ctrl` 키와 `왼쪽 마우스 버튼`이 할당되어 있다. `Reload`는 저자가 별개로 추가했으며, 키보드 `R`키를 사용한다.


### 프로퍼티
이 다음은 감지된 입력값을 나타내는 **프로퍼티**이다. 
```cs
    // 값 할당은 내부에서만 가능
    public float move { get; private set; } // 감지된 움직임 입력값
    public float rotate { get; private set; } // 감지된 회전 입력값
    public bool fire { get; private set; } // 감지된 발사 입력값
    public bool reload { get; private set; } // 감지된 재장전 입력값
```
> `move` : `-1.0`일 때 후진, `+1.0`일 때 전진
> `rotate` : `-1.0`일 때 왼쪽으로, `+1.0`일 때 오른쪽으로 회전
> `fire` : 감지된 발사 입력, `true`일 때 발사
> `reload` : 감지된 재장전 입력, `true`일 때 탄알 재장전

`프로퍼티Property`란 변숫값을 읽거나 쓰는 과정에서 유연한 처리를 삽입할 수 있는 클래스 멤버이다. **변수처럼 보이지만 변수가 아닌 특수한 형태의 메서드이다.**

- 예시) 바이트 단위로 용량을 기록하고 계산하지만 필요 시 다른 단위로 용량을 변환하여 제공하는 케이스
```cs
public class VolumeInfo {
	public float megaBytes
	{
		get {return m_bytes * 0.000001f;}
		set {
			if (value <= 0) {
				m_bytes = 0;
			} else {
				m_bytes = value * 1000000f;
			}
		}
	}
	public float bytes
	{
		get { return m_bytes; }
		set { 
			if (value <= 0) {
				m_bytes = 0;
			} else {
				m_bytes = value;
			}
		}
	}

	private float m_bytes = 0;
}

VolumneInfo info = new VolumeInfo(); // 새로운 용량 정보 생성

info.bytes = 1000000; // VolumeInfo.bytes.set 실행, 1000000 할당
Debug.Log(info.megaBytes) // megaBytes의 get 실행, 1 출력
info.megaBytes = 4; // VolumeInfo.megaBytes.set 실행, m_bytes에는 4000000 할당
Debug.Log(info.bytes) // 4000000
```
1. 프로퍼티의 **선언은 메서드와 동일한데, 내부에 `get, set` 접근자를 사용**한다. 
2. 변수처럼 사용할 수 있는데, 선언할 때와 값을 그대로 이용하는 경우의 동작이 다르다.
	- **선언 : `set` 메서드가 작동하여 해당 값을 할당함**
	- **이용 : `get` 메서드가 작동하여 해당 값을 불러옴**

#### 자동 변환
위 예시처럼 바이트 단위로 저장된 용량을 여러 단위의 값으로 즉시 출력할 수 있었다. 이처럼 어떤 값을 다른 맥락에 맞춰 사용할 수 있다. 

아래 예시는 수동으로 `bool dead`의 값을 변경할 필요 없이, `health`에 따라 자동으로 값이 바뀌는 프로퍼티를 만든다.
```cs
public float health = 100;

public bool dead {
	get 
	{
		if (health <= 0) {
			return true;
		}
		return false;
	}
}
```

#### 안전성 증가
프로퍼티는 데이터를 안전하게 다루는 데 도움이 된다. **프로퍼티를 이용해 값을 읽고 할당하는 처리에 `필터`를 추가하면 외부에서 잘못된 값을 할당했을 때 내부에서 걸러낼 수 있다.**

`VolumeInfo`의 예제를 보면, `m_bytes` 값의 할당은 반드시 프로퍼티를 거쳐야만 가능하도록 구성되어 있으며, `value`의 값이 0 이하인 경우는 할당되지 않도록 `필터` 기능도 포함되어 있다. 위 구조에서는 `-1000` 같은 데이터가 `m_bytes` 값에 할당될 수 없다.

#### 접근자 개별 설정
1. 프로퍼티의 **get, set 접근자는 접근 권한을 각각 다르게 줄 수 있다.**
```cs
public float megaBytes
{
	get { return m_bytes * 0.0000001f; }
	private set {
		if (value <= 0) {
			m_bytes = 0;
		} else {
			m_bytes = value * 1000000f;
		}
	}
}
```
위의 경우 외부에서 값을 가져오는 건 가능하지만, 값을 할당하는 건 에러가 난다.

2. 둘 중 하나만 사용하는 것도 가능하다. 

#### 자동 구현 프로퍼티
```cs
    // 값 할당은 내부에서만 가능
    public float move { get; private set; } // 감지된 움직임 입력값
    public float rotate { get; private set; } // 감지된 회전 입력값
    public bool fire { get; private set; } // 감지된 발사 입력값
    public bool reload { get; private set; } // 감지된 재장전 입력값
```
이번 스크립트 예제인데, 여기의 `move, rotate, fire, reload`는 `자동 구현 프로퍼티Auto Implemented Properties`이다. **자동 구현 프로퍼티는 `get`과 `set`의 접근 권한을 분리하는 것 이외의 처리가 필요하지 않을 때 사용한다.** 

이 중 `move`만을 예로 들면, 위 코드는 아래와 같다.
```cs
public float move {
	get { return m_move; }
	private set { m_move = value; }
}
private float m_move;
```

즉, `move, rotate, fire, reload`는 외부에서 값을 읽기만 가능하고 할당은 `PlayerInput` 내부에서만 가능한 자동 구현 프로퍼티가 된다.

### Update() 메서드
```cs
    // 매프레임 사용자 입력을 감지
    private void Update() {
    
        // 게임오버 상태에서는 사용자 입력을 감지하지 않는다
        if (GameManager.instance != null && GameManager.instance.isGameover)
        {
            move = 0;
            rotate = 0;
            fire = false;
            reload = false;
            return;
        }

        // move에 관한 입력 감지
        move = Input.GetAxis(moveAxisName);
        // rotate에 관한 입력 감지
        rotate = Input.GetAxis(rotateAxisName);
        // fire에 관한 입력 감지
        fire = Input.GetButton(fireButtonName);
        // reload에 관한 입력 감지
        reload = Input.GetButtonDown(reloadButtonName);
    }
```
1. `GameManager`는 17장에서 다룬다. `GameManager.instance`에서 보이듯 싱글턴으로 구현되어 있으며, `isGameover`를 이용해 게임 오버 상태를 알려준다. 

2. 우선 게임 오버 상태인 경우 사용자 입력값을 초기화하고 메서드를 종료한다. 게임 오버 상태에서도 사용자 입력을 감지해서 캐릭터가 동작하는 상황을 막는다.

3. 나머지 조건) 게임 오버가 아니거나, 게임오버 상태를 표시하는 게임 매니저가 씬에 존재하지 않는 경우 입력 감지 코드가 실행된다.
- `Input.getAxis()` : 축 이름을 받아 감지된 입력을 숫자로 반환한다.
- `Input.getButton()` : 버튼 이름을 받아 누르고 있는 동안 `true`를 반환한다.
- `Input.getButtonDown()` : 누르는 순간에만 `true`, 나머지는 `false`를 반환한다. 즉 누르고 있는 동안은 `false`이다. 

플레이어의 입력을 감지해야 하는 **다른** 스크립트는 직접 입력 감지를 구현할 필요 없이 `PlayerInput` 컴포넌트의 `move, rotate, fire, reload`의 값만 확인하면 된다. 프로퍼티로 값을 가져오면 되는 개념임

### PlayerMovement 스크립트
플레이어 입력에 맞춰 캐릭터를 이동하고 적절한 애니메이션을 재생한다. 

- 변수
```cs
    public float moveSpeed = 5f; // 앞뒤 움직임의 속도
    public float rotateSpeed = 180f; // 좌우 회전 속도

    private PlayerInput playerInput; // 플레이어 입력을 알려주는 컴포넌트
    private Rigidbody playerRigidbody; // 플레이어 캐릭터의 리지드바디
    private Animator playerAnimator; // 플레이어 캐릭터의 애니메이터
```

### Start() 메서드
```cs
    private void Start() {
        // 사용할 컴포넌트들의 참조를 가져오기
        playerInput = GetComponent<PlayerInput>(); 
        playerRigidbody = GetComponent<Rigidbody>();
        playerAnimator = GetComponent<Animator>();  
    }
```

### FixedUpdate() 메서드
`Update()`와 달리, **물리 정보 갱신 주기(기본값 0.02초)마다 실행된다.**

여기서는 `Move(), Rotate()`를 실행할 것이다. `Update()`에서 해도 되지만 물리 주기에 맞춰 실행하는 `FixedUpdate()`에서 실행하는 게 오차 확률을 크게 줄일 수 있다. 여기서. 움직이는 메서드들은 이후에 구현함.
```cs
    // FixedUpdate는 물리 갱신 주기에 맞춰 실행됨
    private void FixedUpdate() {
        // 물리 갱신 주기마다 움직임, 회전, 애니메이션 처리 실행
        Rotate();
        Move();

        // 입력값에 따라 애니메이터의 Move 파라미터값 변경
        playerAnimator.SetFloat("Move", playerInput.move);
    }
```
`Move` 파라미터는 애니메이터의 `Movement` 블렌드 트리에서 사용한다. 따라서 사용자 입력에 따라 걷고 뛰는 애니메이션이 자연스럽게 변경된다. 

> `Time.fixedDeltaTime`  
> 물리 정보의 갱신 주기인 `FixedUpdate()` 메서드의 실행 간격을 표시한다.   
> 유니티에서는 개발자의 편의를 위해, `FixedUpdate()` 메서드 내에서 `Time.deltaTime`으로 접근할 경우`Time.fixedDeltaTime`의 값을 출력한다.


### Move() 메서드
```cs
    private void Move() {
        // 상대 이동 거리 계산
        Vector3 moveDistance = playerInput.move * transform.forward * moveSpeed * Time.deltaTime;

        // 리지드바디를 이용, 게임 오브젝트 위치 변경
        playerRigidbody.MovePosition(playerRigidbody.position + moveDistance);

    }
```
1. `moveDistance` : 한 프레임`Time.deltaTime` 동안 현위치에서 상대적으로 더 이동한 거리와 방향. `playerInput.move`는 사용자의 입력값으로 -1 ~ 1까지이다.
2. `MovePosition` : 이동할 `Vector3` 위치를 입력받는다. **전역 위치를 사용한다**는 점에 주의한다. 메서드에 `(0, 0, 3)`을 입력하면 `현위치 + 0, 0, 3`이 아니라 전역 위치 `0, 0, 3`으로 이동한다. 

- 리지드바디 컴포넌트를 사용하지 않고, 트랜스폼 컴포넌트로 같은 이동을 구현할 수도 있다.
```cs
transform.position = transform.position + moveDistance;
```
근데 이렇게 하면 **물리 처리를 무시하고 위치를 덮어쓰는 개념**이 돼서, 벽을 무시하고 반대로 이동할 수도 있다. 

**리지드바디의 `MovePosition()`으로 메서드를 실행하면 이동 경로에 다른 콜라이더가 존재하는 경우 밀어내거나 밀려나는 물리 처리가 발생한다.**

### Rotate() 메서드
```cs
    private void Rotate() {
        // 상대적으로 회전할 수치 계산
        float turn = playerInput.rotate * rotateSpeed * Time.deltaTime;

        // 리지드바디를 이용해 게임 오브젝트 회전 변경
        playerRigidbody.rotation = playerRigidbody.rotation * Quaternion.Euler(0, turn, 0f);
    }
```
1. `turn` : 한 프레임 동안 회전할 각도를 저장한다. `사용자 입력 * 회전 속도 * 시간`
2. 현재 회전에서 `turn`만큼을 Y축 기준으로 더 회전한다. `Quatertion` 곱으로 구현한다. 

여기도 마찬가지로 `transform.rotation()`에 할당하는 방식은 쓰지 않았다 : 물리처리가 무시됨.

- 스크립트 저장 후 PlayerMovement가 잘 동작하는지 테스트하기 위해, 유니티 엔진으로 돌아가 wasd나 방향키를 눌러 플레이어 캐릭터를 움직여본다. `a, d`는 회전, `w, s`는 앞/뒤 이동이다.

## 시네머신 추적 카메라 구성하기
- 캐릭터를 따라다니는 카메라를 만든다. 추적 카메라는 `시네머신`으로 구현한다.

### 시네머신
**카메라의 움직임을 손쉽게 제어하는 유니티 공식 패키지이다.**

카메라 연출은 복잡한 수학적 모델과 수식을 사용, 코드로 직접 구현한다. 컷신을 만드는 경우 좋은 장면이 나올 때까지 카메라 위치를 계속 변경하면서 카메라가 움직일 궤도를 애니메이션으로 녹화하기도 한다. 이렇듯 시간과 노력이 필요한 작업이다.

**시네머신은 카메라 연출에 필요한 코드와 조정 작업 대부분을 대체할 수 있다.** 시네머신을 사용하면 장르마다 고유한 카메라 동작을 별 스크립트 작성없이 구현할 수 있다. 게임 플레이, 게임 컷신 모두에서 많은 부분을 자동화할 수 있다.

컴포넌트들은 `카메라 초점, 화면 상의 피사체 배치, 추적의 지연시간, 카메라 흔들림, 여러 카메라 사이에서의 전환` 등 카메라 연출과 관련된 다양한 수치를 제공한다. 이 값들을 연출 의도에 맞춰 변경하고 카메라가 추적할 대상만 지정하면 시네머신 카메라가 알아서 목표물을 화면에 담는다.

### 시네머신의 원리
시네머신이 제공하는 카메라는 크게 2종류이다.
- `브레인 카메라 Brain Camera`
- `가상 카메라 Virtual Camera`

**시네머신으로 카메라 추적을 구현하려면 우선 브레인 카메라를 만들어야 한다.** 게임 월드를 촬영하는 진짜 카메라이며, 씬에 하나만 존재한다.

`가상 카메라`는 브레인 카메라의 **분신**으로, **브레인 카메라는 여러 가상 카메라 중 하나를 골라 현재 활성화된 카메라를 사용한다.** 머리 하나에 몸을 여러 개 준비한 다음 상황에 맞춰 몸을 바꾸는 것으로 이해할 수 있다.

가상 카메라에는 브레인 카메라를 위한 설정값을 제공한다. 브레인 카메라가 해당 카메라를 이용하기로 했을 때, 브레인 카메라 자신의 설정값으로 이용한다. 

이런 느낌으로 롱테이크 연출이나 카메라 사이의 부드러운 전환이 가능하지만, 여기서는 카메라 전환 기능은 쓰지 않는다. `캐릭터 추적 카메라`를 만들 거임.

### 추적 카메라 만들기
- `Hierarchy > Main Camera 선택 > Cinemachine Brain 컴포넌트 추가 > 새 가상 카메라 생성(Hierarchy > Cinemachine > Virtual Camera) > 이름 Follow Cam으로 변경`

씬을 촬영하는 건 `Main Camera` 오브젝트이지만, 촬영 방법을 결정하는 건 `Follow Cam` 오브젝트이다. 

- 플레이어 캐릭터 추적 설정하기  : `Follow Cam 선택 > CinemachineVirtualCamera 컴포넌트의 Follow, Look At에 Player Character 오브젝트 dnd`

가상 카메라는 Follow 필드에 할당된 게임 오브젝트를 따라다니고, Look At 필드에 할당된 게임 오브젝트를 주시한다. 

### 데드존, 소프트존, 하드 리밋
위에서 **`Look At`에 플레이어 캐릭터를 할당**하는 순간, 게임 차엥 붉은색과 푸른색으로 그려진 영역과 안내선이 나타난다.  
카메라의 **자연스러운 추적을 구현하는 데 사용하는 `소프트존Soft Zone`, `하드 리밋Hard Limit`, `데드존Dead Zone` 이라는 개념**이 있다.

시네머신 카메라는 대상을 주시하는 동안 카메라 연출이 자연스럽게 느껴지도록 지연 시간을 두고 카메라를 부드럽게 회전한다. `데드존, 소프트존, 하드리밋`은 주시하는 물체가 게임 화면으로 벗어나지 않게 추적의 세기를 단계별로 설정한다.

1. **카메라가 주시하는 물체가 데드존에 있는 동안에는 카메라가 회전하지 않는다.**
2. 주시하는 물체가 **소프트존에 있다면, 물체가 화면의 조준점에 오도록 카메라가 부드럽게 회전**한다. 물체가 너무 빠르게 움직여 소프트존을 벗어나 하드 리밋에 도달하려 한다면 카메라가 격하게 회전한다. 따라서, **카메라가 주시하는 물체는 화면의 소프트존을 벗어나지 않는다.**

데드존과 소프트존의 크기를 줄이면 물체가 조금이라도 화면 중앙을 벗어나려 할 때, 지연시간 없이 즉시 카메라가 물체를 향해 회전한다. 이는 화면의 움직임을 딱딱하게 만들 수 있다. 반대로 데드존과 소프트존의 크기를 늘리면 화면의 움직임이 느리게 느껴질 수 있다.

### Body와 Aim 설정
이 게임의 플레이어 캐릭터는 이동속도가 빠르기 때문에, 카메라의 데드존과 소프트존을 최대한 작게 만들어 캐릭터를 빠르게 추적한다. 

- 가상 카메라 시야각, Body 파라미터 설정하기 : `Field Of View : 20 > Body 탭 펼치기 > Binding Mode : World Space로 변경 > Follow Offset (-8, 16, -8)로 변경 > X Damping, Y Damping, Z Damping을 0.1로 변경`

> 내 경우 `FOV`는 `Vertical FOV`로 나타남. 동일한 의미로 보임.

1. `FOV`를 줄여 게임 화면을 줌인한다. `시야각 Field Of View`은 카메라가 한 번에 볼 수 있는 각도로, 시야각을 줄이면 좁은 영역을 보게 되므로 줌인 효과가 나타난다.
2. `Body 파라미터` : `Follow`에 할당한 추적 대상을 어떻게 따라다닐지 결정한다. 
	- 카메라를 `머리`로 보면, 카메라의 추적 대상은 `몸`으로 볼 수 있다. 몸이 움직이면 머리가 따라 움직이기 때문이다.  즉, `Body` 파라미터는 추적 대상을 카메라의 몸통으로 보고, 머리 카메라가 어떻게 매달려 다닐지, 얼마나 떨어져 있을지를 결정한다.
3. `전역 공간World Space` : 카메라와 몸체 사이의 간격을 `전역 공간World Space`을 기준으로 `-8, 16, 8` 만큼 떨어뜨렸다. 카메라는 추적 대상인 게임 오브젝트를 해당 벡터만큼 거리를 두고 추적한다. 
4. `제동Damping`  : 값의 급격한 변화를 "꺾어" 이전-이후 값을 부드럽게 이어주는 비율이다.  값이 커지면 카메라 위치의 급격한 변화는 줄지만, 위치가 신속하게 변경되지 않고 지연 시간이 늘어난다.
	- 모두 `0.1`로 줄였기에 캐릭터를 더 빠르게 쫓아간다.


- 가상 카메라의 `Aim` 파라미터 설정하기 : `Tracked Object Offset`을 `0, 0.5, 0`으로 변경, `Horizontal Damping, Vertical Damping : 0`으로 변경, `Soft Zone Width, Soft Zone Height`를 `0`으로 변경
1. `Tracked Object Offset` : 원래 추적 대상에서 얼마나 더 떨어진 곳을 조준할지 결정한다. `Y` 값을 조금 늘려, 캐릭터의 실제 위치보다 조금 더 높은 곳을 조준한다.
2. 회전 속도 제동값을 모두 0으로 바꿈
3. 소프트존 제거 - 카메라가 지연 시간 없이 게임 오브젝트를 즉시 조준하게 된다.

