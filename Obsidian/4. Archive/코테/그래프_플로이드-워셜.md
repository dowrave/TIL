- [[그래프_다익스트라]]나 [[그래프_벨만-포드]]가 한 점에서 다른 점들까지의 최단 경로를 구하는 알고리즘이었다면, **플로이드-워셜 알고리즘은 모든 노드 간의 최단 경로를 구하는 알고리즘**이다.
- 음의 간선도 사용할 수 있다

## 시간복잡도 :$O(n^3)$

## 과정
- 알고리즘은 **총 노드의 개수 만큼 라운드를 가짐**
	- 각 라운드에서 i번째 노드를 중간 노드로 설정함
- 초기화 : 인접 노드만 그래프에 표시(이 **2차원 그래프가 곧 거리 행렬**이 됨)

- 각 라운드에서는 해당 노드를 중간 노드로 해서 현재 저장된 값과 갱신됐을 때의 값 중 더 작은 값을 갱신하는 방식임

## 파이썬 구현
```python
INF = int(1e9)
graph = [[INF] * (V+1)  for _ in range(V+1)]

for i in range(1, V + 1):
	graph[i][i] = 0

for i in range(m):
	a, b, w = map(int, input().split())
	# 최단거리 정보만 필요함
	if graph[a][b] > w:
		graph[a][b] = w

def floyd_warshall():
	for i in range(1, V+1): # 중간 노드
		for j in range(1, V+1): # 시작점
			for k in range(1, V+1): # 끝점
				graph[j][k] = min(graph[j][k], graph[j][i] + graph[i][k])

floyd_warshall()
```

### 응용) 사이클 찾기
- 그래프의 모든 노드 사이의 최단 거리를 알 수 있음
- 그렇다면 **사이클(시작 노드 = 끝 노드)은 어떻게 찾을 수 있을까?**
	- EZ함 : 플로이드 - 워셜 알고리즘의 **결과 그래프에 `graph[a][b], graph[b][a]` 모두에 값이 있으면 사이클이 발생**한 거임(간선을 몇 개 거치든 **그래프에는 현재 최단거리가 저장되어 있음 + 돌아올 수 있음**)

### 응용 2) 역추적
- 최솟값을 갱신할 때 그래프와 크기가 같은 별도의 배열`trace`을 생성한 다음,
- **중간점 `i`가 돌 때 `graph[j][k]` 값이 갱신되는 상황이라면 `trace[j][k]` 에 `trace[i][k]`를 저장하면 된다.**
	- `j->i->k`에서 k 직전의 마지막 노드는 `i->k`에서 k 직전의 마지막 노드와 일치할 수밖에 없기 때문이다. 