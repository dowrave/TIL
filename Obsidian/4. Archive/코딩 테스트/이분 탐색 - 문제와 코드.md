## 문제

- 프로그래머스의 이분 탐색 문제 질문은 이렇다
```
1. 사람 수 n, 각 심사관이 1명을 심사하는 데 걸리는 시간들을 times 배열로 줬을 때, 모든 사람이 심사를 받는데 걸리는 최소 시간을 리턴하시오

2. 총 거리 `distance`, 바위 위치 배열 `rocks`, 제거할 바위 수 `n`이 주어질 때 바위를 n개 제거한 거리의 최솟값 중 가장 큰 값을 리턴하시오
```

- 둘 다 딱 봤을 때 어떻게 풀지 애매하다, 공통점은 있다. 
1. **~를 하는 최소/최대 값을 반환**하시오
2. 범위가 매우 큼(**10억 단위**)

- 이 때 참고할 건 **문제**에 있다.
```
1. "모든 사람이 심사를 받는 데 걸리는 (최소) 시간"
2. 바위를 n개 제거한 "바위 사이의 거리"의 최솟값 중 가장 큰 값
```
- 1번 문제는 "모든 사람이 심사를 받는 데 걸리는 시간"
- 2번 문제는 "바위를 제거한 바위 사이의 거리"
- 가 이분 탐색을 수행하는 기준, 값이 되는 것이다.

---
실제로 1번 문제는 주어진 시간 범위에 대해, `times` 배열이 수행할 수 있는 최대 인원 수를 구한 뒤 그 값을 `n`과 비교하는 방식으로 진행된다. 
2번 문제도 최대 거리까지의 범위 내에서 이분 탐색을 진행, 제거하는 바위의 개수와 `n`을 비교하는 방식으로 이뤄진다.

- 문제 **흐름만 보고 따라가면 이분 탐색을 생각하기도 어렵고 놓치기도 쉬워서, 관점을 달리 하면서 문제를 풀어야 할 것 같다.**
- 값이 너무 크다면, **임의의 값을 갖고 들이대는 게 더 빠른 경우도 있다**는 것!
---
## 코드
- 원래는 더 간단하게 작성하는 코드[[이분 탐색]]를 썼는데, 내가 헷갈려서 일일이 보여주는 방식으로 감
```python
def binary_search(target, arr):
	left = # ~~
	right = # ~~
	
	answer = 0
	while left <= right:
		mid = (left + right) // 2
		
		
		# 조건문 : 주로 target과 비교하기 위한 변수를 만듦
		# 여기선 그 변수를 temp라고 놓겠음
		
		
		# 다음 루프 - 조건식과 target의 관계에 따라 달라지므로 문제 파악 유의
		# 1. 최댓값 찾기 문제 
		if temp <= target:
			answer = mid
			left = mid + 1
		else:
			right = mid -1
		
		# 2. 최솟값 찾기 문제
		if temp < target:
			left = mid + 1
		else:
			answer = mid
			right = mid - 1
```

> 참고 1. 조건에 따라 left, right값 갱신이 달라짐. 이건 문제에 따라 내가 맞춰가야 함
> 참고 2. `while left <= right`와 `right = mid - 1`은 연동되는 개념임
>> 만약 `while left < right` 및 `right = mid - 1`로 쓰면 무한 루프에 빠질 위험이 있음
>> 따라서 `while left < right & right = mid` 를 쓰거나 `while left <= right & right = mid - 1`을 쓰자.

- 참고 3. 다음 루프를 찾는 과정에서. 아래처럼 작성하면 틀렸다. (최댓값 찾기 문제)
```python
if temp == n:
	answer = mid
	left = mid + 1
elif temp > n:
	left = mid + 1
else:
	right = mid - 1
```
대신 이렇게 작성하면 맞다.(왜인지 모르겠음!)
```python
if temp >= n:
	answer = mid
	left = mid + 1
else:
	right = mid - 1
```