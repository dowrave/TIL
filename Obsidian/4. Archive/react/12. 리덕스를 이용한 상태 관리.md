1. [[#리액트의 상태 관리 리뷰|리액트의 상태 관리 리뷰]]
2. [[#플럭스 아키텍처와 리덕스|플럭스 아키텍처와 리덕스]]
	1. [[#플럭스 아키텍처와 리덕스#플럭스|플럭스]]
	2. [[#플럭스 아키텍처와 리덕스#리덕스 특징|리덕스 특징]]
	3. [[#플럭스 아키텍처와 리덕스#리덕스 상세 보기|리덕스 상세 보기]]
		1. [[#리덕스 상세 보기#리덕스 아키텍처와 처리 과정|리덕스 아키텍처와 처리 과정]]
		2. [[#리덕스 상세 보기#리덕스 구성 요소|리덕스 구성 요소]]
		3. [[#리덕스 상세 보기#리덕스 컨테이너 컴포넌트|리덕스 컨테이너 컴포넌트]]
3. [[#리덕스 적용하기|리덕스 적용하기]]
	1. [[#리덕스 적용하기#프로젝트 설정과 설계|프로젝트 설정과 설계]]
	2. [[#리덕스 적용하기#리덕스 구성 요소 작성|리덕스 구성 요소 작성]]
	3. [[#리덕스 적용하기#리덕스 구성 요소를 사용하는 컴포넌트로 변경|리덕스 구성 요소를 사용하는 컴포넌트로 변경]]
	4. [[#리덕스 적용하기#리덕스 툴킷 이용하기|리덕스 툴킷 이용하기]]
4. [[#다중 리듀서|다중 리듀서]]
	1. [[#다중 리듀서#다중 리듀서란?|다중 리듀서란?]]
	2. [[#다중 리듀서#다중 리듀서 적용|다중 리듀서 적용]]
5. [[#리덕스 미들웨어|리덕스 미들웨어]]
	1. [[#리덕스 미들웨어#테스트용 미들웨어 적용하기|테스트용 미들웨어 적용하기]]
	2. [[#리덕스 미들웨어#간단한 콘솔 로거 미들웨어|간단한 콘솔 로거 미들웨어]]
6. [[#redux-thunk 미들웨어|redux-thunk 미들웨어]]
	1. [[#redux-thunk 미들웨어#redux-thunk란?|redux-thunk란?]]
	2. [[#redux-thunk 미들웨어#redux-thunk 적용하기|redux-thunk 적용하기]]
	3. [[#redux-thunk 미들웨어#redux-thunk와 @reduxjs/toolkit 함께 쓰기|redux-thunk와 @reduxjs/toolkit 함께 쓰기]]
	4. [[#redux-thunk 미들웨어#redux-thunk와 axios 사용 예제|redux-thunk와 axios 사용 예제]]
7. [[#redux-saga 미들웨어|redux-saga 미들웨어]]
		1. [[#redux-saga 미들웨어#redux-saga|redux-saga]]
	1. [[#redux-saga 미들웨어#시작 전 알아야 할 것|시작 전 알아야 할 것]]
	2. [[#redux-saga 미들웨어#redux-saga 아키텍처|redux-saga 아키텍처]]
	3. [[#redux-saga 미들웨어#redux-saga 적용하기|redux-saga 적용하기]]
8. [[#react-redux가 제공하는 훅|react-redux가 제공하는 훅]]
9. [[#리덕스 개발 도구|리덕스 개발 도구]]
	1. [[#리덕스 개발 도구#리덕스 개발 도구|리덕스 개발 도구]]
	2. [[#리덕스 개발 도구#리덕스 개발 도구 사용하기|리덕스 개발 도구 사용하기]]
10. [[#마무리 글|마무리 글]]

## 리액트의 상태 관리 리뷰
- 리액트의 핵심 철학 : 단방향 데이터 흐름
- 단방향 데이터 흐름은 2가지로 살펴볼 수 있다.
1. **부모 컴포넌트 -> 자식 컴포넌트** : **속성**을 이용해 데이터를 전달한다
2. **UI의 변경 -> `EventHandler` -> `setState()` -> `State`에 반영**

- 지금까지는 이 철학을 반영해 부모 컴포넌트에 상태와 상태 변경 로직을 집중시키고, 자식 컴포넌트에서 속성을 전달받아 UI를 렌더링하도록 작성했다.
- 또한, 자식 컴포넌트에서 이벤트가 일어나면 `이벤트 핸들러`를  이용해 부모 컴포넌트로부터 속성을 통해 **전달받은 상태 변경 기능을 가진 콜백 함수**를 호출, 부모 컴포넌트의 상태를 변경했다.
	- 만약 자식 컴포넌트 각각에서 상태를 가진다면, 상태가 바뀔 때마다 모든 자식 컴포넌트의 상태를 바꿔야 한다는 문제가 발생할 것이다.
- 따라서 기존에 작성한 방법이 더 바람직하다. 부모 컴포넌트의 상태 변경 과정만 추적하면 UI가 어떻게 바뀔지를 예측할 수 있다.
- **하지만 대규모 앱에서는 이 방법도 사용하기 힘들다.**
	- 수백 개의 화면을 가진 대규모 앱에서 모든 상태를 화면 단위의 부모 컴포넌트에서 처리할 수 없기 때문에, **앱 수준에서 효과적으로 상태를 관리하는 방법**이 필요하다.
	- 그리고 상태를 자식 컴포넌트에 `주입Inject`해서 `속성 - 속성 - 속성 - ...`과 같이 복잡한 전달과정을 사용하지 않도록 해야 하는데, 여기서 탄생한 것이 **`플럭스Flux`** 아키텍처이다.

## 플럭스 아키텍처와 리덕스

### 플럭스
- `플럭스 아키텍처`는 대규모 앱에서 일관된 데이터 관리를 손쉽게 하기 위해 만들어진 단방향 데이터 처리 과정을 가지는 아키텍처이다. 
- 구조
> 1. `View -> ActionCreator` : `이벤트 핸들러`로 액션 생성자 호출
> 2. `외부 API -> ActionCreator` : API 호출(선택)
> 	- `액션 생성자`는 외부 API 호출과 같은 `side effect` 처리를 수행하고 그 결과를 `액션Action`이라는 객체 형태의 메시지를 생성하여 `디스패처Dispatcher`에 전달한다.
> 	- 예시) `{type : "addTodo", payload : {todo:"강변 달리기", desc:"출근 30분 전 뛰기"}}`
> 3. `ActionCreator -> Dispatcher` : `dispatch(action)`
> 4 `Dispatcher -> Store` : 액션 전달
> 5. `Store -> View` : 바인딩
> 	- `스토어`의 상태가 변경되면 각 스토어와 연결된 컴포넌트의 UI가 갱신된다.

- 플럭스 아키텍처의 가장 중요한 특징은 **단방향 데이터 흐름**이라는 것이다.
	- 앱 수준에서 여러 개의 `스토어Store`가 상태와 상태 변경 기능을 가지고 있다.
	- `스토어`의 상태는 필요로 하는 여러 뷰 컴포넌트에 바인딩되어 렌더링된다.

- 플럭스 아키텍처를 리액트에 적용하면 상태를 필요로 하는 **컴포넌트에 스토어의 상태를 연결**할 수 있으며, 부모 컴포넌트에서 자식 컴포넌트로 반복적이고 계층적인 속성 전달을 하지 않아도 된다.
- 또한 플럭스 아키텍처는 **단일 디스패처**를 이용한다. 모든 데이터 흐름은 단일 디스패처를 거치므로 이곳에서만 **모니터링과 로깅을 하면 모든 액션의 흐름을 볼 수 있고, 액션에 의해 상태가 어떻게 변경되는지를 쉽게 추적**할 수 있다.

### 리덕스 특징
- `리덕스Redux`는 자바스크립트 앱을 위한 예측 가능한 상태 관리 컨테이너이며, UI 상태와 데이터 상태를 관리하기 이한 효과적인 도구이다. 리액트 외에도 모든 자바스크립트 앱에서 사용할 수 있다.
- 플럭스 아키텍처를 쓰되 더 발전시켜 복잡성을 줄였다.
- `플럭스의 기능 + 핫 리로딩Hot Reloading + 시간 여행 디버깅Time Travel Debugging` 기능을 제공한다.

- 기존 플럭스 아키텍처에서는 스토어가 상태와 상태 변경 로직을 포함한다. 따라서 **개발 중에 상태 변경 로직을 변경하면 상태가 초기화**된다.
```tsx
todos : []
addTodo (todo) {
	// 기능
}

// 상태 추가
todos : [ "운동", "공부"]
addTodo (todo) {
	// 기능
}

// 로직 코드 변경
todos : [] // 상태 초기화
addTodo (todo) {
	// 변경된 기능
}
```

- 반면, **리덕스 스토어는 상태만을 갖고, 상태 변경의 기능을 `리듀서Reducer`라는 요소로 분리**했다. 따라서 상태 변경 로직이 개발 중에 변경되더라도 상태를 유지시킬 수 있는데, 이를 `핫 리로딩Hot Reloading`이라고 하며, 디버깅에 유용하다.
```tsx
// 초기 스토어
todos : []
// 리듀서
addTodo (todo) {
	// 기능
}

// 스토어 :상태 추가
todos : [ "운동", "공부"]
// 리듀서
addTodo (todo) {
	// 기능
}

// 리듀서의 로직 코드 변경
todos : [ "운동", "공부"] // 스토어는 초기화되지 않는다
addTodo (todo) {
	// 변경된 기능
}
```

- 리덕스의 다른 특징으로, 리듀서를 이용해 **상태를 변경할 때 기존 객체를 변경하는 게 아니라 새로운 객체를 생성한다**는 점이 있다. 
	- = **불변성의 적용이 필수**라는 뜻으로, 플럭스는 불변성을 갖는 상태 변경이 필수가 아니다.
```
1. 플럭스의 상태 변경 :
Initialize, Action1, Action2, Action3 이 순서대로 State에 변화를 준다고 할 때,
별도의 State를 만드는 게 아니라 모두 같은 State에 변화를 준다.

2. 리덕스의 상태 변경
- 모든 상태 변경을 일으키는 행동들이 새로운 State를 만든다.
- 즉, Initialize -> State -> action1 -> State1 -> action2 -> state2 -> action3 -> state3인 것.
```
> 리덕스의 불변성을 갖는 상태 변경은 시간 흐름에 따라 상태의 `이력History`을 남긴다. 상태 변경 이력은 시간 흐름에 따라 상태의 변경을 손쉽게 추적할 수 있게 해준다. 그리고 앱 개발 중 과거의 어느 한 시점의 상태로 돌아가서 다시 기능을 확인할 수 있어 디버깅할 때 유용하다. 이를 `시간 여행 디버깅`이라고 부른다.

### 리덕스 상세 보기

#### 리덕스 아키텍처와 처리 과정
> 1. `View(React 컴포넌트)` -> `ActionCreator` : 액션 생성자 호출
> 2. `API -> ActionCreator` : 외부 API 호출
> 3. `ActionCreator -> Store` : `dispatch(Action)`. Action 구조는 플럭스와 동일하다.
> 4. `Store -> Reducers` : 3.에서 전달받은 `Action` + `Store 자신의 상태State`를 리듀서 함수의 인자로 전달한다.
> 	- 리듀서 형식 : `(state, action) => {...}`
> 5. `Reducers -> Store` : `NewState` 리턴
> 	- 전달받은 `상태State`는 변경하지 않고, `액션`을 이용해 새로운 상태`NewState`를 만들고 리턴한다.
> 6. `Store -> View(React 컴포넌트)` : 바인딩
> 	- 스토어의 새로운 상태는 뷰 컴포넌트에 연결되어 있으므로 화면이 새롭게 렌더링된다.


#### 리덕스 구성 요소
- 리덕스 아키텍처에서 **스토어는 단 하나**이다. 단일 요소이며, 모든 액션은 이 곳을 거친다.
- 단 하나의 스토어가 전체 앱의 모든 상태를 관리하므로, **상태 변경 기능은 리듀서로 분리**한다.
- **스토어의 상태는 읽기 전용**으로 다뤄지며, **상태 변경은 리듀서로만 수행**해야 한다.

- **리듀서는 여러 개를 만들 수 있다. 계층적으로 구성**해야 한다.
	- **상태 변경 로직을 포함**하면서 스토어가 갖는 **초기 상태를 전달**하는 역할을 한다. 복잡한 상태 트리는 계층적으로 리듀서를 구성하고, 상위 리듀서는 하위 리듀서가 리턴하는 하위 상태를 받아 전체 상태를 구성하여 스토어에게 리턴해준다.
	- 리듀서는 `순수 함수Pure Function`이어야 한다. 
		- 입력 인자가 동일하면 리턴 값도 같아야 한다.
		- 전달된 인자는 불변성으로 여겨지며, 인자를 변경할 수 없다.
		- `부작용Side Effect`이 없어야 한다. 함수 외부의 값을 이용하거나 함수 외부의 기능이나 값에 영향을 주는 효과 등을 의미한다.

- 순수 함수의 예시
```ts
const nums = [10, 20, 30, 40];

const sumNumbers = nums.reduce((sum, num) => {
	return sum + num;
});

console.log(sumNumbers);
```
> 자바스크립트 배열의 `reduce`라는 메서드로, 집계 값을 구하는 메서드이다. 
> 이 메서드의 **인자로 전달되는 함수를 `리듀서Reducer`** 라고 부르는데, 이 함수는 배열 개수만큼 호출되면서 `집계 값sum`과 `배열 아이템 숫자값num`을 인자로 전달 받아 간단한 연산처리를 한 뒤, `새로운 집계 값 sum + num`을 리턴한다. 최종적으로 리듀서가 호출되어 리턴되면 그것이 최종 집계 값이 된다.

- 리덕스의 리듀서도 배열의 `reduce` 메서드와 동일한 구조이다.
```tsx
(state, action) => {
	...
	return newState // 새로운 상태
}
```

- `액션 생성자`는 플럭스와 유사하지만, 리액트 앱에서 개발할 떄는 액션(객체, 메시지)을 생성하는 기능에 집중한다.
- **스토어로 `전달Dispatch`하는 기능은 뷰 컴포넌트에 연결할 때 부여**하도록 작성하는 것이 관례이다.

#### 리덕스 컨테이너 컴포넌트
- 리덕스 스토어와 연결되는 컴포넌트들은 모두 `표현 컴포넌트Presentational Component`로 작성할 수 있다. 
- `react-redux` 같은 라이브러리가 리덕스 스토어의 상태를 표현 컴포넌트의 속성으로 전달해주는 컨테이너 컴포넌트를 손쉽게 작성할 수 있는 `리덕스 훅`들과 `connect()` 같은 고차 함수를 지원하기 때문이다. 이렇게 작성하면 컴포넌트 트리를 통해 반복적, 계층적으로 속성을 전달하지 않아도 된다.
```
Store, ActionCreators -> (훅 or 고차함수로 주입) -> Container Component -> (props로 전달) Presentational Component
```

- 모든 표현 컴포넌트에 대해 컨테이너를 만드는 건 어떨까? : 컨테이너 컴포넌트를 만들려면 간단하지만, 리덕스에 의존적이므로 **리덕스를 사용하지 않는 환경에서 컴포넌트를 재사용하기는 힘들다.**
- 따라서 **주요 거점 컴포넌트만 컨테이너 컴포넌트로 속성을 주입시키고, 짧은 구간만을 속성으로 전달**하는 것이 바람직하다.
	- `주요 거점 컴포넌트`란, 일반적으로 소규모 메뉴, 화면, 화면 레이아웃의 최상위 컴포넌트 단위 등이다.
![[새 폴더 1 - 0.jpg]]

- `react-redux` 라이브러리가 제공하는 `connect()` 고차함수를 적용하는 방법이다.
![[새 폴더 1 - 0 (1).jpg]]
> - 리덕스 스토어의 상태 이름과 표현 컴포넌트의 이름이 같을 수는 없다. 표현 컴포넌트가 속성으로 전달받는 함수 이름도 마찬가지이다.
> - 따라서 리덕스 스토어의 상태와 표현 컴포넌트의 속성명을 매핑한 정보를 제공하는 `mapStateToProps()` 함수를 만들어야 한다. 이 함수는 표현 컴포넌트의 속성에 `dispatch(action)`할 수 있는 함수를 매핑한 정보를 리턴한다.
> - `컨테이너 컴포넌트`는 `connect` 고차 함수에 `mapStateToProps`, `mapDispatchToProps`를 인자로 전달하여 호출한 뒤 리턴 받은 함수에 다시 표현 컴포넌트를 인자로 전달하여 호출하면 컨테이너 컴포넌트가 리턴된다. 이 컨테이너 컴포넌트는 표현 컴포넌트에 `상태`와 `dispatch(action)` 기능의 함수를 속성으로 주입한다.
> - 표현 컴포넌트가 함수 컴포넌트라면 훅을 사용할 수 있겠지만, 클래스 컴포넌트에서는 훅을 쓸 수 없기 때문에 **`connect()` 고차 함수를 사용하는 법을 알고 있어야 한다.**

## 리덕스 적용하기
- 10장 예제인 `todolist-app-router` 프로젝트에 적용한다.
- 기존에는 `AppContainer`에 상태와 상태 변경 로직을 모두 집중시키고, 속성을 이용해 자식 컴포넌트에 전달시켰다.

![[새 폴더 1 - 0 (2).jpg]]
- 변경된 아키텍처에서는 **`AppContainer`의 상태, 상태 변경 기능을 모두 스토어와 액션 생성자로 분리**한다. 따라서 `AppContainer`는 더 이상 필요하지 않다.
- 대신 `/todos`, `todos/add`와 같이 URI 경로에 의해 보이는 화면 단위로 컨테이너를 만들어 짧은 구간의 컴포넌트 계층 구조에서만 속성을 전달하도록 작성한다.

### 프로젝트 설정과 설계
- 프로젝트에 아래 명령을 입력한다.
```sh
npm install redux react-redux @types/react-redux @reduxjs/toolkit
```

- 앱이 사용할 상태 트리와 상태 변경 기능을 설계해야 한다.
	- `todolist-app-router`의 상태
		- 전역 수준에서 관리할 상태는 `todoList` 데이터이다. 기존 컴포넌트에서 사용하던 모든 상태를전역 수준에서 관리할 필요는 없다. 
		- 아래는 로컬 컴포넌트의 상태를 이용하는 걸 권장함
			- 특정 컴포넌트에서만 사용되는 상태
			- 상태 변경을 추적할 만큼 중요한 상태가 아님
			- 컴포넌트의 생명 주기가 바뀌더라도(다른 화면을 갔다 온다든가) 상태가 유지도리 필요가 없는 경우
	- 사용할 액션
		- **상태가 바뀌는 작업에 한해서만 정의**한다. 이 앱에서는 4가지의 상태 변경 작업이 있다.
		- 그리고 각각에 대해 아래 표를 참고해 액션의 형식도 함께 지정한다.
			- `payload` 부분은 상태 변경 시 어떤 값이 필요한지를 생각해보면 된다.

| 액션명     | 액션 형식                                                |
| ---------- | -------------------------------------------------------- |
| addTodo    | {type: "addTodo", payload: {todo: string, desc: string}} |
| deleteTodo | {type: "deleteTodo", payload: {id: number}}              |
| toggleDone | {type: "toggleDone", payload: {id: number}}              |
| updateTodo | {type: "updateTodo", payload: {id: number, todo: string, desc: string, done: boolean}}                                                         |

### 리덕스 구성 요소 작성
- `src/redux` 디렉터리를 작성한 뒤, `Appstore.ts, TodoReducer.ts, TodoActionCreator.ts` 파일을 생성한다. 

- `TodoActionCreator.ts`
```ts
// 1.
export const TODO_ACTION = {
    ADD_TODO : "addTodo" as const,
    DELETE_TODO : "deleteTodo" as const,
    TOGGLE_DONE : "toggleDone" as const,
    UPDATE_TODO : "updateTodo" as const,
};

const TodoActionCreator = {
    addTodo : (todoItem: {todo : string; desc: string}) => {
        return { type : TODO_ACTION.ADD_TODO, payload: todoItem};
    },
    deleteTodo : (todoItem : {id: number}) => {
        return { type: TODO_ACTION.DELETE_TODO, payload: todoItem};
    },
    updateTodo : (todoItem : {id: number, todo: string; desc: string; done: boolean}) => {
        return { type : TODO_ACTION.UPDATE_TODO, payload: todoItem };
    },
    toggleDone: (todoItem : {id: number}) => {
        return { type: TODO_ACTION.TOGGLE_DONE, payload: todoItem };
    }
}

export type todoActionType = 
    | ReturnType<typeof TodoActionCreator.addTodo>
    | ReturnType<typeof TodoActionCreator.deleteTodo>
    | ReturnType<typeof TodoActionCreator.toggleDone>
    | ReturnType<typeof TodoActionCreator.updateTodo>

export default TodoActionCreator;
```
> 1. 액션의 타입을 지정할 때는 문자열을 사용하는데, 지정한 타입을 상수로 쓰기 위해 `as const`를 사용한다. 타입스크립트의 `as const` 문법은 상수 타입으로 추론하도록 하는 기능이다.
> 2. `TodoActionCreator` 함수 : 객체 형태로 인자를 받아 액션 메시지 객체를 만든다.
> 3. `todoActionType` : `TodoReducer`에서 사용할 액션의 타입을 액션 생성자 함수들의 리턴값을 조합해 선언한다.

- `TodoReducer.ts`
	- 불변성을 갖도록 상태를 변경하기 위해 `immer`를 사용한다.
```ts
import { produce } from 'immer'
import { TodoActionType, TODO_ACTION } from './TodoActionCreator'

export type TodoItemType = {
    id: number;
    todo: string;
    desc: string;
    done: boolean;
}

export type TodoStatesType = { todoList: Array<TodoItemType> };

const initialState: TodoStatesType = {
    todoList: [
        { id: 1, todo: "ES6 학습", desc:"설명1", done: false},
        { id: 2, todo: "React 학습", desc:"설명2", done: false},
        { id: 3, todo: "ContextAPI 학습", desc:"설명3", done: true},
        { id: 4, todo: "야구 경기 관람", desc:"설명4", done: false},
    ]
};

const TodoReducer = (state: TodoStatesType = initialState, action: TodoActionType) => {
    let index : number;
    switch (action.type) {
        case TODO_ACTION.ADD_TODO:
            return produce(state, (draft) => {
                draft.todoList.push({
                    id: new Date().getTime(),
                    todo: action.payload.todo,
                    desc: action.payload.desc,
                    done: false,
                });
            });
        case TODO_ACTION.DELETE_TODO:
            index = state.todoList.findIndex((item) => item.id === action.payload.id);
            return produce(state, (draft) => {
                draft.todoList.splice(index, 1);
            });
        case TODO_ACTION.TOGGLE_DONE:
            index = state.todoList.findIndex((item) => item.id === action.payload.id);
            return produce(state, (draft) => {
                draft.todoList[index].done = !draft.todoList[index].done;
            });
        case TODO_ACTION.UPDATE_TODO:
            index = state.todoList.findIndex((item) => item.id === action.payload.id);
            return produce(state, (draft) => {
                draft.todoList[index] = { ...action.payload };
            });
        default:
            return state;
    }
};

export default TodoReducer;
```
> 1. 앱을 처음 실행 시, `스토어Store`가 비어 있기 때문에 리듀서가 초기 상태를 제공해야 한다. 그래서 `TodoReducer`에서 초기 상태`initialState`를 선언하고 있다. 초기 상태가 사용할 타입을 위해 `TodoStatesType`까지를 미리 선언하기도 했다.
> 2. `TodoReducer`의 인자 형식을 보면 `(state : TodoStatesType = initialState, action: TodoActionType)`이다.
> 	- 앱이 처음 실행될 때는 `state = undefined`로 전달된다. 이 때, `initialState`가 `state` 인자로 할당될 것이고, `switch` 문의 `default case`에 의해 리턴된다. 이게 앱의 초기 상태가 된다.
> 	- 리듀서 함수의 인자를 지정할 떄 초기 상태를 지정해야 한다. 같은 이유로 `action`의 `type`에 따라 분기할 때도, 반드시 `default`는 자기 자신 `state`을 리턴하도록 해야 한다.
> 3. 각 `case`에서는 불변성을 가진 변경 : 즉, 새로운 `state`을 만들어서 리턴할 수 있도록 작성해야 한다. 리듀서는 순수 함수여야 하기 때문이다.

- `Store` 객체를 작성한다. 
	- 예전엔 `redux` 라이브러리가 제공하는 `CreateStore` 함수를 이용했지만, 최근에는 `@reduxjs/toolkit`의 `configureStore` 함수를 더 많이 이용한다.
	- `@reduxjs/toolkit` 라이브러리는 액션 생성자, 리듀서, 스토어를 작성할 때 이용할 수 있는 여러 툴킷 함수를 제공하기 떄문에 리덕스를 리액트 앱에 적용할 때 더 간단하고 정리된 코드로 작성할 수 있다.
	- 그러나 **처음에는 어렵더라도 기본 라이브러리를 먼저 이용해보고 툴킷을 쓰는걸 권장**한다.
- `AppStore.ts`
```ts
import { configureStore } from '@reduxjs/toolkit'
import TodoReducer from './TodoReducer'

const Appstore = configureStore({ reducer: TodoReducer })

export default Appstore;
```
> 여기서 만든 `스토어` 객체는 앱에서 쓸 수 있게 `제공자Provider`를 지정해줘야 하는데, 이는 `src/main.tsx`에서 진행한다.
- `main.tsx`
```tsx
import App from './App.tsx'
// import AppContainer from './AppContainer'

import Appstore from './redux/Appstore.ts'
import { Provider } from 'react-redux'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <Provider store={Appstore}>
      <App />
    </Provider>
  </React.StrictMode>,
)
```

### 리덕스 구성 요소를 사용하는 컴포넌트로 변경
- `App.tsx`를 바꾼다.
	- 자식 컴포넌트로 속성을 전달하지 않는 게 가장 큰 차이점.
```tsx
// import Loading from './components/Loading'
// import { CallbacksType, StatesType } from './AppContainer'

// type PropsType = {
//   states: StatesType,
//   callbacks: CallbacksType;
// }

// 원래 PropsType의 states, callbacks 에 있는 속성들을 받았으나, 이들을 모두 제거함
          <Route path="todos" element={<TodoList />} />
          <Route path="todos/add" element={<AddTodo />} />    
          <Route path="todos/edit/:id" element={<EditTodo />} />
```

- `TodoList`, `TodoItem`, `AddTodo`, `EditTodo` 컴포넌트를 변경한다.
	- `TodoItem`을 뺀 나머지는 `connect()` 고차함수를 이용해 컨테이너 컴포넌트를 생성한다.

- `/pages/TodoList.tsx`
```tsx
import TodoActionCreator from '../redux/TodoActionCreator';
import { AnyAction, Dispatch } from 'redux'
import { connect } from 'react-redux';
import { TodoStatesType, TodoItemType } from '../redux/TodoReducer'
// import { CallbacksType, StatesType } from '../AppContainer'

// type PropsType = { states: StatesType, callbacks: CallbacksType };
type PropsType = { todoList: Array<TodoItemType>;
                deleteTodo: (id: number) => void;
                toggleDone: (id: number) => void;
}

// 넣는 속성이 바뀜
const TodoList = ({ todoList, deleteTodo, toggleDone }: PropsType) => {
    let todoItems = todoList.map((item) => {
        // return <TodoItem key={item.id} todoItem={item} callbacks = {callbacks} />;
        return <TodoItem key={item.id} todoItem={item} deleteTodo={deleteTodo} toggleDone={toggleDone} />
    });
    ...
}

// 여기부턴 새로 추가
const mapStateToProps = (state : TodoStatesType) => ( {
    todoList: state.todoList,
})

const mapDispatchToProps = (dispatch: Dispatch<AnyAction>) => ({
    deleteTodo: (id: number) => dispatch(TodoActionCreator.deleteTodo({ id })),
    toggleDone: (id: number) => dispatch(TodoActionCreator.toggleDone({ id })),
})

// export default TodoList;
export default connect(mapStateToProps, mapDispatchToProps)(TodoList);
```
>  바뀌는 부분들은 모두 주석처리 했음
>  - 더 이상 `states, callbacks`처럼 모든 상태와 콜백 함수를 묶어서 전달하지 않는다. 속성이 변경되었기 때문에 컴포넌트 속성도 변경되었다.
	- `todoItem` 컴포넌트로 `todoItem` 한 건과 `deleteTodo, toggleDone` 함수를 속성으로 전달하고, `mapStateToProps` 함수에서 상태와 컴포넌트의 속성을 매핑하는 정보를 리턴한다. 
	- `mapDispatchToProps`에서는 액션 생성자가 생성한 액션을 인자로 전달해 스토어로 전달하는 `dispatch(action)` 함수를 만들어서 전달한다. 
		- 예를 들어, `deleteTodo` 속성에 전달되는 함수는 아래처럼 호출된다.
```ts
dispatch( { type : "deleteTodo", payload: {id: 1}})
```
> - 이후 `connect()` 고차함수를 이용해 `TodoList` 컴포넌트에 속성을 주입해주는 컨테이너 컴포넌트를 생성해서 익스포트한다.

- `TodoItem.tsx`를 변경한다.
```tsx
import { TodoItemType } from '../redux/TodoReducer'
// import { CallbacksType, TodoItemType } from '../AppContainer'

// type PropsType = { todoItem: TodoItemType; callbacks: CallbacksType };
type PropsType = {
        todoItem : TodoItemType;
        deleteTodo : (id: number) => void;
        toggleDone: (id: number) => void;
}

const TodoItem = ({ todoItem, deleteTodo, toggleDone } : PropsType) => {
	...
	return
		li
			<span className={todoItem.done ? "todo-done pointer" : "pointer"}
            // onClick = {() => callbacks.toggleDone(todoItem.id)}>
            onClick = {() => toggleDone(todoItem.id)}>
            ...
			<span className="float-end badge bg-secondary pointer m-1"
            // onClick = {() => callbacks.deleteTodo(todoItem.id)}>
            onClick = {() => deleteTodo(todoItem.id)}>
```
> - `callbacks` 속성을 사용하지 않아 변경하고, `todoItem, delteTodo, toggleDone` 만을 전달 받도록 속성 타입을 바꾼다.
> - 또한, 컨테이너 컴포넌트를 생성하지 않는다. 모든 컴포넌트를 컨테이너 컴포넌트로 작성하는 것은 바람직하지 않기 때문이다.

- `pages/addTodo.tsx`
```tsx
import TodoActionCreator from '../redux/TodoActionCreator'
import { connect } from 'react-redux'
import { AnyAction, Dispatch } from 'redux'
// import { CallbacksType } from '../AppContainer'

// type PropsType = { callbacks: CallbacksType }
type PropsType = {
    addTodo: (todo: string, desc: string) => void;
}

const AddTodo = ({ addTodo } : PropsType) => {

	const addTodoHandler = () => {
		// callbacks.addTodo(todo, desc, () => {
		// 	navigate("/todos");
		// });
        addTodo(todo, desc);
	}
	return ...
}


const mapDispatchToProps = (dispatch: Dispatch<AnyAction>) => ({
    addTodo: (todo: string, desc: string) => 
        dispatch(TodoActionCreator.addTodo({ todo, desc })),
    
})

const AddTodoContainer = connect(null, mapDispatchToProps)(AddTodo);
export default AddTodoContainer;

```
> `mapStateToProps`를 `connect()` 고차 함수에 전달하지 않는데, 속성으로 전달할 상태가 없기 때문에 그렇다. 이럴 경우, `connect(null, mapDispatchToProps)(AddTodo)`처럼 `null`을 인자로 전달하면 된다.


- `EditTodo.tsx`를 변경한다.
```tsx
// import { CallbacksType, StatesType, TodoItemType } from "../AppContainer"
import TodoActionCreator from '../redux/TodoActionCreator';
import { connect } from 'react-redux';
import { TodoStateType, TodoItemType } from '../redux/TodoReducer'
import { AnyAction, Dispatch } from 'redux'

// type PropsType = { callbacks: CallbacksType; states: StatesType}
type PropsType = {
    updateTodo : (id: number, todo: string, desc: string, done: boolean) => void;
    todoList: Array<TodoItemType>;
}

const EditTodo = ({ todoList, updateTodo }: PropsType ) => {

    // let todoItem = states.todoList.find((item) => item.id === parseInt(id ? id : "0"));
    let todoItem = todoList.find((item) => item.id === parseInt(id ? id : "0"));

	const updateTodoHandler = () => {
	
	        // callbacks.updateTodo(id, todo, desc, done, () => {
        //     navigate("/todos");
        // });
        updateTodo(id, todo, desc, done);
        navigate("/todos");
	}
}

// export default EditTodo;
const mapStateToProps = (state: TodoStatesType) => ({
    todoList : state.todoList,
});

const mapDispatchToProps = (dispatch : Dispatch<AnyAction>) => ({
    updateTodo: (id: number, todo: string, desc: string, done: boolean) =>
    dispatch(TodoActionCreator.updateTodo({ id, todo, desc, done })),
});
const EditTodoContainer = connect(mapStateToProps, mapDispatchToProps)(EditTodo);

export default EditTodoContainer;
```
> 1. `todoList, updateTodo`만 속성으로 전달하도록 `PropsType`에서 속성의 타입과 속성을 변경한다. 그 결과 `updateTodo`는 `callbacks`을 쓰지 않게 된다.
> 2. `connect()` 고차함수를 이용해 컴포넌트를 작성했다.

- `npm run dev`를 실행한다.
![[Pasted image 20231201145525.png]]
> `ReactRedux.Provider` 컴포넌트에서 `value`를 열어본 다음, **우클릭**해서 `Store as global variable`을 클릭한다.
> - `Store` 객체를 전역 변수에 할당하므로, 콘솔 탭에서 `$reactTemp0.store.getState()` 처럼 접근할 수 있다.
![[Pasted image 20231201145632.png]]
- 전역 변수명은 `$reactTempN` 같은 이름으로 할당되며, `store` 객체에서 `getState()` 함수를 호출하면 스토어의 현재 상태를 콘솔에서 확인할 수 있다.

### 리덕스 툴킷 이용하기
- 리덕스의 아키텍처를 정확히 이해하면 어렵지 않으나, 코드가 장황해진다.
- 이 때 쓸 수 있는게 `리덕스 툴킷@reduxjs/toolkit`이다.

- 위에서 스토어 객체를 생성할 때 `configureStore` 함수를 사용했다. 이외에도 다양한 기능이 있는데, `TodoActionCreator.ts`를 변경해보자.
```ts
import { createAction } from "@reduxjs/toolkit";

// export const TODO_ACTION = {
//     ADD_TODO : "addTodo" as const,
//     DELETE_TODO : "deleteTodo" as const,
//     TOGGLE_DONE : "toggleDone" as const,
//     UPDATE_TODO : "updateTodo" as const,
// };

// const TodoActionCreator = {
//     addTodo : (todoItem: {todo : string; desc: string}) => {
//         return { type : TODO_ACTION.ADD_TODO, payload: todoItem};
//     },
//     deleteTodo : (todoItem : {id: number}) => {
//         return { type: TODO_ACTION.DELETE_TODO, payload: todoItem};
//     },
//     updateTodo : (todoItem : {id: number, todo: string; desc: string; done: boolean}) => {
//         return { type : TODO_ACTION.UPDATE_TODO, payload: todoItem };
//     },
//     toggleDone: (todoItem : {id: number}) => {
//         return { type: TODO_ACTION.TOGGLE_DONE, payload: todoItem };
//     }
// }

// export type todoActionType = 
//     | ReturnType<typeof TodoActionCreator.addTodo>
//     | ReturnType<typeof TodoActionCreator.deleteTodo>
//     | ReturnType<typeof TodoActionCreator.toggleDone>
//     | ReturnType<typeof TodoActionCreator.updateTodo>

const TodoActionCreator = {
    addTodo: createAction<{ todo: string; desc: string}>("addTodo"),
    deleteTodo: createAction<{ id: number }>("deleteTodo"),
    toggleDone: createAction<{ id: number }>("toggleDone"),
    updateTodo: createAction<{ id: number; todo: string; desc: string; done: boolean }>("updateTodo"),
}

export default TodoActionCreator;
```
> 코드가 엄청 깔끔해진다. 

- `createAction`으로 만들어진 생성자는 아래와 유사한 기능의 코드를 생성한다. `addTodo`를 예로 들면..
```ts
addTodo: ( {todo, desc} : {todo:string, desc:string}) => {
	return { type: "addTodo", payload : {todo: todo, desc: desc}}
}
```
> 1. `createAction` 함수의 제네릭 타입으로 전달하는 액션의 페이로드 값을 지정한다.
> 2. 그리고 `createAction` 함수의 인자로는 액션의 타입명을 문자열로 전달한다. 

- 리듀서도 마찬가지로 훨씬 깔끔하게 작성할 수 있다.
- `TodoReducer.ts`
```ts
import { createReducer } from '@reduxjs/toolkit'
import TodoActionCreator from './TodoActionCreator'
...

// const TodoReducer = (state: TodoStatesType = initialState, action: TodoActionType) => {
//     let index : number;
//     switch (action.type) {
//         case TODO_ACTION.ADD_TODO:
//             return produce(state, (draft) => {
//                 draft.todoList.push({
//                     id: new Date().getTime(),
//                     todo: action.payload.todo,
//                     desc: action.payload.desc,
//                     done: false,
//                 });
//             });
//         case TODO_ACTION.DELETE_TODO:
//             index = state.todoList.findIndex((item) => item.id === action.payload.id);
//             return produce(state, (draft) => {
//                 draft.todoList.splice(index, 1);
//             });
//         case TODO_ACTION.TOGGLE_DONE:
//             index = state.todoList.findIndex((item) => item.id === action.payload.id);
//             return produce(state, (draft) => {
//                 draft.todoList[index].done = !draft.todoList[index].done;
//             });
//         case TODO_ACTION.UPDATE_TODO:
//             index = state.todoList.findIndex((item) => item.id === action.payload.id);
//             return produce(state, (draft) => {
//                 draft.todoList[index] = { ...action.payload };
//             });
//         default:
//             return state;
//     }
// };

const TodoReducer = createReducer(initialState, (builder) => {
    builder
        .addCase(TodoActionCreator.addTodo, (state, action) => {
            state.todoList.push({
                id: new Date.getTime(),
                todo: action.payload.todo,
                desc: action.payload.desc,
                done: false,
            });
        })
        .addCase(TodoActionCreator.deleteTodo, (state, action) => {
            let index = state.todoList.findIndex((item) => item.id === action.payload.id);
            state.todoList.splice(index, 1);
        })
        .addCase(TodoActionCreator.toggleDone, (state, action) => {
            let index = state.todoList.findIndex((item) => item.id === action.payload.id);
            state.todoList[index].done = !state.todoList[index].done;
        })
        .addCase(TodoACtionCreator.updateTodo, (state, action) => {
            let index = state.todoList.findIndex((item) => item.id === action.payload.id);
            state.todoList[index] = { ...action.payload };
        })
        .addDefaultCase((state, action) => state);
})
```
> - `createReducer`를 통해 리듀서를 만드는데, 1번째 인자는 `초기 상태 값`, 2번째 인자는 리듀서 기능을 만드는 `빌더 콜백builderCallback` 함수이다. 이 함수의 인자로 전달된 `builder` 객체를 이용해 액션 생성자에 따라 각각 다른 처리를 하도록 `case`를 추가하면 된다.
> - 특이한 점으로 **불변성 라이브러리를 이용할 필요가 없다**는 점이다. `addCase()` 함수로 전달되는 2번째 인자인 `(state, action) => {}` 함수의 `state`는 단순한 상태가 아닌 `WritableDraft`한 상태이다. 따라서 새로운 상태를 만들어 리턴하지 않고, `state`를 직접 리턴해도 내부적으로 새로운 상태를 만들어낸다.

- 여기까지 오면 리덕스의 1번째 고비를 넘긴 것으로, **무작정 예제를 쓰지 말고 리덕스 아키텍처와 처리 흐름을 머리속에서 생각하고 그림을 참조하면서 작성해보자.** (뜨끔!)

## 다중 리듀서

### 다중 리듀서란?
- 앱의 상태가 복잡해지면 상태 외에도 상태 변경 기능인 리듀서가 지나치게 많아질 것이다.
- 이걸 하나의 모듈로는 처리할 수 없어서, **리덕스는 상태는 1개이지만 여러 개의 리듀서로 분리할 수 있다.**

- 다중 리듀서를 쓰려면 상태 트리를 꼼꼼하게 설계하는 것이 중요하다. 각 리듀서는 상태 트리 중 특정 하위 트리를 담당하도록 설계된다.
- 예를 들면 상태 트리가 아래와 같다고 하자.
```
{
	home: {currentTime : " ... "},
	todos: {
		todoList: [
			{id:1, todo:"react", desc:"리액트 학습", done: false},
			...
		]
	}
}
```
> 여기서 `home` 필드 하위의 상태는 `TimeReducer`가 담당하게 하고, `todos` 필드의 하위의 상태는 `TodoReducer`가 담당하게 한다면 각 리듀서의 1번째 인자 `state`로 전달되는 객체는 `TimeReducer`의 경우 `{ currentTime : " ... " }`이 전달되는 것이다.

- 각각의 자식 리듀서는 `combineReducers`라는 함수를 통해 상위 리듀서를 만들 수 있다. 이 떄, `home, todos` 같은 필드명을 설계된 상태 트리 구조에 맞춰 지정해야 한다.

### 다중 리듀서 적용
- `RootReducer -> {TimeReducer, TodoReducer}` 같은 구조를 갖는다고 하자.
- `todolist-app-router` 예제에 적용한다.
- `TimeReducer.ts` 파일과 `TimeActionCreator.ts` 파일을 추가하고, `Home` 컴포넌트 하위에 `MyTime`이라는 자식 컴포넌트를 작성하여 하위 상태를 보여주도록 구성해보자.

- `redux/TimeActionCreator.ts`
```tsx
export const TIME_ACTION = {
    CHANGE_TIME: "changeTime" as const,
}

export type TimeActionType = ReturnType<typeof TimeActionCreator.changeTime>;

const TimeActionCreator = {
    changeTime() {
        return { type: TIME_ACTION.CHANGE_TIME, payload: { currentTime: new Date() }};
    }
}

export default TimeActionCreator;
```

- `redux/TimeReducer.ts`
```ts
import { TimeActionType, TIME_ACTION } from "./TimeActionCreator";

const initialState = {
    currentTIme: new Date(),
}

export type HomeStatesType = { currentTime : Date };

const TimeReducer = (state: HomeStatesType = initialState, action: TimeActionType) => {
    switch(action.type) {
        case TIME_ACTION.CHANGE_TIME:
            return { ...state, currentTIme: action.payload.currentTime };
        default:
            return state; 
    }
}

export default TimeReducer;
```

- 위 두 파일을 결합한 `RootReducer`를 생성하고, 스토어의 리듀서로 지정하도록 `AppStore`도 변경한다.
- `redux/AppStore.ts`
```ts
import { configureStore } from '@reduxjs/toolkit'
import { combineReducers } from 'redux';
import TodoReducer, { TodoStatesType } from './TodoReducer'
import TimeReducer, { HomeStatesType } from './TimeReducer'

export type RootStatesType = {
    home: HomeStatesType;
    todos: TodoStatesType;
}

const RootReducer = combineReducers({
    home: TimeReducer,
    todos: TodoReducer
})

const Appstore = configureStore({ reducer: RootReducer });
export default Appstore;
```

- 리덕스 구성 요소의 변경이 완료되었고, 뷰 컴포넌트를 변경할 차례이다.
- 이전 예제와 달리, **전체 상태 트리가 바뀌었다.** 따라서 기존 코드 중 상태를 주입하는 `TodoList`와 `EditTodo` 컴포넌트의 `mapStateToProps` 매핑 정보 함수의 코드를 아래처럼 변경해야 한다.
 ```tsx
import { RootStatesType } from '../redux/AppStore'

...

const mapStateToProps = (state: RootStatesType) => ({
	todoList: state.todos.todoList,
})
```

- `MyTime` 컴포넌트를 추가하고, `Home -> MyTime`으로 전달하도록 컨테이너 컴포넌트를 생성하는 코드로 변경하면 완료된다.
	- `MyTime` 컴포넌트는 `Home` 컴포넌트로부터 `currentTime, changeTime` 속성을 전달받는다.
- `pages/MyTime.tsx`
```tsx
type PropsType = {
    currentTime: Date;
    changeTime: () => void;
}

const MyTime = ({ currentTime, changeTime }: PropsType) => {
    return(
        <div className="row">
            <div className="col">
                <button className="btn btn-primary" onClick={() => changeTime()}>
                    현재 시각 확인
                </button>
                <h4>
                    <span className="label label-default">{currentTime.toLocaleString()}</span>
                </h4>
            </div>
        </div>
    )
}

export default MyTime;
```

- `Home` 컴포넌트는 `currentTime, changeTime` 속성에 필요한 값을 주입시키도록 컨테이너를 생성한다.
```tsx
import MyTime from './MyTime'
import TimeActionCreator from '../redux/TimeActionCreator'
import { connect } from 'react-redux'
import { AnyAction, Dispatch } from 'redux'
import { RootStatesType } from '../redux/AppStore'

type PropsType = {
  currentTime: Date;
  changeTime: () => void;
}

const Home = ({ currentTime, changeTime }: PropsType) => {
  return (
    <div className="card card-body">
        <h2>Home</h2>
        <MyTime currentTime={currentTime} changeTime={changeTime} />
    </div>
  )
}

const mapStateToProps = (state: RootStatesType) => (
  { currentTime: state.home.currentTime }
);

const mapDispatchToProps = (dispatch: Dispatch<AnyAction>) => ({
  changeTime: () => dispatch(TimeActionCreator.changeTime()),
})

const HomeContainer = connect(mapStateToProps, mapDispatchToProps)(Home);
export default HomeContainer;
```
> `combineReducers`할 때 지정한 필드명으로 전체 상태 트리가 만들어졌는지를 확인할 수 있다.
> 1. 개발자 도구에서 `ReactRedux.Provider` 선택
> 2. 속성에서 `store` 우클릭
> 3. `store` 객체의 참조를 전역 변수로 복사 & 콘솔에서 `$reactTempN.getState()` 실행

- 결과) `currentTIme`으로 잘못 작성했는데, 이는 `TimeReducer.ts`의 `intialState = currentTime`으로 수정했더니 고쳐졌다.

## 리덕스 미들웨어
- `리덕스 미들웨어`는 `액션Action : 객체 메시지`이 스토어로 `전달Dispatch`된 후, **리듀서에 도달하기 전과 상태 변경이 완료된 후에 수행할 중앙집중화된 작업을 지정**할 수 있는 함수이다.
- 리덕스 미들웨어는 **스토어 내부에 등록**된다.
```
1. View -> ActionCreators : 액션 호출
2. ActionCreator -> Store : 전달Dispatch
3. Store -> Reducers : 현재의 State와 Action 전달
4. Reducers -> Store : newState 리턴
5. Store -> View : Binding
```

- `모든 데이터흐름은 단일 요소인 지점에서 모니터링, 추적할 수 있다`는 설명에서, **리덕스가 단일 스토어 아키텍처**이다.
- 스토어에 뭔가 들여다볼 수 있는 요소를 설치하면 **모니터링, 비동기, 로깅** 등 다양한 작업을 수행할 수 있다. 이 때 설치되는 요소가 **`리덕스 미들웨어Redux Middleware`** 이다.

- 미들웨어 함수의 구조와, 다중 미들웨어 구조를 살펴보면 아래와 같다.
![[새 폴더 1 - 0 (3).jpg]]
```ts
// 미들웨어 함수 구조 1
const middleware1 : Middleware = (store) => (next) => (action) => {
	... (리듀서 실행 전)
	next(action)
	... (리듀서 실행 후)
}

// 미들웨어 함수 구조 2
const middleware2 : Middleware = function(store) {
	return function(next) {
		return function(store) { ... }
	}
}
```
> 구조 1에서 `=>`가 여러 개로 구성되어 있는 구조인데, 이는 가장 바깥쪽 함수를 호출하면 안쪽 함수를 리턴하는 형태로 중첩되어 있다. 이를 `커링Currying`이라고 부른다.

- 아래처럼 사용할 수 있다.
```tsx
middleware1(store)(next)(action)
```
> - 커링에서 중요한 것은, 가장 안쪽에 중첩된 함수는 `store, next, action` 3개의 인자를 모두 사용할 수 있다는 것이다. 각각 `리덕스 스토어`, `dispatch()`, `스토어로 전달되는 액션 메시지`이다.
> - `next(action)` 호출을 기점으로 앞쪽은 리듀서로 전달하기 전에 실행하는 영역이었고, 뒤쪽은 리듀서가 호출되고 상태가 변경된 후의 시점에 실행되는 영역이다. 실제로 미들웨어는 여러 개 등록할 수 있다.
> - 한 미들웨어에서 리듀서로 전달하기 전의 실행이 완료되면, `next(action)`을 호출하여 다음 리듀서로 `action`을 전달해줄 수 있다. 만약 액션을 전달하지 않으면 다음 미들웨어는 물론, 리듀서로 액션이 전달되지 않으므로 상태를 변경하지 않을 것이다.

- 즉, 위 그림의 흐름을 따르면 아래와 같다.
	- 미들웨어1의 전처리 실행 -> `next(action)`
	- 미들웨어2의 전처리 실행 -> `next(action)`
	- 리듀서 실행 -> 새로운 상태 리턴 -> 스토어의 새로운 상태로 설정
	- 미들웨어2의 후처리 실행
	- 미들웨어1의 후처리 실행
- `전처리 실행` = 리듀서 실행 전
- `후처리 실행` = 리듀서 실행 후

### 테스트용 미들웨어 적용하기
- `AppStore.ts` 적용하기
- 미들웨어는 스토어에 등록하는 것이므로 `AppStore`만 변경한다.
```ts
import { combineReducers, Middleware } from 'redux';

const mw1: Middleware = (store) => (next) =>(action) => {
    console.log("### mw1 전")
    next(action);
    console.log("### mw1 후")
}

const mw2: Middleware = (store) => (next) =>(action) => {
    console.log("### mw2 전")
    next(action);
    console.log("### mw2 후")
    console.log(store.getState());
}

// const Appstore = configureStore({ reducer: RootReducer });
const AppStore = configureStore({
    reducer: RootReducer,
    middleware: (getDefaultMiddleware) => {
        return getDefaultMiddleware({ serializableCheck: false}).concat(mw1).concat(mw2)
    }
})
export default AppStore;
```
> 2개의 미들웨어를 등록했다. 흐름을 파악할 수 있게 콘솔에 로그를 출력하도록 작성한다.
> 또한, 스토어 객체의 `getState()` 함수를 통해 변경된 상태를 출력한다.
> 스토어를 등록할 때, 미들웨어를 지정하기 위해 **`configureStore` 함수의 인자 옵션으로 `middleware`를 설정한다.** 미들웨어를 여러 개 추가하려면 순서대로 `concat()` 함수로 추가하면 된다.

- `@reduxjs/toolkit`은 직렬화 가능 여부, 불변성 제공 여부를 체크하는 내장된 기본 미들웨어와 비동기 처리를 위한 `redux-thunk` 기능을 제공하는 미들웨어를 내장하고 있다.
	- `todolist-app-router` 앱의 `Date` 타입을 사용하는 `currentTime`은 직렬화가 지원되지 않기 때문에 경고가 발생할 수 있다. 이를 발생시키지 않기 위해 `serializableCheck: false`로 지정했다.

- 위 상태로 실행하면 `mw1 전 -> mw2 전 -> mw2 후 -> mw1 후`처럼 실행된다.
- `AppStore` 코드에서 1번째 미들 웨어의 `next(action)`을 주석처리하면 2번째 미들웨어와 상태 변경 작업이 실행되지 않는다.

### 간단한 콘솔 로거 미들웨어
- `mw1, mw2` 미들웨어를 주석 처리한 후, 간단한 콘솔 로거 미들웨어를 등록한다.
```ts
// const mw1: Middleware = (store) => (next) =>(action) => {
//     console.log("### mw1 전")
//     next(action);
//     console.log("### mw1 후")
// }

// const mw2: Middleware = (store) => (next) =>(action) => {
//     console.log("### mw2 전")
//     next(action);
//     console.log("### mw2 후")
//     console.log(store.getState());
// }

const loggerMW: Middleware = (store) => (next) => (action) => {
    console.log("### action 실행 : ", action);
    console.log("### action 변경 전 상태 : ", store.getState());
    next(action);
    console.log("### action 변경 후 상태 : ", store.getState());
};

// const Appstore = configureStore({ reducer: RootReducer });
const AppStore = configureStore({
    reducer: RootReducer,
    middleware: (getDefaultMiddleware) => {
        return getDefaultMiddleware({ serializableCheck: false}).concat(loggerMW);
    }
})
export default AppStore;
```
> 이걸 개발할 떄 확인할 수 있는건 아래와 같다.
> 	 - 전달된 액션
> 	 - 전달된 액션에 의해 변경되기 전의 상태
> 	 - 전달된 액션에 의해 변경된 후의 상태
![[Pasted image 20231201161626.png]]
> `todoList`의 개수 등에도 잘 반영된 것을 볼 수 있음.


## redux-thunk 미들웨어
- 대부분의 **앱은 많은 작업과 기능을 비동기로 처리**하고 있다.
	- 백엔드 API와의 통신
	- `setTimeout()`을 이용해 일정 시간 뒤에 실행
- 만약 백엔드 API로 브라우저에서 요청을 하면, 약간의 지연시간 뒤에 응답을 수신할 수 있는데 요청을 동기적으로 처리하면 브라우저 화면에서는 먹통 현상을 경험할 수 있다. 이는 자바스크립트의 `Promise, async/await` 같은 비동기 처리 방법으로 해결할 수 있다.
- 그렇다면 **리덕스의 어느 시점에 비동기 처리 코드를 적용**해야 할까?
	1. `리듀서`에는 비동기 처리를 배치하지 않는다. 리듀서는 상태 변경 기능만을 다루며, 순수 함수이기 떄문이다.
	2. `액션 생성자ActionCreator`는 작업이 완료될 때까지 기다렸다가 액션을 리턴하도록 만들기 때문에 동기적으로 작동해야 한다. 비동기 처리를 하면 액션 리턴 시점을 몰라서 사용하는 것에 어려움이 있다.
	3. 따라서 리덕스에서는 액션 생성자에서 비동기 처리를 해주거나, **별도의 구성 요소로 비동기 처리 모듈을 분리**할 수 있는 다양한 미들웨어를 사용한다. 가장 널리 알려진 게 `redux-thunk`이다.

### redux-thunk란?
- 액션 대신 `thunk`라는 함수를 전달dispatch하도록 하여 비동기 처리를 수행하는 기능을 제공하는 미들웨어이다. 
	- `thunk` : 컴퓨터 프로그래밍에서 **다른 서브루틴이나 함수로 연산 기능을 주입시킬 때 사용하는 서브루틴, 함수**를 의미하며, 결과가 도출될때까지 연산을 지연시키거나 다른 서브루틴의 시작과 끝에 어떤 작업을 삽입할 때 주로 사용한다.
	- 한마디로 **지연된 연산 실행을 위해 표현식으로 만든 함수**이다.

```sh
npm install redux-thunk
```
> 을 실행하지 않더라도, `@reduxjs/toolkit` 패키지에 이미 포함되어 있어서 별도로 패키지를 설치할 필요는 없다.

- `redux-thunk`의 구조
![[새 폴더 1 - 0 (4).jpg]]
> 1. `dispatch(action)`이 호출되며 스토어로 액션이 전달된다.
> 2. `redux-thunk` 미들웨어를 거치며 전달된 액션이 `thunk` 형태의 함수인지 확인한다.
> 3. `thunk`라면 `thunk()` 함수 내부에서 비동기 처리 코드를 실행, 이 과정에서 상태 변경 액션을 전달한다.
> 	4. 이 함수 내부에서 비동기 처리가 시작되었음을 나타내기 위한 상태 변경 액션을 전달Dispatch한다. 이는 (6) 단계를 거친다.
> 	5. 비동기 처리 완료 시, 처리 결과를 화면에 나타내기 위한 상태 변경 액션을 전달한다.
> 6. 4, 5단계 각각이 완료된다면 이들을 다시 2번 단계에 전달한다.
> 7. `thunk`가 아니라면, `next(action)`을 호출해 리듀서가 새로운 상태를 만들어내도록 한다.

- 액션이 비동기 처리를 포함한 thunk라면 thunk를 바로 호출하고 비동기 처리가 진행되는 동안 `dispatch(action)`으로 처리 과정 중의 상태를 변경하게 된다.
- 상태 변경이 필요한 시점은 크게 3가지이다.
	- 작업 요청 시작 시점
	- 작업이 성공적으로 완료된 시점
	- 작업이 실패한 시점

- 예를 들어, 백엔드 API에 할 일 데이터를 추가하는 비동기 처리 작업을 한다면
	1. 프런트 -> 백엔드 : `todo` 추가 작업 요청
	2. 백엔드 -> 프런트 : `todo` 추가 성공/실패 여부 응답

- 이렇게 비동기 처리를 진행하는 동안 각 시점에 상태를 변경해야 하므로, `thunk` 함수의 일반적인 패턴은 다음과 같다.
```ts
// thunk 함수의 일반적인 패턴 (Promise 버전)
(dispatch: ThunkDispatch<{}, {}, AnyAction>) => {
	// dispatch 함수를 이용해 작업의 시작 상태로 바꿈
	dispatch(ActionCreator.getTodosRequested());
	axios.get(url)
		.then((response) => {
		// 성공 시 작업 성공 상태 + 응답 데이터 전달
		dispatch(ActionCreator.getTodosCompleted());
	})
		.catch((error) => {
		// 실패 시 에러 메시지를 전달
		dispatch(ActionCreator.getTodosFailed());
		})
}

// async, await 버전
async (dispatch: ThunkDispatch<{}, {}, AnyAction>) => {
	try {
		// dispatch 함수를 이용해 작업 시작 상태로 바꿈
		dispatch(<ActionCreator.getTodosRequested());
		const response = await axios.get(url);
		// dispatch 함수를 이용, 작업 성공 상태 + 응답 데이터 전달
		dispatch(ActionCreator.getTodosCompleted());
	} catch (error) {
		// dispatch 함수를 이용해 실패 시에는 에러 메시지를 담아 전달
		dispatch(ActionCreator.getTodosFailed())
	}
}
```

- 최종적으로, **일반적인 비동기 처리 과정**을 위해 액션 생성자에 만들어야 하는 함수는
	- 상태 변경 기능을 제공하는 3개의 함수
	- 비동기 처리를 위해 `thunk`를 리턴하는 함수 1개
	- 총 4개의 함수를 작성해야 한다.

### redux-thunk 적용하기
- `Home` 화면에서 `<현재 시각 확인>` 버튼을 누르면 2초 지연 후 시간이 변경되도록 한다.
	- 지연 중에는 `시간 확인 중` 같은 메시지가 나타나도록 UI를 구성한다.

- `redux/TimeActionCreator.ts`
```ts
import { AnyAction } from "redux";
import { ThunkDispatch } from "redux-thunk"

export const TIME_ACTION = {
    CHANGE_TIME_REQUEST: "changeTimeRequest" as const,
    CHANGE_TIME_COMPLETED: "changeTimeCompleted" as const,
}

const TimeActionCreator = {
    changeTimeRequest: () => {
        return {type: TIME_ACTION.CHANGE_TIME_REQUEST};
    },
    changeTimeCompleted: ({ currentTime }: {currentTime: Date}) => {
        return {
            type: TIME_ACTION.CHANGE_TIME_COMPLETED,
            payload: { currentTime: currentTime }
        };
    },
    asyncChangeTime() {
        // 의도적 지연 시간 1초
        return (dispatch: ThunkDispatch<{}, {}, AnyAction>) => {
            dispatch(this.changeTimeRequest());
            setTimeout(() => {
                dispatch(this.changeTimeCompleted({ currentTime: new Date() }))
            }, 1000)
        }
    }
}

export type TimeActionType =
    | ReturnType<typeof TimeActionCreator.changeTimeCompleted>
    | ReturnType<typeof TimeActionCreator.changeTimeRequest>;
```
> 상태 변경 액션으로 요청 시점과 성공 시점만을 사용했다.
> `asyncChangeTime()` 액션 생성자가 호출되면 `thunk` 함수를 리턴하고, 이 함수 내부에 비동기 처리를 작성`return 부분`했다. 
> - 위 예제는 `setTimeout()`을 이용해 2초 후에 현재 시각을 전달해 상태를 변경한다. (1초가 아니라?)
> 참고) `redux-thunk`는 별도로 등록하지 않더라도 `@reduxjs/toolkit`에 내장되어 있다.

- 2가지 상태 변경 시점을 처리하도록 `TimeReducer`를 변경한다.
- `redux/TimeReducer.ts`
```ts
import { TimeActionType, TIME_ACTION } from "./TimeActionCreator";

const initialState = {
    currentTime: new Date(),
    isChanging: false
}
export type HomeStatesType = { currentTime : Date; isChanging: boolean; };

const TimeReducer = (state: HomeStatesType = initialState, action: TimeActionType) => {
    switch(action.type) {
        case TIME_ACTION.CHANGE_TIME_REQUEST:
            return { ...state, isChanging: true };
        case TIME_ACTION.CHANGE_TIME_COMPLETED:
            return { ...state, currentTime: action.payload.currentTime, isChanging: false };
        default:
            return state; 
    }
}

export default TimeReducer;
```
> - `isChanging` 상태를 추가, 시간 변경이 요청되면 `true`로 변경되어 `시간 확인 중` 같은 메시지가 나타나게 하고, 완료 후에는 `false`로 변경되어 메시지가 사라지도록 한다.

- `pages/Home.tsx`
```tsx
import { ThunkDispatch } from 'redux-thunk'

type PropsType = {
  currentTime: Date;
  changeTime: () => void;
  isChanging: boolean;
}

const Home = ({ currentTime, changeTime, isChanging }: PropsType) => {
  return (
    <div className="card card-body">
        <h2>Home</h2>
        <hr />
        {
          isChanging? <h4>시간 확인 중</h4>
          : <MyTime currentTime={currentTime} changeTime={changeTime} />
        }
    </div>
  )
}

const mapStateToProps = (state: RootStatesType) => (
  { currentTime: state.home.currentTime,
  isChanging: state.home.isChanging, }
);

const mapDispatchToProps = (dispatch: ThunkDispatch<{}, {}, AnyAction>) => ({
  changeTime: () => dispatch(TimeActionCreator.asyncChangeTime()),
})
```
> - `isChanging` 속성을 속성 타입에 추가, 상태를 속성에 주입시키도록 매핑하고, 컴포넌트 속성도 명시한다.
> - `ThunkDispatch`를 이용해 비동기처리하는 `thunk`가 액션으로 전달될 수 있도록 `changeTime` 함수를 매핑한다. 

- `AppStore.ts` 변경
```ts
    // console.log("### action 변경 전 상태 : ", store.getState());
    next(action);
    // console.log("### action 변경 후 상태 : ", store.getState());
```
> 저 부분만 주석처리 하면 됨
![[Pasted image 20231201165358.png]]
> 버튼을 누르면 `Request` 동안 `시간 확인 중`, `Completed`이면 다시 시간이 뜬다.

### redux-thunk와 @reduxjs/toolkit 함께 쓰기
- 지금까지 예제에서 `TodoActionCreator, TodoReducer`는 툴킷 함수로 작성했고, `TimeReducer, TimeActionCreator`는 직접 작성하면서 작동 원리를 이해하기 위해 툴킷을 적용하지 않았다.
- `TimeReducer`와 `TimeActionCreator`에도 툴킷을 적용한다.

- `@reduxjs/toolkit`에서는 `redux-thunk`가 기본적으로 미들웨어로 등록되어 있다. 
- 이외에도, 편리하게 쓸 수 있게 `createAsyncThunk()`라는 툴킷 함수도 있는데, 이를 이용한다.
- 사용법
```ts
const asyncAction = createAsyncThunk("액션명", async (arg, thunkAPI) => {
	...
	return payload;
})
```
> - `args` : 비동기처리에 필요한 인자. 
> - `payload` : 비동기처리 후 마지막에 리턴하는 값이 최종적으로 완료했을 때 전달하는 `action`의 페이로드가 된다.

- 위 함수의 특징은 **시점별로 직접 `dispatch(action)`하지 않아도 된다**는 것이다.
	내부적으로 액션 생성자 함수를 생성해 자동으로 해당 시점에 `전달dispatch`하고, 액션 생성자 함수는 리턴받은 `asyncAction` 함수의 정적 멤버에 할당해준다.

- 앞 예시처럼 `createAsyncThunk()`를 호출해서 리턴받은 함수의 이름의 `asyncACtion`이고 액션명을 `searchPerson`으로 지정했다면, 각 시점의 액션 생성자 함수와 액션이 사용하는 액션명은 다음과 같다.

| 시점             | 액션명                 | 액션 생성자 함수      |
| ---------------- | ---------------------- | --------------------- |
| 비동기 작업 시작 | `searchPerson/pending`   | `asyncAction.pending`   |
| 비동기 작업 완료 | `searchPerson/fulfilled` | `asyncAction.fulfilled` |
| 비동기 작업 실패 | `searchPerson/rejected`  | `asyncAction.rejected`                      |

- 2번째 인자인 `thunkAPI`는 `payloadCreator`라 부르는 비동기 처리를 수행하는 함수이다. 함수 내부에서 시점별로 `dispatch(action)`하지 않아도 된다.
- 액션의 전달도 자동으로 수행된다. 직접 수행하고 싶다면 `thunkAPI` 인자를 이용해 `dispatch.fulfillWithValue, rejectWithValue, getState` 함수를 이용해 상태를 확인하고 액션을 전환할 수 있다.
- `createAsyncThunk()`를 호출해서 받은 리턴값도 함수이다. 이를 이용해 비동기 처리를 시작하면 된다.
	- `PayloadCreator` 함수는 `Promise` 기반이다. 

- `redux/TimeActionCreator.ts` 변경
```ts
import { createAction, createAsyncThunk } from '@reduxjs/toolkit'

const timeout = (delaytime: number) => new Promise((resolve) => setTimeout(resolve, delayTime));

const TimeActionCreator = {
    // asyncChangeTime() {
        // 의도적 지연 시간 1초
        // return (dispatch: ThunkDispatch<{}, {}, AnyAction>) => {
        //     dispatch(this.changeTimeRequest());
        //     setTimeout(() => {
        //         dispatch(this.changeTimeCompleted({ currentTime: new Date() }))
        //     }, 1000)
        // }
    asyncChangeTime: createAsyncThunk(
        "changeTime",
        async (undefined, thunkAPI) => {
            await timeout(2000);
            return { currentTime: new Date() };
        }
    )
}
```
> - `setTimeout()`은 `promise`를 리턴하지 않는다. `createAsyncThunk()`를 사용할 수 없기 때문에, `timeout` 함수를 이용해 `setTimeout()`을 Promise로 사용할 수 있게 만든다.
> - `createAsyncThunk()` 함수를 호출하여 리덕스 툴킷의 표준적인 액션 생성자를 리턴받는다. 자동으로 생성된 액션 생성자는 아래와 같다.
> 	- `TimeActionCreator.asyncChangeTime.pending`
> 	- `TimeActionCreator.asyncChangeTime.fulfilled`
> 	- `TimeActionCreator.asyncChangeTime.rejected`
> - `payloadCreator` 함수를 등록할 때 `arg`로 필요한 값을 전달할 수 있다. 만약 `arg` 값으로 `현재 시각currentTime`을 전달한다면 `TimeActionCreator.asyncChangeTime` 과 같이 호출하여 비동기 처리를 시작할 수 있다. 그러나 이 예제에서는 `payloadCreator` 함수의 `arg` 인자를 사용하지 않아 `undefined`를 전달한다.

- `TimeReducer`를 변경한다.
	- `TimeActionCreator`의 `asyncChangeTime` 액션 생성자와 함께 만들어진 액션 생성자 이름으로 리듀서를 작성한다.
	- `@reduxjs/toolkit`이 제공하는 `createReducer` 함수를 이용하면 더 편리하게 리듀서를 작성할 수 있다.
```ts
// import { TimeActionType, TIME_ACTION } from "./TimeActionCreator";
import { createReducer } from "@reduxjs/toolkit"
import TimeActioncreator from './TimeActionCreator'

// const TimeReducer = (state: HomeStatesType = initialState, action: TimeActionType) => {
//     switch(action.type) {
//         case TIME_ACTION.CHANGE_TIME_REQUEST:
//             return { ...state, isChanging: true };
//         case TIME_ACTION.CHANGE_TIME_COMPLETED:
//             return { ...state, currentTime: action.payload.currentTime, isChanging: false };
//         default:
//             return state; 
//     }
// }
const TimeReducer = createReducer(initialState, (builder) => {
    builder
        .addCase(TimeActionCreator.asyncChangeTime.pending, (state, action) => {
            state.isChanging = true;
        })
        .addCase(TimeActionCreator.asyncChangeTime.fulfilled, (state, action) => {
            state.isChanging = false;
        })
})
```

- 리덕스를 학습할 때는 툴킷을 적용하기 전의 코드를 먼저 확인하고 툴킷을 사용하는 것을 권장한다.

### redux-thunk와 axios 사용 예제
- 이 책에서는 예제를 싣지 않았으며, 원리는 이미 설명했대요

## redux-saga 미들웨어

### redux-saga
- `redux-thunk`를 쓰면서, 액션 생성자에서 외부 API를 비동기로 호출하는 부작용을 작성했다.
- 액션 생성자는 액션을 생성하는 일에만 집중해야 하는데, 부작용 처리까지 떠안고 있다.
- 따라서 한 액션 생성자가 다른 액션 생성자를 포함해서 호출하는 형태가 되었고, 이 상태에서 액션 생성자는 상태 관리나 부작용 처리 어느 하나에 집중할 수 없다. 즉, "예측 가능한 상태 관리 컨테이너"의 역할을 못한다.
- 따라서 부작용을 생성자에서 분리해서 손쉽게 관리할 수 있도록 만들어진 리덕스 미들웨어가 `redux-saga`이다. 
	- 리덕스 스토어의 흐름을 보다가 특정 액션을 감지해서 지정한 `saga`에 의해 작업이 시작, 중지, 취소되도록 정의할 수 있다.

### 시작 전 알아야 할 것
- `saga`란 마이크로 서비스 환경에서 분산된 서비스가 제공하는 기능을 트랜잭션 단위로 처리하기 위해 만들어진 개념이다. 
- `saga`는 분산 트랜잭션에서의 개별 로컬 서비스들을 실행해나가는 시퀀스의 개념으로 볼 수 있다. 즉, 여러 개별 트랜잭션의 순서가 있는 집합이다.
- `redux-saga`를 시작하기 전, ES6과 타입스크립트의 `제너레이터Generator` 문법을 이해해야 한다. 제너레이터란, `Iterable` 객체를 리턴하는 특수한 함수이다. 
- 이 함수는 이터러블 객체를 이용해 함수 실행의 제어권을 함수 밖으로 넘겼다가 돌려받는 것도 가능하다.
```ts
const numGenerator = function*() {
	const x = yield 1;
	const y = yield (x + 1);
	const z = yield (y + 2);
	return x + y + z;
}

const it = numGenerator();
console.log(it.next()); // 1
console.log(it.next(10)); // 11
console.log(it.next(20)); // 22
console.log(it.next(30)); // 60
```
> 실행 구조는 이렇다.
```
1. it.next() 실행 
2. const x = yield 1; 이 {value : 1, done : false} 반환
3. it.next(10) 실행
4. x = 10 & 그 다음 코드인 const y = yield(x+1)이 실행, {value : 11, done: false} 반환
5. it.next(20) 실행
6. const z = yield (y + 2)에 y = 20이 반영, 22를 반환한다.
7. it.next(30) 실행 
8. z = 30이 반영되며, 앞에서 반영된 x = 10, y = 20, z = 30이 더해져 60을 반환하고 done:true가 된다.
```
> - `const it = numGenerator()`에서 제너레이터 함수는 실행되지 않았다.
> - 함수를 실행하려면 이터러블 객체의 `next()`를 호출해야 한다.
> - 제너레이터 함수 내부에서 **`yield` 문을 만나면, 함수 내부의 실행을 잠시 중단하고 중간 결과를 함수 밖으로 던져준다.** `value, done`을 던진다.
> - 제너레이터 함수 밖에서 다시 이터러블 객체의 next()가 호출되면, 인자값이 제너레이터 내부의 `x`로 전달되고 중단된 시점부터 다시 실행된다.

- 즉, 제너레이터는 `yield`문을 통해 실행의 제어권을 제너레이터 함수 밖으로 넘겼다가 다시 받을 수 있는 특수한 함수이다.
	- 비동기 처리에 유용하게 쓸 수 있다. 제너레이터 함수 밖으로 제어권을 넘겨서 비동기 처리를 하도록 하고 처리가 완료되면 `next()`를 이용해 처리 결과를 제너레이터 함수 내부로 받아올 수 있다.

- 다음 예제를 [여기](https://todosvc.herokuapp.com/)의 브라우저 콘솔에서 실행해보자
```ts
const url = "https://todosvc.herokuapp.com/todolist_long/gdhong";
const getTodoList = () => {
	fetch(url).then((response) => response.json()).then((json) => it.next(json));
}

const getTodoOne = () => {
	fetch(url + "/" + id).then((response) => response.json()).then((json) => it.next(json));
}

const todoListGenerator = function* (){
	console.log("### Start!")
	let todoList = yield getTodoList();
	console.log(`### 전체 ${todoList.length}건의 데이터 확인`);
	for (let i=0; i<todoList.length; i++) {
		let todo = yield getTodoOne(todoList[i].id);
		console.log(`${i+1}번째 Todo : `, todo);
	}
	console.log("## 조회 완료");
	return;
}

const it = todoListGenerator();
it.next()
```
> 사이트가 작동을 안함. 어쨌든 1초 간격으로 할 일이 1개씩 출력된다고 한다.

- `redux-saga`는 이러한 제너레이터로 실행한다.

### redux-saga 아키텍처
![[새 폴더 1 - 0 (5).jpg]]
> - 액션 생성자와 별개로 `관찰자Watcher`와 `작업자Worker` 사가로 구성된다. 여러 비동기 작업이 필요하다면 관찰자 사가가 여러 개일 것이므로, 관찰자 여러 개를 그룹으로 묶어 루트 사가를 등록하여 미들웨어로 등록하고 관찰을 시작한다.
> - `관찰자 사가`들은 미리 지정한 액션이 지나가면 즉시 준비해둔 `작업자 사가`를 구동시킨다. 또는 여러 작업자의 일련의 흐름을 실행하기도 한다. 이 흐름 동안 다시 상태를 바꾸거나 작업을 중지할 수도 있다. 또한 새로운 사가 작업을 시작하거나, 다른 작업의 종료를 기다리는 등의 작업을 할 수도 있는데, 이런 개별 작업과 관련된 기능을 `효과Effect`라고 부른다.
> - 위 그림에서는 작업 흐름을 처리하다가 `put()`이 있는데, 이는 액션을 전달하는 효과이다. 이외에도 여러 코드가 있으나 예제를 보면서 확인한다.
> - `관찰자 사가`와 `작업자 사가`로 부작용을 분리하고 효과 중심으로 작업 흐름을 관리하면 비동기 처리가 일목요연해지고 관리하기도 쉽다. 더불어 `액션 생성자`는 부작용이 포함되지 않은 정말로 상태 변경을 위한 액션 생성 기능에만 집중할 수 있게 된다.

- 사가의 효과
	- `takeEvery` : 들어오는 모든 액션 감시, 액션 포착 시 작업자 사가 실행
	- `delay` : 실행 지연
	- `put` : 액션 전달
	- `fork` : 새로운 사가 작업 시작
	- `call` : 함수를 동기적으로 시작하고, Promise가 완료될 때까지 블로킹 상태로 대기한다.
	- `select` : 상태로부터 필요한 데이터를 읽어온다.
	- `all` : 여러 제너레이터를 배열로 전달하면 병렬로 실행하고 모두 완료될 때까지 대기한다.
	- `join` : 다른 작업`task`이 완료될 때까지 대기한다.

### redux-saga 적용하기
```sh
npm install redux-saga
```

- `TimeActionCreator`와 `TimeReducer`를 새롭게 작성한다.
- `TimeActionCreator.ts`
```ts
export const TIME_ACTION = {
    CHANGE_TIME_REQUEST: "changeTimeRequest" as const,
    CHANGE_TIME_COMPLETED: "changeTimeCompleted" as const,
    CHANGE_TIME_FAILED: "changeTimeFailed" as const,
}

const TimeActionCreator = {
    changeTimeRequest() {
        return {type: TIME_ACTION.CHANGE_TIME_REQUEST};
    },
    changeTimeCompleted(currentTime: Date) {
        return {
            type: TIME_ACTION.CHANGE_TIME_COMPLETED,
            payload: { currentTime: currentTime }
        };
    },
    changeTimeFailed() {
        return {type: TIME_ACTION.CHANGE_TIME_FAILED }
    }
}

export type TimeActionType =
    | ReturnType<typeof TimeActionCreator.changeTimeCompleted>
    | ReturnType<typeof TimeActionCreator.changeTimeRequest>
    | ReturnType<typeof TimeActionCreator.changeTimeFailed>
```

- `TimeReducer.ts`
```ts
import { TimeActionType, TIME_ACTION } from "./TimeActionCreator";

const initialState = {
    currentTime: new Date(),
    isChanging: false
}
export type HomeStatesType = { currentTime : Date; isChanging: boolean; };


const TimeReducer = (state: HomeStatesType = initialState, action: TimeActionType) => {
    switch(action.type) {
        case TIME_ACTION.CHANGE_TIME_REQUEST:
            return { ...state, isChanging: true };
        case TIME_ACTION.CHANGE_TIME_COMPLETED:
            return { ...state, currentTime: action.payload.currentTime, isChanging: false };
        case TIME_ACTION.CHANGE_TIME_FAILED:
            return { ...state, isChaning: false };
        default:
            return state; 
    }
}  

export default TimeReducer;
```

- 위까지는 리덕스 구성요소를 작성한 것이다.
- 여기부터는 사가 구성 요소를 작성한다. `sagas` 디렉터리를 생성하고, `timeSaga.ts` 파일을 작성한다.
- `sagas/timeSaga.ts`
```ts
import { all, fork, takeEvery, call, put} from 'redux-saga/effects'
import TimeActionCreator, { TIME_ACTION } from '../redux/TimeActionCreator'

// 비동기 처리 함수 : 2초 후 현재 시각을 응답함
const changeTimeApi = () => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve({ currentTime: new Date()});
        }, 2000)
    })
}

// 비동기 처리 진행하는 작업자 사가
function* changeTime() {
    try{
        // Promise 완료까지 changeTimeApi를 블록되도록 fork한다.
        // 완료 시 response로 리턴
        const response: {currentTime: Date} = yield call(changeTimeApi);

        // 리턴받은 response를 put() 해서 액션을 디스패치한다(전달한다)
        yield put(TimeActionCreator.changeTimeCompleted(response.currentTime));
    } catch (e) {
        console.error(e);
        // 실패 : 실패 시의 액션을 전달함
        yield put(TimeActionCreator.changeTimeFailed());
    }
}

// CHANGE_TIME_REQUEST 액션을 감시한다. 액션 포착 시 changeTime 작업자 사가를 시작한다.
function* watcher_changeTime() {
    yield takeEvery(TIME_ACTION.CHANGE_TIME_REQUEST, changeTime);
}

// watcher.changeTime() 을 이용하는 새로운 사가 작업을 시작한다
export default function* timeSaga() {
    yield all([fork(watcher_changeTime)]);
}
```

- `sagas/index.ts` 파일을 작성한다.
```ts
import { all, fork } from 'redux-saga/effects'
import timeSaga from './timeSaga'

// timeSaga 외에 다른 사가가 있다면 모두 모아 병렬로 fork 시킨다.
export default function* rootSaga() {
    yield all([fork(timeSaga)]);
}
```

- 여러 사가를 취합한 루트 사가`rootSaga`를 이용한 `redux-saga` 미들웨어를 스토어에 등록하도록 `AppStore`를 변경한다.
```tsx
import createSagaMiddleware from 'redux-saga'
import rootSaga from '../sagas'

const sagaMiddleware = createSagaMiddleware();

...

// const Appstore = configureStore({ reducer: RootReducer });
const AppStore = configureStore({
    reducer: RootReducer,
    // middleware: (getDefaultMiddleware) => {
    //     return getDefaultMiddleware({ serializableCheck: false}).concat(loggerMW);
    middleware: (getDefaultMiddleware) => {
        return getDefaultMiddleware({ serializableCheck : false })
            .concat(loggerMW).concat(sagaMiddleware)
        }
    }
)

// 사가 미들웨어를 등록한 뒤, rootSaga를 이용해 사가를 구동한다.
sagaMiddleware.run(rootSaga);
```

- 마지막으로 `Home` 컴포넌트를 변경한다.
	- 기존 `asyncChangeTime()` 액션을 실행하도록 작성했던 것을 `TimeActionCreator.changeTimeRequest()`을 실행하도록 변경하면 된다.
	- 비동기 처리를 수행하는 액션 생성자가 아니라, 순수하게 액션을 만들어내는 액션 생성자를 호출하도록 변경하는 것이다.
```tsx
import { AnyAction, Dispatch } from 'redux'

// const mapDispatchToProps = (dispatch: ThunkDispatch<{}, {}, AnyAction>) => ({
//   changeTime: () => dispatch(TimeActionCreator.asyncChangeTime()),
// })

// ThunkDispatch가 아닌 Dispatch<AnyAction> 타입의 dispatch를 이용, TimeActionCreator.changeTimeRequest()를 액션으로 전달하도록 바꾼다.
const mapDispatchToProps = (dispatch: Dispatch<AnyAction>) => ({
  changeTime: () => dispatch(TimeActionCreator.changeTimeRequest())
})

```
> 이제 개발서버를 구동, `현재 시각 확인` 버튼을 누르고 콘솔 창을 확인한다.

## react-redux가 제공하는 훅
- `connect()` 고차 함수는 리덕스의 상태, 액션 생성자를 표현 컴포넌트로 주입시키기 위해 썼다.
- 하지만 고차 함수가 익숙치 않다면, 불편하고 직관적이지 않은 코드라고 생각할 수 있다.
- 함수 컴포넌트 기반의 개발을 한다면 더 직관적인 `react-redux`가 제공하는 훅들을 이용할 수 있다.
	- `useStore()` : 리덕스 스토어 객체를 리턴한다. 스토어의 상태를 읽으려면 `getState()` 함수를 이용한다.
	- `useDispatch()` : 스토어의 `dispatch()` 함수를 리턴한다. 리턴 받은 함수를 이용해 액션을 스토어에 전달할 수 있다.
	- `useSelector()` : 리덕스 스토어의 특정 상태를 선택해 리턴한다.

- `TodoList.tsx`
```tsx
import { useDispatch, useSelector } from 'react-redux';

...

// const mapStateToProps = (state : RootStatesType) => ( {
//     todoList: state.todos.todoList,
// })

// const mapDispatchToProps = (dispatch: Dispatch<AnyAction>) => ({
//     deleteTodo: (id: number) => dispatch(TodoActionCreator.deleteTodo({ id })),
//     toggleDone: (id: number) => dispatch(TodoActionCreator.toggleDone({ id })),
// })

// 훅을 이용한 컨테이너 컴포넌트 생성
const TodoListContainer = () => {
    const dispatch = useDispatch();
    const todoList = useSelector((state: RootStatesType) => state.todos.todoList);
    const deleteTodo = (id: number) => dispatch(TodoActionCreator.deleteTodo({ id }));
    const toggleDone = (id: number) => dispatch(TodoActionCreator.toggleDone({ id }));

    return <TodoList todoList={todoList} deleteTodo ={deleteTodo} toggleDone = {toggleDone} />;
};

// export default connect(mapStateToProps, mapDispatchToProps)(TodoList);
export default TodoListContainer;
```
> `connect()` 고차함수로 컨테이너를 만드는 부분만 변경하면 된다.
> 	- `useDispatch()`를 이용해 `dispatch()` 함수를 리턴 받고, 표현 컴포넌트의 속성에 전달하는 기능을 수행할 함수를 생성할 때 사용한다.
> 	- `useSelector()` 훅을 사용해 전체 함수중 `todoList` 만을 속성으로 전달하도록 작성한다. 전달하는 함수의 인자가 `state`이고, 일부 객체를 리턴해 필요한 상태만을 추출한다. 뽑아낸 값은 `return` 부분처럼 표현 컴포넌트로 전달한다.
> 	- 주석 처리한 부분은 기존 `connect()` 고차함수를 사용한 부분이다.
> 
- 훅의 사용이 쉽지만, 클래스 컴포넌트 기반으로만 작성하겠다면 `connect()`를 써야 함.

## 리덕스 개발 도구
### 리덕스 개발 도구
- 리덕스가 복잡해서 왜 쓰는지 모르겠을 때, `리덕스 개발도구Redux DevTools`를 사용하면 생각이 달라질 것이다.
- 브라우저 화면을 통해 리덕스 앱의 상태 변경을 추적하고, 상태와 액션 정보들을 시각화할 수 있는 강력한 개발, 디버깅 도구이다.
- 미들웨어로 만들어져 있으며, `@reduxjs/toolkit`의 `configureStore` 툴킷 함수에 내장되어 있다. 브라우저의 확장 프로그램(`Redux DevTools`)만 설치하면 리덕스 개발 도구를 바로 이용할 수 있다.
- 개발 도구는 개발 환경에서만 쓰면 되므로, 운영 환경일 때는 작동되지 않도록 설정한다. 이 설정은 `configureStore` 툴킷 함수에서 수행한다.
```sh
npm install -D @types/node
```
> `node` 타입 정보를 설치한다.

- `AppStore.ts`에서 `devTools` 옵션을 추가한다.
```ts
const AppStore = configureStore({
    reducer: RootReducer,

    middleware: (getDefaultMiddleware) => {
        return getDefaultMiddleware({ serializableCheck : false })
            .concat(loggerMW).concat(sagaMiddleware)
        },
    devTools: process.env.NODE_ENV !== "production", // 여기만 추가
    }
)
```

### 리덕스 개발 도구 사용하기
- 브라우저 개발자 도구의 `Redux` 탭을 클릭해서 연다.
- 크게 3가지의 도구가 있다.
1. `Inspector`
	- 화면 아래쪽에 `Inspector`를 클릭해서 볼 수 있다.
	- 시간 순으로 어떤 액션이 전달됐는지, 액션에 의해 상태는 어떻게 변경됐는지, 기존 상태와 현 상태에는 어떤 차이가 있는지를 한눈에 볼 수 있도록 도와준다.
	- `Action, State, Diff` 정보는 각각 전달된 액션 정보, 상태 정보, 기존 상태와의 차이를 볼수 있으며, 이는 차트(`State - Chart`)로 볼 수도 있다.
	- `재생` 버튼을 누르면 처음 상태부터 현재 상태까지의 변화를 영상 재생하는 것처럼 시간순으로 확인할 수 있다.
	- 가장 강력한 기능은 `시간 여행 디버깅Time Travel Debugging` 기능이다.
		- 액션을 일으켜 상태를 여러 번 변경시킨 뒤, 초기 상태로 돌아가고 싶다면 `Revert` 버튼을 누른다.
		- 특정 시점 상태에서 `Commit` 버튼을 누르면 이 시점의 상태가 `@init` 상태가 되도록 해서 다시 액션 작업을 수행하다가, `Revert` 버튼을 누르면 직전에 커밋한 시점으로 돌아올 수 있다.
		- `익스포트, 임포트`(다운로드 버튼, 업로드 버튼)
			- 익스포트 버튼은 앱의 현재 상태를 로컬 컴퓨터에 JSON 파일로 저장한다.
			- 이 파일을 필요 시 임포트하면 외부 파일에 백업한 상태로 돌릴 수 있다.

2. `로그 모니터Log Monitor`
	- 로깅에 충실한 기능을 제공한다.
	- 이를 이용하면 `loggerMW`는 더 이상 필요하지 않다. 
	- 스토어로 액션이 전달되면 액션과 액션으로 인해 변경된 상태를 로깅한다.
	- 중요한 것으로는 `핀 고정 기능`과 `상태 잠금 기능`이 있다.
	- `핀 고정`
		- 활성화된 동안 상태가 계속 저장된다. 웹 브라우저를 새로고침하더라도 앱 상태가 유지된다.
	- `상태 잠금`
		- 상태를 변경할 수 없도록 설정한다. 어떤 액션이 발생해도 상태가 바뀌지 않는다.

3. `차트Chart`
	- 앱 상태를 시각화하여 보여준다.
	- 애니메이션 효과가 있어서 `Play` 버튼을 클릭하면 시시각각 바뀌는 상태를 한눈에 볼 수 있다.

## 마무리 글
- 리덕스는 플럭스 아키텍처를 발전시켜 개선한 자바스크립트 어플을 위한 상태 관리 컨테이너이다. `단방향 데이터 흐름`이 특징이다.
- 가장 중요한 부분은 `스토어`와 `리듀서`이다. 특히 **리듀서와 상태트리 설계가 중요**하다.
	- 상태 트리가 복잡해지면 1개의 리듀서가 모두 처리하지 못하므로, 다중 리듀서 구조로 개발해야 한다. 특히 다중 리듀서일때 상태 트리 설계가 중요해진다.
- `비동기 처리`는 `리덕스 미들웨어`를 이용한다. 미들웨어는 `스토어에 탑재`되는 함수로, 미들웨어를 통해 단일 스토어를 거쳐 가는 모든 액션을 모니터링할 수 있고, `부작용Side Effect`을 실행하도록 활용할 수 있다.
- 비동기 처리를 위해서는 `redux-thunk`와 `redux-saga`를 주로 사용한다. 어느 것이든 본인에게 익숙한 것을 사용하자. 초보자는 `redux-thunk`를 권장하며, `redux-saga`는 익숙해진 후에 쓰는 걸 추천한다.
- 리덕스는 `리덕스 개발 도구`를 지원해 개발, 디버깅 중에 활용할 수 있다. 상태와 액션을 시각화하고, 시간의 흐름에 따라 추적하기 용이한 도구이다.
