- `C#`의 자료형은 닷넷에서 제공되는 타입을 명칭만 바꿔서 예약어로 추가한다

### 소수형
- 소수점 연산은 `double`이 좋음
- `float`는 빠른 처리속도가 필요할 때, 적은 숫자를 쓰고 싶을 때 사용함
- `float`와 `decimal`은 이런 식으로 쓰임
```c#
float f = 5.2f;
decimal money = 200.099m; // 소수점 포함할 때만 사용함

Console.WriteLine(f) // 5.2
Console.WriteLine(money) // 200.099

```

### 문자형
 `char` : 유니코드 16비트 문자
 - 사칙 연산 시 오류가 발생함
 - 이스케이프 시퀀스를 지원함
```c#
char ch1 = '\t';
char ch2 = 'T';
char ch3 = '\n';
char ch4 = 'o';


// 4개에 각각 Console.Write()을 하면 아래와 같이 출력됨
	T
o
```
- 키보드로 입력할 수 없는 경우도 `\u2023` 같은 지정이 가능함

 `string` : 유니코드 문자열
- 문자가 둘 이상인 경우
- **큰따옴표**를 사용함
- 이스케이프의 경우, `\\` 같은 식으로 쓰지 않고 앞에 `@`을 넣어줄 수 있다
```c#
string text = @"\tHello\nWorld"
Console.WriteLine(text);
```
- `String`은 **`+` 연산을 지원**하며, 이를 통해 문자열을 연결할 수 있다.(`char`은 사칙연산 불가능)

### c#은 정적 타입이라 반드시 자료형을 명시한다
- 이는 **기억 장소를 효율적으로 사용하기 위한 차이** 때문이다. 정적이 쓸 때는 복잡하지만 더 빠름.
- 고용량 / 고속화가 되면서 저장 공간을 더 먹는 이슈의 단점이 죽었는데, `C#`도 동적 타입 언어의 편리한 구문을 수용했으며 이는 `C# 3.0`에서 다룬다.

## 형 변환(Casting)

### 암시적 변환(Implicit Conversion)
- 크기가 **작은 데이터 타입 -> 큰 데이터 타입**으로 바꾸는 건 컴파일러가 암시적 변환으로 간주해서 오류 없이 완료 가능함
```c#
byte b = 250;
short s = b;

Console.WriteLine(s); // 250
```

### 명시적 변환(Explicit Conversion)
```c#
ushort u = 65;
char c = u;
```
- `ushort`는 숫자만, `char`은 문자만 담을 수 있기 때문에 컴파일러가 중단해버림
- 그러나 알파벳 A = 65임을 알고 있고, 이를 의도한 것이라면 컴파일러에게 아래와 같이 알려준다.
```C#
ushort u = 65;
char c= (char)u; // 여기서 ()을 형변환 연산자라고 한다 
Console.WriteLine(c); // A
```
- 당연히 크기가 큰 -> 작은 변환도 명시적 변환이 필요하다

## 기본 문법 요소

### 예약어, 키워드
- 자료형 선언 등이 예약어에 해당함
- 이외에도 이것저것 있음. ㄱㄷ

### 식별자
- 마음대로 바꿀 수 있는, 개발자가 프로그래밍을 하면서 임의로 선택해서 지을 수 있는 단어
> 식별자 규칙  
> 1. 숫자로 시작할 수 없다. 반드시 문자로 시작해야 함.  
> 2. 특수문자 중에서는 _만 시작 문자로 쓸 수 있다.
> 3. 한글도 가능함(유니코드라서)
> 4. 예약어를 식별자로 사용할 수 없다. 필요한 경우 @를 식별자의 접두사로 붙인다.  
> 5. 이스케이프 시퀀스`\`로도 식별자를 쓸 수 있다.  

### 리터럴
- 소스코드에 포함된 값으로, 식별자에 지정된 값을 의미함

### 변수
- 식별자의 하나로, 변수가 선언되었을 때 지정된 형식에 부합하는 저장소에 메모리가 할당되어 값을 담을 수 있음.
```c#
int n = 5; // 식별자 n이 가리키는 리터럴은 5였는데
n = 10; // 여기서 식별자 n이 가리키는 리터럴은 10으로 바뀐다.
```
- 이 경우 식별자 = 변수라고 써도 무방함
- 크게 **값을 가리키는 변수와, 참조 형식을 가리키는 변수**가 있다.

#### 스택과 힙
- 윈도우 프로그램은 1개의 스레드를 갖는다. 개별 스레드는 전용으로 사용할 수 있는 저장소가 메모리에 할당되는데, 이를 스택이라고 한다. 한편, 힙은 프로그램이 필요에 의해 메모리를 사용하겠다고 요청했을 때 사용할 수 있는 저장소이다.
	- 닷넷은 CLR이 직접 프로그램에서 사용될 힙을 관리한다.
- 메모리 사용 후, 더 사용하지 않겠다는 표현이 필요하다. 메모리는 유한 자원이기 때문이다.
- **스택은 변수 선언 만으로 C# 컴파일러에 의해 자동 할당 및 해제**된다.
- **힙은 개발자가 명시적으로 요청한 것으로, 해제 과정이 별도로 필요**하다.
	- `네이티브 환경` : 메모리 할당 - 해제를 반드시 쌍으로 맞춰야 함(`C, C++`)
	- 가비지 수집기 : 개발자는 할당만 하며, 해제는 관리 환경 내의 구성 요소(가비지 수집기)가 담당한다. `C#`

#### 값 변수
- 값 자체가 스택에 할당되고, 변수는 그 메모리를 가리킨다.
- 위 예제에서 `5`는 스택에 저장됨.

#### 참조 변수
- `String`, 배열, 클래스, Object 모두 참조 형식이다.

- **값 변수와의 유일한 차이점은, 값을 스택에 저장하느냐 힙에 저장하느냐에 있다.**
	- 즉 값 변수는 그냥 스택에 저장된다.
	- 참조 변수는 
		1. 값을 힙 영역의 메모리에 할당하여 담음
		2. 스택의 변수는 힙 영역에 있는 값을 가리키는 메모리 주소를 담음
- 이러한 차이점도 있음
```c#
int n1 = 5;
int n2 = n1;

string txt1 = 'c#';
string txt2 = txt1;
```
- `n1, n2`는 각각 스택의 메모리 공간에 `5`를 할당함
- `txt1, txt2`는 변수 자체로서는 스택에 별도의 공간으로 지정되지만, 값은 힙에 있는 `c#`이 있는 동일한 주소를 가리킴

##### null 사용
- 값을 할당하지 않은 참조 변수는 `null` 값을 담는다. 이는 참조형 변수를 `null`로 지정한 것과 동일함.
- 혹은, 참조형 변수를 더 이상 쓰지 않을 때 `null`을 할당하기도 한다. 

#### 기본값
- `bool` : `false`
- `int` : 0
- `string` : null

### 상수
- `const` 예약어로 정의, 바꿀 수 없음
- 컴파일할 때 반드시 값이 결정되어야 함 (**컴파일 -> 실행**은 별개의 과정인 거 기억하죠?)
```C#
int n = Math.Max(0, 5)
const int MaxN = Math.Max(0, 5)
```
- `Math.Max`는 실행할 때 값이 결정된다. 즉, 컴파일 과정에서는 값이 결정되지 않은 상황이다.
- 따라서, 컴파일 과정에서 `MaxN`은 값이 결정되지 않기 때문에 오류가 발생한다.
	- 수식이 들어가더라도 정해진 값이 계산되는 수식이라면 사용할 수 있다.

### 연산자, 문장 부호

#### 연산자(Operator)
- `=` : 대입 연산자(Assignment Operator) 
- `;` : 구문의 끝을 컴파일러에 알림
	- `string text = "hello"; text = text + "world";` - 출력시 `hello world`
- `string`에서 `+`을 쓸 수 있다고 했는데, 다른 자료형이 올 수 있으며 그 다른 자료형은 `string`로 변환되어 처리된다.

## 배열
- 같은 데이터 유형의 여러 변수를 동시에 관리하고 싶을 때 사용함
```c#
int [] products = new int[5];
string [] names = new string[1000];
```

- 예약어 `new` : **참조 형식과 함께 사용될 때, 이에 필요한 메모리를 힙에 할당**함. 
- 변수 선언 시 `[]`을 사용하면 해당 변수는 배열임을 의미함
- 시작 인덱스가 `0`임에 유의

- 배열의 초기화
```c#
int [] products = new int[5] {1, 2, 3, 4, 5}
int [] products = new int[] {1, 2, 3, 4, 5}
```
- 둘의 차이는 요소 개수를 미리 지정했느냐 아니냐의 차이이며, **후자는 뒤에 오는 `{}`의 갯수에 따라 자동으로 맞춰짐.**

- `String`도 파이썬처럼 인덱스로 글자에 접근할 수 있음. 일단은 인덱싱만 나왔고 슬라이싱은 없다.

- **한번 정해진 배열의 크기는 바꿀 수 없다.**
- 배열 선언 시, 모든 값은 지정된 타입에 따른 초기화 값을 갖는다. `string - null` 같이.

#### 다차원 배열

- 2차원 이상은 아래와 같이 선언한다
```c#
int [,] arr2 = new int[10, 5]
short [,,] arr3 = new short[8, 3, 10]
```
- 전자는 `int = 4바이트` -> 200byte, 후자는 2 * 240 = 480 byte를 차지한다.

- 배열의 각 원소는 너가 알던 그 규칙과 동일함 : 가장 앞에 붙는 숫자가 새로운 차원인 방식
	- 즉 `[10, 5]`는 각 열에 5개가 있고 10개의 행이 있는 배열
	- `[8, 3, 10]`은 행 = 3, 열 = 10, 두께 8개인 배열임

#### 가변 배열(`Jagged Array`)
- 배열의 배열이라고도 한다.
```c#
int [][] arr = new int[5][];
arr[0] = new int[10];
arr[1] = new int[9];
arr[2] = new int[8];
arr[3] = new int[3];
arr[4] = new int[5];
```
- 즉 각 배열의 요소가 임의 크기의 배열이 될 수 있다.
- 필요한 만큼의 메모리를 쓸 수 있다는 장점이 있으나, **일반적으로 그냥 다차원 배열을 쓴다 :  유지보수가 편하기 때문.**

## 제어문

### 연산자
- 반드시 `bool` 형태로 연산의 결과가 나옴
- 관계 연산자: 크기 비교
- 논리 연산자 : `&&`(and), `||`(or), `!`(not) `^`(XOR)

- 논리연산자 사용시 주의점 : 파이썬의 `and` 같이, 앞에서 값이 나오면 뒤는 보지도 않는 연산자들이 있음 : `단락 계산, 단축 평가`

### if 문
```c#
if (조건식) 
	구문;
// or
if (조건식) 구문;
```
- 조건식이 참일 때 구문을 실행함
- 여러 구문이 온다면, `{}`로 묶고 그 안에 `구문;`들을 넣으면 됨

- `if / else if / else` 로 작동함

- 이를 간단히 줄여서 쓸 수 있는 `조건 연산자`가 있음
```c#
(조건식)?표현식1:표현식2;
```
- 조건식이 참이면 표현식1을 평가하여 반환, 거짓이라면 표현식2를 평가해서 반환함.

### Switch 문
- 조건 판단의 기준이 되는 식이 상수라면 `switch`를 쓰는게 편할 수 있다. 
- 모든 `switch`문은 다중 `if`가 가능하지만, 특정 다중 `if`만이 `switch`로 쓸 수 있다.

```c#
switch (인스턴스){
	case 상수식1:
		구문;
		break;

	case 상수식2:
		구문;
		break;

	case 상수식3:
		구문;
		break;

	default:
		구문;
		break;
}
```
- 실행 시 결정되는 인스턴스 값 = case의 상수식 결과값이 일치하면 해당 케이스의 구문을 실행한다. 없으면 `default` 구문을 실행한다.

- 조건이 많아질 경우 `switch`문을 쓰는 게 더 직관적이다.
- `default` 구문은 강제사항은 아니다. 생략해도 됨.
- **참고** : `case` 문의 `break` 포함은 강제사항이다. `구문`이 없는 경우에만 생략할 수 있음.

## 반복문

- 증감 연산자
```C#
int n = 50;
int result;

Console.WriteLine(n ++); // 50 출력후 1 증가
Console.WriteLine(++ n); // 1 증가 후 51 출력

result = ++ n; // 51
result = n ++; // (50에서 시작한다고 가정) 50, n은 51로 변경.
```

- 주의
```C#
int x = 100;
if (x > 10 || n ++ > 10)
```
- 오른쪽 `n++`은 증가하지 않음 : x가 이미 10을 넘기 때문에, 오른쪽 항목은 수행되지 않는다. (`단락 계산`)
- 따라서 논리연산자의 피연산자가 되는 경우, 증감 연산자를 쓰지 않는 게 좋으며 증감 연산자는 따로 쓰는게 좋음

- 복합 대입 연산자
`+=, -=, *=, /=, %=` : 대충 뭔지 아니까 ㄱ

### for 문
```C#
for (초기화; 조건식; 반복식){
	구문;
}
// or
for (초기화; 조건식; 반복식) 구문;
```
- **반복식의 경우, `구문`이 끝나고 난 다음에 수행**된다.
- 쓰고 싶지 않은 식은 생략 가능(셋 다 생략 가능함) -> 이 경우 `for (;;)`로 쓸 수 있음.

#### 중첩 루프
```C#
for () {
	for () {
		구문;
	}
}
```

### foreach 문
- 배열, `컬렉션` 등이 올 수 있음. 구문이 더 간결해서 `for`보다 더 자주 사용됨
```C#
int [] arr = new int[] {1, 2, 3, 4, 5};
foreach (int elem in arr)
{
	Console.WriteLine(elem);
}

```

### while 문
```C#
int sum = 0;
int n = 1;

while (n <= 1000)
{
	if (n % 2 == 0)
	{
		sum += n;
	}
}
```
- `do while`문도 가능하며, 이 경우 구문이 1번 실행된 후 조건식 평가가 들어감

## 점프문
- `break` : `switch`나 반복문 내에서만 사용 가능. 반복문 탈출
- `continue` : 밑의 구문을 실행하지 않고 바로 조건식 평가로 넘어감
- `goto`문 : 가독성 이슈로 일반적으로 사용되지 않으나, **중첩 반복문을 탈출할 때는 유용**
	- 먼 옛날 어셈블리어로 만들 때 쓰던 방식임
```C#
for (int x = 2; x < 10; x ++)
{
	for (int y = 1; y < 10; y ++ )
	{
		if (x == 5 && y == 8) goto LOOP_EXIT;
	}
}

LOOP_EXIT: ;
```