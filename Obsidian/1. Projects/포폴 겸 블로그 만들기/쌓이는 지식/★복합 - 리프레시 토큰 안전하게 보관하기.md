- 관리자만 사용할 수 있는 기능을 프론트엔드에 구현하는 중, 새로고침 시 관리자 상태가 초기화되는 문제 발생
- 그 과정에서 **로컬 스토리지에 리프레쉬 토큰을 저장하는 것이 보안 상 문제가 될 수 있다**는 언급이 있어서, 이를 어떻게 바꿔야 할지에 대한 과정을 적었다.

---

## HTTP Only Cookie
- `HTTP Only 쿠키`는 클라이언트, 서버 간의 통신에서만 사용된다. 클라이언트 측 JavaScript로는 쿠키에 접근할 수 없다. 
- 클라이언트는 쿠키를 서버로 자동으로 전송하므로, 서버는 리프레시 토큰으로 사용자를 인증하고 세션을 유지한다. 
- 또한, XSS 공격으로부터 보호될 수 있다 : 악의적인 스크립트가 있더라도 쿠키에 접근할 수 없다.

- 서버는 클라이언트에게 리프레시 토큰을 포함한 HTTP Only 쿠키를 설정한다. 이렇게 하면 브라우저는 쿠키를 자동으로 관리한다.

### 쿠키에 뭘 저장하지?
- (X) 아이디, 닉네임
	- 사용자의 개인정보이며, 쿠키는 클라이언트 측에서 쉽게 접근할 수 있기 때문에 정보가 탈취될 우려가 있다.
	- 아이디와 닉네임 같은 정보가 변경되면 쿠키의 정보와 서버의 정보가 일치하지 않게 되므로 `데이터 불일치` 문제가 발생할 수 있다.
- (O) 토큰
	- 사용자 인증에 쓰이는 임시적인 값이다.
	- **일정 시간이 지나면 만료**된다.
	- 사용자의 **개인정보를 직접 포함하지 않는다.**
	- 사용자 식별에 필요한 **정보를 암호화한 형태로 저장**하고 있다.
		- 이를 복호화하는데 필요한 키는 백엔드에서 저장하고 있다.
		- 예를 들어, JWT는 서명 부분을 생성할 때 `시크릿 키`를 사용한다. 이는 서버에서만 알고 있는 정보로, 토큰이 변조되지 않았음을 검증하는 중요한 역할을 한다.
		- 따라서 서버에서는 이 `키`의 보안과 관리가 중요하며, 많은 시스템들은 키를 주기적으로 회전하거나, 복잡한 키 관리 시스템을 사용하기도 한다.



## 여러 가지
1. 기존엔 로컬 스토리지에 `리프레쉬 토큰`과 `액세스 토큰`, `닉네임`을 저장했다. 
	- 스크립트를 이용해 2개의 토큰의 유효 시간을 확인하고, 만료 여부에 따라 토큰을 재발급 받는 방식으로 구현했다. 
	- 그렇다면 **클라이언트의 스크립트에서 접근할 수 없는, 쿠키에 있는 리프레쉬 토큰을 이용하여 어떻게 로그인 상태를 유지할 수 있을까?**
2. 토큰에는 사용자의 권한과 같은 중요한 정보를 포함시키지 않는 게 좋다. **사용자의 식별 정보만을 포함하는 것을 추천.** 권한 확인은 식별 정보를 통해 백엔드에서 확인하면 된다.

## 구현
- HTTP Only Cookie를 이용하는 과정에서, 액세스 토큰이나 리프레쉬 토큰을 확인하고 갱신하는 과정 - 즉 **로그인을 유지하는 과정 자체를 싹 갈아 엎을 필요가 생겼다.** 
### 백엔드

- `views.py` - 느낌만 보자(`response.set_cookie`)
```python
            refresh = RefreshToken.for_user(user)
            refresh['is_admin'] = user.is_staff

            response = Response({'nickname' : user.nickname}, status = status.HTTP_200_OK)
            # 이런 느낌으로 추가해주면 됨
            response.set_cookie('refresh_token', 
                                refresh, 
                                httponly = True)
            return response
```

- `settings.py`
- 기존의 CORS 설정 이외에 아래 설정을 추가함.
```python
CORS_ALLOW_CREDENTIALS = True
```


### 프론트엔드
- 요청에 `{withCredentials: true}`를 추가하면 됨.

