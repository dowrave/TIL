- `PostDetail, QuillRead, HeaderLinkBox` 컴포넌트 관련.
## 구현하려는 것과 문제 상황

>1. Redux로 관리되는 상태와 액션이 있다. 하위 컴포넌트인 `QuillRead`에 상태와 액션을 전달하고, 하위 컴포넌트에서 액션을 실행시켜 상위 컴포넌트로 다시 돌려받는 식으로 구현되어 있음.
>2. 상태가 변화하면, 삼항연산식에 의해 기존엔 렌더링되지 않았던 다른 하위 컴포넌트인 `HeaderLinkBox`가 실행될 조건이 됨
>3. 해당 컴포넌트가 렌더링됨 

- 위 상황에서 발생하는 문제는 이렇다 :
	- `useCallback` 및 `React.memo`로 재렌더링을 막은 상태에서, 상태 변경에 성공함(`useEffect` 문으로 확인)
	- 상태 변경에 성공했지만, `HeaderLinkBox`가 실행되지 않는 것으로 보임

- 이외에 언급할 만한 점으로는, 실제 출력 순서는 `상태 false -> HeaderLinkBox 실행 -> 상태 true -> 로딩 완료 문구 출력`이다. 의도했던 출력 순서는 `상태 false -> 로딩 완료 문구 출력 -> 상태 true -> HeaderLinkBox 실행`이었음. 
## 해결
- **`Redux` 대신 `useState`를 쓰면 훨씬 편하다. 굳이 전역적으로 관리될 상태가 아니기도 하다.** 
	- 왜냐하면, `isQuillLoaded`라는 상태는 각 페이지에서만 쓰면 되는 것이지 다른 페이지로 가져갈 상태가 아니기 때문.
	- `Redux`로 구현은 할 수 있겠으나, 상태 변경이 즉각적으로 반영이 안되는 게 느껴졌다. 설명을 보면 상태 변경은 바로 이뤄진다는데, 다른 페이지로 넘어가면 `HeaderLinkBox`가 바로 실행되는 문제가 있음. 반면 `useState`를 이용하면 그런 문제는 없다.

- `Redux`로 관리되는 상태의 특성에 대해 알아야 한다.
	- `dispatch`를 통해 액션을 바로 보낼 때, 상태는 바로 업데이트된다.
	- **상태의 변경은 즉각적으로 리렌더링을 발생시키지 않는다.** (useState든 Redux든 동일)
		- `useState`의 상태 변경은 해당 컴포넌트를 리렌더링하도록 직접적으로 트리거한다.
		- `Redux`의 상태 변경은 Redux 스토어를 통해 이뤄지며, `useSelector` 훅을 통해 해당 상태를 구독하는 컴포넌트에만 영향을 미친다. 또, 컴포넌트의 리렌더링을 트리거하는 방식이 `useState`와 다를 수 있다. Redux는 내부 최적화를 수행해 불필요한 리렌더링을 방지하는데, 이게 예상치 못한 리렌더링 행동으로 이어질 수 있다.


- `Redux`로 관리되는 상태가 유리한 건
	- **전역적인 상태 관리** - 여러 컴포넌트 간 상태 공유 및 일관성 유지
	- 상태 변경 추적
	- 복잡한 상태 관리

- `useState`가 유리한 건
	- **간결함, 직관성**
	- 컴포넌트 내부 상태 관리
	- 즉각적인 상태 업데이트와 반응