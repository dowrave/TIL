

## 유니티 프로젝트 열기

- 여기선 2D 프로젝트를 사용함

- 2D 프로젝트의 특징
	- 이미지 파일을 `스프라이트 타입`으로 임포트한다
	- 기본 생성 카메라가 `직교Orthographic 모드`를 사용한다
	- 라이팅 설정 중 일부가 비활성화된다.
	- 씬 창이 2D 뷰로 보인다

- 프로젝트의 2D/3D 모드 설정과 사용할 컴포넌트의 종류는 관계 없다. 게임 장르에 따라, 2D 프로젝트에서 2D가 아닌 일반 컴포넌트를 사용해도 문제 없다.
- 2D 컴포넌트는 `Vector2`나 `Vector3(Z값 무시)`로 동작한다. 2D 오브젝트의 실제 위치값은 `Vector3`로 동작하는데, 원근감이 없어서 `z`축을 무시한다.

- 프로젝트는 미리 준비된 게 있음) 모든 에셋이 준비된 상태, 미완성 프로젝트를 완성해나간다.

- `유니티 허브 > Projects 탭 > Add > 11 > Uni-Run 폴더 열기`
- 프로젝트가 열린 뒤, `Ctrl + S`로 현재 활성화된 임시 씬을 `Main`이라는 이름으로 프로젝트에 저장한다.

## 시작 지점 만들기

- 캐릭터가 서 있을 기본 발판과, 낙사 판정 영역을 만든다.

### 시작 지점 발판 만들기
- `프로젝트 > Sprites/ > Platform_Long`을 Hierarchy 창으로 옮김, 이름 `Start_Platform` 변경
- 해당 게임 오브젝트의 위치를 (0, -1, 0)으로 변경
- `Box Collider 2D` 컴포넌트 추가 `Add Component > Physics 2D > Box Collider 2D`

### 데드존 만들기
- 낙사 판정 영역을 의미함
- 게임 화면의 하단 영역에 가로로 긴 트리거 콜라이더를 만들어 구성한다. 
	- 데드존 게임 오브젝트를 만들고, `Dead` 태그를 할당한다.
	- 해당 태그는 플레이어 캐릭터를 죽게 하는 게임 오브젝트에 할당할 태그이며, 저자가 미리 추가해뒀다. 

- `Create Empty`, 이름 `Deadzone`, 태그 `Dead`, 위치 `(0, -8, 0)`
- `Box Collider 2D` 추가, `Is Trigger` 체크, `Size (50, 2)`

## 캐릭터 스프라이트 편집
- 플레이어 캐릭터를 위한 2D 그래픽
- `Sprites/`에는 여러 스프라이트 에셋이 있다. `Toko_Die, Toko_Jump, Toko_Run`을 사용할 것이다
	- `Toko`는 일본 유니티의 마스코트 캐릭터이다. 
	- 각 스프라이트는 단일 이미지 파일에 캐릭터의 여러 모습을 합친 `스프라이트 시트Sprite Sheet`이다. 
		- 여러 이미지를 하나의 이미지 파일로 합친 것
		- 리소스 관리가 편하고 성능도 좋다.
- 유니티는 2D 프로젝트에서 이미지를 기본적으로 `싱글 스프라이트 모드`로 가져온다. 하나의 스프라이트 에셋이 하나의 스프라이트를 표현한다.
- 이를 `멀티플 스프라이트 모드`로 변경하면, 하나의 스프라이트 에셋을 여러 개의 개별 스프라이트로 잘라 사용할 수 있다. 
	- 저자가 `Toko_Die`와 `Toko_Jump` 스프라이트를 미리 개별 스프라이트로 잘라뒀다.

- 실습) `Toko_Run`을 `멀티플 스프라이트`로 바꾸고 잘라보기
	- `프로젝트 > Sprites > Toko_Run > Inspector > Sprite Mode > Multiple > Apply`
	- 이후 `Sprite Editor > 스프라이트 편집 > Slice`
	- `Type : Grid by Cell Size`
	- `Pixel Size : (64, 64)`
	- `Slice 클릭, Apply로 저장, 편집 창 닫기`

## 2D 캐릭터 게임 오브젝트 준비
- 플레이어 캐릭터의 기능은 아래와 같아야 한다
	- 물리 상호작용
	- 조작 감지 및 점프
	- 사망
	- 애니메이션 재생 및 제어
	- 효과음 재생

### 게임 오브젝트 준비
- `Toko_Run_0` 스프라이트를 사용한 `Player` 게임 오브젝트를 만들고, `Player` 태그를 할당한다.

- `프로젝트 > Toko_Run 펼치기(플레이 버튼 같은거 누르면 됨) > 0번만 하이어라키로 > 이름과 태그 Player로 변경 > (-6, 2, 0)으로 위치 변경 > Rigidbody 2D 컴포넌트 추가 > Collision Detection : Continuous로 변경 > Constraints 펼치기 > Freeze Rotation Z 체크 `
> 1. `rigidbody 2D 컴포넌트 충돌 감지 방식` : 이산 -> 연속 변경
> 	- 이산 : 충돌 감지를 일정 시간 간격으로 끊어서 실행한다
> 	- 연속 : 움직이기 이전 위치와 움직인 다음 위치 사이에서 예상되는 충돌까지 함께 감지한다. 연속은 이산보다 더 정확하지만 더 성능을 요구한다.
> 2. `Freeze Rotation Z` : 캐릭터가 회전하는 상황 예방

- `Collider 2D 컴포넌트 추가`
- `Circle Collider 2D` 컴포넌트 추가, `Offset (0, -0.57)`, `Radius 0.2`
> - 원 모양 콜라이더로, 하체의 일부만을 차지하게 한다.
> - 써클 콜라이더인 이유 : 게임 오브젝트가 점프 후 각진 모서리에 안착했을 때, 부드럽게 모서리를 타고 올라가도록 만들기 위함

### 오디오 소스
- 게임 오브젝트에 소리를 낼 수 있는 능력을 부여한다. 

- `Add Component > Audio > Audio Source > AudioClip 필드 오른쪽의 버튼 클릭 > Jump 오디오 클립 클릭 > Play On Awake 해제`

> - 오디오 소스 컴포넌트는 소리를 재생하는 부품이며, 소리를 담은 파일이 아니다. `AudioClip` 필드가 카세트테이프인 거고, 오디오 소스 컴포넌트는 카세트테이프 플레이어에 해당함.
> - `Play On Awake` : 오디오 소스 컴포넌트 활성화 시, 최초 1회 오디오를 자동 재생하는 옵션이다. 만약 활성화되어 있다면, 게임 시작과 동시에 소리가 1번 나오므로 해제한다. 

> -- 오디오 소스 컴포넌트가 소리를 재생하더라도, **소리를 듣는 `오디오 리스너 컴포넌트`가 없으면 씬에서 재생되는 소리가 플레이어에게 들리지 않는다.** 이 컴포넌트에서 듣는 소리가 게임에 최종 출력되는 소리이다. 
> -- 3D 사운드 설정을 사용할 수 있다. 오디오 리스너 컴포넌트를 가진 물체와 소리를 발생시키는 물체 사이의 거리에 따른 소리 크기 조절이 된다. 
> -- **오디오 소스 컴포넌트는 소리를 내는 오브젝트 수만큼 씬에 존재한다. 반면, 오디오 리스너는 씬에 하나만 존재**해야 한다.
> --- 만약 오디오 리스너가 2개 이상이라면 경고 로그가 출력되며, 둘 중 하나만 정상적으로 동작한다.

기본적으로 씬을 생성할 때 자동으로 추가되는 `Main Camera` 게임 오브젝트에 오디오 리스너 컴포넌트가 추가되어 있기 때문에, 씬을 생성할 때 리스너 컴포넌트를 만들 직접 필요는 없다.


## 캐릭터 애니메이션 준비하기
- `Animations` 폴더를 만든다. 
- `유니티 상단 툴바 > Window > Animation > Animation` 으로 창을 띄운다
- `Toko_Run`의 스프라이트를 연속으로 배치, 캐릭터가 뛰는 `Run` 애니메이션 클립을 만든다.
- `애니메이션 > Create(안보이면 너비 확장) > 이름 Run으로 Animation 폴더에 저장`

- 클립 구성하기
- `Sprites/ > Toko_Run 스프라이트 펼치기 > Shift + 클릭으로 0 ~ 7까지 선택 > 애니메이션 창의 타임라인으로 드래그 & 드롭`
	- 스프라이트들이 타임라인에 키프레임으로 배치되면 ㅇㅋ 
	- 이런 식으로 2D 애니메이션 클립을 만들 수 있다 : **연속된 스프라이트를 타임라인 위에 키프레임으로 배치하기.**
- 현재는 재생하면 너무 빠른데, 초당 샘플 프레임이 60으로 설정되어 있어 1초에 스프라이트를 60번 교체한다. 이를 `16`으로 바꿔준다
	- 여기서 책에는 `Samples` 값을 입력할 수 있는 란이 있는데, 지금 내 버전에서는 타임라인 우측 상단에 `...` 에서 `Show Samples`를 눌러서 활성화시키면 됨

- 마찬가지로 `Jump, Die`도 비슷한 방법으로 만들면 된다.
	- `Animation > Run 부분의 Create New Clip > Jump라는 이름으로 저장` 
	- `Sprites/ > Toko_Jump 스프라이트 펼치기 > Shift + 클릭으로 Toko_Jump_0 부터 4까지 선택 > 타임라인으로 옮기기 > Samples 6으로 변경하기`
	- Die도 마찬가지로 하면 됨, 단 Die는 마지막에 `Project > Die 클립 선택 > Loop Time` 해제까지 해주자)
> `Animation Clip의 Loop Time` : 애니메이션을 반복 재생함. 디폴트는 활성화.


### 유한 상태 머신
- 애니메이션 클립을 만들었지만, 언제 어떻게 재생하기 위한 `애니메이터 컨트롤러`가 필요하다.
- `애니메이터 컨트롤러`란, 상황에 따라 어떤 클립을 재생해야 할지 저장한 지도로, `유한 상태 머신Finite State Machine`을 사용한다. 
	- 유한한 수의 상태가 존재하며, 한 번에 한 상태만 `현재 상태`가 되도록 프로그램을 설계하는 모델이다. 
	- 다른 상태로 `전이Transition`하여 현재 상태를 전환할 수 있다.

- 기초적인 게임의 적 AI가 유한 상태 머신의 한 예시이다 
	- 탐색 : 목표를 찾아다닌다
	- 추적 : 목표를 쫓는다
	- 공격 : 목표를 공격한다
	- `상태도` : 유한 상태 머신을 표현한 그림
	- 2개 이상의 상태가 현재 상태가 될 수 없고, 다른 상태로의 전이는 어떤 조건에 따라 발동할 수 있다.

### 애니메이터 컨트롤러와 애니메이터
- `애니메이터 컨트롤러` : 유한 상태 머신을 사용, 재생할 애니메이션을 결정하는 상태도를 표현한 에셋. 
	- `Project > Create > Animate Controller`로 생성 가능
	- `Project`에서 생성하는 것에서 보이듯 **애니메이터 컨트롤러는 `에셋`이다.**
- `애니메이터` : 애니메이터 컨트롤러를 참고해 게임 오브젝트에 애니메이션을 적용하는 컴포넌트
	- **`애니메이터`는 `컴포넌트`이다.**

- 애니메이션을 게임에서 재생하려면 **둘 다 필요함**(전자는 지도, 후자는 부품)
	- `Run` 애니메이션 클립을 만들 때 `Player` 애니메이터 컨트롤러가 자동 생성되었고, `Player` 게임 오브젝트에 `Player` 애니메이터 컨트롤러 에셋을 사용한 애니메이터 컴포넌트가 자동 추가 되어서, 이 프로젝트에서는 직접 애니메이터 컨트롤러를 만들 필요는 없다.
	- `Project` 창의 `Animations` 폴더에서 `Player` 애니메이터 컨트롤러, `Player` 게임 오브젝트에서 애니메이터 컴포넌트를 찾을 수 있다.

- 애니메이터 열기 : `상단 툴바 > Window > Animation > Animator`
![[Pasted image 20240617231117.png]]
> `Entry` : 현재 상태가 진입하는 입구
> `Exit` : 상태 머신의 동작이 종료되는 출구
> `Any State` : 현재 상태가 무엇이든 상관없이 특정 상태로 즉시 전이하게 허용하는 상태

- `Entry` 상태와 전이로 연결된 상태는 `기본 상태Default State`가 된다. 
- `기본 상태`는 주황색으로 하이라이트 된다.
- 어떤 상태를 기본으로 만들고 싶다면 마우스 우클릭 > `Set as Layer Default State`를 클릭한다. 
- `Any State` : **피격, 사망 애니메이션 등 현재 상태와 관계 없이 즉시 재생해야 하는 애니메이션**에 자주 사용된다.

### 전이 구성하기
> 1. Run 우클릭 > Make Transition > 화살표를 Jump에 연결
> 2. Jump 우클릭 > Make Transition > 화살표를 Run에 연결
> 3. Any State 우클릭 > Make Transition > 화살표를 Die에 연결

> 만약 잘못 연결했다면 전이화살표 클릭 후 Delete 키 클릭

- 파라미터 추가
> 1. 애니메이터 창 > Parameter 클릭
> 2. + 클릭 > Bool 클릭 > Grounded 로 이름 변경
> 3. + 클릭 > Trigger 클릭 > Die 로 이름 변경

- 파라미터의 타입 : `float, int, bool, trigger`
- 왜 `Die`는 트리거일까? 
	- 트리거 타입은 특정 값을 할당할 수 없다. 
	- 트리거 타입은 트리거를 `셋Set` 또는 `발동Invoke`하여 방아쇠를 당기는 방식으로 사용하는데, `셋`하는 순간 `true`가 되고 곧바로 `false`가 된다.
	- **어떤 사건이 발생했을 때 전이가 일어나도록 조건을 구성할 때는 트리거 파라미터**를 쓰자.

- Run -> Jump 전이 설정
> 1. 애니메이터 창 > Run->Jump전이화살표 클릭 > Inspector에서 Has Exit Time 체크 해제
> 2. Settings 펼치기> Transition Duration을 0으로 변경
> 3. 조건에 Grounded 추가 (Condtions의 + 버튼 클릭)
> 4. Grounded의 조건 값을 false로 변경

- `Has Exit Time` : 종료 시점을 활성화하는 옵션.
	- 전이 상태에서 현 상태를 탈출해 다음 상태로 넘어가는 시점이다.
	- **활성화 시** 종료 시점이 존재하게 되어 전이 조건을 만족해도 바로 다음 상태로 전이하지 않는다. 즉, **지연된다.**
- `Transition Duration`
	- 전이가 이뤄지는 시간 동안, 현재 클립과 다음 클립을 부드럽게(블렌딩) 이어주는 역할을 한다. 
	- 하지만 2D 스프라이트를 사용한 경우, 전환 지속 시간 동안의 블렌딩이 정상적으로 동작하지 않고 전이 시점만 지연된다. 스프라이트는 3D와 달리 관절이 존재하지 않기 때문이다.

- 나머지 설정
	- Jump -> Run 전이 설정
		1. 설정 동일, 마지막에 `Grounded = true`만 다르다.
	- Any State -> Die 전이 설정
		1. Transtion Duration = 0
		2. Conditions에 `Die` 추가

## PlayerController 스크립트
- 부터 내일 합시다