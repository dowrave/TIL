
# 1. 구조화된 프로그래밍
- C에서 함수라는 것은 일반적으로 `구조화된Structured 프로그래밍 언어`에서 `프로시저Procedure` 및 `함수Function`이라는 2가지 개념을 모두 포함하는 것이다.

- **리턴값이 있으면 함수, 없으면 프로시저**라는 개념에 **일반적으로 함수라는 이름으로 묶어서 사용**하며
- 여기서 중요하게 말하는 건 **하나의 함수를 정의해서 이곳저곳에서 함수의 이름만 호출해서 사용할 수 있다는 개념**임. 이게 없으면 함수 코드들을 일일이 필요한 곳에 갖다 붙여야 하는 거니까.
- 그리고 복잡한 기능을 구현하면 내부 구조를 잊어도 함수의 논리적 기능만 알고 있으면 더 복잡한 프로그램도 만들 수 있다.

...위의 내용이 기본적으로 알고 있는 것들이고, 여기서는 **함수가 C에서 구체적으로 어떻게 구현되는가**를 다룬다.

- 함수를 `호출`한다는 말은, 함수를 부르는 지점에서는 함수의 코드가 삽입되는 게 아니라 함수의 코드가 있는 곳으로 `점프`한다는 의미이다. 베이직의 서브루틴과 같은 개념이다.

> `서브루틴`
> - 따로 사용되지 않고 메인 루틴과 결합해서 기능을 수행하며 특정 기능을 반복 수행할 때 이용함
> - CPU 입장에서 보면, `jmp` 인스트럭션을 통해 제어권이 함수의 코드가 있는 메모리 주소로 넘기는 것인데, 이것만으로는 부족하다.

> 함수의 중요한 요소
> 1. 함수 루틴으로 점프해서 수행이 끝나면 다시 호출했던 지점으로 복귀해야 한다
> 2. 함수를 호출하고 리턴할 때 함수와 호출된 지점 사이에 데이터 교환이 있어야 한다. 즉, 함수를 호출했다면 인풋을 전달해야 하고 끝나고 나서는 리턴값을 받아야 한다.
> 3. 중첩 가능해야 한다. 함수 내에서 함수를 호출할 수 있어야 한다. 자기 자신도 포함할 수 있어야 한다.
> 이러한 기능을 구현하기 위해, **C는 함수에 대해 `스택Stack` 자료구조를 사용**한다.

# 2. 함수 호출의 기본 원리 - 스택 프레임
어셈블리로 서브루틴을 어떻게 구현할 것인가를 생각해보자. 메모리를 복사하는 루틴을 만들고 자주 활용해야 한다면, 복사할 시작 주소, 타겟 주소, 복사할 양을 서브루틴에 전달한다. 그리고 루틴이 끝난 후에 다시 호출된 지점으로 돌아와 하던 작업을 계속해야 한다.  위의 1번과 2번을 만족시켜야 한다.

이를 구현하기 위해 레지스터를 활용할 수 있다. CPU의 범용 레지스터 중 일부를 인자 전달이나 반환값을 받는 용도로 할애할 수 있다. 실제로 활용되는 방식이지만, 
- 레지스터만을 활용하는 방식은 레지스터 부족에 시달릴 수 있게 된다. 전해야 하는 인자가 100개가 넘는다면? 110개의 범용 레지스터를 CPU가 갖고 있다고 하더라도, 서브루틴 내에서는 나머지 10개의 레지스터만으로 작업해야 하므로 부족해진다. 
	- 또, 서브루틴 내에서도 레지스터를 사용하지 않으리란 보장이 없다.
- 그리고 서브루틴은 자기를 호출한 시점에서 어떤 레지스터가 사용 중인지를 알 방법이 없다. 서브루틴은 아무 곳에서나 부를 수 있고, 그걸 부른 시점에서 5개의 레지스터만을 사용한다는 보장도 없다.

여기서 `스택 프레임Stack Frame`이라는 게 등장한다. 비슷한 스택 세그먼트와 비교해보자.
- `스택 세그먼트Stack Segment` : 프로그램에서 쓰기 쉽도록 메모리를 몇 가지 용도로 나눈 것 중 하나이다. 코드 세그먼트, 데이터 세그먼트와 함께 용도에 따른 메모리 구분 방식 중 하나이다.
- `스택 프레임` : **함수가 호출될 때마다 그 함수 호출을 위해 할당받는 메모리 덩어리**이다. 스택 세그먼트 내에 잡히게 된다.

 함수가 호출될 때 필요한 메모리란? 

1번째 요건이 함수의 수행이 끝난 뒤 원래의 장소로 되돌아오는 것이었다. 함수의 코드 자체는 고정된 메모리 주소에 존재해서 컴파일러가 함수 호출이 발생할 때마다 주소를 계산해서 줄 수 있지만, 함수에서 호출 코드로 되돌아갈 때는 주소가 고정되어 있지 않다. 어느 쪽으로 이동하든 `jmp` 인스트럭션을 쓰지만, 주소를 알 수 없기 때문에 돌아올 때는 `jmp`를 쓸 수 없게 된다.

이를 해결하기 위해, **CPU에서 함수 호출을 지원하기 위한 특별한 레지스터를 마련하고, 이 레지스터에 리턴 주소를 보관하는 방식**이 있다. CPU는 `jmp`와 다른 별도의 인스트럭션을 제공한다. 함수가 호출되면 레지스터에 주소를 저장해서 돌아올 때 사용한다는 것.

위 방식은 CPU가 별도의 인스트럭션을 지원하지 않아도 불가능하지는 않다. PC 레지스터만 읽을 수 있으면 원하는 레지스터에 PC 레지스터 값을 저장하고, `jmp` 인스트럭션으로 함수 코드로 점프하고 레지스터를 읽어서 다시 `jmp`로 돌아오면 되기 때문이다.
- 하지만 **함수 호출은 프로그램에서 빈번히 일어나는 작업이기 때문에 대다수 CPU는 함수 호출(정확히는 서브루틴 호출)을 위한 별도의 인스트럭션을 제공**한다. 
	- 이는 개발자 입장에서도 (PC값 저장 + `jmp` 인스트럭션 사용)이라는 2가지 작업을 한 인스트럭션으로 끝낼 수 있게 하므로 성능 향상에도 도움이 된다.

위처럼 **특정 레지스터로 함수(서브루틴) 호출을 하면 어떤 문제가 발생할까? : 3번째 요건인 중첩 호출이 불가능**해진다. 함수 내에서 또다른 함수를 호출할 수 없다는 것인데, 왜냐하면 `call`로 다른 함수를 호출하면 복귀 주소를 다시 `rx` 레지스터에 저장하게 되는데, 이미 기존에 수행했던 함수가 복귀할 주소가 있기 때문에 `rx` 레지스터의 값을 다른 곳에 보관하고 호출해야 한다. 1번만 중첩되는게 아니라면 더 심각해지는데, 호출된 함수는 자신이 몇 번째 호출인지 알 수 없고 어떤 레지스터를 건드리면 안 되는지 알 수 없다. 메모리에 저장하는 방법도 절대 주소를 사용하면 레지스터와 다를 바가 없어진다.(주소 덮어쓰기)

이래서 고안된 방식이 `스택 프레임`이다.

이전에도 다뤘듯, 함수 호출의 중요한 특징 중 하나는 **`콜러는 콜리의 리턴 전까지 절대 리턴하지 않는다`가 있었다.** 

함수가 호출될 때, 복귀 주소를 어딘가에 기록해둬야 함수가 리턴할 수 있게 되는데, 이 **복귀 주소를 특정 레지스터나 메모리에 저장하는 대신 스택 공간 내에 쌓는다고 가정**하자. 그리고 복귀 주소를 쌓은 메모리 중, 가장 윗부분 주소를 특정 레지스터에 저장하도록 약속한다. 이 레지스터를 `스택 포인터(Stack Pointer, SP)`라고 부른다.

- 예제
```c
void func1() {
	void func2();
	return;
}

void func2() {
	return; // 
}

main() {
	func1(); 
}
```

- `main`이 `func1`을 호출한 다음 주소를 `0x400`, `func1`에서 `func2`를 호출한 주소가 `0x100`이라고 가정하고, 스택 세그먼트의 시작 주소를 `0x88C`, 스택 주소는 SP 레지스터에 저장된다고 가정한다.

1. `main`에서 `func1`이 호출되기 전까지의 스택 세그먼트의 구성
	- `main`도 일반 함수로 취급되기 때문에, 이 때의 주소값은 스택 세그먼트의 시작주소인 `0x88C`가 아니다. `0x888`이라고 놓으면, SP가 가지는 주소는 `0x888`이 된다.
	- 그리고 `0x888`에 들어가는 값은 `xxxx`로, `main` 함수가 종료되고 리턴할 주소가 된다.

2. `func1`이 호출된 다음의 구성
	- `0x400`이 `main` 함수의 복귀 주소 위에 저장된다. 
	- `SP`는 4바이트만큼 조정되어 `0x884`를 가리킨다.

3. `func2`가 호출되면
	- `0x100`이 `func1` 함수의 복귀 주소 위에 저장된다.
	- `SP`는 `0x880`을 가리킨다.

4. `func2`의 리턴 후
	- `0x100`이 저장된 스택의 주소는 SP에서 얻어올 수 있다. 

.. 를 반복함.

위 내용에서 **스택 프레임은, 함수의 복귀 주소**를 나타낸다. 지금까지의 내용에서는 함수를 호출할 때 꼭 필요한 데이터가 복귀 주소였고, 이는 4바이트 단위의 복귀 주소 하나하나가 각 함수 호출에 대한 스택 프레임이 되는 것이다.

그렇다면 스택 프레임은 복귀 주소 하나만으로 구성될까?

# 3. 스택 프레임을 통한 함수 간 값 전달
2번 요소였던 `콜러와 콜리의 데이터 교환`을 고려해보자. 

일반적으로 함수는 인자로 어떤 값을 전달, 이를 처리해서 결과로 다시 리턴해주는 경우가 대부분이다. 스택 프레임에서도 이를 수행할 수 있는데, 어떻게 달라질까?
```c
void func1(int a) {
	void func2(1, 2);
	return;
}

void func2(char x, char y) {
	return; // 
}

main() {
	func1(5); 
}
```

1. `main`의 호출, `func1` 실행 전까지는 위와 동일함.
2. `func1`이 실행된 다음이 살짝 달라진다.
	- 스택 프레임에 저장되는 값은 
		1. `복귀 주소`인 `0x400`
		2. 전달된 인자 `5`
	- 이며, 각각이 차지하는 크기인 `4byte`만큼이 들어가기 때문에 `SP`도 `0x880`을 가리킨다.
3. `func2`가 실행된 다음도
	- `복귀 주소` : `0x100`와
	- 2개의 `char(각각 1바이트)` 라서
	- `SP`는 `0x87A`을 가리킨다.

이렇게 데이터 타입에 따라 1바이트, 2바이트처럼 SP를 조절할 수 있으려면 CPU에서 이를 지원해줘야 한다. 스택 포인터 레지스터는 일반적으로 직접 값을 조정할 수 없고, `push, pop` 등의 인스트럭션으로 스택에 데이터를 저장하거나 빼오면서 자동으로 조절된다. 이러한 인스트럭션은 32비트 CPU 기준 32비트(4바이트) 단위로 스택에 데이터를 저장하므로, 별도로 1바이트나 2바이트를 지원하는 인스트럭션을 지원하지 않으면 데이터 형에 맞춰서 스택 사이즈가 조절되는 경우는 없다. CPU에서 이를 허용하더라도, 성능적인 면에서 딱 정해진 크기만큼만 할당하고 해제하는 것`정렬Alignment`이 훨씬 효율적인 경우가 많다. 

요점은 성능적인 이슈로 `char(1byte)`도 일부러 `4byte`로 만들어서 쓴다는 얘기임. 만약 그렇게 적용된다면 3번의 경우 `SP`는 `0x874`가 된다.

이제, 콜리에서 어떻게 스택에 저장된 인자를 액세스하는지를 다룬다. 크게 다를 건 없는데, 복귀 주소에 액세스하고 싶다면 현재 SP + 4로 가져오면 되고 인자를 가져오고 싶다면 4바이트로 설정했다는 기준 하에 SP + 8, SP + 12에서 가져오면 된다. 수행을 마치면 SP가 가리키는 `0x100`으로 점프하면 된다.

> 이전에 나온 내용이지만 살짝 헷갈려서 적어두면, 여기서 함수의 메모리 주소는 유독 달라보이잖음? 함수는 지금의 스택 세그먼트에 있는 게 아니라 코드 세그먼트에 있고, 어떤 **함수를 수행해야 할 상황이라면 코드 세그먼트에 있는 메모리에 접근한다**는 의미임. 
> 즉 함수는 코드 세그먼트에 있는 것들에 접근해서 동작시키는 것이고
> 스택 세그먼트에서는 해당 함수의 (코드 세그먼트에 있는) 메모리 주소와 해당 함수가 실행시킬 인수들을 저장
> SP는 스택으로 구현한 구조에서 각 요소에 접근하기 위한 기준점이라고 보면 됨

---
위의 예제는 `void`였는데, 리턴값이 있는 경우는 어떨까? 

대부분의 경우 레지스터를 이용한다. 리턴값은 일반적으로 하나로 고정되어 있어서 주로 특정 레지스터를 통해 전달한다. `PC`라면 `EAX`라는 레지스터로 값을 넘긴다.(실수라면 실수 연산용 별도 레지스터에 저장.) 호출받은 함수가 **리턴하기 직전에 `EAX` 레지스터에 리턴하고자 하는 값을 저장하고, 호출한 측은 함수 호출이 끝나면 `EAX` 레지스터에 리턴값이 있다고 간주하고 다음 처리**를 해나간다. 
`int sum(int a, int b)` 같은 함수가 있다면, `sum` 함수 내부에서는 `a + b`를 `eax` 레지스터에 저장하고, 호출한 측에서는 `eax` 함수의 호출 바로 다음부터 `eax` 레지스터의 값으로 작업을 이어나간다.

---
구체적으로, 스택 포인터 레지스터 값 조정 등은 호출한 쪽에서 할까? 받은 쪽에서 할까?

이건 제미나이한테 물어봤다.

1. 콜러의 역할
	1. 인자 전달 
		- 함수 호출 전에 인자들을 스택에 `push`한다. 
			- `push` 명령어는 데이터를 스택에 넣고, SP 값을 감소시킨다.
	2. 함수 호출
		- `call` 명령어를 실행한다. 
			1. 복귀 주소 저장 : 함수 실행 후 돌아올 메모리 주소를 스택에 `push`한다. SP를 감소시킨다.
			2. 점프 : 콜리의 시작 주소로 프로그램 카운터를 점프시킨다.
	3. 스택 정리
		- 호출된 함수가 반환된 다음, 호출할 때 스택에 쌓았던 인자들을 제거하기 위해 SP 값을 증가시킨다.

2. 콜리의 역할
	1. 스택 프레임 설정(Prologue)
		- (선택) 이전 스택 프레임의 기준점(base pointer)을 스택에 푸시해서 저장, SP가 감소한다.
		- 현재 SP값을 BP 레지스터에 복사, 현재 함수의 스택 프레임 기준점을 설정한다.
		- 지역변수 공간 확보 : 함수 내에서 사용할 지역 변수들을 위한 공간을 스택에 확보한다. SP값을 필요한 크기만큼 감소시켜 수행한다.
	2. 함수 본문 실행 : 함수 로직을 수행한다. 지역 변수나 인자는 BP 레지스터를 기준으로 접근한다.
	3. 스택 프레임 해제(Epilogue)
		- 지역변수 공간 해제 : 지역변수를 위해 사용했던 공간을 해제한다. BP를 SP에 다시 복사해서 SP를 원래 위치로 되돌린다.
		- (선택) 이전 프레임의 BP 값을 스택에서 `pop`해서 복원시킨다. sp가 증가한다.
	4. 반환
		- `ret` 명령어를 실행한다. 가장 위의 복귀 주소를 `pop`해서 프로그램 카운터에 넣는다.
		- 프로그램 흐름은 콜러의 `call` 명령어 다음 위치로 돌아간다.
	5. 스택 정리(Stack Cleanup - `stdcall 규약 등`)
		- 반환 직전에 호출자가 전달한 인자들을 스택에서 제거하기 위해 `ret` 명령어에 인자 크기를 지정해서 sp를 조정한다.

> 요약) 양쪽 모두에 의해 이뤄진다. 정확히는, **구체적인 책임 분담은 컴파일러가 따르는 호출 규약에 의해 이뤄진다.**

# 4. 지역 변수
- **스택 프레임은** 함수 호출에서 인자 전달, 리턴값을 위해서도 사용되지만, **함수 내부에서 사용되는 지역변수를 위해서도 사용된다.**
```c
int triple_sum(int a, int b) {
	int nTripleA = a * 3;
	int nTripleB = b * 3;
	return nTripleA + nTripleB;
}
```

지역변수 2개를 만들고, 이 변수에 넘겨받은 인자를 곱해서 넣는 방식이다. **이게 컴파일되는 방식은, 지역 변수가 선언된 크기만큼 스택을 늘려놓는 것이다.** : int는 4바이트이므로, `sub esp, 8`처럼 구현됨. 

일단, `ESP : 스택 포인터`와 `EBP : 베이스 포인터 / 프레임 포인터`의 차이를 보면
- `ESP` : **항상 스택의 최상단을 가리킨다.**
- `EBP` : **현재 실행 중인 함수의 스택 프레임의 기준점**이다. 
	- 스택 프레임은 함수 호출 시 해당 함수만을 위해 할당되는 스택 영역
	- 즉 현재 실행 중인 함수에 대해 항상 고정된 위치를 가져서 다른 값들에 접근할 수 있는 기준점 역할을 한다.

왜 이 개념을 설명했냐면, (가장 말단에서 실행된 함수를 가정했을 때) **지역 변수가 설정되었다면 ESP와 EBP가 달라지기 때문이다.** 

```
- ... (이전 스택 내용) ...

- **인자 (Arguments)** <--- EBP + 8, EBP + 12, ... (높은 주소)
- **복귀 주소 (Return Address)** <--- EBP + 4
- **저장된 이전 EBP (Saved EBP)** <--- EBP + 0 (현재 EBP가 가리키는 곳)
- **지역 변수 (Local Variables)** <--- EBP - 4, EBP - 8, ... (낮은 주소)

- ... (더 push되는 데이터) ... <--- 현재 ESP가 가리키는 곳 (가장 낮은 주소)
```

> 위에서 나온 설명 중 EBP가 설정되는 시점은 **인자와 복구 주소가 들어간 다음**(`Prologue`)이 되며, 지역 변수는 그 이후에 할당이 된다. 이 과정에서 함수 스택의 끝인 `ESP`의 위치가 자연스럽게 올라간다.

---

> `호출 규약Calling Convention`
> - 함수를 호출하기 위해 스택 프레임이라는 구조를 사용할 때, 인자를 위해 확보한 스택 공간을 콜러에서 해지하는가? 콜리에서 해지하는가? 에 대한 문제이다.
> - 스택 공간의 해지는 `add esp, 8` 처럼 스택 포인터 레지스터를 인자 크기만큼 강제로 조정하는 것으로 이뤄진다.
> - C에서는 모두 `_cdecl`로 함수가 선언된다. **콜러**에서 삽입됨. 
> 	- 호출할 때마다 전달인자 크기를 계산해서 넣어야 한다. 어셈블리라면.
> - 한편 `_stdcall` 형으로 선언된 함수에서는 해지 코드가 **콜리**에 리턴되기 전에 삽입된다. 
> 	- 코드 사이즈가 컴팩트해지고, 독립성을 높일 수 있다. 개념적으로도 함수에 관한 부분이다.
> - 그렇다면 왜 `_cdecl`이 남아 있는가?
> - `_stdcall`은 원래 파스칼에서 사용되던 규약이었다. 하지만 C에서는 `_stdcall`을 쓸 수 없는 요인이 있으니, **가변 인자**라는 것이다. `printf`가 가변 인자를 대표하는 함수다. `printf`는 인자의 제약 없이 무한히 많은 인자를 계속 넣을 수 있다. `int __cdecl printf(const char*, ...)`에서 `...`이 가변 인자다.
> 	- 물론 가변 인자 자체는 다른 함수와 별 차이점이 있는 게 아니다. 어차피 함수 호출 시에 기재된 갯수만큼 `push` 인스트럭션으로 스택에 저장하고 함수를 호출하면 된다. 
> 	- 하지만 문제는 함수 수행이 끝난 다음 인자를 스택에서 해지할 때 발생하는데, `__cdecl`이라면 인자 해지를 호출한 부분에서 하므로 `add esp, xx` 같은 해지 코드가 들어가면서 **각 호출 때 사용된 인자 갯수만큼 컴파일러가 알아서 `xx`를 결정**하면 된다.
> 	- `__stdcall`을 사용하는 경우, 인자 해지 코드가 함수에 들어가는데, **가변 인자가 들어간다면 몇 개의 인자가 실제로 들어갔는지 함수 내부에서 알 방법이 없다.** 
> - 이외에도 `__fastcall`이라는 게 있다. 2개까지의 인자는 메모리 액세스를 하지 않고 바로 레지스터로 전달시켜서 속도를 높이고자 만들어진 규약이다. 앞에서 2개까지는 `ecx, edx`로 사용해서 전달하므로 레지스터에 비해 빠르지만, CPU에 따라 여분의 레지스터가 없을 수도 있고 컴파일러가 레지스터를 어떻게 활용하느냐에 따라 구현이 불가능할 수도 있다.
> - 윈도우의 API 라이브러리는 모두 `__stdcall` 형태의 호출 규약을 사용해서 만들어져 있다. 따라서, C 컴파일러에서 선언된 윈도우즈 API 함수들의 헤더는 모두 `WINAPI`라는 키워드를 포함하고 있다. 이 키워드가 바로 `__stdcall`을 `#define`을 사용해서 재정의한 것일 뿐이다.

위 내용은 2007년 책 기준이었고(32비트), 요즘(2025년)에는 64비트 아키텍처가 표준이 되면서 변화가 있었다고 함.

1. `x64` 호출 규약의 표준화
	- `_stdcall, _cdecl, _fastcall`의 중요도 감소 : 운영체제별로 표준화된 호출 규약이 주로 사용됨
	- `Microsoft x64 호출 규약`
		- 처음 4개의 정수 / 포인터 인자는 레지스터`RCX, RDX, R8, R9`를 통해 전달되며, 부동소수점 인자는 `XMM0 ~ XMM3` 레지스터를 사용한다.
		- 추가 인자는 스택을 통해 전달된다.
		- **콜러가 스택을 정리한다.** 콜러는 레지스터로 전달되는 인자들을 위해 스택에 섀도 공간 / 홈 공간을 할당해야 한다(최소 32비트)
		- `WINAPI` 매크로는 64비트 환경에서는 이 규약을 따른다. `_stdcall` 키워드 자체가 큰 의미를 갖지 않는다.
	- `System V AMD64 ABI(유닉스 계열 : Linux, macOS, BSD 등)`
		- 처음 6개의 정수 / 포인터 인자는 레지스터`RDI, RSI, RDX, RCX, R8, R9`를 통해 전달된다. 부동소수점 인자는 `XMM0 ~ XMM7` 레지스터를 사용한다.
		- 추가 인자는 스택을 통해 전달된다.
		- **콜러가 스택을 정리한다.**
	- 레지스터 활용의 증대 : `_fastcall`의 개념처럼 현대의 표준 x64 호출 규약은 기본적으로 여러 개의 레지스터를 사용해서 인자를 전달하므로, 메모리 접근 없이 더 빠른 함수 호출이 가능해졌다.

2. 가변 인자 처리 : x64 호출 규약에서도 가변 인자를 지원한다. 호출자가 스택을 정리하는 방식이 x64 표준 규약에 채택되었기 때문에, `_stdcall`의 가변 인자 이슈는 발생하지 않음.

이건 개인적으로 궁금했던 것) 프로그래밍 언어에 영향을 받는가? - 가변 인자 얘기가 나왔을 때 파이썬이 생각나서 물어봤음
- **호출 규약은 기본적으로 기계어 수준에서의 약속**이라서, **컴파일러, 런타임 환경, OS, CPU 아키텍처에 더 큰 영향을 받는다.** 
- 파이썬을 쓰더라도 CPython을 쓰지 않으면 인터프리터 내부의 메커니즘을 따르기 때문에 C 수준의 호출 규약을 쓰지 않는다.
	- C로 작성된 확장 모듈을 호출하거나 외부 C 라이브러리를 호출할 때는 반드시 해당 라이브러리가 어떤 호출 규약으로 컴파일되었는지를 알아야 한다. 
- TS나 C# 등도 JavaScript 엔진의 내부 매커니즘 / .Net 런타임의 JIT 컴파일러가 생성하는 코드의 내부 호출 규약을 따름.

