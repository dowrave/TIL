지금까지 공부한 것 중, 임베디드만 하겠다면 충분하지만 대부분 OS를 빼놓을 수는 없다. 

1990년대만 해도 컴퓨터는 IT 분야에 눈뜬 젊은 사람들의 전유물이었지만, 2000년대로 들어오면 대부분의 사람이 컴퓨터를 쉽게 이용할 수 있었다. 왜냐하면 OS가 좋아졌기 때문으로, 이전엔 커맨드로 일일이 기능을 수행했다면 지금은 직관적으로 해당 기능들을 이용할수 있다.

흔히 하는 착각 중 하나로, 쉘이나 윈도우즈의 탐색기 같은 프로그램을 OS로 생각하는 경우도 있다. `쉘`은 바탕화면의 아이콘을 클릭해서 프로그램을 실행시키는 기능을 제공하는 일종의 프로그램인데, (당시 OS 기준) `explorer.exe` 라는 프로그램을 강제 종료시키면 바탕화면의 아이콘이나 시작 메뉴가 있는 작업줄이 사라진다.
> 이거 경험 있음 ㅋㅋㅋㅋ

즉, 윈도우즈에서 항상 접하던 화면도 OS가 아니라 프로그램이라는 것.

---

그러면 OS가 뭘까? `운영 체제Operating System`의 줄임말이지만, `운영`이라는 말은 뭘까?

사람이 법과 인프라 위에서 살아가고 있다. 이걸 OS에 그대로 비유할 수 있는데, **OS는 프로그램들이 서로 간에 충돌이 일어나지 않으면서 서로 협조하고, 자신의 역할을 효율적으로 수행할 수 있도록 하는** 법규와 인프라 같은 존재이다. 

예를 들어서 `printf("Hello World!")`라는 코드를 작성한다고 하면, 
- OS가 있는 PC : Visual C++을 실행시키고 새 프로젝트를 만든 뒤 코드를 추가하고 컴파일하고 실행하면 끝이다.
- OS가 없는 PC : 모니터 화면에 점을 찍기 위해 비디오 카드에 액세스 -> 비디오 모드를 원하는 모드로 전환 -> 원하는 위치에 점을 원하는 색으로 찍을 수 있도록 프로그램 작성(이것도 비디오 카드가 바뀌면 코드가 바뀌어야 함) 
	- 이외에도 폰트 데이터가 필요하다. 모니터는 점 단위로 표시하므로 각 글자를 표시하기 위해 점들이 어떤 위치에 찍혀야 하는지에 대한 정보가 있어야 하는데, 이게 폰트이다. OS가 없다면 폰트도 없기 때문에 코드상에 그에 해당하는 데이터를 갖고 있어야 한다.

코드를 작성했더라도, 프로그램 실행은 다른 얘기다. 
- OS가 있다면 컴파일러를 돌려 `exe` 파일을 만들고 실행하는 과정이 된다
- OS가 없다면 `파일`이라는 개념도 없기 때문에 이를 실행하기 위해 `Hello World` 코드는 PC 전원이 들어오면 CPU의 PC 레지스터에 해당하는 초기값에 해당하는 주소에 코드를 넣어야 한다. 이를 위해 전원이 꺼져도 지워지지 않는 ROM에 직접 프로그램을 구워서 CPU의 시작 주소에 프로그램이 위치할 수 있도록 주소를 계산해서 롬을 CPU와 연결해야 한다. 프로그램이 조금이라도 수정되면 매번 롬을 구워야 한다.

---

OS가 구체적으로 하는 일이 무엇일까? 를 알아보기 위해, **OS가 생겨난 배경**을 파악해보자.

초창기의 컴퓨터는 중앙 전산실에 한 대가 있고, 많은 사용자들이 공동으로 사용하는 형태였다. 원하는 프로그램을 천공 카드 등의 형태로 작성해서 관리자에게 가져다 주면, 관리자가 프로그램을 돌리고 결과를 프린트해서 다시 돌려주는 방식이었다. 당연히 라인 단위의 디버깅 같은 건 불가능했다.

이러한 여러 작업이 산재해 있다면, CPU의 실질 이용률이 떨어진다. 한 명이 코드를 돌리고 프린트를 출력하면 대부분이 출력 시간에 소비되어야 했고, 다음 사람은 CPU가 쉬고 있어도 이용할 수 없었다. 이를 위해 `프린트 스풀링Spooling` 같은 개념을 도입해서 **여러 작업을 동시에 메모리에 적재해 한 작업이 끝나면 다음 작업으로 넘어가도록 하는 게 초창기 OS의 목적**이었다. 이러한 작업을 `일괄처리 시스템`이라고 불렀다.

이것도 여전히 CPU가 유휴 상태로 있는 시간이 많았다. 예시로, 한 프로그램이 중간에 I/O 장치를 많이 사용할 경우 상대적으로 I/O 장치가 훨씬 느리기 때문에 CPU의 유휴 시간이 많아졌다. 이를 개선하기 위해, OS는 한 프로그램을 끝내고 다음 작업으로 넘기지 않고, 프로그램이 중간에 I/O 작업을 기다려야 하는 상황이 발생하면, 끝날 때까지는 다른 프로그램을 실행시켰다. 새롭게 실행되는 프로그램 역시 대기 상태가 되면 다음 프로그램, 혹은 이전에 멈췄던 프로그램을 다시 실행시키는 방식인데, 이를 `다중 프로그래밍Multi-Programming` 혹은 `멀티태스킹Multitasking`이라고 한다. 

이 과정에서 **`스케쥴링Scheduling`의 필요성이 대두되었다. 어떤 작업이 더 이상 진행될 수 없을 때, 어떤 프로그램을 실행해야 하느냐의 문제**이다. 

# 선점과 비선점

다중 프로그래밍 만으로는 윈도우즈 같은 단계에 이르지 못한다. 

도스의 예시를 들어보자. 도스는 전형적인 일괄 처리 시스템의 일종이었다. `램 상주Terminate and Stay Resident-TSR`라고 하는 형태로 동시에 다른 프로그램이 실행되는 것이 있지만, 진짜 의미의 멀티태스킹은 아니다. 이 방식은 램 상에 프로그램 코드를 남겨둔 채로 도스에게 프로그램이 종료된 것처럼 알려주고, 추후에 다른 프로그램을 실행하다가 어떤 이벤트(인터럽트 등)가 발생하면 다시 램 상주 프로그램이 있는 메모리로 제어권을 넘기는 방식이었다. 즉, **도스는 프로그램이 멈출 때마다 교대로 하나씩 실행하는 방식**이었고, 동시에 여러 처리를 하는 건 아니었다는 것이다.

윈도우즈 프로그램은 도스와는 달리 `이벤트 드리븐Event driven` 방식이라고 해서, 마우스나 키보드 등의 이벤트가 발생하면 그 이벤트에 대해서만 처리하고 다음 이벤트가 발생할 때까지 Sleep 모드로 들어가서 다른 프로그램에게 CPU를 양보하는 방식이다.
반면 도스 프로그램은 자신 혼자만이 돌아간다고 생각하므로 `main` 함수 내에서 루프를 돌면서 계속해서 함수를 생성하든가 하는 방식으로 항상 CPU를 점유하고 있다.

- `비선점형 멀티태스킹Preemptive Multitasking`이란, **한 프로그램이 CPU의 제어권을 선점하고 있다면 스스로 그 제어권을 양보하지 않는 이상 다른 프로그램이 이를 가져올 방법(=실행될 방법)이 없는 방식**이다.

자발적인 양보라는 방식이 추상적으로 들리는데, 예를 들면 `도스`에서는 `C`에서 제공하는 표준 라이브러리만으로 프로그램을 작성하지만 `윈도우즈` 같은 멀티태스킹 OS에서는 `WIN32 API`라고 부르는 `C`의 표준 라이브러리와는 다른 **OS 표준 라이브러리를 같이 사용**한다. 이를 유닉스 계열에서는 `시스템 콜System Call`이라고도 하는데, **OS가 제공하는 편의성을 이용**하려는 목적 및 이 **API(시스템 콜)을 통해서 작성되어야만 해당 OS 위에서 안전하게 돌아갈 수 있는 규제**이기도 하다.
> 그래서 인프라와 법규 얘기를 한 거네

이 API에는 여러 함수가 있는데, 편리함 + 다른 프로그램과 동시에 돌아갈 수 있도록 설계한 함수이다. 
- 윈도우즈 생성 : `CreateWindow`
- I/O 작업 : `Read, Write`
- 입력 이벤트 처리 : `GetMessage`

제어권의 양보는 위와 같은 API 함수를 부를 때 발생한다. `GetMessage`를 예로 들면, 메시지가 발생하지 않으면 대기 상태로 있는데 이 때 `GetMessage` 함수 내에서는 다른 대기 중인 프로그램을 실행하도록 스케쥴링이 일어난다. `I/O` 함수에서도 마찬가지로 데이터가 들어올 때까지 기다리면서 그 안에서 다른 프로그램을 실행하도록 스케줄링하고, 디바이스 드라이브가 작업을 마무리하면 이벤트 방식으로 본 프로그램에게 알리는 방식이다.

즉, **API 함수를 이용하는 것 자체가 제어권을 양보하는 것**이다.

이러한 `비선점형 방식의 멀티태스킹`에는 어떤 문제가 있을까?

MP3나 JPEG 이미지 뷰어 등의 긴 수학적 연산을 수행해야 하는 프로그램을 만든다고 가정해보자. `Decode`라는 함수가 있어서, 그 함수 내부에서 주어진 데이터를 디코딩한다고 가정하고, 아주 긴 연산을 해야 해서 극단적으로 1분 정도 소비된다고 하면, 모든 프로그램이 1분 동안 기다려야 한다는 얘기가 된다. 왜냐하면 선점형 멀티태스킹 방식에서는 **능동적으로 제어권을 가진 프로그램이 API 함수를 불러 제어권을 넘겨주지 않는 이상 CPU는 계속 그 프로그램만을 수행**하기 떄문이다. 

이를 해결하기 위한 방식이 `선점형Preemptive` 방식이다. **선점형 방식은 프로그램 하나가 CPU를 독점할 수 없는 방식**으로, `while True`문을 만들어도 CPU를 해당 프로그램이 독점할 수 없다. 이를 다른 말로 `시분할 시스템Time Sharing System`이라고 하는데, 말 그대로 **CPU의 제어권 이전**을 각 프로그램의 자발성에 맡기지 않고 **강제로 OS에서 조금씩 프로그램마다 시간을 할당해 어떤 한 프로그램이 CPU를 독점하는 것을 막는다.**

---
이제 OS의 역할에 대해 정의해본다. OS를 명확히 말로 정의하는 건 매우 어려운 일이다. 필자가 생각하는 OS의 정의는

1. 사용자에게 편의성을 제공하기 위한 `일종의 라이브러리`이다. `라이브러리`는 자주 사용되는 기능을 묶어 함수 형태로 미리 작성된 코드들이다. 
	- `OS`를 `라이브러리`처럼 생각할 수 있다는 말이 이해가 가지 않는 케이스도 있을 것이다. 라이브러리는 수동적으로 호출되어서 사용되는 함수의 집합이지만, `OS`는 하나의 능동적인 프로그램으로, 이 OS 위에 다른 응용 프로그램이 돌아간다고 여길 수도 있다.
	- ~~하지만 OS는 그 자체로서는 어떠한 능동적인 역할도 하지 않는다.~~ 도로를 잘 깔아놔도 차가 달리지 않으면 아무 일도 일어나지 않는 것처럼, OS는 도로나 신호등 같은 규칙을 만들고 이를 라이브러리 형태로 제공한다. 
	- **OS에서 실행되는 코드는 실제 프로그램 코드 외에도 OS 위에서 돌아가기 위한 다른 정보를 헤더에 포함해야 한다.** 또, 이 프로그램은 OS에서 제공하는 API 함수를 사용해서 운영체제 안에서 조화를 이루며 돌아가야 한다.
		- 예를 들면 도스 프로그램에서는 화면에 글자를 찍을 때 `printf` 를 썼지만, 윈도우즈에서는 `TextOut`이나 `DrawText` 같은 윈도우즈 제공 API 함수를 사용해야 한다.
		- 또, `CreateWindow`로 윈도우즈를 그려야지 **임의의 프로그램이 비디오카드에 직접 액세스해서 선과 사각형을 그리는 것도 안된다.** 보통은 CPU 차원에서 실행 레벨이라는 응용 프로그램이 독단적인 행동을 막기 위해 있지만, 이런 제어 장치가 없더라도 **조화적인 측면에서 OS가 제공하는 API 함수를 반드시 이용하는 게 좋다.**
	- OS가 능동적이라고 오해를 사는 다른 이유 중 하나는 OS에서 여러 프로그램이 돌아가는 게 OS가 각 프로그램들을 조금씩 실행시켜주면서 멀티태스킹을 구현하는 것이라고 생각하기 때문이다. 이 역시도 OS가 능동적으로 한다기보다는 각 응용 프로그램이 OS의 API 함수를 부를 때 스케쥴링이 발생하는 것에 가깝다.
	- 결국 OS는 여러 응용 프로그램이 동시에 실행되고 편리하게 작성될 수 있도록 기반 시설, 즉 API를 제공하는 라이브러리 같은 존재이다. ~~응용 프로그램에서 API를 부르지 않는다면, 그 자체로는 어떤 일도 할 수 없는 존재인 셈이다.~~

> 약간 미리보기 개념이 될 수도 있지만, 제미나이한테 위 서술을 먹여보고 맞는지 물어봤다. 오해의 소지가 있거나 틀린 부분에 대해 추가함. 시간이 흘러서 개념이 바뀌었을 수도 있고.
> 1. OS 자체는 그 자체로 능동적인 역할을 하지 않는다 -> **현대 OS의 핵심인 `커널Kernel`은 매우 능동적으로 시스템 자원을 관리하고 제어한다.**
> 	- **프로세스 / 스레드 스케쥴링** : **커널의 스케쥴러는 프로그램에게 CPU 시간을 할당할지를 능동적으로 결정**하고, 타이머 인터럽트 등을 이용해 실행중인 프로그램을 강제 중단`선점`시키고 다른 프로그램으로 전환`컨텍스트 스위칭`한다. **스케쥴링은 응용 프로그램이 API를 호출할 때에만 일어나는 것이 절대 아니다.**
> 	- **메모리 관리** : 커널은 각 프로세스에게 독립된 가상 메모리 공간을 할당하고 관리하며, 물리 메모리와의 매핑, 페이징 등을 능동적으로 처리한다.
> 	- **인터럽트 및 예외 처리** : 하드웨어 장치로부터의 인터럽트, 프로그램 오류 등이 발생하면 커널이 즉시 개입해서 해당 처리 루틴`인터럽트 핸들러`을 실행한다.
> 	- **시스템 콜 처리** : 응용 프로그램이 API를 호출하면(=시스템 콜을 발생시키면) 커널은 사용자 모드에서 커널 모드로 전환되어 능동적으로 해당 요청을 처리하고 결과를 반환한다.
> 2. 멀티태스킹은 각 응용 프로그램이 OS의 API 함수를 부를 때 스케쥴링이 발생하는 것에 가깝다 
> 	- **선점형 멀티태스킹에서는 응용 프로그램의 API 호출 여부에 관계 없이, OS 커널(스케쥴러)이 주기적 / 특정 이벤트 발생 시 강제로 실행 흐름을 관리하고 제어**한다.
> 3. OS는 응용 프로그램에서 API를 부르지 않는다면 그 자체로는 어떤 일도 할 수 없다
> 	- 응용 프로그램이 **전혀 없더라도**, OS 커널 자체는 부팅부터 시작해서 시스템을 유지하고 백그라운드 서비스를 관리하며 외부 이벤트에 반응하는 등 끊임없이 능동적으로 동작하고 있다.

2. 효율적인 시스템 운영을 위한 것이다.

예전에는 게임 하나를 돌려도 게임 자체에서 지원하는 사운드카드나 그래픽카드를 사용해야 했지만, 지금은 **OS가 이런 부분을 맡아 `디바이스 드라이버`라는 형태로 하드웨어와 응용 프로그램을 분리**시키게 되었다. 따라서 개발자는 하드웨어에 대해 신경쓰지 않고, OS가 제공하는 API 함수를 이용해서 개발하면 된다. 

즉, OS가 응용 프로그램과 하드웨어 간의 중개자 역할을 하게 되었고, 이는 컴퓨터 산업 자체의 폭발적인 증가로 이어지게 되었다. 윈도우즈의 성공은, 사용자에게 편리한 기능을 제공한 것보다는 개발자에게 개발에 편리한 환경을 제공한 것이 더 큰 원인이다. 역으로 세세한 부분이 많이 가려져 있어서 개발자들이 그 실체를 모르는 경우도 많은데, 그래서 리눅스나 유닉스 같은 시스템에서 개발하는 사람은 윈도우즈에서 개발하는 사람보다 더 시스템이나 OS 자체에 대한 해박한 지식을 가진 경우가 많다.

