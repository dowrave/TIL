
- `Million Instruction Per Seconds`
- 여기서 `명령어 = Instruction`으로 봐도 될 듯
## 1. 기본 특징

- 단순하고 규칙적인 명령어 집합(RISC)
	- 32비트 길이로 고정
	- 명령어의 종류가 적고 각 명령어의 기능이 명확하다. 
		- 복잡한 기능은 각 명령어를 조합해서 구현한다.
	- 명령어 내부의 필드 위치(OP 코드, 레지스터 번호 등)가 비교적 일정해서 명령어 해독 단계도 빠르다.
- 하드웨어 설계가 단순하기 떄문에, 클럭 속도를 올리거나 칩 면적을 줄이거나 남는 공간에 캐시 메모리나 더 많은 레지스터를 넣는 등 다른 성능 향상 요소들을 넣을 수 있고, 컴파일러의 코드 최적화도 용이하다.


## 2. 레지스터 중심 설계
- CPU 코어의 연산 속도는 메인 메모리(RAM) 접근 속도보다 훨씬 빠르기 때문에, CPU 코어 내부의 저장 공간인 레지스터에 저장하고 연산을 수행하는 편이 빠르다.
- **32개의 범용 레지스터**
	- `$zero` (`$0`): 항상 0 값을 가진다. 상수 0을 만들 때 유용.
	- `$sp` (`$29`): 스택 포인터 (Stack Pointer). 메모리의 스택 영역을 관리.
	- `$ra` (`$31`): 반환 주소 (Return Address). 함수 호출 시 돌아올 위치를 저장.
	- `$a0-$a3` (`$4-$7`): 함수 인자 전달용.
	- `$v0-$v1` (`$2-$3`): 함수 반환값 저장용.
	- `$s0-$s7` (`$16-$23`): 함수 호출 후에도 값이 보존되어야 하는 변수 저장용 (Callee-saved).
	- `$t0-$t9` (`$8-$15`, `$24-$25`): 임시 변수 저장용 (Caller-saved).
- **특정 레지스터에 정해진 용도가 있다는 약속**이 있기 때문에, 서로 다른 코드 조각들이 데이터를 주고 받거나 상태를 유지할 때 혼란 없이 동작한다.
	- **함수 호출 예시:** 함수 `func(a, b)`를 호출할 때,
	    1. 호출하는 쪽(Caller)은 인자 `a`와 `b`를 `$a0`, `$a1` 레지스터에 넣습니다.
	    2. `jal func_label` 명령어로 함수로 점프합니다. 이때 돌아올 주소는 자동으로 `$ra` 레지스터에 저장됩니다.
	    3. 함수 `func` 내부에서는 `$a0`, `$a1` 값을 사용해 연산을 수행하고, 결과값을 `$v0`에 넣습니다.
	    4. 함수 실행이 끝나면 `jr $ra` 명령어로 `$ra`에 저장된 주소로 돌아갑니다.
	    5. 호출한 쪽에서는 `$v0` 레지스터의 값을 확인하여 반환값을 얻습니다.
	- **임시 vs. 보존 레지스터 (`$t` vs. `$s`):** 함수를 호출할 때, 호출된 함수(Callee)가 `$t` 레지스터(임시)는 마음대로 덮어써도 되지만, `$s` 레지스터(보존)는 원래 값을 유지해야 합니다. (만약 `$s`를 써야 한다면, 원래 값을 스택에 저장했다가 함수 종료 전에 복원해야 함). 이는 함수 호출 전후에 중요한 값이 유실되지 않도록 보장하는 규칙입니다.

## 3. 명령어 형식(Instruction Format) 설명

- **R-타입 (Register):** _레지스터 간의 연산_에 주로 사용됩니다.
    - 구조: `| opcode (6) | rs (5) | rt (5) | rd (5) | shamt (5) | funct (6) |`
    - `opcode`: 0 (R-타입임을 나타냄)
    - `rs`, `rt`: 연산에 사용할 소스 레지스터 번호 (Source Registers)
    - `rd`: 연산 결과를 저장할 목적지 레지스터 번호 (Destination Register)
    - `shamt`: 시프트 연산 시 이동할 비트 수 (Shift Amount)
    - `funct`: 실제 연산 종류를 구체적으로 지정 (예: 덧셈, 뺄셈, AND, OR 등)
    - 예: `add $s0, $s1, $s2` -> `$s1`과 `$s2`를 더해서 `$s0`에 저장.

- **I-타입 (Immediate):** _상수값을 이용한 연산, 메모리 접근, 조건 분기_에 사용됩니다.
    - 구조: `| opcode (6) | rs (5) | rt (5) | immediate (16) |`
    - `opcode`: 연산 종류 (addi, lw, sw, beq 등. R-타입의 0과 다름)
    - `rs`: 첫 번째 소스 레지스터 또는 베이스 주소 레지스터
    - `rt`: 두 번째 소스 레지스터 또는 목적지 레지스터 (로드/스토어 시 데이터 레지스터)
    - `immediate`: 16비트 상수값 또는 주소 오프셋. 부호 확장을 통해 32비트 값처럼 사용될 수 있음.
    - 예: `addi $t0, $t1, -10` (`$t1 - 10` 결과를 `$t0`에), `lw $s0, 16($sp)` (`$sp + 16` 주소에서 읽어 `$s0`에), `beq $a0, $a1, loop` (`$a0 == $a1`이면 `loop`로 분기. `immediate`는 현재 주소로부터의 상대 거리)

- **J-타입 (Jump):** _긴 거리를 무조건 점프_할 때 사용됩니다.
    - 구조: `| opcode (6) | address (26) |`
    - `opcode`: 점프 종류 (j, jal)
    - `address`: 점프할 목표 주소의 일부. (실제 주소는 현재 PC의 상위 비트와 결합하여 계산됨)
    - 예: `j main_loop` (`main_loop` 레이블 주소로 점프), `jal my_function` (`my_function`으로 점프하며 복귀 주소를 `$ra`에 저장)

> 고정형식이므로 첫 6비트만 보고 어떤 형식이고 어떤 종류의 연산인지 바로 알 수 있다. 특정 위치에서 필요한 정보를 빠르게 읽어 처리할 수 있으므로 명령어 디코딩 과정이 매우 효율적이다.

## 로드/스토어 아키텍쳐 상세 설명

- 핵심 : 메모리 접근은 로드 / 스토어 명령어로만, 연산은 레지스터에서만
- 왜?
	- 하드웨어 단순화 : 연산 수행 회로`ALU`는 레지스터 접근만 신경쓰면 되고, 메모리 접근 회로는 로드/스토어 명령어만 처리하면 된다. 각자 역할이 명확하므로 설계도 간단해진다.
	- 파이프라이닝 효율 증대 : 메모리 접근 속도 < 레지스터 접근 속도이고, 소요 시간도 예측하기 어렵다(캐시 히트 / 미스 등). 만약 연산 명령어 자체가 메모리에 접근하면 파이프라인 단계의 시간이 들쭉날쭉해지므로 파이프라인이 지연되거나 복잡해진다. 
		- 로드 / 스토어 구조에서는 느린 메모리 접근을 특정 단계(MEM)에서만 처리하도록 격리, 파이프라인 흐름을 원활히 유지하는 데 도움이 된다.
- CISC와의 비교 : CISC(x86)에서는 `ADD EAX, [memory_address]` 처럼 레지스터 값과 메모리 값을 직접 더하는 명령어가 존재할 수 있다. 프로그래머에게는 편리하지만 CPU 내부적으로는 더 복잡한 처리 과정을 거친다.
- **실행 흐름:** 메모리에 있는 변수 `x`와 `y`를 더해 `z`에 저장하는 과정 (간략화):
    1. `lw $t0, address_of_x` (x 값을 메모리에서 `$t0` 레지스터로 로드)
    2. `lw $t1, address_of_y` (y 값을 메모리에서 `$t1` 레지스터로 로드)
    3. `add $t2, $t0, $t1` ($t0와 $t1을 더해 결과를 `$t2` 레지스터에 저장)
    4. `sw $t2, address_of_z` (`$t2`의 결과값을 메모리의 z 위치에 스토어)

## 파이프라이닝

- 목표 : 명령어 하나를 처리하는 시간`레이턴시`을 줄이는 게 아니라, 단위 시간 당 처리하는 명령어의 개수를 늘리는 것
- 아이디어 : **명령어 처리 과정을 여러 단계로 나눠, 각 단계가 동시에 다른 명령어를 처리하도록 한다.** 
	- 핵심은 하나의 명령어가 완전히 처리되기까지를 기다리지 않고, 처리 단계를 나누고 `a`가 1단계를 마쳤으면 `a`의 2단계와 `b`의 1단계를 동시에 처리한다는 말임. 
		- 병목 같은 게 생기는 게 맞고, 그거에 대응해서 CPU가 설계되어 있기도 하다. 아래의 '단점' 부분이 그것들임.
- 5단계 파이프라인
	- `IF(Instruction Fetch)` : 프로그램 카운터`PC`가 가리키는 주소에서 명령어를 읽어온다.
		- `프로그램 카운터PC` : CPU 내부에 있는 특별한 레지스터로, 다음에 실행할 명령어의 메모리 주소를 갖고 있다. 명령어를 가져온 다음, 자동으로 다음 명령어의 주소를 가리키도록 업데이트 된다.
	- `ID(Instruction Decode and Register Fetch)` : 읽어온 명령어를 해석, 연산에 필요한 레지스터 값을 파일에서 읽어온다.
	- `EX(Execute)` : 실제 연산을 수행한다. `R-타입`은 ALU 연산, `I-타입`은 주소 계산이나 ALU 연산, 분기 조건 검사 등을 수행한다.
	- `MEM(Memory Access)` : `lw` 명령어는 메모리에서 데이터를 읽어오고, `sw` 명령어는 메모리에 데이터를 쓴다. 다른 명령어는 그냥 통과한다.
	- `WB(Write Back)` : 연산 결과나 메모리에서 읽어온 데이터를 최종 목적지 레지스터에 쓴다.
- 장점
	- 이상적으로는 매 클럭 사이클마다 하나의 명령어가 완료되어 나온다.(5단계 파이프라인이라면 5개의 명령어가 동시에 각기 다른 단계에서 처리됨)
- 단점
	- 데이터 해저드 : 이전 명령의 결과값이 필요한데 아직 준비되지 않은 경우
		- MIPS에서는 이를 해결하기 위해 `포워딩 기법`이나 `파이프라인 지연(Stall/Bubble 삽입)`을 사용한다.
			- `포워딩 기법` : 결과가 `WB` 단계 전에 `EX`나 `MEM` 단계에서 바로 다음 명령어의 `EX` 단계로 전달
	- 컨트롤 해저드 : 분기 명령어의 결과가 확정되기 전에 다음 명령어들을 미리 처리해버리는 경우.
		- MIPS는 분기 예측, 지연된 분기(분기 명령어 다음 슬롯의 명령어를 무조건 실행) 등을 이용함
	- 구조적 해저드 : 서로 다른 명령어가 동시에 같은 하드웨어 자원을 사용하려고 할 때 발생함.
		- MIPS는 설계 단계에서 각 단계별 필요한 자원을 분리하여 최소화한다.
- MIPS와 파이프라이닝
	- MIPS의 고정 길이 명령어, 로드/스토어 구조, 단순한 명령어 방식 등이 파이프라인 단계를 균일하게 나누고 해저드를 처리하는 걸 용이하게 만들기 때문에 파이프라이닝을 효율적으로 구현하는 데 매우 적합하다.