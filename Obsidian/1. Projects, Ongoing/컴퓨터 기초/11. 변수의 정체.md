아무리 간단한 프로그램을 만들려고 해도, 변수가 없다면 구현이 힘들다. 
그런데 CPU 입장에서 변수를 선언하고 사용한다는 건 어떤 동작을 의미하는 것일까?

## 변수의 종류와 선언
- 변수의 종류는 매우 다양하다. C의 경우, 정수 타입만 해도 매우 다양한데, 용도에 따라 타입을 선택하는 게 중요하다. 예를 들면 0 ~ 100을 도는 루프를 만드는데 굳이 `short`를 쓸 필요는 없는 것이다. `unsigned char`만 써도 충분함.

- 그러면 CPU 입장에서 변수를 선언한다는 건 구체적으로 어떤 의미일까?
```c
#include "stdafx.h"

int main(int argc, char* argv[])
{
	int val;
	return 0;
}
```
1. `int val;` 부분에서 브레이크 포인트로 지정하고 실행해보면, 유효하지 않은 브레이크 포인트 경고창이 뜬다. 이를 클릭하면 `return 0;`부분으로 브레이크 포인트가 옮겨짐. 
2. 하지만 `int val = 1;`처럼 값을 할당하기까지 했다면, 브레이크 포인트 경고문은 발생하지 않는다.

쭉 공부해왔듯, C로 작성한 코드는 CPU가 알아볼 수 없고, 어셈블리 코드와 인스트럭션으로의 변환을 마친 뒤에 CPU가 동작하는 것이다. 브레이크 포인트도 인스트럭션 상에서 걸리는 것이다.

그런데 `int val;`처럼 선언만 한 경우, 브레이크 포인트가 걸리지 않았다는 것은, 실질적으로 어떤 인스트럭션으로도 변환되지 않았음을 의미한다. 즉, **변수를 선언하는 것 자체는 CPU 입장에서는 어떤 동작도 할 필요가 없음을 의미**하는 것이다.

`C`에서는 변수 사용 시 선언이라는 과정을 거쳐야 하지만, **어셈블리나 인스트럭션으로 작성할 때는 변수 선언이라는 게 필요 없다. 메모리나 레지스터 전체가 이미 선언된 변수이기 때문**이다.  로우 레벨에서는 임의의 범용 레지스터나 메모리 주소에 원하는 값을 쓰거나 읽어올 수 있는 것이고, 이게 변수에 액세스하는 과정이다. 물론 이 때도 이미 값이 할당되어 있다거나, 다른 데이터가 있는 경우 등을 주의해야 하겠지만.

**C에서 변수 선언을 한다는 것은, C 컴파일러에게 임의의 빈 메모리를 확보하라고 알려주는 것**과 같다. 따라서 CPU 입장에서는 특별히 할 일이 없고(= 인스트럭션이 생성되지 않고) 브레이크 포인트도 걸리지 않는다.

> Gemini : 최신 컴파일러는 이렇게 선언만 되고 사용되지 않는 변수가 있다면, 아예 메모리 할당 자체도 없는 걸로 처리한다고 함.

하지만 변수 할당을 했다면, 컴파일러가 잡아놓은 메모리 영역에 실질적으로 값을 쓰므로, 값을 쓰는 `STORE` 인스트럭션으로 변환되고, 여기서 브레이크 포인트가 걸린다.

> 1. 상수 값 로드 : CPU는 기계어 명령어에 포함된 즉치값 1을 내부 레지스터 중 하나로 가져온다.
> 2. 메모리 쓰기 : CPU는 레지스터에 저장된 값 1을 스택 메모리에서 `VAL` 변수를 위해 할당된 정확한 주소에 복사하여 저장한다.


> 어셈블리어로 변환한 다음의 얘기도 나오는데, 이 부분은 읽기만 하고 넘김
## 변수의 크기와 부호
(`unsigned`) + `char, short, long` 등의 변수들이 있다.
예를 들어 `char`은 `-128 ~ 127`을 표현할 수 있는데, `200`을 넣으면 어떻게 될까? `unsigned char`에 `-1`을 넣으면 어떻게 될까? 의외로 많이 나오는 실수로, **CPU에 따라 부호처리가 달라지기도 하고, 부족한 부분은 컴파일러가 채워주기도 한다.**

- 예시
```c
#include "stdafx.h"
#include <stdio.h>


int main(int argc, char* argv[])
{
	char val = 127; // -128 ~ 127 표현 가능
	
	if (var == 127) 
	{
		printf("First : Right Answer!\n");
	} else {
		printf("First : Wrong Answer!\n");
	}
	
	val = 128;
	if (var == 128) 
	{
		printf("Second : Right Answer!\n");
	} else {
		printf("Second : Wrong Answer!\n");
	}
	return 0;
}
```
> 둘 다 `Right Answer!`가 나오지 않는다. 아래는 `Wrong Answer!`가 나옴.

일단 아래의 128은 `char`의 범위를 벗어난 것이기도 하지만, 여기서는 인스트럭션이 어떻게 되는지를 살펴본다.

1. 상수를 변수에 저장하는 부분.
	-  `char`은 1바이트 변수로, 컴파일러는 1바이트 공간에 127을 저장한다.
	- 인텔 cpu에는 `byte ptr`이라는 키워드가 있다. 바이트 단위 오퍼레이션을 위한 인스트럭션인데, 이게 없는 cpu에는 컴파일러가 다른 형태로 인스트럭션을 나열해서 같은 기능을 구현한다.
		- 예를 들어 16비트로만 메모리에 액세스한다면, 저장할 메모리 주소에서 16비트를 읽어온 뒤 이 레지스터의 상위 바이트를 다시 상수값으로 치환해서 메모리에 저장할 수도 있다.
```assembly
// 인텔 80x86에서는 이렇게 변환됨
MOVE BYTE PTR [Mem], 127 // 메모리 주소에 즉치값을 지정 크기BYTE로 넣어라

// 위 명령어와 동일한 작업
LOAD R1, [Mem]
LUI R1, 127

STORE R1, [Mem]
```
> 아래의 인스트럭션이 여러 줄이지만 실질적으로 더 느리지는 않다. RISC를 채용한 CPU에서는 인스트럭션 자체는 많아지지만, 한 인스트럭션당 수행되는 시간인 클럭이 훨씬 짧기 때문에 더 빠르거나 비슷할 수 있다.

- 부호에 대한 이야기
	- 127을 변수에 저장하면 `0x7F`로 기록된다.
	- -1을 변수에 저장하면 `0xFF`로 기록된다. 

- 1바이트를 벗어나는 경우, `300 = 0x12C`을 넣으면 컴파일러가 변수 크기에 맞춰 상수값을 자른다. 1바이트 크기에 맞도록 뒤의 `0x2C` 부분만 남는다. 

2. 상수와 변수값을 비교하는 부분.
	- **어떤 값들을 비교하기 위해서는, 값들 모두가 레지스터에 있어야 한다.** 모든 연산에 해당됨.
	- 그래서 많은 CPU의 레지스터 - 상수나 레지스터 - 레지스터 간의 연산 인스트럭션이 존재하지만, 메모리가 개입한 연산용 인스트럭션은 없다.
		- 느리니까.
	- 어느 경우든 메모리에서 값을 읽어오긴 해야 함.
	- 그런데 변수의 크기에 맞춰서 옮겨야 한다는 이슈가 있음. `byte ptr` 같은 키워드로, 변수가 가리키는 메모리에서 몇 바이트를 읽어올지를 결정해야 한다.
	- 또, 부호에 대해서도, 해당 메모리의 값이 양수인지 음수인지를 결정해야 한다. 
		- 메모리에 `255`라는 `0xFF`라는 값이 있고, 레지스터의 크기가 32비트라면 이를 4바이트 포맷에 맞게 확장해야 한다. 그런데 양수냐 음수냐에 따라 확장 방법이 달라진다.
			- 양수라면 실제 값 앞의 비트가 모두 0
			- 음수라면 앞의 비트가 모두 1
		- 근데 `0xFF`는 `11111111`이므로, 2의 보수를 쓸 경우 가장 첫번째 비트가 1인 음수로 봐서 `-1`이 될 수도, 그냥 양수 `255`일 수도 있다. 
		- 이들을 구분하기 위해, 4바이트 확장 시에는 `255`는 `0x000000FF`가 되고 `-1`은 `1xFFFFFFFF`가 된다.
		- 인텔 CPU 에서는 하드웨어적으로 부호가 없을 때는 `movzx`라는 인스트럭션을 쓰고, 부호가 있다면 `movsx`을 별도로 쓴다. 즉, 같은 값을 옮겨오더라도 어떤 인스트럭션을 쓰는지에 따라 값이 달라질 수 있다.
		- 컴파일러에서는 메모리가 양수냐 음수냐를 어떻게 판단할까? - 당연히 데이터 타입을 보고 판단한다. `unsigned`가 붙으면 `movzx`를, 없으면 `movsx`를 쓰겠지.
	- **메모리 데이터가 레지스터로 로드되면, 이 값과 상수 127을 비교한다.**
		- `80x86`에서는 `cmp`라는 인스트럭션과 조건 분기 인스트럭션의 조합으로 비교문을 구성한다.
			- `cmp`는 단순히 두 오퍼랜드 간의 빼기 연산을 한다. 결과에 따라 플래그 값을 설정한다. 
				- 0이라면 Z 플래그 값이 1
				- 양/음일 때 S 플래그 값이 1 or 0
			- 조건 분기 인스트럭션들은 이 플래그를 보고 분기 여부를 결정한다. `jne`은 `z`플래그가 0이냐 아니냐에 따라 분기함.
		- `char` 대신 `unsigned char`을 쓸 경우, `movsx -> movzx`로 바뀐다. 실제 동작은 똑같이 `127`에 대해 수행되므로 나머지는 동일함

- `val = 128`일 경우
	- **`movsx`(부호가 있을 때의 인스트럭션)에서, `0x80, 10000000`이므로 부호를 고려한 1바이트 변수 `char`에서는 음수값 `-128`로 판단**한다. 이를 32비트로 확장할 경우, 32비트에서도 -128을 나타내야 하기 때문에 앞의 3바이트를 모두 1로 채워서 음수 `-128`을 표현하도록 확장한다. 
	- 그래서 `movsx`로 `128`을 32비트 레지스터로 옮겨오면 `0x000000F0`이 아니라 `0xFFFFFFF0`이 된다. 이후 `cmp` 인스트럭션에서 `0x8001`과 비교했을 때 서로 다른 숫자이므로 Z 플래그가 0이 되고, `jne`는 `Wrong Answer`을 출력하게 된다.

## 포인터
- "포인터란 무엇인가를 가리키는 특별한 변수다"로만 설명할 수는 없다.

- 컴파일러와 어셈블러의 차이점
- 컴파일러
	- 메모리의 사용 영역을 명확히 구분함
		- 프로그램이 차지할 영역
		- 프로그램 실행 과정의 변수를 위한 영역
		- 개발자가 변수를 이름으로 기억하게 해서 찾기 쉽도록 함
- 어셈블러
	- 용량이 작고, 빠르고 효율적인 프로그램을 만들 수 있음
	- but) 각 변수를 개발자가 직접 메모리의 공간에 지정하므로 개발 시 복잡해지고, 각 변수의 위치를 기억하기 쉽지 않음

여기서 포인터 변수는 뭘까? : 일반 변수와 전혀 다른 게 없다. 변수를 메모값에 비유한다면, 포인터도 똑같은 메모값일 뿐이다. 계산 중에 어떤 변수를 기억하고 싶다면, `int, short, char` 변수 외에도 **`포인터 변수`도 선언할 수 있다.** 

```c
#include "stdafx.h"
#include <stdio.h>
#include <conio.h>

// 1번 코드
int main(int argc, char* argv[]) {
	int a = 10;
	int b = 20;
	int c = a + b;
	
	printf("Result = %d\n", c);
	
	getch();
	return 0;
}
```
> 당연히 `Result = 30`이 나옴

여기서
```c
// 2번 코드
int* a = (int *)10;
int* b = (int *)20;
int c = (int)a + (int)b;
```
으로 써도 결과는 동일하게 나온다. `int` 변수를 `int`의 포인터 형으로 선언한 것만 차이점임. 이 사용법은 일반적인 포인터의 사용법과는 조금 다르다.

추가로, 이런 실험도 해본다. 반드시 `int` 형일 필요는 없는데, 그러면 포인터를 사용한 덧셈에서도 다른 형의 포인터를 사용해도 무방할까? 그렇다.
```c
// 3번 코드
	char* a = (char *)10;
	char* b = (char *)20;
	char c = (char)a + (char)b;
```

각 코드의 원리

1. 1번 코드

3개의 정수형 변수가 메모리에 마련되고, 적당한 값이 들어가는 것이다.

구체적으로 설명하면, a, b, c 라는 이름으로 C 컴파일러가 기억하고 있다가, 세 곳의 메모리 공간에 각각 10, 20과 이 둘을 더한 30이라는 값을 저장하는 것이다. 연습장의 구석의 세 공간에 각각 값을 적어두는 것과 동일하다.

`int`로 선언하게 되면 각 변수마다 4바이트 공간을 확보하고, `short int`나 `char`로 선언하면 각각 2바이트나 1바이트 공간을 확보하게 된다. (`char`은 -128 ~ 127을 표현)

2. 2번 코드

그러면 `int`가 아닌 `int의 포인터`로 선언된 경우는 어떻게 동작하는가?

포인터 변수는 다른 변수와 마찬가지로 연습장 한 귀퉁이에 적은 메모일 뿐이다. 즉, 메모리 한 부분에 원하는 값을 기록해둔뒤, 그 값을 갖고 나중에 필요할 때 쓰는 용도에서는 완전히 동일하다.
차이점은 **크기와 사용 용도**이다. 크기는 변수가 선언됨과 동시에 컴파일러가 정해진 메모리를 확보하기 때문에 어떻게 할 수 있는 부분이 아니고, **사용 용도는 임의로 정할 수 있다.** `char`으로 선언된 변수는 주로 글자를 저장하는 데에 사용하지만, 이를 글자로 취급할지 숫자로 취급할지는 개발자에게 달려 있다. 

```c
// include문 생략

int hex2int(char hex) 
{
	if ( hex >= '0' && hex <= '9')
	{
		return (hex - '0');
	}
	else if (hex >= 'a' && hex <= 'f')
	{
		return (10 + hex - 'a');
	} 
	else if (hex >= 'A' && hex <= 'F')
	{
		return (10 + hex - 'A');
	} 
}

int main (int argc, char* argv[]) 
{
	char hexa = 'f';

	printf("As Character : %c\n", hexa);
	printf("As Number : %d\n", hexa);
	printf("As Converted Number : \d\n", hex2int(hexa));
	
	getch();
	return 0;
}
```

`hex2int` 문을 보면, `char` 변수는 문자 변수이므로 덧셈이나 뺄셈 등의 연산의 대상이 아니지만, 변수라는 것은 크기만 정해져 있을 뿐, 사용 용도는 그 변수를 사용하는 개발자에게 달려 있다. 

위의 예제는 아스키 코드의 순서를 이해하고 활용한 경우로, `f`나 `F`는 16진수를 나타낼 때 15라는 값을 나타내고, `a`나 `A`는 10을 나타내는 값이다. 나머지 숫자 0 ~ 9의 문자 또한 아스키 코드로 나타낼 때 들어가는 순서가 일반적인 숫자와 똑같기 때문에 문자 '0'을 빼는 것으로 기능할 수 있다는 것.

> 1. 실제 연산에서, `char`은 **정수 타입**임
> 2. 아스키 표준에 따라 각 문자에는 고유한 정수 값이 할당되어 있음.
> 3. `char` 타입의 변수나 리터럴이 산수 연산에 사용될 때, C 언어는 이들을 `int` 타입으로 자동으로 승격시킨다. 즉, 실제 연산은 `int`값 사이에서 진행된다.

따라서 `아스키 코드 테이블`에서 `hex`로 들어온 문자가 어떤 범위 내에 있는지 알 수 있다면, 이를 숫자로 변환하는 것도 가능하다는 것이다.

> 다른 케이스) 만약 **파이썬**이라면 **`hex`의 타입은 `string` 이든 `int`이든 `10 + hex - 'a'` 같은 식으로 사용할 수 없음.**  `a`는 `ord(a)`을 써야 하고, `hex`도 `string`이라면 `ord`를 써야 함
> - 대신 더 간단한 방식으로 `int(value, 진수)`로 사용할 수 있다고 함.

- 위 예제를 굳이 든 이유는, 포인터를 인식하는 뿌리 자체를 '특별한 용도, 동작을 위한 변수'라는 인식을 바꾸기 위함이다. 계속 반복하지만, **변수는 형태에 따라 크기만 정해지고 꼭 지켜야 하는 규칙이나 용도는 없다.** 

> C에만 해당하는 얘기에 가까워보이며, 타입에 따라 사용에 제약이 걸리는 언어는 많음. 굳이 고수준 언어를 쓰면서 어떤 타입으로 저장된 정보에 접근해서 메모리나 비트 단위로 다른 타입으로 바꿔서 사용할 이유가 많지 않아 보이기는 함.

- 하지만 맥락을 보자! 제미나이한테도 물어봤다.
- 2번 코드, 3번 코드 모두 포인터의 원래 용도를 간과한 위험한 사용법이라고 한다. 물론 예시용이긴 하지만.   

 - 일단 이 파트는 재낌. C나 C++을 쓸 게 아니라서 포인터를 쓸 일도 없다. 
