## 참고
- **옵시디언으로 봐야 멀쩡하게 보임!!!**
- **옵시디언으로 작성된 만큼 깃허브의 마크다운에서는 지원하지 않는 기능들이 있을 수 있다.** `[[]]`, 이미지 첨부 방식 등이 대표적.
- `[[]]` 링크는 `유니티/보관함`이나 `작업 일지/직접 작성/일지`에 대부분 있다.

## 블로그
- 데이터가 제때 수집되고 있는지 눈팅 정도만 하면 충분할 것 같다.
- 사실 Quill을 쓰면서 되돌리기 / 붙여넣기 기능이 좀 이상하게 작동하고 있는 문제가 있긴 한데... 언제 해결할지는 모르겠음?

## 작업 예정

### 남은 작업 내용 
- 남은 작업들
	- 스테이지 1-0 ~ 1-3 밸런싱
	- 1-3에 보스 추가
	- 보상 설정

- 보고 참조할 내용
	- [[오퍼레이터들 스탯 정리]]
	- [[적 스탯 정리]]

- 테스트 및 수정

### 작업 중 
1. 스테이지 `1-1` 밸런싱 (이후 `1-2`, `1-3`)
	- **스테이지 완성, 보상 설정, 보스 추가** 등으로 게임을 완성하는 게 젤 중요함!! 다른 건 다 부차적인 요소! 
	- ...인데 잘 실천이 안 되고 있다. 계속 고칠 점이 보임...

### 구현 예정

### 하고 싶은데 못할 듯
- 캐릭터 스프라이트 
	- 현재 Capsule로 Operator나 Enemy 등을 구현한 상태
	- 이걸 투명한 Quad로 바꾸고 그 위에 2D 스프라이트들을 구현하는 방식이 명방에서 쓰고 있는 방식으로 보임
	- 직접 하려면 배워서 할 수는 있겠지만 시간이 문제겠다. 
- 도전과제 구현
	- 예를 들면 1-1에서 바리케이드만 이용해서 스테이지를 클리어하기 같은 게 있겠다 (= 오퍼레이터를 배치하지 않고 스테이지 클리어하기)
- 인게임 / 다른 패널에서 스킬 범위 보여주기 
	- 일관성 때문에 다른 곳에서도 구현을 해보고는 싶은데, 드는 품을 생각하면 미뤄도 될 것 같음. 


## 4월
- `250410, 250411` : AWS로 만들었던 블로그 프리티어 만료와 관련, 정리할 사항들이 있어 정리함
	1. AWS에 띄운 사이트를 언제 엎을지 모르니까 일단 `github.io`에 `hugo`로 사이트 & 포트폴리오 구축
	2. EC2 인스턴스에 띄운 것 중 블로그에 함께 띄웠던 텐서플로우 & 다른 컨테이너로 띄웠던 데이터 수집 컨테이너 정리
	3. RDS로 띄웠던 MySQL을 EC2의 별개 컨테이너로 옮김.


## 250421 - 짭명방

### 기타 이슈 수정
- [x] `FloatingText` 
	- 오퍼레이터가 클릭될 때 카메라 각도가 돌아가는 상황에서 `FloatingText`의 각도도 돌아가는 현상 - `LateUpdate`에서 회전이 실시간으로 반영되고 있기 때문.
	- `LateUpdate`의 코드를 없앨 경우 회전이 `0, 0, 0`으로 고정되는 문제가 있었는데, 이건 `SpawnFromPool`에서 `Rotation`값이 `0, 0, 0, 0`으로 전달됐기 때문이다.
	- `FloatingText.OnEnable`에서 설정해도 수정이 되지 않았던 이유는 `SetActive(true) -> OnEnable -> SetupPooledObject` 순서대로 메서드가 동작했기 때문에, 가장 마지막의 것만 반영되었음. 
	- `FloatingText`에서 `OnObjectSpawn` 메서드는 구현만 되어 있었다. **인터페이스 상속을 안해놨음.** 
	- 수정 사항
		1. `FloatingText.OnEnable`에 넣었던 `OnObjectSpawn`을 해제하고, 인터페이스 상속을 받게 함
		2. `FloatingText`의 회전은 `ObjectPoolManager.ShowFloatingText`에 직접 넣는 방식으로 구현.
![[Pasted image 20250421161011.png]]

- 배치 가능 타일 머티리얼 수정
	- [x] **배치 가능 타일(원본 게임에서는 초록색으로 표시)은 기존 머티리얼을 넣되 색만 변경**되는 방식
		- `Mesh Renderer`에 여러 개의 머티리얼을 넣을 수 있다. 
		- `Tile`에 2개의 `SharedMaterials`을 준비해서 뒤의 배열에는 `highlightMaterial`을 추가한 뒤, 하이라이트 상황일 때와 아닐 때를 구분해 `SharedMaterials`을 전환하는 방식으로 구현했음.
		- 근데 `Map`으로 구현된 각 타일들은 프리팹 설정이 해제되어 있다. 반영이 안 되어서 인스펙터에서 `highlightMaterial`을 설정하는 건 직접 작업함.
	- **공격 범위 타일 표시는 타일 전체의 머티리얼이 변하는 게 아니라 타일 윗쪽에만 새로운 이미지가 나타나는 방식**으로 보임
		- 줄무늬 이미지를 하나 만들고, 셰이더를 만들어서 셰이더의 텍스쳐에 반영
		- Quad 3D 오브젝트에 해당 셰이더를 적용하고, 타일의 자식 오브젝트로 추가.
		- 하이라이트를 분리 : 배치 하이라이트 / 공격범위 하이라이트
		- 이 방식의 현재 문제점은, `Map`에 있는 타일들은 프리팹과 연결되어 있지 않다는 것이다. 프리팹의 모든 변경사항이 즉각적으로 반영되지 않기 때문에, 노가다로 집어넣어야 함.
			- 맵 에디터에 문제가 있었나 싶어도.. 지금 맵에 관한 프로토타입은 다 만들어둔 상태라서 바꿔도 큰 의미는 없어보인다.
			- 프리팹에 다시 연결해도 어차피 할당을 전부 다시해야 하는 부분이 생겨서, 일단은 그대로 집어넣는다.
			- 다행히 `Ctrl + Shift + V`라는, 로컬 트랜스폼을 그대로 살려서 집어넣는 기능이 있다. 그걸 모든 타일에 한땀한땀 넣는 중. 이건 여러 타일 지정하고 넣는 게 안된다.

> `Medic`의 공격범위 구현
![[Pasted image 20250421205041.png]]
- 색깔 분기를 넣고, 구현 자체는 `Operator - MedicOperator` 상속관계의 다형성을 이용

> `Vanguard`의 공격범위 구현
 ![[Pasted image 20250421205143.png]]
- 저 이미지 부분을 넣어보니까 심리스가 아니라서 걱정됐는데, 생각보다 자연스러운 느낌이라 텍스쳐를 재작업할 필요는 없을 것 같음.

오늘은 여기까지!


## 250418 - 짭명방

### 기타 이슈 수정
- `OperatorUI` 요소들 수정
	- `Enemy`와 겹치는 경우가 있어서 인스펙터에서 y값을 낮추려고 했는데, 부모 오브젝트의 `rotation`이 있기 때문에 원하는 느낌의 구현이 되지 않음.
		- 일단 `transform.localRotation`으로 설정하던 값을 `transform.rotation`(월드 좌표 기준)으로 수정.
		- `OperatorUI` 자체의 `y` 포지션을 `-0.3` 정도 낮추면 원하는 구현이 나오는데, 스킬 사용 가능 아이콘도 같이 움직이는 이슈가 있다.
			- `DeployableBarUI`랑 `directionIndicator`가 함께 들어가는 부모 오브젝트를 하나 추가함
		- 이미 구현된 기능이지만, **수정하기가 좀 번거로운 면이 있기 때문에 기능을 분리하겠음**
			- 오퍼레이터의 **회전을 따라가는 게 필요한 기능(`directionIndicator`)은 오퍼레이터의 자식 오브젝트**로 둠
			- 오퍼레이터의 **회전을 따라갈 필요가 없는 기능`OperatorUI`은 별도 오브젝트**로 구현함
	- 이참에 추가로 `Operator`에 설정된 `operatorUIPrefab`을 `UIManager`로 뺀다.
		- 지금 같은 경우는 `Operator`마다 별도로 `SerializeField`에 프리팹을 할당하는 방식이다. 기존 방식은 Operator로 구현된 프리팹마다 일일이 할당해야 하는 이슈가 있었음.
	- 추가로 `OperatorUI`에서 카메라를 보게 하는 시점은 `Initialize`로 변경. 
		- 기존엔 `Awake`에 있었음
		- 그래도 게이지가 각도에 따라 좀 삐딱해보이는 문제는 있다.
	- `OperatorUI`의 자식 오브젝트로 들어가는 `DeployableBarUI` 관련
		- 일단 `Unpack`했음. `DeployableBarUI` 프리팹을 없애면 `Barricade` 등에서 사용하고 있기 때문에 그건 안된다.
		- 2개의 `HealthBar`(체력, SP)의 레이아웃은 이제 `Vertical Layout Group` 컴포넌트로 관리함
			- 기존에 `Height, Scale.y` 2가지 요소로 관리했는데 이제 `Height`로만 관리함

- `EnemyBarUI`에 알파 `0.7`, `OperatorBarUI`의 요소들에 알파 `0.9`로 지정
	- 특히 `Enemy`가 겹치는 경우 어떤 상황인지 잘 보이지 않는 경우가 많아서 이렇게 구현
	- 원본 명방은 충돌이 있어서 살짝 밀려나는 효과가 구현되어 있는데, 이걸 어떻게 구현할지 몰라서 일단 UI에 투명도를 추가하는 방향으로 진행함.

- 일단 이 정도 하고 세이브.



## 250417

### 블로그(AWS 사이트)

- MySQL을 EC2로 옮기고 나서, 뻗는 일이 좀 있다.
- SQL까지 관리하기에 EC2의 t2.micro가 사양을 못 따라가는 느낌. 
	- 블로그는 트래픽이 적으니 상관이 없지만.
- 일단 `스왑 메모리`라는게 있다고 함
	- 램이 부족할 때 스토리지를 메모리처럼 사용하는 공간.
	- EBS는 어차피 남아도니까 크게 상관도 없다.
	- **느리다.** 
```sh
# 1GB 스왑 파일 생성 (원하는 용량으로 변경 가능)
sudo fallocate -l 1G /swapfile

# 파일 권한 변경
sudo chmod 600 /swapfile

# 스왑 영역 생성
sudo mkswap /swapfile

# 스왑 활성화
sudo swapon /swapfile

# 적용 확인
swapon -s
free -m
```



### 짭명방
#### 기타 이슈
- [x] 이펙트와 UI의 렌더링 순서 문제 
	- `WorldCanvas`에 있는 UI가 이펙트보다 뒤로 가 있는 현상
		- `VFX`에 있는 `Renderer`의 `Order in Layer`, `Sorting Layer` 등의 옵션 / `Canvas`에 있는 `Order in Layer, Sorting Layer` 값을 변경하면 된다.
		- **여기서 말하는 레이어랑 오브젝트에서 설정하는 레이어는 다른 개념임**
		- [[유니티 레이어의 종류]]
		- **지금 상황에서는 `Sorting Layer`, `Order in Layer`의 동작 원리**만 알면 되는데
			- `Sorting Layer`는 렌더링 그룹을 정하는 거고
			- `Order in Layer`는 같은 그룹 내에서의 렌더링 순서를 정의한다. **높은 값이 나중**에 그려진다. 
			- 다른 렌더링 그룹 간의 비교, **즉 `Sorting Layer`의 설정은 인스펙터의 `Tags & Layers - Sorting Layer`에서 설정**한다. 
				- **아래에 있는 레이어가 나중에, 즉 유저에게 가장 가까운 위치에서 그려진다. 하이어라키의 오브젝트 배치 순서와 동일한 원리임.**
			- 지금 보니까 `Rendering Layer`라는 게 추가되었는데, 이건 지금 문제와는 관련 없는 것이다. 어떤 라이트 / 카메라 / 이펙트가 어떤 오브젝트에만 적용될지를 지정하는 3D 기반 시스템이라고 함. 
![[Pasted image 20250417144552.png]]
> 얘가 되면 다른 것도 됐다고 치려고 했는데 잘된 것 같다. 굳.

- [x] 버프 스킬에 이펙트 추가
	- 지금은 회오리 모양의 3D 메쉬를 만들고, 텍스쳐를 넣은 상태에서 UV 값을 0부터 1까지 시간에 따라 쫙 땡기는 방식으로 구현되어 있음
	- 사실 큰 문제는 아닌데, 버프를 켜고 버프가 켜진 걸 확인할 수 있는 시각적인 장치가 약간의 딜레이 후에 나오는 게 아쉬워서, **간단하게 오퍼레이터의 하단에 커졌다 작아졌다 하는 플레어 이펙트만 추가**하겠음.
		- 예전에는 `Periodic Burst` 이랑 `Lifetime`을 컨트롤하는 방식으로 구현했는데, 이 방식의 문제점은 나중에 `Output`에서 설정하는 `Over Lifetime` 관련 설정에서 이펙트의 크기나 색상의 변화 속도가 `Lifetime`에 영향을 받는데에 있었음
		- 이 `Over Lifetime`을 없애고, **`Set Size`에 직접 삼각함수 공식을 넣음.** `lifetime`은 `999`로 고정해서 스킬의 지속시간에 상관 없이 크기/색상의 증가/감소 속도를 항상 일정하게 구현하는 식으로 수정함
```
1. Multiply 노드에 인풋을 하나 추가한 다음 아래 3가지 요소를 모두 넣음
- Total Time(Per-Particle)
- Pi(2pi)
- frequency(1초 동안 동작 횟수)
2. 1번의 아웃풋을 Sine에 넣음
3. 2번의 아웃풋을 Multiply로 곱함. 나머지 요소는 변동폭.
4. 3번의 아웃풋에 1을 더함. 최종적으로 1 + A * sin(T * 2pi * f)가 됨.
- 여기서 컨트롤할 요소는 f랑 A 정도로, f는 1초동안 진동하는 횟수, A는 이미지 크기 변화량 정도로 정리하면 편하겠다.
```


- [x] OperatorBarUI와 EnemyBarUI에 일관성 주기
	- 지금까지 확인한 바로는 설정이 똑같은 것 같은데 실제 화면에 나타나는 두께가 좀 다르다. 
	- 또, `OperatorBar`의 `SpBar` 부분은 스킬이 활성화됐을 때 일반 적의 HP Bar 색과 비슷한 주황색이라서 구분될 정도로 차이는 줘야할 것 같음.
	- `OperatorUI`가 실제로 사용되는 부분이라서, `DeployableBarUI` 자체를 수정해야 하는 게 아니라 `OperatorUI`에 들어가는 `DeploybleBarUI`를 수정했음



## 250416 - 짭명방
### 기타 이슈

- [x] `ArcaneFieldSkill` : 스킬을 다시 사용할 때, 이전의 범위가 함께 나타나는 현상이 있음. 
	- 확인해보니 이전의 범위가 비활성화되는 건 오브젝트 풀링의 기능이 맞는데, 문제는 다시 실행할 때 이전의 요소들을 재활용하지 않는다는 거?
	- **문제 상황을 더 명확하게 정리하면** `FieldEffectController`는 기능적인 부분을, `SkillRangeVFXController`는 시각적인 부분을 담당한다.
		- `FieldEffectController`는 자기 기능을 수행하면 `Destroy`.
		- `SkillRangeVFXController`는 오브젝트 풀링으로 관리.
		- 여기서 문제가 되는 건 `SkillRangeVFXController`로 동작되는 VFX 부분.
	- 해결) 스킬이 끝날 때, `AreaEffectSkill`에서 `ActualSkillRange` 부분을 초기화하지 않았다. `OnSkillEnd` 메서드를 오버라이드 해서 아래처럼 추가.
		- 그래서 `ActualSkillRange`에 있는 요소들로 이펙트 실행 여부를 감지하기 때문에 `MeteorSkill` 같이 오퍼레이터가 한 번 배치되고 나서 스킬 범위가 고정되는 스킬은 정상적으로 작동했던 것도 자연스럽게 설명됨.
```cs
	protected override void OnSkillEnd(Operator op)
	{
		// 스킬 범위 초기화
		actualSkillRange.Clear();
		// 활성화된 스킬 효과와 VFX를 제거함
		activeEffects.Clear();

		base.OnSkillEnd(op);
	}
```

- [x] `Caster` 관련 :  `Lightning`이라는 이름으로 오퍼레이터의 피격 이펙트를 관리하고 있었는데, 이거는 `ArcaneField` 스킬을 시전할 때만 나타나게 하고 나머지 상황, 즉 오퍼레이터에서 설정하는 피격 이펙트에서는 일반적인 피격 이펙트의 색만 변경한 걸 사용하겠음
	- 이 과정에서 `AreaEffectSkill`에 `hitEffectPrefab` 부분을 `SerializeField`로 돌려서 인스펙터에서 할당할 수 있게 하고, 만약 없다면 오퍼레이터의 `GetHitPrefab`을 가져오도록 한다.
	- [x] 근데 인스펙터에서 `Lightning`으로 할당했는데 오퍼레이터의 그걸 가져오는 문제가 발생 중.
		- 체크해보니까 할당하는 로직의 문제가 아니라 `TakeDamage`의 문제다. `AttackSource`에 이미 `HitEffectPrefab`으로 이펙트를 관리하고 있는데, `TakeDamage`에서 이펙트를 실행하는 부분은 `Operator/Enemy`에서 이펙트를 가져오고 있음.
		- 근데 지금처럼 **스킬에 관한 피격 이펙트를 따로 다루고 싶으면, 스킬의 타격 이펙트에 대한 오브젝트 풀, 풀을 지정하는 태그 등도 새롭게 설정**해야 함
			- 이건 AreaEffectSkill에 구현하면 될 듯?
	- 그러면 할 일은 아래 2가지 정도가 되겠다.
		1. `AttackSource`에 `HitEffectTag`까지 넣게 해서 어떤 오브젝트 풀에서 가져와야 하는지 지정하기
		2. `AreaEffectSkill`에서 오브젝트 풀을 만들고 사용하도록 하기
			- 여기서 `HitEffectTag`라는 값은 일반적으로는 `Operator`에서 이름을 이용해서 자체적으로 `string` 값을 만들어서 사용하고 이게 대부분의 경우는 문제가 안 됨. `Enemy`의 경우는 인스턴스 ID까지 합쳐서 쓴다.
			- 그런데 지금처럼 다른 공격수단을 사용했을 때 다른 이펙트를 보여주고 싶다면, 그런 경우에는 다른 `HitEffectTag` 값을 전달하는 방식이다. 지금은 `ArcaneFieldSkill`에 대해서만 할당이 되어 있음.
			- 이제부터는 `AttackSource`에 전달하는 프리팹, 태그 값만 다르게 지정하면 됨.

#### 이펙트 로드 관련
- 현재 `VFXGraph`로 구현된 이펙트들의 경우, 테스트 시에 초반에 불러오는 시간 같은 게 생기는 듯함 -> 이게 게임 플레이 시에 끊김 등의 현상도 나타남.
- 조금 더 자세히 설명하면 아래와 같음.
```
1. 어떤 쉴드 이펙트를 구현했다. 이 이펙트는 3D 모델에 색과 셰이더를 적용해서 일정 주기로 커졌다가 작아졌다가 하는 이펙트이다.
2. 문제 상황은 이 3D 모델은 잘 나타나는데, 색상이 밝은 하늘색/청록색 계열로 초반에 나타난다. 일정 시간이 지나고 나면 의도했던 모양이 나타난다.
3. 느낌 상 뭔가가 로드가 안 됐다는 느낌인데, 플레이 테스트에서의 예를 들면 완전 처음에 할 때는 2번의 문제 상황이 나타나지만, 플레이 테스트를 중단하고 다시 실행했을 때에는 2번의 문제 상황이 나타나지 않는다.
```
- 근데 이게 프로젝트를 껐다가 다시 켜서 실행했을 때에는 또 멀쩡히 작동한다. 일관적으로 재현되지 않아서 테스트하기 어려운 상황임.
- 에디터를 껐다 켜도 다시 발생하지 않는다..

- 이 이슈는 따로 문서로 빼놓음. [[이펙트의 최초 실행 이슈]]

- 가장 간단한 해결 방법은 스테이지 씬을 로드하는 과정에서, 현재 씬에서 나타나야 하는 관련된 오브젝트들을 싹다 한번씩 인스턴스화한 다음 끄는 게 있을 것 같기는 한데.. 이것도 비용은 크지 않나?




## 250415 - 짭명방

### 밸런싱, 스테이지 만들기
- `1-2` 작업 시작.
	- 경로랑 대략적인 스폰 과정은 완료
	- 더 강한 적을 만들어야 하나? 라는 생각은 든다. 


### 튜토리얼 내용 추가
- [x] 레벨업 안내 후에 다음 내용 추가
	- 레벨업 안내의 마지막 부분에 스테이지 반복 클리어 시에도 경험치 아이템이 지급됨을 알림
	- 정예화 안내
		- 패널로 들어가는 안내는 아니고, `OperatorDetailPanel`에서의 설명이 되겠다.
		
>- 0정예화 50레벨이 되면, 정예화를 할 수 있다
> - 정예화 시, 오퍼레이터의 새로운 스킬이 해금되며 일부 오퍼레이터는 공격 범위가 추가된다.
> - 정예화에 필요한 아이템은 **1-0, 1-1, 1-2 스테이지를 3성으로 최초 클리어**했을 때에만 지급된다

- 이 과정에서 보상도 수정
	- 정예화 아이템은 최초 클리어 시 1-0부터 1개, 2개, 3개 지급
	- 정예화 아이템 지급 로직은 3성일 때만 지급이므로 수정 필요 없음.
### 기타 이슈 수정

- [x] `StageResultPanel`
	- 3성 클리어가 아닌 상황에서 `ItemPromotion`은 0개 -> 0개인데도 UI에 보이는 문제 수정
	- `StageResultPanel.ShowItemElements`에서 보상 아이템이 0개인 경우는 나타나지 않도록 수정
```cs
    private void ShowItemElements(IReadOnlyList<ItemWithCount> rewards, bool showFirst = false)
    {
        if (rewards.Count > 0) // 보상 아이템이 있을 때
        {
            foreach (var itemPair in rewards)
            {
				if (itemPair.count == 0) continue; // 보상 아이템이 0개인 경우는 나타날 필요 없음
				// UI 표시 로직 생략
            }
        }
    }
```

- [x] `OperatorLevelUpPanel`
	- 레벨업 후의 스탯에 소수점이 나타나는 현상이 있음 -> 처리 완료


#### PathDataEditor 수정
- [x] `PathData`에서 활성화 버튼을 누르고 씬 뷰의 타일을 클릭해도 아무 동작도 하지 않는 현상

- 맵을 **프리팹**에 띄우고 타일들을 클릭할 때는, 타일의 콜라이더가 활성화되지 않는다.
```cs
// 콜라이더 감지 로직
Ray ray = HandleUtility.GUIPointToWorldRay(e.mousePosition);
RaycastHit hit;
if (Physics.Raycast(ray, out hit))
{
	pickedObject = hit.collider.gameObject;
}
Tile? clickedTile = FindTileComponent(pickedObject);
...
```

- 프리팹 편집 상태에서 사용할 수 있는 로직은 `HandleUtility`가 있다.
```cs
       GameObject pickedObject = HandleUtility.PickGameObject(e.mousePosition, false);

```

- 프리팹 편집 여부를 감지하는 메서드도 있다
```cs
bool isPrefabMode = PrefabStageUtility.GetCurrentPrefabStage() != null;
```

- 마지막으로, 편집 상태에서 타일을 클릭했을 때 유니티의 기본 동작인 해당 오브젝트 활성화도 막는다.
```cs
HandleUtility.AddDefaultControl(GUIUtility.GetControlID(FocusType.Passive));
```


## 250414 - 짭명방

### 밸런싱
- 밸런스와 보상
	- 일단 1스테이지 보상만으로 `1-1`을 잘 깰 수 있는가 -> 충분히 가능함

### 기타 수정
- [x] `InStageInfoPanel` - 0 정예화일 때는 레벨 표시 부분이 사라지게 하고, `Horizontal Layout Group`을 추가해 나머지 부분이 왼쪽으로 밀리게 수정
- [x] 오퍼레이터들의 사이드 패널 중, 공격 속도 부분 : 소수점 둘째자리까지는 볼 수 있게 함(기존 : 0자리)
	- `.ToString("F2")` 라고 한다.(Fixed-Point) 
- [x] `OperatorLevelupPanel`에서 체력을 표시하는 부분에 소수점이 나타나는 현상
	- 체력의 저장 자체는 소수점으로 해야 함 : 게임을 켤 때마다 레벨업이 반영되는데, 레벨당 올라가는 스탯이 소수이기 때문에.
	- ~~경험상 게임에서 체력은 소수로 보여주는 경우는 아예 없었다. 이걸 생각해보면 **체력을 보여줄 때는 값을 하나 올려서 보여주면 될 듯.** ~~
		- 예를 들어서 `537.5`라는 체력을 갖고 있다고 하면, 데이터 자체는 `537.5`로 저장해야 맞음. 위에서 얘기한 레벨업 반영 로직 때문에, 소수값을 버리거나 올리면 시행마다 계산이 달라질 여지가 생기기 때문임.
		- 그런데 소수값을 버려서 보여주면 `537`의 대미지를 받았다고 했을 때 죽지 않는 경우가 있을 것이다. 
		- 하지만 `538`으로 체력을 표시한다면 실제 체력이 `537.5`라고 해도, `537`의 대미지를 받았을 때 죽지 않는 것이 설명이 되고, `538`의 대미지를 받았을 때 죽는 것도 설명이 된다. 여기까지 이 게임을 팔 것 같지는 않지만.
	~~수정) `Mathf.CeilToInt()`으로 체력을 나타내는 부분들 수정.~~
		- 0번째 자릿수로 올림하고 정수로 바꾸는 로직, 
		- `Ceil()`도 소수로 바꿔준다. 
		- 두 메서드 모두 자릿수를 지정하는 기능은 없음
	- **값을 보여주는 방식, 계산하는 방식 모두 버림으로 구현하겠음**
		- 이게 가장 직관적이고 관리하기도 괜찮은 듯. 
		1. 위에서 수정한 `UI`요소들은 전부 `FloorToInt`로 수정
		2. `Operator`, `Enemy`의 `Attack` 메서드는 `Floor`을 반영, `UnitEntity`의 `TakeDamage` 메서드, `CurrentHP`나 `MaxHP` 초기화 로직 등에 모두 `Mathf.Floor()`을 적용함

덤으로, 이런 걸 쭉 보다보니 궁금해진 게 생겼다.
- 실제 데이터는 소수로 관리되어야 할 건 분명함
	- UI 상에서 값을 정수로 보여줄 때 어떻게 보여주는가? 
		- 원본 명방을 참조해보니 **레벨업 패널에서는 값을 버리는 것 같음**
		- 버메일을 예로 들면 렙업당 hp가 5.4 정도 증가함 -> 5렙에서 표시되는 최대 체력은 +21임(5.4 * 4 = 21.6)이므로 버림을 하는 듯
	- 실제로 이런저런 생각을 많이 해봤는데, 결론은 그냥 `TakeDamage`에서 계산이 끝난 다음, 마지막 부분에 어떤 연산을 가할지 정도만 생각해보면 될 듯. 
--> 위에서 말하는 **모두 버림으로 구현**으로 이어짐

- [x] `OperatorUI`의 스킬 사용 가능 아이콘 : 높이 낮추고 크기 줄임
- [x] `FloatingText` 등장 위치 조금 더 높게(`Vector3.up * 0.3f`) 조정
# 이전 일지

- 깃허브 링크는 향후 프로젝트 폴더 링크 이동에 따라 손상될 수 있음
- 이 경우 대부분 `Archive` 폴더로 들어갔을 듯.
## 짭명방
- [짭명방 프로젝트 일지 깃허브 링크](https://github.com/dowrave/TIL/tree/main/Obsidian/1.%20Projects%2C%20Ongoing/%EC%9C%A0%EB%8B%88%ED%8B%B0%20-%20%EC%9E%91%EC%9D%80%20%EB%AA%85%EB%B0%A9%20%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/%EC%9E%91%EC%97%85%20%EC%9D%BC%EC%A7%80/%EC%A7%81%EC%A0%91%20%EC%9E%91%EC%84%B1)
- 옵시디언 링크
	- [[24년 7월]]
	- [[24년 8월]]
	- [[24년 9월]]
	- [[24년 10월]]
	- [[24년 11월]]
	- [[24년 12월]]
	- [[25년 1월]]
	- [[25년 2월]]
	- [[25년 3월]]
	- [[1. Projects, Ongoing/유니티 - 작은 명방 구현하기/작업 일지/직접 작성/25년 4월|25년 4월]]

## 블로그
- [React + Django 프로젝트 일지 월별 작업 기록 깃허브 링크](https://github.com/dowrave/TIL/tree/main/Obsidian/1.%20Projects%2C%20Ongoing/%ED%8F%AC%ED%8F%B4%20%EA%B2%B8%20%EB%B8%94%EB%A1%9C%EA%B7%B8%20%EB%A7%8C%EB%93%A4%EA%B8%B0/%EC%9B%94%EB%B3%84%20%EC%9E%91%EC%97%85%20%EA%B8%B0%EB%A1%9D)
- 옵시디언 링크
	- [[23년 12월]]
	- [[24년 1월]]
	- [[24년 2월]]
	- [[24년 3월]]
	- [[24년 4월]]
	- [[24년 5월]]
	- [[1. Projects, Ongoing/포폴 겸 블로그 만들기/월별 작업 기록/25년 4월|25년 4월]]
