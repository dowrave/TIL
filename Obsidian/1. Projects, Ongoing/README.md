# 참고
- **옵시디언으로 봐야 제대로 보인다.**
	- **옵시디언으로 작성된 만큼 깃허브의 마크다운에서는 지원하지 않는 기능들이 있을 수 있다.** `[[]]`, 이미지 첨부 방식 등이 대표적.
- `[[]]` 링크는 `유니티/보관함`이나 `작업 일지/직접 작성/일지`에 대부분 있다.
---
# 작업 내용 : 짭명방

## 남은 작업
- **이펙트 공부 후 수정 중** 
	- **VFX 그래프를 썼던 것도 모두 파티클 시스템으로 변환**
- 1-3 밸런싱, 보스 추가
- 테스트 및 수정

### 보고 참고할 내용
- [[오퍼레이터들 스탯 정리]]
- [[적 스탯 정리]]
- [[프로크리에이트로 텍스쳐 작업 시 유의할 점]]
## 사용 툴
- `Unity`
- UI 이미지 제작 : `Procreate`
- `VFX` 제작 사용 툴(강의 보면서 따라함)
	- `Krita`
	- `Blender`

## 하고 싶은데 못할 듯
- 캐릭터 스프라이트 
	- 현재 Capsule로 Operator나 Enemy 등을 구현한 상태
	- 이걸 투명한 Quad로 바꾸고 그 위에 2D 스프라이트들을 구현하는 방식이 명방에서 쓰고 있는 방식으로 보임
	- 직접 하려면 배워서 할 수는 있겠지만 시간이 문제겠다. 
- 도전과제 구현
- 인게임 / 다른 패널에서 스킬 범위 보여주기 
	- 일관성 때문에 다른 곳에서도 구현을 해보고는 싶은데, 일단 보류.
	- 현재는 정예화 패널에서만 스킬 범위를 볼 수 있음. 아니면 인게임에서 실행시켜도.




---
# 작업 일지


## 짭명방 예정

### 작업 중

>[!todo]
>- 보스 구현하기
>	- 보스 이펙트 만들기
>- 기존 이펙트 수정하기

>[!todo]
>남은 이펙트 정리해보기
>1. 스킬
>	- 슬래쉬 스킬
>	- 코스트...는 냅둘까?
>2. 보스
>	- 최종적으로 보스까지 구현하면 완료인 듯?


# 250822 - 짭명방

>[!done]
>1. `Caster_AreaEffect` 수정
>2. `MeteorSkill` 이펙트들 구현
>	- `Area` : 발동 시 영역 경계가 잠깐 번쩍이는 효과
>	- `MeteorParticle`
>		- 파티클이 도달하는 위치 이슈 수정
>		- 다른 콜라이더와 충돌해서 먼저 사라지는 이슈 수정
>	- `Hit`
## Caster_AreaEffect 수정
- 번뜩이는게 있어서 구현해봄. 
- 별 건 아니고 예전에 강의 들으면서 완성했던 Lightning 텍스쳐 시트가 있었다. 영역의 벽에 그것들을 붙일 수 있지 않을까? 라는 아이디어에서 출발.

### 텍스쳐 시트를 플레이하는 셰이더
- 기존의 벽이 `Mesh`로 구현되어 있었다. 파티클 시스템을 활용하는 편이 알고 있는 내용이므로 더 빠르게 구현할 수 있겠지만, 이런 생각도 들었다.

>[!question]
>- 셰이더에서 스프라이트 시트나 텍스쳐 시트를 플레이시킬 수 있을까?

- 관련 정보를 찾아보니..
- 유니티 셰이더그래프에서는 `Flipbook`이라는 노드가 있다. 
- 구현도 간단하다.
![[Pasted image 20250822124037.png]]
텍스쳐의 Width, Height를 집어넣고 Tile 인풋으로 속도를 조절하는 방식임.
기존의 Wall 쉐이더에서 시트 기반으로 기능하게끔 Flipbook 관련 노드들만 추가했다.

![[Area_ArcaneField_v1.gif]]

이런 느낌. 텍스쳐가 `Seamless`가 아님 + 언덕 타일에서 영역이 끊어져보인다는 점이 보이지만 지금은 그냥 넘어간다. 

올라오는 전기 아이콘 파티클도 `Vertical Billboard -> Billboard`로 수정했다. 잘 안보이는 것 같아서..

## MeteorSkill 이펙트들 구현

### Area
- 벽 이펙트를 수정함.
- 이 스킬은 일발성 스킬이다. 그래서 스킬의 발동을 알리게끔 번쩍!하고 튀어올랐다가 천천히 가라앉는 느낌으로 구현하려고 함.
- 위에서 캐스터 벽 이펙트로 구현했던 요소를 이용해 스킬이 발동될 때 위에서 경계선이 내려오는 방식으로도 구현해봤음. 
	- 근데 정신없다. 어차피 파티클이 위에서 떨어지는데 경계선까지 위에서 떨어질 이유는 없음.

![[Area_Meteor_v1 1.gif]]
굉장히 정신이 없다. 각 변의 가장자리에서 잠깐 올라왔다가 내려가는 이펙트다. 나오는 타이밍이 정해져 있어야 하므로 **파티클 시스템**으로 구현, 높이를 늘렸다가 줄이는 방식이다.


### Meteor

#### 파티클이 도달하는 위치
- 파티클 자체는 괜찮은데, 파티클이 도달하는 위치가 좀 이상해보였다. 
![[Pasted image 20250822164932.png]]

> 일단 **기절 효과의 마젠타 색깔도 이슈**가 맞지만 그건 지금은 패스하고 저 위치 부분만 봄.

이것저것 만져본 결과, **파티클 오브젝트 자체의 회전값이 `90, 0, 0`으로 들어가는 지점이 문제였던 걸로 보임.** 기존에는 원뿔을 아래 방향으로 맞추기 위해 넣었던 기능으로 보이는데, 지금은 필요 없다. 삭제.
- 왜 그런지는 모르겠지만 회전값이 파티클의 위치에 영향을 준다. 
	- 로컬 좌표계의 원점을 가리키고 있으니 영향을 주지 않아야 정상 아닌가..
	- 피격 대상의 자식 오브젝트로 들어가지만 부모 오브젝트의 영향은 아님.
```cs
// MeteorSkill.cs

// Quaternion.identity로 수정
GameObject meteorObj = Instantiate(meteorPrefab, spawnPos, Quaternion.identity, target.transform);
```

#### 의도하지 않은 콜라이더 충돌 발생
- 또, 원거리 `Enemy`에 한해서 파티클이 도착하지도 않았는데 바로 타격 판정을 발생시키는 현상이 있다. 아마 원거리 적만이 갖는 콜라이더 때문인 듯. 판정 기준을 더 엄격하게 들어가야 한다.
```cs
// MeteorController.cs
    private void OnTriggerEnter(Collider other)
    {
        // 몸통에 닿은 콜라이더에 대해서만 실행되어야 함. 이게 없으면 사거리 콜라이더와 충돌했을 때도 동작함
        BodyColliderController bodyCollider = other.GetComponent<BodyColliderController>();
        
        if (bodyCollider != null)
        {
            UnitEntity tempTarget = other.GetComponentInParent<UnitEntity>();

            // 목표에 닿으면 실행
            if (tempTarget != null && tempTarget == target)
            {
                ApplyDamage();
                ReturnToPool();
            }
        }
    }
```

- 이 부분은 레이어 & 충돌 매트릭스로 특정 레이어끼리의 충돌만 가능하게 하는 방식으로 구현할 수도 있다.
- 근데 **지금의 이슈는 정확히는 `GetComponentInParent`를 바로 썼던 게 문제였음.** `BodyColliderController`인지 체크하고, 이것의 부모 유닛이 `Meteor`의 목표인가?만 점검하면 공격 범위 콜라이더에 걸리는지 여부는 아예 관계가 없는 상황이었다. 
- 그래서 그냥 이렇게 줄일 수 있음. **컴포넌트 점검 로직 자체는 필요하다.**
	- 레이어 & 충돌 매트릭스를 이용하면 성능상 조금 더 좋겠다는 생각은 듦.
```cs
private void OnTriggerEnter(Collider other)
{
	// 몸통에 닿은 콜라이더에 대해서만 실행되어야 함. 이게 없으면 사거리 콜라이더와 충돌했을 때도 동작함
	BodyColliderController bodyCollider = other.GetComponent<BodyColliderController>();
	
	// 목표에 닿으면 실행
	if (bodyCollider != null && bodyCollider.ParentUnit == target)
	{
		ApplyDamage();
		ReturnToPool();
	}
}
```

- 둘 다 정상적으로 동작하는 거 확인함

### Hit
- 어떤 식으로 구현할지 생각 중.
- 바닥에 흔적 남기기

- 결과물
![[Hit_Meteor_v1.gif]]
> 바닥에 `Beam`으로 `Debris`를 남기는 구현이 빠져 있다. 알파값이 0으로 돼있음;


- 타격 이펙트는 `Muzzle` 메쉬를 이용했다. 
	- 메쉬는 여러 개 생기며, 3D 사이즈에 변주가 있음. 
	- 각 파티클은 발생하면 z축으로 커지는 효과를 구현했다.
		- `lifetime`이 너무 길면 어색해보인다. 일단 0.2초는 어색해보였음. 
	- 머티리얼은 `Impact03_Add`를 사용함.
	- 위로 튀는 이펙트, `Muzzle`의 경우 `Alpha Blended` 부분도 구현해봤다.
		- 보통 이런 구현은 `Add` 셰이더보다 살짝 오래 남기는 구현을 가져간다.  그런데 순간적으로 나타났다가 사라지는 이펙트에는 적합해보이지 않음. 눈에 띄긴 하는데, 나쁜 의미다.
		- 그래서 위로 튀는 부분은 AB를 구현했다가 제거했음.

- 바닥에 퍼지는 파티클
	- `Stretched Billboard`를 썼다.
	- 불꽃 이펙트 레퍼런스를 보면서 궁금했던 게 **파티클이 사라질 즈음에 길이가 짧아지는 것이었다.**
	1. **`Length Scale`을 줄일 것**
		- 기본 길이 설정값이다. 이 값이 크면 속도가 줄어도 파티클의 길이가 줄지 않음.
		- 위의 경우 0.01로 설정됨.
	2. **`Velocity Over Lifetime`에서 `Speed Modifier`를 `Curve`로 구현**
		- 위 이펙트의 경우 2개의 커브로 구현됨. **빠른 속도로 퍼져나가되 멀리 퍼지게 하고 싶진 않다면 `Start Speed`를 높이고 `Speed Modifier`가 0이 되는 시점을 빠르게** 가져가면 된다.




## 기타 수정
### SkillRangeVFXController
- **기존**에는 파티클을 바닥에서 올라오게 하고, `Trail`을 남기는 방식으로 구현했음. 이를 위해 `Prewarm`이 필요했고, **`Simulation Speed`를 100으로 올린 다음 1로 되돌리는 방식**을 택했다.
	- 이거 그냥 파티클 시스템에서 `Prewarm`을 켜면 된다.
- 어쩄든 **지금은 해당 기능이 필요없어진 상태고, 굳이 스크립트로 따로 구현할 필요도 없어보인다.** 그래서 삭제.




# 250821 - 짭명방

>[!done]
>1. 셰이더 공부 & 수정
>2. `Wall` 셰이더 구현 및 적용
>3. `MeteorSkill` - 떨어지는 투사체 구현
>	- 타격이랑 범위 이펙트는 내일!
## 셰이더 탐구 : AddScroll과 Trail
- 어제 벽 효과 관련, `AddScroll` 쉐이더랑 `Trail` 쉐이더의 차이점을 알고 싶어졌다. 
	- 원하는 효과는 `Trail`인데, `AddScroll`도 그게 가능하지 않을까 싶어서 테스트해봤는데 그런 느낌이 나지 않았기 때문이다.

### `Trail` 쉐이더
![[Pasted image 20250821124715.png]]
> `Add`로 들어오는 `A`는 `Simple Noise`에 스크롤을 더한 값.

- 분석
	- `One Minus`는 왼쪽이 1, 오른쪽이 0인 행렬
	- `Add`로 노이즈 값들이 더해짐
	- 여기서 왼쪽이 0, 오른쪽이 1인 행렬을 뺌
	- 최종적으로 왼쪽은 1보다 크거나 1에 가까운 값들이 주로 오고 오른쪽은 0에 가까운 값들이 주로 오게 됨. 노이즈에 따라 값 편차는 있겠지만 전체적으로 이런 경향을 따르는 편.

### `AddScroll` 쉐이더
- 원리는 위와 크게 다르지 않다.
- 차이점
	1. `Gradient Noise`를 썼다는 것
	2. `UV`의 R값들을 이용한 `Color` 계산이 들어가지 않았다는 것
- 그래서 상대적으로 텍스쳐를 탄다. 


### 결론
- `AddScroll`로도 구현이 가능하다. 단, 텍스쳐를 탄다.
- `Trail`은 `U`값을 기반으로 한 밝기 설정이 추가로 들어가 있다. 그래서 어떤 텍스쳐를 받아도 방향 설정만 잘 해두면 일렁이는 효과를 낼 수 있다.
- **알파 클립 기능은 이런 경우에는 이용하지 않는 편이 더 좋아보인다.** 물론 케바케지만, 전체적인 알파 값들이 그렇게 밝지 않기 때문에 살짝만 건드려도 이펙트가 어색해보임.
- 불이 일렁이는 듯한 효과는 `Simple Noise`가 일단은 더 그런 느낌으로 보인다. 

![[Pasted image 20250821134243.png]]
> 왼쪽이 `Trail` 쉐이더를 이용한 `Quad`, 오른쪽이 `AddScroll` 쉐이더를 이용한 `Quad`이다.

## 셰이더 수정
- `Trail, AddScroll`에 노이즈에 `Power` 값을 곱하는 프로퍼티 추가
- ~~`AddScroll`의 경우 `Simple Noise`와 `Gradient Noise` 중 선택 가능하게 구현~~
	- `Simple Noise`를 선택하는 경우의 효과가 미미함. 추가적인 세팅이 들어가야 할 것으로 보여서 일단 `Gradient Noise`만 사용 가능하도록 유지함.

### Gradient Noise에 마젠타색이 나타나는 현상
- `Gradient Noise`에 `Power`를 연결했을 때 발생하는 현상.
![[Pasted image 20250821134001.png]]

- 이유)
	- **`Gradient Noise`는 -1 ~ 1 사이의 값을 갖는다.** 
	- 그래서 음수의 거듭제곱을 시도할 때, 예를 들어 `(-2)^5/2` 같은 연산도 발생할 수 있다. 음수의 제곱근은 실수 범위에서 존재하지 않기 때문에 `NaN`을 반환하게 된다.

- 해결)
	- `Gradient Noise`에 `Power`를 사용하려는 경우에는 `Remap`이나 `Saturate(0, 1 사이로 강제 제한)` 등을 연결해서 사용해야 한다.

## Wall 셰이더 만들기
- 텍스쳐의 좌우 스크롤 + 노이즈의 상하 스크롤로 텍스쳐에서 파티클들이 시작해서 서서히 위로 올라가면서 사라지는 듯한 효과를 주려고 함
- 생각보다 쉽진 않다. **텍스쳐의 경계와 노이즈의 경계가 부드럽게 녹아드는 느낌이 잘 안 나기 때문**임. `Lerp`라든가 `SmoothStep`이라든가 다 써보긴 했는데 잘 모르겠다. 스읍..
![[Pasted image 20250821152842.png]]
> 일단은 이런 느낌으로 마무리. 

> 인게임에서 보면 이런 느낌으로 들어갔다. 생각보다 괜찮다. 
> - 연기가 조금더 올라갔으면 하는 생각이 있다. 텍스쳐 모양만 어떻게 잡으면 구현이 될지도 모르겠다.
![[Area_CasterSkill_v1 1.gif]]

## MeteorSkill - 떨어지는 물체 구현
- 특사스의 3스킬이 모티브이긴 한데, Mesh로 구현해야 할까? Billboard로 구현해야 할까?
- `Mesh`로 검 모양을 만들고 모서리마다 윤곽선을 그리는 방식을 시도해봤는데, UV Map 만드는 부분에서 막혔다. **어디를 잘라야 전개도가 잘 그려지는지 감이 안 잡힘.**
- 그래서 텍스쳐만 만들고 빌보드 파티클을 이용하는 방식으로 구현한다.

![[Area_Meteor_v1.gif]]
> `MeteorSkill`은 타겟의 좌표를 정확히 추적하면서 y좌표만 +에서 -로 내리꽂는 방식인데, 이상하게 게임 화면에서는 살짝 뒷쪽으로 떨어지는 듯한 인상이 있다. 
> 근데 뚜렷한 해결법은 모르겠음.

**`Hit` 이펙트랑 `Area` 이펙트는 내일 해야겠다. 오늘 `Hit` 이펙트에 사용할 텍스쳐를 만들어봤는데 잘 모르겠음..**

## 기타 수정
- `Projectile`의 콜라이더 크기 `0.1`로 통일
	- 기존) `0.25` : 오브젝트에 부딪히기 전에 사라지는 것처럼 보여서.

- `MeteorSkill` 스크립트 수정
	- 메테오를 소환하는 로직 수정
		- 기존에는 2개를 만들어 놓은 다음 딜레이 후 1개씩 떨어뜨렸다면
		- 1개를 만듦 -> 딜레이 -> 다시 1개를 만드는 방식으로 수정함
	- `MeteorSkill` 자체는 `ScriptableObject`의 상속이므로 `Coroutine`의 실행이 불가능하다. `Operator`에 실행을 요청하는 방식으로 넣으면 됨. 이 때 `IEnumerator` 메서드는 `public`일 필요는 없는 듯?
```cs
	if (enemyIdSet.Add(enemy.GetInstanceID()))
	{
		// 코루틴은 Monobehaviour을 받는 객체에서만 실행 가능
		// 이 스크립트는 ScriptableObject의 상속임. 실행 가능한 객체에게 요청한다.
		op.StartCoroutine(CreateMeteorSequence(op, enemy));
	}
```



# 이전 일지

- 깃허브 링크는 향후 프로젝트 폴더 링크 이동에 따라 손상될 수 있음
- 이 경우 대부분 `4.Archive` 폴더에서 볼 수 있다.
## 짭명방
- [짭명방 프로젝트 일지 깃허브 링크](https://github.com/dowrave/TIL/tree/main/Obsidian/1.%20Projects%2C%20Ongoing/%EC%9C%A0%EB%8B%88%ED%8B%B0%20-%20%EC%9E%91%EC%9D%80%20%EB%AA%85%EB%B0%A9%20%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/%EC%9E%91%EC%97%85%20%EC%9D%BC%EC%A7%80/%EC%A7%81%EC%A0%91%20%EC%9E%91%EC%84%B1)
- 옵시디언 링크
	- [[24년 7월]]
	- [[24년 8월]]
	- [[24년 9월]]
	- [[24년 10월]]
	- [[24년 11월]]
	- [[24년 12월]]
	- [[25년 1월]]
	- [[25년 2월]]
	- [[25년 3월]]
	- [[1. Projects, Ongoing/유니티 - 작은 명방 구현하기/작업 일지/직접 작성/25년 4월|25년 4월]]
	- [[1. Projects, Ongoing/유니티 - 작은 명방 구현하기/작업 일지/직접 작성/25년 5월|25년 5월]]
	- [[짭명방_25년 6월]]
	- [[짭명방_25년 7월]]
	- [[짭명방_25년 8월]]
## 블로그
- [React + Django 프로젝트 일지 월별 작업 기록 깃허브 링크](https://github.com/dowrave/TIL/tree/main/Obsidian/1.%20Projects%2C%20Ongoing/%ED%8F%AC%ED%8F%B4%20%EA%B2%B8%20%EB%B8%94%EB%A1%9C%EA%B7%B8%20%EB%A7%8C%EB%93%A4%EA%B8%B0/%EC%9B%94%EB%B3%84%20%EC%9E%91%EC%97%85%20%EA%B8%B0%EB%A1%9D)
- 옵시디언 링크
	- [[23년 12월]]
	- [[24년 1월]]
	- [[24년 2월]]
	- [[24년 3월]]
	- [[24년 4월]]
	- [[24년 5월]]
	- [[1. Projects, Ongoing/블로그 만들기/월별 작업 기록/25년 4월|25년 4월]]
	- [[1. Projects, Ongoing/블로그 만들기/월별 작업 기록/25년 5월|25년 5월]]
	- [[블로그_25년 6월|블로그_25년 6월]]
	- [[블로그_25년 7월]]