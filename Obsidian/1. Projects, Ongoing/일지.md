- `240808~` : **Claude AI를 이용한 뒤에 대화가 너무 길어지거나 다른 내용으로 바꾸려고 하면 마지막에 지금까지 한 내용을 정리해달라는 식으로 넣겠음** 
	- 여기에 직접 정리하지 못하는 내용들은 거기에 들어간다. 물론 다 반영 안될 수 있음. AI가 던져준 코드를 쓰는 대신 다른 코드를 쓸 수도 있기 때문에!

# 앞으로 구현할 거 정리

## 유사 명방
- 게임적인 목표
	- 스테이지 : `1-1 ~ 1-3` 까지 구현하기
	- **최소 8명**의 오퍼레이터 구현 (스킬도 일단은 1개씩만 구현)
- 시스템 관련
	- 경로
		- 지금 하는 a* 알고리즘이 아니라 개발자가 직접 설정할 수 있어야 함
		- 즉 Spawner는 적의 종류, 적이 생성되는 시간을 갖고 있어야 함
			- 여기서 생성되는 Enemy는 자신의 경로를 갖고 있어야 함 
			- 상대 경로로 들어갈지 그리드 좌표로 일일이 넣을지는 그 때 가서 생각해보자.
	- `OperatorManager`에서 받는 오퍼레이터들의 정보는, 이전 씬에서 가져와야 함(이를 `편성 씬`이라고 하자)
	- 육성 요소 추가
		- 스테이지를 저런 식으로 구현할 거면, `레벨업 재화`를 1-1 시작 전에 얼마를 주고, 스테이지를 클리어할 때마다 `레벨업 재화`를 오퍼레이터에게 사용해서 육성을 시키게끔 구현하는 것도 괜찮을 듯(어떤 오퍼레이터에게 사용할지는 유저가 정하는 방식, **한정된 재화를 어떻게 사용할 것인가?**)
		- 오퍼레이터가 특정 레벨에 도달하면 재능(패시브)을 얻게 하거나 또다른 액티브 스킬을 얻게 하는 방식도 넣어볼 만 하겠다.



## 블로그
- 데이터가 제때 수집되고 있는지 눈팅 정도만 하면 충분할 것 같다.
- 사실 Quill을 쓰면서 되돌리기 / 붙여넣기 기능이 좀 이상하게 작동하고 있는 문제가 있긴 한데... 언제 해결할지는 모르겠음?

## 현재 발생 중인 문제

# 9월

## 240913
> 가장 먼저 할 일 : 수정된 Stats, Data 들로 기존 Entity, Operator, Enemy 스크립트 수정하기



## 240912
[[240912 정리]]
### 유사 명방

#### 리팩토링
- [[Unity - Vector3.MoveTowards]]
- `Enemy, Operator`까지는 정리 완료, 이제 배치 로직 정리 시작
![[Pasted image 20240912230100.png]]
> OperatorData를 살펴보니 이런 식으로 `Stats`가 중복해서 나타나는 현상이 있다. ㅡㅡ

- `Stats`, `Data` 관련 로직들은 다 뜯어 고침. 이들의 상속 구조를 없애고 모두 개별 필드로 정의했다. 이게 제일 쉽겠다. 하..
- 이걸 이용하는 기존 객체 스크립트는 내일 고치자. 후...

## 240911

### 유사 명방

#### 시작 전 구조에 대한 생각
- 커피를 사러 가다가 이런 생각이 들었다. 
- 지금의 프로젝트 구조는 아래의 방식으로 스탯을 사용하고 있다.
```
UnitEntity : UnitStats currentStats
	- DeployableUnitEntity : DeployableUnitStats currentStats
		- Operator : OperatorStats currentStats
```
여기서 피격 로직은  `UnitEntity`에 정의되어 있고 그 메서드는 `UnitStats currentStats`의 필드의 값을 가져와서 사용하는 방식이다. 그러면 메서드를 상속받은 `currentStats`에서는 `UnitStats`을 사용하나? `currentStats`을 사용하나?

> 자식 클래스에서 동일한 변수명을 재정의하고 있기 때문에, 부모 클래스의 `currentStats`은 숨겨진다. 

- **스탯은 `구조체 -> 클래스`로 바꿨음!**

#### 리팩토링
- `Operator.cs` 정리 얼추 됨. `Enemy` 관련 스탯과 `EnemyData` 정리 시작.
- 스탯을 프로퍼티로 관리해야 하는지 여부에 대해서 계속 고민이 많다. 진도가 생각보다 못 나가고 있음.



## 240910

### 유사 명방
[[240910 정리]]
#### 리팩토링
- `DeployableUnitEntity` 및 여러 인터페이스를 기반으로 `Operator, Barricade` 구현
- 기존 `Deployable`을 사용하던 다른 스크립트들도 수정
- [[Unity - 스크립터블 오브젝트]] 하단에 보충 설명 추가.
	- `Stats`은 구조체로 구현하는데, 스탯도 자식 클래스로 가면서 더 많은 것들을 사용해야 해서 어떻게 구현할지 고민했음. **부모 클래스에서 사용하는 구조체의 필드를 자식 클래스에서 사용하는 구조체의 필드로 복사 / 붙여넣기**해서 사용함. 
		- 이렇게 안 하면 `구조체.구조체.구조체.필드` 같이 필드로 접근해야 하고, 어떤 필드가 어떤 구조체에 있는지 파악하는 것 등 여러모로 번거로워짐
		- 각 클래스의 `Initialize`도 추상화하지 않고 각각의 `ScriptableObject`를 초기화하는 방식으로 변경함
		- 이러면 상속의 의미가 조금 애매해지는 거 아닌가? 싶었는데, 부모 클래스에서 자식 클래스로 오버라이드하는 메서드들이 있기 때문에 크게 상관 없을 것 같다. 



## 240909

### 유사 명방

#### 리팩토링
- 리팩토링을 한 번 하기는 했는데, 그 결과물이 그렇게 만족스럽다는 느낌은 아니어서 아예 싹 한번 다시 갈아엎겠음
	- 명방 게임 자체는 장애물 같은 배치 가능한 요소도 그냥 오퍼레이터처럼 처리되게 만든 것 같음. 단, 방향을 지정하는 로직 자체는 없는 듯.
- 일단 타일 위에 배치되는 / 돌아다니는 요소를 위한 `UnitEntity`의 구현부터 시작.
- `DeployableUnitEntity`까지 구현하고, `Operator`나 `Barricade`의 공통된 기능들을 정리
★ 아직 실행 불가능. 최종적으로 배치 로직까지 완전히 적용되어야 완료된다.


## 240906
[[240906 정리]]
### 유사 명방

#### 배치 로직 리팩토링
> 어제 발생한 문제들 수정 중
> - 화면 하단의 패널의 아이콘 색깔들이 흰색으로 되는 현상
> - `IDeployable` 드래그 시, 미리보기가 동작하지 않음
> - 배치 방향 설정 같은 것도 나타나는 듯 보이는데, 실제로 배치될 요소가 나타나거나 하지는 않고 있음.

* 수정 완료
	- 색상 변하는 문제
	- 미리보기 나타나지 않는 문제
	- 하단 패널 / 오퍼레이터 클릭 시 카메라가 이상하게 이동하는 현상
- 새로 발견한 문제 -> 해결 완료
	- 오퍼레이터 퇴각 버튼 눌러도 동작하지 않음 
	- 바리케이드 클릭해도 ActionUI 나타나지 않음

- 이제 장애물 배치하고 나서 적의 경로 바뀌는 구현하면 될 듯? 
- 바리케이드 관련 아직 남은 문제도 있음


## 240905
[[240905 정리]]
### 유사 명방

#### 바리케이드 구현, BottomPanelOperatorBox 리팩토링
- 만들고 복잡해져서 엎기를 수 차례 반복했다..
- 일단 전체적인 과정 자체는 마무리가 됐는데, 여전히 머릿속으로 정리가 되지 않는 것들이 있음. 급하게 가지 말고 차근차근 해야 할 것 같다. 예를 들면 `IDeployable`을 상속받는 `Operator`, `Barricade` 만으로는 약간 부족한 느낌이 듦. 차라리 클래스를 상속받게 하는 게 나을지도.
	- 근데 추상 클래스를 또 구현하면 `Unit` 상속과 충돌이 일어난다. `Unit`은 `Enemy`로 또 이어지기 떄문에, 골치가 아픈 부분.
- IClickable를 IDeployable로 통합.

> 대략적인 수정은 마친 상황에서, 현재 발생중인 문제
> - 화면 하단의 패널의 아이콘 색깔들이 흰색으로 되는 현상
> - `IDeployable` 드래그 시, 미리보기가 동작하지 않음
> - 배치 방향 설정 같은 것도 나타나는 듯 보이는데, 실제로 배치될 요소가 나타나거나 하지는 않고 있음.




## 240904
[[240904 정리]]
### 유사 명방

#### 오류 수정
- 배치 중인 오퍼레이터가 미리보기 상태일 때 `Enemy`가 오퍼레이터를 공격하는 문제 수정
	- `isDeployed` 필드를 `IsDeployed`라는 프로퍼티로 관리

#### 스크립트들 정리
- 어제 작업하면서 이게 왜 여기 있지? 하는 느낌이 드는 부분들이 종종 있었다. 이 부분을 정리해보려고 함.
- 크게 `Unit, Enemy, Operator`를 만지고 있는데, 또 되던게 작동 안하기 시작. ㅡㅡ 
	- `Data` 들을 뜯어고치는 과정에서 `Melee`로 지정되어 있었다. 후... 그래서 `AttackRange` 값이 `0`으로 나타났기 때문에 작동을 안했던 것.
```cs
Operator op = collider.GetComponent<Operator>();
```
> 여기서 `collider`는 자식 오브젝트인 `model`에, `Operator` 스크립트는 부모 오브젝트에 있는데도 동작했다. 왜냐하면 `GetComponent`는 해당 오브젝트에 스크립트가 없다면, 부모 오브젝트로 거슬러 올라가며 뒤지기 때문이다.
> 따라서, 작동은 하지만 (큰 차이는 없더라도) 성능적인 열화가 있을 수 있다. `GetComponentInParent`로 수정.

#### 바리케이트 구현
- `바리케이트` : 타일 위에 배치해서 적의 경로를 비틀 수 있음
- 기존 오퍼레이터와 동일하되 약간의 차이가 있는 구현을 해야 하는데, 이거 설정이 생각보다 까다롭다. 바꿔야 할게 좀 많기 때문이다.
- 근데 기존 깃으로 되돌리기에는 경로 변경 시 수정 사항을 작업해 놓은 게 있다.  바리케이드 스크립트, 오브젝트까지는 냅두고, 나머지 로직들을 원상복구 해놓겠음.




## 240903

### 유사 명방

- 경로 설정 과정에서 `Enemy`의 포지션이 타일 속으로 묻히는 문제가 있었음
	- `targetPosition`의 좌표 설정 시 `Vector3.up * 0.5f`를 더해주면 됨

#### 원거리 적 구현하기
- 공격 범위는 "값"으로 구현하겠음 : 적은 이동하면서 쿨타임이 돌 때마다 **가장 최근에 배치된 적을 공격함**
- `RangedEnemy`라는 클래스를 따로 구현하는 것도 생각해봤는데, 실질적으로 차이는 `EnemyData`에 `EnemyType`을 두고(`Melee, Ranged`) `AttackRange`값의 차이 만으로 실질적인 동작의 차이가 발생할 것 같아서 별도로 구현하지는 않음. 즉, `Enemy` 하나에 근거리, 원거리 동작을 다 포함시킨다.
- 이전에 `Unit`에 근/원거리 여부나, 공격 타입 등이 설정되어 있어서 `EnemyType`을 쓰지 않고 해당 `enum` 타입들을 사용하고 있음.

- 코드를 나중에 한 번 고칠 필요는 있을 것 같다. 상속이 큰 의미가 없는 경우도 있고..

## 240902
[[240902 정리]]
### 유사 명방
- 오퍼레이터 배치 시, 몇몇 하이라이트된 타일에 배치가 불가능한 문제 수정 
	- 예전에 맵을 수정한 적이 있었는데, 거기서 새로운 타일을 생성한 경우, 해당 타일이 하이라이트되지만 그 위에 스냅핑이 되지는 않는다.
	- `OperatorManager.cs`를 살펴보면 `GetHoveredTile` 메서드에서
```cs
    private Tile GetHoveredTile()
    {
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        RaycastHit hit;

        if (Physics.Raycast(ray, out hit, Mathf.Infinity, tileLayerMask))
        {
            return hit.collider.GetComponentInParent<Tile>();
        }

        return null; 
    }
```
> 위와 같음. 즉, `tileLayerMask`라는 레이어를 레이캐스트로 검사한다.
- 실제로 새로 에디터로 만든 타일들에는 `Tile` 레이어가 할당되어 있지 않다. 하이라이트 자체는 잘 작동함.
	- 따라서 타일이 생성될 때 레이어에 `타일` 레이어를 지정하는 것만으로 충분함

- `Map.cs`의 메서드 이름 수정 : 기존엔 메서드의 역할이 불분명하거나 이름만으로 어떤 기능을 하는지 직관적으로 파악하는 게 어려웠음

- 오퍼레이터 배치 동작 시 시간이 느려졌다가 원상복구될 때, 2배속임에도 1배속으로 돌아오는 현상 수정, `OperatorManager`에 있는 시간 관리 메서드들을 `StageManager`로 통합

- 일단 보이는 문제는 다 처리한 듯?

#### 경로 설정하기
- 기존엔 `PathfindingManager`를 이용해서 최단 경로를 찾는 알고리즘으로 구현했다.
- 그런데 실제 명방을 보면, 어떤 위치에서 몇 초 쉰다든가, 아니면 빙글빙글 돈다든가 하는 식으로 개발자가 직접 경로를 설정하는 것으로 보이는 예시가 많았다.
- 그래서 이번엔 경로를 직접 설정하는 방식을 구현해보려고 함.
- 아예 `ScriptableObject`에 `PathData`를 만들고, 여기에 유니티 엔진 상에서 씬 뷰를 클릭해서 해당 타일을 경로에 넣는 방식으로 직접 편집할 수 있게끔 구현하고 있다. 
- 그런데 `Tile` 레이어로 설정하면 `Scene` 뷰에서는 안 보이는데 `Game` 뷰에서는 보이는 문제가 있다. ???? `Culling Mask` 이슈도 아니다.
	- 그냥 `Tile` 레이어를 옮겼다. 나중에 충돌이 나는 사안이 있다면 그때 보자.
- 대기 시간도 설정을 한 상태인데, 대기가 끝나면 다음 노드로 옮겨야 하는데 그러지 못하고 그 자리에서 그대로 끝나버리는 현상이 있었다
	- 인덱스만 잘 추적시켜 놓으면 된다. 


## 240901

### 유사 명방
- 공격 범위에서 적이 벗어나도 계속 공격하는 문제 해결
- `StageManager`에서 `UIManager` 의 역할을 하는 부분을 `UIManager`로 옮김
- 사실 원래 계획은 버튼의 클릭 이벤트가 마우스 버튼다운 때 1번, 마우스 버튼 업 때 1번 총 2번 발생하는 걸 해결하려는 계획이었는데, 정작 이건 해결 못하고 있음.
	- **`ClickDetectionSystem`과의 충돌 때문 아닐까??** 실제로 `MouseButtonDown` 때 `HandleClick` 메서드가 발동되도록 하고 있다.
	- `MouseButtonDown`과 `Click`을 구분했다.

- 머릿속으로 생각하려니 계속 헷갈려서 동작을 정리함 : [[마우스버튼다운, 클릭 동작 정리]]
	- 문제 자체는 해결됐다. 근데 갈수록 스파게티 코드가 되고 있는 것 같다..
	- 며칠 동안 헤맨 문제여서 해결한 것에 의의를 둬야겠음.

- `Button` 컴포넌트의 `OnClick`의 경우, 별도로 구현하지 않더라도 유니티의 UI 시스템에 의해 기본적으로 동작한다. 따라서 `ClickDetctionSystem`에서 굳이 별도로 `onClick.Invoke()`를 구현할 필요는 없다. 이거 구현하면 2번 실행됨.

