## 참고
- **옵시디언으로 봐야 멀쩡하게 보임!!!**
- **옵시디언으로 작성된 만큼 깃허브의 마크다운에서는 지원하지 않는 기능들이 있을 수 있다.** `[[]]`, 이미지 첨부 방식 등이 대표적.
- `[[]]` 링크는 `유니티 - 보관함`이나 `일지`에 대부분 있다.

## 블로그
- 데이터가 제때 수집되고 있는지 눈팅 정도만 하면 충분할 것 같다.
- 사실 Quill을 쓰면서 되돌리기 / 붙여넣기 기능이 좀 이상하게 작동하고 있는 문제가 있긴 한데... 언제 해결할지는 모르겠음?

## 작업 예정

### 유사 명방(전체)

#### 진행 중
#### 구현 예정
- 스테이지 1-1 ~ 1-3 구현

#### 발생 중인 이슈
- `StageData`의 `Spawner`들 관리하는 거
- (241216) 레벨업 후에 `OperatorLevelUpPanel`의 스냅핑 동작이 정상적으로 동작하지 않을 때가 있다. 

- 간헐적인 문제
	-  `Enemy` 기준, 바리케이드 파괴 로직이 동작하지 않는 현상이 있음

#### 하고 싶은데 못할 듯
- 캐릭터 스프라이트 

# 1월

## 250128
### 짭명방

- 아쉬운 게 살짝 있는데 그냥 마무리함
	- 갈수록 창의력의 부족과 표현의 부족을 느끼므로 원본 게임을 참조할 수밖에 없게 되었다

#### 스킬 아이콘 추가(2)
![[ForObsidian_Skill_ArcaneField.png]]

![[ForObsidian_Skill_AreaHasteHeal.png]]

![[ForObsidian_Skill_Meteor.png]]
> 이게 인게임에서 보면 뚜렷하지 않아서 아쉬운데 고치는게 귀찮음

![[ForObsidian_Skill_Shield.png]]

![[ForObsidian_Skill_Slash.png]]
> 얘도 인게임에서 보면 사이즈가 더 작아서 뒤의 궤적이 천 같은 느낌으로 있음

## 250127

### 짭명방

#### 스킬 아이콘 추가
- 프로크리에이트 작업 - 6개 완료
- 스킬 아이콘의 서식은 **당연히 원본 명방을 참조**
![[ForObsidian_AttackUp.png]]

![[ForObsidian_CostRecovery.png]]

![[ForObsidian_Skill_DefenseUp.png]]

![[ForObsidian_Skill_DoubleShot.png]]

![[ForObsidian_Skill_HealUp.png]]

![[ForObsidian_Skill_Smash.png]]
- 의외로 방어력 증가는 노란색이고 힐 쪽은 파란색을 쓰고 코스트는 초록색을 쓰더라

#### 기타 수정 완료 사항
- 인벤토리 패널 : 1정예화인데도 스킬 설정이 불가능해지는 현상 수정
- 디테일 패널에서 디폴트 스킬을 변경했을 때 디폴트 스킬이 바뀌었음을 알리는 메시지 띄우기
- 스쿼드에 OwnedOperator 정보를 넘길 때, 현재 선택한 스킬을 넘기지 못하는 현상이 있었음
```cs
    private void OnConfirmButtonClicked()
    {
        if (selectedSlot != null && selectedSlot.OwnedOperator != null)
        {
            selectedSlot.OwnedOperator.SetStageSelectedSkill(selectedSkill);
            //selectedSlot.OwnedOperator.StageSelectedSkill = selectedSkill;
            GameManagement.Instance.UserSquadManager.ConfirmOperatorSelection(selectedSlot.OwnedOperator);
            // 돌아가기
            ReturnToSquadEditPanel();
        }
    }
```
> StageSelectedSkill이라는 프로퍼티가 게터, 세터 모두 public이었다. 이걸 게터만 남기고 세터는 `SetStageSelectedSkill`이라는 별도의 메서드를 만들어서 오퍼레이터 자체에서 새로운 스킬을 받는 메서드를 실행시키도록 변경함



## 250126

### 셰이더 공부
- [이 동영상](https://www.youtube.com/watch?v=KnueAgpUL3Y&t=1042s) 참고
- 어쩌면 난 이미 필요한 것들을 얼추 알고 있었을지도 모르겠다. 이게 들을 때는 내가 막 다루면 잘 될 것 같은데, 생각보다 어려울 때도 많음
- 그래도 기본적인 각 버텍스가 갖는 벡터들, 렌더링 순서라고 해야되나 계산되는 순서 같은 걸 알 수 있어서 좋았음. 아쉽다면 템포가 조금 빠른 편이고 어떤 맥락에서 이 설명을 하는지가 좀 헷갈렸다. 순서가 어느새 넘어가 있기도 하고.. 
- 책을 사서 공부해봐야 할까?


## 250124

[[250124]]
> `Claude`의 `Project`에서, 문서가 73% 정도 쌓이니까 대화가 길어지는 경고문이 뜰 쯤에 5시간 동안 사용할 수 있는 횟수가 벌써 소진되었음.
### 짭명방

- 오늘의 목표는 크게 2개이다
	- `OwnedOperator` 관리 방식(완료)
	- 스킬 선택 UI 구현
#### OwnedOperator 관리 방식
이전에는 연산을 반복한다는 이유로, `OwnedOperator`에 레벨 정보뿐만 아니라 아예 스탯 정보까지 집어넣는 식으로 구현했었다. 그런데 위 방식의 문제점은, 밸런스 수정 등을 하면 기존에 들어가 있던 정보들을 다시 계산할 필요가 생김. 

따라서 이전에 엎었던 방식인, 핵심 정보(오퍼레이터의 레벨, 정예화 단계) 등만 저장하고 **게임을 켤 때마다 스탯, 보유한 스킬 등을 새롭게 계산해서 메모리에서 갖고 있는 식으로 수정**하겠음

##### 궁금해진 지점
> 저장된 데이터를 불러올 경우 생성자가 동작하는가?
- **동작 안 한다.** 
- 따라서 새로운 OwnedOperator 데이터를 만드는 상황과 기존에 저장된 OwnedOperator를 불러와서 스탯, 공격 범위, 스킬 초기화를 구현하는 과정은 별도로 진행되어야 한다. 같은 메서드를 쓰더라도 **불러오는 상황에서는 생성자를 쓰지 않는 점**을 염두에 두자.

#### 스킬 선택 UI 구현
이걸 구현해야 하는 지점은 크게 두 곳
- `OperatorInventoryPanel`의 좌측 하단
	- 여기서 지정되는 스킬은 스쿼드에 들어갈 때 사용할 스킬임
- `OperatorDetailPanel`의 우측 중앙(레벨업 아래 지점)
	- 여기서 지정되는 스킬은 기본으로 설정되는 스킬
	- 즉, `OperatorInventoryPanel`의 해당 OperatorSlot을 클릭했을 때, 디폴트로 설정되는 스킬임

![[Pasted image 20250124213212.png]]

![[Pasted image 20250124213228.png]]

![[Pasted image 20250124213251.png]]
이런 느낌으로 들어갔음.

> 생각해보면 실제 명방에서 `OperatorInventoryPanel`의 경우

```
스킬 아이콘 | 스킬 설명
```
같은 느낌으로 들어가 있던 것 같은데.. 이미 구현했으니 냅두자.


#### 이슈 컨트롤
1. 새로 생성된 데이터들의 스킬 범위 표시가 나타나지 않는 이슈
	- 공격 범위의 초기화는 `OwnedOperator.Initialize`에서 진행되었는데, 생성자에는 이 메서드가 들어가 있지 않았기 때문에 공격 범위가 정상적으로 나타나지 않았음.
	- `Initialize`를 생성자에 넣고, 중복되는 스크립트는 제외해서 해결.

2. 경험치 게이지 서식 깨졌다.. 불편. 왜 깨졌지????


## 250123
[[250123]]
### 짭명방

#### AreaHasteHeal 이펙트 구현
- **최종) 그냥 이거에 대해선 벽 모양만 바꿨다, 셰이더 그래프 연습했다고 생각하고 넘어가겠음.** 
	- 원래 구현하려던 건 장판에서 일정 시간 간격으로 힐이 동작할 때 이펙트에 연동시키려는 것이었음

> 이 정도로만 구현하고 넘어간다. 안 그래도 할 건 많음.
![[Pasted image 20250124011923.png]]



아래는 시행착오 과정. 최종적으로는 힐에 동반되는 VFX 동작은 구현하지 않았다.
##### 시행착오 과정
- 셰이더 그래프를 다루는 게 어렵다. 확실히.. 
	- 뭘 구현하고 싶은지도 뚜렷하지 않은 상태라서 더 그런 것도 있음.
	- 하루 종일 고민해봤는데 딱히 해소되는 건 없어서, 다른 이펙트의 벽 부분과 달리 해당 이펙트의 벽 부분은 파티클 이펙트를 없애고, 힐이 발동하는 시점에만 **이미지**가 나타나고 사라지는 식으로 구현하려고 했는데
	- 벽을 메쉬로 구현할 경우 기존 `SkillRangeVFXController`의 리팩토링이 필요해진다. 파티클 시스템을 쓸 것을 전제로 코드를 작성했기 때문에 추가적인 수고로움이 들어감

- 따라서 그냥 파티클 시스템을 유지하되, `AreaHasteHealVFXController`는 힐이 들어오는 타이밍에만 이펙트를 플레이하도록 함

![[Pasted image 20250124000606.png]]
> 여기서 벽 부분은 기존 스크립트랑 크게 차이가 없다. 

#### 기타 수정 사항
- `AreaHasteHealSkill.cs`에서, 시전자의 방향을 고려하지 않는 문제 수정

## 250122
[[250122]]
### 짭명방
#### 메딕 2스킬 구현
- 프틸롭시스의 2스킬과 비슷한 구현
	- 프틸은 기본이 멀티 힐러라서 단순히 공격 속도 감소만 구현하면 됐지만 내 프로젝트의 메딕은 기본이 단일 힐러이므로 멀티 힐도 함께 구현해야 함
	- 이걸 구현하는 방법으로는 크게 2가지가 떠오른다.
		1. 기본 공격 중지 + 범위 내의 모든 아군을 힐하는 장판을 구현하는 것
		2. 기본 공격은 나가게 하되, 힐이 들어가는 방식이나, 공격 속도를 일시적으로 증가시키는 것
	- `AreaEffectSkill`의 구현을 고려했을 때에는 **1번 방법이 훨씬 좋아보임.** 다 기본적으로 따라가는 기능임.

- 장판 스킬의 효과를 구현하는 `FieldEffectController`라는 추상 클래스를 추가하고, `ArcaneFieldController`와 `AreaHasteHealController(메딕 2스킬)`은 이들을 상속받도록 구현함.
##### 상속 코드 구현에 관한 고민
- 예를 들어서 Initialize를 할 때
```cs
// 부모 추상 클래스의 필드
    protected Operator caster; // 시전자
    protected Vector2Int centerPosition; // 중심 위치
    protected HashSet<Vector2Int> affectedTiles; // 실제 영향을 받는 타일들
    protected float fieldDuration; // 지속 시간

// 자식 리프 클래스의 필드
    private float damagePerTick;
    private float slowAmount;
    private float damageInterval; 

// 어차피 리프 클래스에서는 이렇게 구현해야 함
public void Initialize(Operator caster, Vector2Int centerPosition, ...)
```
내가 고민한 지점은
1. 코드의 중복을 감수하고 부모 클래스에서 Initialize를 하고 오버라이드해서 자식 클래스에서 추가 구현하기 
2. 어차피 자식 클래스에서 모든 인수를 받으니까 자식 클래스에서만 구현하기
중 이었으나, 정리 : [[SOLID]]

---

#### 기타 버그 수정
- 피격 이펙트 발동 시에도 그 피격 요인을 발생시키는 공격에서 피격 이펙트를 저장하고 있어야 함
	- 예를 들어서 투사체가 날아가는 중이다
	- 지금 구현에서는 공격자에게 공격이 적중했을 때 나타나는 `GetHitEffect`가 들어가 있음
		- 그런데 투사체가 날아가는 중에 공격자가 사망했다면? - `GetHitEffect`를 가져올 곳이 없어서 오류가 발생함.
- 따라서 이 피격 이펙트를 유발하는 요인 자체를 공격 구조체에서 설정하면 좋을 것 같고, 이건 `AttackSource`라는 걸 이미 쓰고 있어서 이 안에다가 구현하면 좋을 듯.
![[Pasted image 20250122175901.png]]
> 스킬이 동작하고 오퍼레이터가 사라졌는데도 Null Reference Exception이 발생 중. 왜 그런지는 모르겠다. 이거 수정 중.

- 추적해보면, CrowdControl.cs의 `source` 부분이 문제가 될 수 있겠다. 더 들어가면 `target.Takedamage`부터 문제가 될 수도 있는 상황이고.
```cs
    private void ApplyDamage()
    {
        if (target != null)
        {
            // 대미지 적용
            ICombatEntity.AttackSource attackSource = new ICombatEntity.AttackSource(transform.position, false, hitEffectPrefab);
            target.TakeDamage(caster, attackSource, damage);

            // 기절 효과 적용
            StunEffect stunEffect = new StunEffect();
            stunEffect.Initialize(target, caster, stunDuration);
            target.AddCrowdControl(stunEffect);

            hasDamageApplied = true;
        }
    }
```
- 이런 경우, 떠오르는 수정 방안은 2가지임.
1. 오퍼레이터가 사라져도 스킬 효과가 남게 구현하고 싶다면, 대미지를 가하는 주체, 효과를 가하는 주체 등등이 모두 게임 상에서의 오퍼레이터의 동작을 뜻하는 `Operator` 대신, 스테이지 씬에서 해당 오퍼레이터라는 정보를 알려줄 수 있는 전역적인 매니저 같은 게 하나 필요함.
	- `Operator`가 사라지는 경우 해당 동작들이 다 막히는 현상이 발생하기 때문임. 이는 통계 같은 것까지도 포함.
2. **오퍼레이터가 사라지면 시전한 스킬도 같이 사라지면 되는 거 아님?**

... 누가 봐도 2번이 훨씬 빠르고 효율적이다. "오퍼레이터는 사라졌지만 스킬은 남는다.." 라는 묘사도 조금 이상하기는 하다.

> 1. 내일은 메딕 2스킬 이펙트 구현
> 2. 이펙트는 힐이 들어가는 틱마다 시각화
> 3. 이펙트 구현도 잘 됐다면 스킬 아이콘 / 로비에서의 스킬 아이콘 UI 구현 시작
## 250121
[[250121]]
### 짭명방

#### VFX 오브젝트 풀링 관련 수정
- `GetHit, Attack` 등의 **순간적으로 발생하는 VFX의 오브젝트 회수는 자체적으로 이뤄지게 해야 한다.** 지금 스크립트에서는 오브젝트 풀링도 `UnitEntity` 이하에서 이뤄지도록 하고 있는데, 이럴 경우 `UnitEntity`가 죽으면 스크립트 실행이 캔슬되면서 작업을 마친 오브젝트가 사라지지 않고 남아있는 문제가 있음. 보이진 않지만.
- 구현은 된 것 같은데, 정작 이펙트가 보이지 않는다. 
	- `effectDuration` - 지속시간 문제였습니다~

#### 스킬 범위 이펙트 수정
- 기존에 수직으로 솟는 이펙트에 더해, 타일의 가장자리에 붙는 이펙트 하나를 더 구현해보려고 함
- [이 강의](https://www.youtube.com/watch?v=b8dIO9tehno&list=PLCQWb9ZvSdN1WT74VFOTP5lK03xvR5xbl)를 참고해서 구현을 해봤는데, 나한테 실제로 필요한 건 하나의 변에 대해서 나타나는 스킬 로직이다. 
	- 그래디언트 텍스쳐를 만들고 그걸 Vector2 * Time의 Offset을 만들어서 적용함
	- 이걸 Image로 만들어서 각 타일의 4개변에 붙일 건데, 이럴 경우에 **`Source Image`를 비워둬야 원하는 바가 구현되는 듯.** 

> 구현한 셰이더 그래프
![[Pasted image 20250121184021.png]]


> 실제 구현된 내용
![[Pasted image 20250121184142.png]]
여기서 보이는 보라-검정 테두리 부분을 오늘 구현함. 

`SkillRangeVFXController`에 들어가는 저런 구성 요소들은 머티리얼에 HDR 색을 사용해서 넣었다. 스크립트에 색을 직접 할당하는 것보다 저게 훨씬 나을 것 같음. 시각적으로 피드백을 받으면서 작업해야 하기 때문에.

#### 버그수정
- Caster의 ArcaneFieldSkill 범위가 제대로 나타나지 않는 현상 있음.
	- `duration` 설정에서 값이 `0`으로 들어오지 않는 경우를 처리하지 않았음. ㅋㅋ;


## 250120

### 짭명방

#### 뭔가 아쉬운 뱅가드 2스킬 이펙트 마저 수정
- 일단 메쉬의 색이 파티클에 연동되는 현상은 `Shape - Mesh Renderer - Use Mesh Colors`가 체크되어 있기 때문이었다. 이걸 못 보고 이상하네 이러고 있었네.ㅋㅋㅋㅋㅋㅋㅋ
- 메쉬 주변에 일렁이는 효과...를 구현하고 싶은데, 아직 실력이 안돼서 거기까지는 무리다. 단순히 메쉬에서 파티클들이 진행 방향의 반대로 일렁이는 수준의 효과만 구현했음.
![[Pasted image 20250120133845.png]]

> 살짝 오해할 뻔 한거
```cs
protected override void PlaySkillEffect(Operator op)
{
	CalculateActualSkillRange(centerPos);
	VisualizeActualSkillRange(op);
	GameObject fieldEffect = CreateEffectField(op, centerPos);

	// 필드 효과 추적 및 사망 이벤트 구독
	if (fieldEffect != null)
	{
		if (!activeEffects.ContainsKey(op))
		{
			TrackEffect(op, fieldEffect);
			op.OnOperatorDied += HandleOperatorDeath; 
		}
	}
}
```
- 이 메서드가 자식 클래스에 의해 실행될 때, 여기서 사용되는 메서드들은 `private`이어도 무방하다. 
	- 자식 클래스에서 직접 해당 메서드를 실행하거나 오버라이드를 할 경우가 아닌 경우에만 한정이다.

#### SkillRangeVFXController 수정
- `fieldDuration = 0f`일 경우, 기본 1초는 이펙트가 보이게끔 수정했다.

- 기존에는 범위 표시를 할 때, 파티클이 올라간 다음 트레일을 남기는 구조였음. 이건 즉발형 스킬처럼 **잠깐 영역을 보여줘야 하는 경우**에 파티클이 올라올 시간이 충분하지 않기 때문에 시각화가 되기 전에 스킬이 종료되는 현상이 발생했다.
> 따라서 스킬이 켜진 직후에 `main.simulationSpeed`를 순간적으로 높인 다음 `IEnumerator`로 0.01초 정도 기다린 후 다시 원상복구하는 식으로 구현함. 0.01초는 거의 보이지 않는다고 보면 되니까.

#### 버그 수정
> 1. 버그 발견
> - MeteorSkill 시전 중 오퍼레이터 사망 시 Meteor Object의 동작도 멈춤

원하는 동작) 스킬이 즉발 시전이므로 Meteor Object의 동작도 자기 임무를 다 마쳐야 함
- 원인) `MeteorSkill`에서 각 메테오를 만들고 초기화하는 과정 사이에 딜레이가 있었는데, 이 딜레이 사이에 오퍼레이터가 파괴되면 참조할 `op`가 사라져서 초기화가 제대로 되지 않음
- 따라서 스킬을 눌렀을 때 초기화 과정까지 다 넣은 다음, 

> 2. 오퍼레이터 사망 시 DeployableBox로 돌아오지 않음
```cs
        if (StageManager.Instance != null && StageManager.Instance.currentState == GameState.Battle)
```
여기서 뒤의 조건이 `!=` 이었음
- 근데 이걸 이렇게 설정해놨을 이유가 없었을 것 같다는 느낌이 든다. 언젠가 바꾼 적이 있지 않을까..

> 3. 활성화된 오브젝트 풀 요소에 대해, 오퍼레이터가 죽거나 대상이 죽거나 하는 상황에서 사라지지 않는 현상

이거만큼은 딱 뭐가 답이다..를 생각하는 게 어렵다. 여러 테스트를 해봐도 모르겠음.



## 250119
### [셰이더 그래프] 별도 공부 : Dissolve 효과 구현하기
[[Dissolve - 사라지고 나타나는 이펙트]]
## 250118
### 독서
- 타이난 실베스터 - `게임 기획의 정석` [[1. 경험의 엔진]]
	- 역시 책은 그냥 읽는 게 낫다.. 정리까지 기록해두는 건 품이 너무 많이 든다. 그래서 정리하다가 gg침.
	- 수요일에 교보문고에서 산 책인데, 저자가 림월드의 그 타이난이다. 원본은 2013년 책이라고 하는데, 한국에는 2024년에 번역되어서 나온 듯. 3만원이지만 재밌다.
### 짭명방

#### 뱅가드 2스킬 구현 계속
- 셰이더 그래프 : `DarkFlame` 구현 시작
![[Pasted image 20250118151436.png]]

- UV와 텍스쳐 간의 관계를 짚고 넘어가보면,
- UV는 어떤 위치에 대해 `어디를 볼까?`를 가리키는 개념이고, 텍스쳐는 `거기엔 어떤게 있어!`를 가리키는 개념이다.
 - **UV 자체는 값을 갖는 개념이 아니다.** 진짜 말 그대로, 어떤 위치에 대해 텍스쳐의 어디를 볼까?를 정하는 개념이다.
	 - 변형된 UV Map은 `[0, 1]`을 벗어날 수 있다. 이런 경우, 텍스쳐가 늘어나거나 줄어들 수 있음. 

- 추가로, UV Map에 들어가는 버텍스는 어떤 식으로 선정되는지가 궁금해졌다. 일단 `Output = UV Map(Input)` 개념이므로 지금 하는 UV Map 조작은 인풋(3D 좌표)에 아무런 영향을 주지 않음.
	- 3D 메시의 버텍스는 2가지 좌표계를 갖는다.
		- `3D 공간 좌표(X, Y, Z)`
		- `UV 좌표(U ,V)`
	- 예전에 **블렌더에서 UV Unwrapping을 했던 걸 기억할 거다.** 이게 3D 공간 좌표와 UV 좌표를 매핑하는 과정이었던 거임.
	- 알아두면 좋은 점으로
		- 1개의 3D 공간 좌표는 여러 UV 좌표를 가질 수 있다.
		- 큐브의 꼭짓점은 3개의 면에 공유되므로, 3개의 다른 UV를 가질 수 있다.
	- 따라서 실제로 UV 매핑은 `(3D 버텍스 ID, 면의 ID) -> (U, V)`로 매핑됨.

- 그냥 원뿔의 표면에서 연기 파티클이 쏟아져 나오는 식으로 구현했다. 어렵네..
## 250117
[[250117]]
### 짭명방

#### 뱅가드 2스킬 구현 계속
- 기본적인 로직은 구현 완료
- 추가로 구현할 내용 
	- 스턴에 걸린 상태 표시
	- 떨어지는 메쉬 이펙트 추가 구현

- 스턴에 걸린 이펙트를 표현하기 위해, `CCEffectManager, CCEffectDataBase` 등이 추가로 구현됨

- 뱅가드 2스킬 자체의 구조가 스턴을 먹이는 투사체가 2번 떨어지는 구조이기 때문에, CC의 갱신을 어떻게 할까도 구현해야 함
	- 결국은 기존 CC가 있을 때 동일한 타입의 CC가 들어가면 기존 CC의 이펙트 동작과 코루틴을 취소하고 새로운 CC의 이펙트 동작과 코루틴을 실행시키는 게 될 듯

- 타입 - 게임 오브젝트 딕셔너리 구현
```cs
    public struct CCEffectMapping
    {
        public System.Type ccType; // CC 타입
        public GameObject effectPrefab;
    }
    
	effectMap = new Dictionary<System.Type, GameObject>
	{
		{ typeof(StunEffect), stunEffectprefab },
		{ typeof(SlowEffect), slowEffectPrefab }
	};
```

- 관련 현상 수정 중
	- CC가 사라졌을 때 Enemy가 멈추는 현상
		- 2번째 스턴이 들어갈 때 1번째 스턴의 처리가 종료되지 않은 상태였다면 원래 속도인 `target.MovementSpeed` 값이 `0`으로 잡힘. 스턴의 효과는 이동 속도를 0으로 만드는 것이기 때문.
		- 이를 수정하는 방법으로, 2가지 방법이 생각난다. 뭐가 더 나을지는 모르겠음.
			1. CC를 갱신하는 과정에서 이전 CC가 정상적으로 종료됨을 확인하고 다음 CC를 실행하거나
			2. 스턴의 로직 자체를 바꾸는 방법. 스턴 대상인 유닛에 대해 스턴 여부를 확인하고 Update 메서드에서 바로 return으로 빼는 방식.
	- CC가 끝났는데도 이펙트가 남아 있는 현상

둘 다 일단은 잘 되는 듯 함. 앞으로는 또 어떻게 될런지는 모르겠지만. 오늘은 여기까지!
> 이제 이펙트만 구현하면 이 스킬은 마무리될 듯

## 250116
- 어제는 급작스런 일이 있었다.
### 짭명방

#### 기존 코드 개선
- 범위를 만들고, 범위 이펙트 / 효과 컨트롤러를 따로 구현하는 방식은 기존에 구현했던 캐스터의 2번째 스킬 `ArcaneFieldSkill`과 크게 다르지 않음
- 따라서, 코드의 중복을 줄이기 위해 이들을 추상화할 클래스를 하나 또 만들겠음 : `AreaEffectSkill`
- `AreaEffectSkill`을 상속받는 모든 장판 생성 스킬은 오퍼레이터가 제거되면 사라지도록 수정
	- 오퍼레이터 사망 -> 사망 이벤트를 구독하는 메서드에서 `ForceRemove` 메서드를 실행 -> 장판에 들어가 있는 2개의 스크립트에 `ForceRemove`를 구현하는 인터페이스 `IEffectController`를 상속받게 하고 스크립트에서 구현
	- 이펙트 컨트롤러에서 `ForceRemove`를 실행하는 것 자체는 큰 이슈는 아니다. 지속시간이 다 해서 사라질 때의 동작을 실행시키면 되기 때문..

#### 뱅가드 2스킬 구현 
- 기?획 : 텍사스 2스킬과 같다.
```cs
- 스킬 시전 시 코스트 즉시 회복
    
- 스킬 시전 시점, 오퍼레이터의 위치를 중심으로 범위 내에 있는 적들을 대상으로 월드 좌표상 y축 위치에 2개의 오브젝트가 생김
    
- 2개의 오브젝트는 적들의 위치를 따라다니되, 월드 좌표 기준 y좌표만 다름
    
- 2개의 오브젝트는 시간 차를 두고 떨어짐.
    
- 떨어지는 오브젝트가 적과 충돌했을 때, 대미지와 기절을 가함
```

#### 추가 팁
- **`HashSet`은 직렬화되지 않음**
	- `O(1)`이고, 중복을 허용하지 않는다.
	- 해쉬셋을 사용할 경우 런타임에서 완성해야 함. 스킬 범위를 `Offset Vector2Int List`로 만든 다음에 실제로 적을 지정할 때 그 위치를 중심으로 해쉬셋에 추가하는 식으로 구현하면 되겠다.



## 250115
### 짭명방

#### 스킬 구상
- 메딕, 뱅가드가 남았음
- 뱅가드는 텍사스 2스킬을 생각 중
	- 범위는 `ArcaneFieldEffect`와 동일
	- 스킬 발동 시점을 기준으로 
		1. 코스트 즉시 회복
		2. 범위 내의 적의 머리 위에 이펙트가 발생. 
			- 적이 이동하더라도 이펙트가 따라서 이동함
			- 이펙트가 떨어져서 적에게 닿으면 대미지와 n초의 스턴을 가함
- 메딕은 프틸롭시스의 2스킬을 가져올까 생각 중 

#### 뱅가드 2스킬 구현
- **명방의 텍사스 2스킬과 로직이 완전히 동일함**
- `StunEffect`를 구현할 건데, 우선 기반이 되는 추상 클래스인 `CrowdControl`의 `target`부터 수정해야 할 것 같다. `Enemy`로만 설정이 되어 있기 때문.
	- `CC`를 받을 수 있는 인터페이스를 구현하고, `Operator`와 `Enemy`에 상속을 했다
		- 이 과정에서 기존에 했던 고민이, 인터페이스 자체는 `MonoBehaviour`를 상속받지 않으니까 그 타입만 그대로 쓸 경우에 `transform` 같은 기능은 그대로 사용할 수 없었다는 점이 있었음
		- 그냥 `Position`이라는 프로퍼티를 인터페이스에 정의해서, 이를 상속받는 클래스에서 `Position => transform.position` 같이 사용하면 됨.

#### 기타 잡썰
- 객체 지향 설계 원칙 / 캡슐화 등을 너무 원칙적으로만 생각할 필요는 없을 것 같다. 
- 일단은 **프로퍼티로 구현하더라도 게터는 `public`, 세터는 별도의 public 메서드로 정의하는 걸 원칙으로 하겠음**
	- 이런 과정에서 `MovementSpeed` 같은 상황, 즉 다른 구조체의 필드를 가리키는 프로퍼티가 있을 수 있는데 똑같이 게터는 `currentStats.movementSpeed`, 세터는 별도의 메서드 안에 저 필드를 똑같이 넣으면 됨. 프로퍼티를 게터로만 구현하므로 `MovementSpeed`를 세터 안에 넣을 수는 없음

## 250114
### 짭명방
#### 추가 수정 사항
- 스킬 범위 이펙트에 바닥 추가
	- `Mesh Filter(Plane), Mesh Renderer`를 이용, 타일의 `+`높이에서 `0.001`만큼의 위에 `Plane`을 띄우고, 메시 렌더러의 머티리얼 값을 수정함
	- 여기서 머티리얼로 접근해서 값을 수정하려면 아래처럼 접근한다
```cs
private static MaterialPropertyBlock propertyBlock; 
private static readonly int colorID = Shader.PropertyToID("_BaseColor");

// Initialize
// 바닥 평면의 색상 설정 
if (floorRenderer != null) 
{ 
	propertyBlock.SetColor(colorID, new Color(effectColor.r, effectColor.g, effectColor.b, baseAlpha)); 
	floorRenderer.SetPropertyBlock(propertyBlock); 
}
```

- 기존 `CostSkill`의 이펙트 수정
	- 파티클이 사라지는 기준점으로 잡은게 코스트 아이콘을 xz 평면에 투사한 위치였음
	- 그런데 막상 파티클의 위치는 xz 평면에 투사 안하게 y좌표까지 고려했다. 그러다보니까 `Threshold`를 높게 잡아도 파티클이 해당 위치로 가도 사라지지 않는 현상이 있었음
	- 해결) **파티클의 위치도 xz 평면으로 투사**하고, **투사된 벡터값들끼리 거리 비교**
		- 이 경우 `Threshold`를 `0.1` 정도로 낮췄을 때 메인 카메라 위치 기준 아이콘이 사라지는 게 설득력 있음
		- 오퍼레이터를 클릭해서 카메라 시점이 돌아가는 경우는 좀 어색해보이는데, 돌아간 카메라 시점 기준으로 코스트를 향하는 것도 이상해보인다.
## 250113
[[250113]]
### 짭명방

#### 스킬 범위 이펙트 제작
- 여러 타일을 대상으로 함 / 근처 4방향에 대해 다른 타일도 범위 내에 있다면, 해당 변에는 스킬 이펙트를 생성하지 않음
- 예를 들면 아래 같은 이펙트가 있다고 했을 때 
```
  □
□ ■ □
  □
```
스킬 이펙트는 가운데 사각형의 4개변에 나타나지는 않아야 함

- 구현 방법으로는 크게 아래 2가지가 있는데, 후자가 훨씬 나아보인다.
	- 스킬 범위마다 이펙트를 따로 만들든가
	- 스크립트랑 연동하는 방식

> 스크립트랑 연동했을 때 가능할 것 같기는 한데, 파티클 시스템의 스크립트 연동은 아직은 정확히 모르는 영역이어서 이걸 배워가는 과정이 될 것 같다.

그러면 발상은 이렇게 들어감. 실제 구현에선 최적화 이슈 등으로 달라질 수 있겠다.
```
1. 각 타일에 대해, 상/하/좌/우 이펙트가 들어감
2. 스킬의 공격 범위를 받고, 해당 방향에 있는 타일(정확히는 벡터)이 스킬 범위에 있는지를 체크
3. 해당 방향에 스킬 범위 내에 있는 벡터가 있다면 이펙트를 생성하지 않음.
```

- **그리드 좌표를 좌측 상단을 (0, 0)으로 정의한 게 새삼 후회된다.** 만질 때마다 헷갈림 ㅋㅋㅋㅋㅋ 근데 다시 건드리긴 무서워서 냅둔다.
	- `Vector2Int.Up`은 내 프로젝트에서는 `-y` 방향, `Down`이 `+y` 방향이다. 

- 길이 반환 : 배열은 `Length`, 리스트는 `Count`
![[Pasted image 20250113195635.png]]

이런 느낌으로 구현 완료
## 250110

### 짭명방

#### 스킬 제작
- 뱅가드, 캐스터, 메딕 남음
- 캐스터부터 시작
	- 범위 도트 딜 + 슬로우를 까는 장판 생성

- 이 "슬로우" 라는 개념은 상태 이상 개념이라서 이것과 관련한 추상 클래스를 정의해놓고 들어가는 게 좋겠다.
	- 기존에 오퍼레이터에 구현한 버프 스킬도 비슷한 맥락이지만 새로운 묶음을 만들지는 않겠음. 배보다 배꼽이 더 커지는 상황이기도 하고.

- `CrowdControl`이라는 추상 클래스와, `SlowEffect`라는 슬로우에 붙는 클래스를 구현했음.

- 장판을 만들고, 장판이 일정 시간마다 장판 위의 적에게 대미지를 주는 방식으로 구현함
- 디폴트로 `Caster`의 `HitEffect`가 나타나므로 대미지 판정이 날 때마다 번개가 계속 떨어지는 방식으로 나타난다. 

- 장판 이펙트 정도만 구현하고, 피격 이펙트 실행에 변주를 줘야 할 것 같음


## 250109
[[250109]]

### 짭명방
#### 액티브 스킬 활성화 이펙트 제작
- 기존에 구현한 BuffSkill 이펙트를 사용해도 되겠지만, 스킬이 동작하고 있음을 알리는 요소는 계속 나타나도록 해야겠음
- **파티클 시스템으로 구현함** 
	- VFX 그래프는 아직까지는 다양한 곳에서 쓰인다는 얘기를 듣지 못했어서, 훨씬 범용성이 있을 거라고 생각되는 파티클 시스템으로 구현하는 게 맞는 것 같다. 지금까지 작업해왔던 건 어쩔 수 없고, 어차피 PC 용으로만 만들어둘 생각이니까.
- [[셰이더 그래프 - 중심 기준으로 확대 , 축소 반복]]
	- 파티클 시스템에서 버프 이펙트를 구현할 때, 오퍼레이터의 아래에 Flare를 구현하되 확대 / 축소를 반복시키고 싶었음
	- `Size Over Lifetime`으로 구현하면 사이클을 구현해도 `Lifetime`이라는 값에 의존적임. 예를 들어 `Lifetime`을 `999`로 하면 곡선을 엄청 느리게 타기 때문에 크기 변화도 엄청 미미하다.
	- `Tiling And Offset`에 대한 제대로 된 이해가 필요함. 결국 UV Map도 제대로 이해해야 함.
	- 근데 다시 생각해보니까 **한 파티클이 끝나면 다음 파티클이 나타나는 식으로 구현하는 게 더 편했을 것 같기는 하다..** `Size Over Lifetime`으로 파티클이 하나 나타났다가 사라지고, 그 다음 파티클이 나타났다가 사라지고.. 이런 식으로 구현해도 되지 않았을까 싶다.
	- 어쨌든 해놓은 게 아까우니까 정리해둠.
- 또 기존의 셰이더 - 파티클 시스템 간의 색깔 충돌이 있었는데, 셰이더 그래프에 Vertex Color를 추가하고 Color랑 곱하는 방식으로 구현했다. 근데 이것 때문에 된 건지, 다른 원인이 있는 건지는 모르겠음. 안되는 것 같더니 어느 순간 돼버려서;;

#### 기타 스킬 이슈 수정
- 가드 1정예화 스킬 -> `SlashSkill`로 이름 변경
- 검기 안나가는 이슈 : `SlashEffect`가 있고 `SkillEffect(액티브 스킬 공통 상속)`이 있다. 후자를 호출하려고 해서 이슈가 발생했음. 수정 완료.

## 250108

### 짭명방

#### 스나이퍼 2스킬 관련 수정
- 어제 작업하던거 계속 진행.
- [[ScriptableObject - Reset]]
- 추상 클래스를 상속받은 중간 추상 클래스에서는 상위 추상 클래스의 추상 메서드를 정의할 필요는 없다. 단, **인스턴스화가 가능한 클래스까지 내려가면 반드시 추상 메서드를 정의**해야 함.
- `ScriptableObject`에는 런타임에서 변경되는 필드를 설정하지는 않는다. 
	- `isSkillOn` 같은, 스킬이 켜져 있는 상태는 `Operator`에서 관리하는 게 더 좋아보임.

- 얼추 작업 완료. 이제 웬만하면 리팩토링은 하지 말자.. 그래도 더블샷 잘 나가지만..

#### 기타 수정 
- `Operator`나 `Enemy` 수정 중
	- `Enemy`에서 마지막 타일까지 향하는 상황일 때 바리케이드를 넣어도 그냥 뚫고 지나가는 현상이 있음. 
	- 현재 길이 막혔는지를 점검하는 로직은 아래와 같음
		1. 현재 위치 -> 목표 위치까지의 타일들이 막혔는가
		2. 목표 위치 -> 다음 목표 위치까지의 타일들이 막혔는가(를 반복)
```cs
    private bool IsPathBlocked()
    {
        for (int i = nextNodeIndex; i <= currentPath.Count - 1; i++)
        {
            // 
            if ((i == nextNodeIndex && PathfindingManager.Instance.IsPathSegmentValid(transform.position, currentPath[i]) == false) ||
                PathfindingManager.Instance.IsPathSegmentValid(currentPath[i], currentPath[i + 1]) == false)
            {
                pathData = null;
                currentPath = null;
                Debug.Log("현재 경로가 막힘");
                return true;
            }
        }
        return false;
    }
```
> 조건문이 더럽긴 한데 저걸 `else if`로 빼기 싫어서 그냥 저렇게 구현함 ㅋㅋ;
> 모든 이동 상황에서 `nextNodeIndex`을 설정하고 이동하는 상태임 
> - 현재의 목표 노드는 현위치 ~ 다음 위치 사이를 점검하고, 그 다음부터는 노드 - 노드 사이를 점검하는 방식임
> - 그래서 **반복문의 종결 조건에 `=`이 들어가는 게 중요하다.** 
> 실제 명방은 소란의 법칙 EX 스테이지 등에서 보이듯이, 다음 노드로 이동하는 경로만 수정하는 방식임. 내 경우는 그냥 최초 설정 경로가 막히면 최종 목표로 향하는 경로 자체가 아예 다시 계산되는 방식이다. 그런 차이는 있다고 정리해두고 넘어감.
- 기존에 구현했던, 경로가 막혔을 때 가장 가까운 바리케이드를 파괴하는 동작도 잘 실행된다.

- `Operator`의 `DirectionIndicator`가 나타나지 않는 현상 수정. `DirectionIndiator`는 `OperatorUI`로 통합.

## 250107

### 짭명방
### 스나이퍼 2스킬 관련 수정
- 아예 스킬 구조를 좀 바꾸고 진행하겠음
```
BaseSkill
- PassiveSkill
	- SmashSkill
	- CostRecoverySkill
- ActiveSkill
	- GuardPromotionSkill
	- ShieldSkill
	- DoubleShotSkill
	- StatModifierSkill
```

- [[virtual vs abstract]]


## 250106
### 짭명방
- 현재 1정예화 스킬은 가드랑 디펜더에게만 있음

#### 1정예화 스킬 구상
- 뱅가드
	- 팽 세부직군의 2스킬 느낌? : 수동 발동, 코스트 증가, 버프 효과?
	- 아니면 텍사스처럼 특정 범위에 광역 스턴 + 대미지 + 코스트 증가?
- 캐스터
	- 액티브 발동
		- 안 1) 범위 도트 딜?
		- 안 2) 범위 일발성 광역 뎀?
- 스나이퍼 
	- 발동 시 특정 시간 동안 n%의 공격력으로 2회 타격
- 메딕
	- 안 1) 스택형, 스킬 사용 시 1회성 광역 즉발 힐
	- 안 2) 스킬 사용 시 지속 시간동안 광역 힐

### 스나이퍼 2스킬 구현
- `DoubleShotSkill.cs` 구현
	- 스킬 지속시간동안 `x%`의 공격력으로 2회 공격함

- 그냥 구현하면 기본 `Operator.cs`의, `Update`에서 `Attack` 메서드와의 충돌이 발생할 것 같음
- 더블샷 개념은 아래처럼 구현한다.
```cs
private IEnumerator PerformDoubleShot(Operator op)
{
	UnitEntity target = op.CurrentTarget;
	float modifiedDamage = op.AttackPower * damageMultiplier;

	op.Attack(target, modifiedDamage);
	yield return new WaitForSeconds(delayBetweenShots);

	if (target != null && !target.Equals(null))
	{
		op.Attack(target, modifiedDamage);
		yield return new WaitForSeconds(1f / op.AttackSpeed);
	}
}
```
> 일단은 이렇게 구현해놓으니 잘 동작했음. 더블샷 사이의 간격이 실제 공격 쿨다운보다 작아지면 문제가 발생할 것 같지만, 대부분의 경우는 잘 동작할 것으로 보임.

- `nullable` 파라미터는 `HasValue`로 유무를 체크하고 `.Value`로 사용한다
- 추가로 스나이퍼 2스킬이 동작하고 있음을 알리는 이펙트도 구현하면 좋겠다. 일단은 `AttackBuff`로 땜빵해봄.

- 코루틴과 이펙트 제거 타이밍, 스크립트 구조 등에 대해서 생각해볼 필요가 있겠다..


## 250103
[[250103]]
### 짭명방
#### 검격 이펙트(발사) 구현, Guard 1정예화 스킬로 넣음

- [[원거리 검격 이펙트 구현하기]]

> 씬 뷰에서 이펙트 외곽선 비활성화하기
> - 씬뷰 우측 상단 기즈모 아이콘 - `Selection Outline` 체크 해제.

- 이펙트는 구현 완료

- 스킬 내용
	- 오퍼레이터가 보고 있는 방향 **전방 3칸**으로 검격을 발사
	- 검격은 `파티클 시스템`이나 `VFX 그래프`로 구현

- 구현 과정에서 `enemy`의 콜라이더 위치를 `Model -> Enemy`로 이동

- 이펙트에 맞춰서 스크립트를 구현한 상태라서, 3칸이라는 범위가 딱 지켜질지 모르겠음
- 정확한 스킬 범위를 구현하기 위해, 콜라이더의 충돌이 발생했을 때 추가로 스킬 범위에 있는 타일에 Enemy가 있는지 체크, true일 때에만 대미지를 입히도록 수정함

- **파티클 시스템을 인스턴스화 한 다음에 실행 여부를 확인**해야 함
	- 그래야 파티클 위치를 추적하고, 거기에 콜라이더를 다는 방식으로 판정을 계산할 수 있음
![[Pasted image 20250104002447.png]]


#### 파티클 시스템 vs VFX 그래프
- 프로젝트 자체는 PC 용으로만 빌드할 생각이라 큰 상관은 없겠지만, 길게 보면 파티클 시스템으로 구현하면서 알아가는 게 좋을 것 같다. 결국 여기저기 쓰일 건 파티클 시스템으로 보이기 때문임.

> 유튜브에서 이펙트를 보다가 댓글을 봤는데, **VFX 그래프는 대부분의 모바일 기기에서 구동이 불가능하다는 말이 있다.**
> [[VFX 그래프 vs 파티클 시스템(Shuriken)]] 을 작성하면서 댓글도 좀 보고 있다. 여기서 나온 VFX 그래프의 특징이라면
> - **`GPU`에서 실행하기 때문에 `CPU`에서 실행하는 것보다 무거움.** CPU와의 통신이 오고가기 때문에.
> - **파티클의 수가 많을수록 파티클 시스템보다 유리함.** 
> - 하지만 **대부분의 경우 파티클은 많아도 수백 개 정도를 쓸 것임.** 그 이상을 쓴다면 VFX 그래프가 최적화된 툴이지만 그 미만이라면 VFX 그래프가 최선은 아님.
> - `Rigid Body` 같은 물리 시스템과 상호작용할 수 없음. 다른 방식으로 접근할 수는 있는 듯.
> - 위에서도 언급했듯 대부분의 모바일 기기와 상호작용 불가능. 

## 250102

### 짭명방

#### 번개 이펙트 구현
- [[번개 이펙트 구현하기(ㄴㄴ)]]
	- `Plane`에 셰이더 그래프를 올리는 방식으로 구현하는 방식.
	- 하지만 카메라 각도에 따라서 의도치 않은 상황들이 발생했다.
	- 똑같이 카메라 로테이션이 잡혔는데도 이상하게 인게임에서는 `Plane`이 눕는 형태가 나타났다. `Orient : Face Camera Plane` 등도 제대로 동작하지 않았음.
	- 또, `Plane` 자체는 한쪽 면만 렌더링된다. 관련 옵션을 찾아봤는데 보이지 않아서 그냥 같은 사람이 새로 올린 동영상 강의를 따라가겠음. 
	- ~~중간에 좀 쉬었지만 아무튼 4시간이 물거품이 되었습니다. ~~
- [[번개 이펙트 구현하기(진)]]
	- 구현 완료. `Top Flash`는 피격 지점마다 카메라 앵글에 담기는 게 어색하다. 그래서 제거.

- 참고)
	- 이펙트를 실험할 때, 동영상과 다르게 HDR의 Intensity를 올렸는데도 블러 효과 등이 나타나지 않는다면
![[Pasted image 20250102162311.png]]
저게 꺼져있지는 않은지 점검해보자. 
- 옵시디언을 못 보는 경우) **씬 뷰의 전구 아이콘** (씬의 라이팅을 사용할지 여부)

## 250101

### 짭명방
- `SniperProjectile` 이펙트 수정
- `Deploy` 이펙트 수정
- 메인 메뉴로 돌아갈 때 `DeployableBox` 생성되는 이슈 수정

