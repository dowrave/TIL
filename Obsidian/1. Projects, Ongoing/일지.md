
# 앞으로 구현할 거 정리

## 유사 명방
- 게임적인 목표
	- 스테이지 : `1-1 ~ 1-3` 까지 구현하기
	- **최소 8명**의 오퍼레이터 구현 (스킬도 일단은 1개씩만 구현)
- 시스템 관련
	- 경로
		- 거시적으로 띄엄띄엄 타일들을 지정할 거냐, 아니면 지나가야 하는 모든 타일을 일일이 지정할 것이냐는 문제가 남아 있다.
	- `DeployableManager`에서 받는 오퍼레이터들의 정보는, 이전 씬에서 가져와야 함(이를 `편성 씬`이라고 하자)
		- 추가로 그 스테이지에서만 쓸 수 있는 요소가 있다면 그것도 추가해서 최종적으로 `BottomPanel`에 모두 나타나도록 해야 함
	- 육성 요소 추가
		- 스테이지를 저런 식으로 구현할 거면, `레벨업 재화`를 1-1 시작 전에 얼마를 주고, 스테이지를 클리어할 때마다 `레벨업 재화`를 오퍼레이터에게 사용해서 육성을 시키게끔 구현하는 것도 괜찮을 듯(어떤 오퍼레이터에게 사용할지는 유저가 정하는 방식, **한정된 재화를 어떻게 사용할 것인가?**)
		- 오퍼레이터가 특정 레벨에 도달하면 재능(패시브)을 얻게 하거나 또다른 액티브 스킬을 얻게 하는 방식도 넣어볼 만 하겠다.
	- **탄알집 만들기**
		- 오퍼레이터 배치 로직도 탄알집으로 구현 가능?
		- `Projectile`이 날아가다가, 그 주체가 제거된 경우에는 `Projectile`이 비활성화된 다음에 제거되도록 구현하고자 함


## 블로그
- 데이터가 제때 수집되고 있는지 눈팅 정도만 하면 충분할 것 같다.
- 사실 Quill을 쓰면서 되돌리기 / 붙여넣기 기능이 좀 이상하게 작동하고 있는 문제가 있긴 한데... 언제 해결할지는 모르겠음?

## 현재 발생 중인 문제
- 수정 중
	- 필드 이름 중복 문제
	


# 9월
- 앞으로 할 일) 
> 	(X) 다른 경로가 없다면 바리케이드를 공격해야 함
> 	(X) 클릭 메서드가 배치 직후의 마우스 버튼 업을 바로 인식해서 ActionUI가 나타나는 이슈
- 다 완료됐다면 그 다음에 구현할 것
	- 스킬
	- 레벨
	- 편성 씬
	- 탄알집(`BottomPanelDeployableBox`)
	- 이 다음엔 스테이지 1-1 ~ 1-3 구현

## 240924
[[240924 정리]]
### 유사 명방

#### 바리케이드 배치, 경로 변경, 갈 수 있는 길이 없을 경우 바리케이드 공격

이것들부터 시작함
> (O) Enemy가 생성되기 전에 바리케이드가 경로에 생겨서 진로를 바꿔야 하는 경우

- `PathfindingManager`에 바리케이드 배치 여부를 두고, `Enemy`의 초기화에서 이를 체크하도록 함
- 바리케이드 배치 위치 : 타일 바로 위로 수정
- 바리케이드 공격 로직 관련
- [[Unity - IEnumerator와 Update가 동시에 있음]]

- 코드로만 작성하려니까 안 그려져서 초안을 잡고 가겠음
- **길이 막힌 경우**
	- `IsPathBlocked()`으로 검사
	- 배치된 바리케이드 중 가장 가까운 경로의 바리케이드를 검색
	- 원거리 적의 경우 공격하는 상태를 계속 유지
	- 바리케이드는 원거리 공격으로 파괴되어서 안됨. 공격 거리에 관계 없이 바리케이드에 도달했을 경우에만 바리케이드를 공격함

> 예상이랑 동작이 너무 다른 지점들이 있어서 당황스럽다. 계속 만져야 할 것 같음.

## 240923
[[240923 정리]]
### 유사 명방
- 바리케이드 배치 확인 및 바리케이드 배치 시 Enemy의 경로 변화 확인
	- (O)바리케이드가 `DeployableUnitEntity.cs`의 자식인 만큼, `Data`를 이용해서 일률적으로 관리할 필요가 있을 것 같음. 
> `EntityDataEditor.cs`를 수정, 해당하는 Data 타입이 없으면 부모 Data 타입의 필드들을 인스펙터에 나타나도록 수정. 끌로드 만세 

- 이슈) 바리케이드가 배치됐을 때 경로가 수정되지 않는 문제
	- 바리케이드를 그냥 통과하는 것 자체는 문제가 아니다. 애초에 충돌 구현을 안했으니까.
	- (O)배치됐을 때 경로가 바뀌는 것
		- `PathfindingManager.CalculatePath` 부분의 `neighbor.Data.isWalkable` 을 `neighbor.IsWalkable`로 변경했다. 근데 이러니까 경로가 있는데도 없다고 뜬다.  `FindPath` 부분이 잘 동작하지 못하는 듯?
			- `IsWalkable` 프로퍼티가 각 타일에 할당되지 않았음. `Tile.Awake`에서 할당.

> Enemy가 생성된 상태에서, 바리케이드가 경로 중에 설치된 경우 진로를 바꿔 진행하는 것까지는 구현이 되었다.
> - 앞으로는 Enemy가 생성되기 전에 바리케이드가 경로에 생겨서 진로를 바꿔야 하는 경우
> - 다른 경로가 없다면 바리케이드를 공격해야 함
> 추가로 클릭 메서드가 배치 직후의 마우스 버튼 업을 바로 인식해서 ActionUI가 나타나는 이슈도 수정하면 바리케이드 관련해서는 다 정리될 것 같다.



## 240921
[[240921 정리]]
### 유사 명방
- `Operator`의 타겟 선정 로직 개선 : 남은 거리가 가장 짧은 `Enemy`를 우선 공격함
	- 이를 위해 `Enemy`는 목적지까지 남은 거리값을 가져야 함
	- 일단 이거 자체는 구현했음. 원래 더 하려고 했는데 오늘은 뭔가 매우 나른하다.


## 240920
### 유사 명방
- 공격 대상에 구분을 주기 위해 `IFactionMember` 인터페이스 추가
	- `Ally, Enemy, Neutral`
- `Enemy` 기준, `Operator`의 배치 순위 조정
- [[CSharp - LINQ]]
- 발생 중이었던 문제 수정
	- `Operator`의 `AttackCooldown`이 계속 0으로 뜨는 문제
	- 체력이 0이 됐음에도 `Enemy`가 제거되지 않는 문제
	- `Operator`가 이제 공격도 안하는 문제
	- 모두 `UnitEntity.TakeDamage`에서 `OnHealthChanged.Invoke(CurrentHealth, MaxHealth);`에서 `nullException`이 떴기 때문이었던 것으로 보인다. 이벤트에 널 체크 추가 `?`을 해줘서 해결했음.
	- - 배치 중에, 배치 불가능한 타일에서 커서를 놨음에도 공격 범위가 표시되는 현상
- 탄알집(오브젝트 풀링)
	- 이를 위한 `ObjectPoolManager`를 구현하고 `Operator`, `Enemy` 스크립트 수정

## 240919
[[240919 정리]]
### 유사 명방

- 수정 완료
	- 체력이 0이 됐음에도 `Operator`가 제거되지 않음 + `DirectionIndicator`가 없다는 이슈
		- **`Operator.Initialize()`가 사용되지 않고 있었다. `DeployableManager`에서 사용하도록 수정.**
		- 인스턴스화는 됐는데 초기화는 안 되어서 나타나야 할 요소들이 나타나지 않았던 거임! 
	- 배치 중에는 반투명하게, 배치 후에는 불투명하게 머티리얼 설정 조정
		- [[Unity - 투명 머티리얼 설정]]
	- 타일 하이라이트 설정 조정
	- 배치 불가능한 타일에서 커서를 뗐을 때 공격범위 표시되는 현상 수정

- 그래도 진도 못나가고 있는 지금 사태의 끝이 보인다

## 240918

### 유사 명방
- 배치 자체는 잘 구현되고 있음
- 대신 전투 관련 이슈들이 있어서 그거 수정 중.
	- (O)`Enemy`의 `HP` 초기화 문제
	- (O)쿨타임 없이 무한 원거리 공격을 날리는 `Enemy`
	- (O)`Operator`가 배치된 후에 체력이 초기화가 되지 않는 현상
	- (X) 체력이 0이 됐음에도 `Operator, Enemy`가 제거되지 않는 현상
- [[Unity - 변수 초기화 타이밍]]


## 240916

### 유사 명방
- 리팩토링 전, 정상적으로 작동하던 기능들 돌려놓기
	- `BottomPanelDeployableBox` 초기화 이슈
	- 알았어도 막상 써먹으려면 어려운 기능들
		- [[CSharp - 형 변환(Type Casting)]]
		- [[CSharp - 제네릭]]

- 너무 골치아파요 ㅠㅠ
- `currentStats`으로 초기화하고 거기 프로퍼티로 접근하는 거랑 그걸 `currentStats.detail`로 접근하는 거랑 동작이 다르다?
1. 이왕이면 `currentStats`이라는 프로퍼티 내의 구조체 필드로 직접 접근함. 별도의 정의가 필요한 경우에만 엔티티에 별도로 구현.
2. `deployableUnitEntity`와 `Operator` 간의 다형성이 있지만, 각각의 필드를 사용하는 것에 있어서는 위의 `형 변환`에 의해 별도로 접근하는 게 좋은 것 같다.

> - 주로 문제가 터졌던 곳들이 `ScriptableObject`로 구현했던 것들의 필드를 프로퍼티로 사용했기 때문인데, 이렇게 구현하는 경우 필드에 값을 할당한 직후에 그걸 바로 사용하려고 할 때 Null이 발생하는 문제가 있었음.
> 	- 그냥 `currentStats`이라는 구조체로 퉁쳐서 정리하고 그것의 필드들로 접근하기로 함. 
>- 대신 프로퍼티는 구조체 내에서 정의해서 여러 계층으로 나뉘지 않게 했음.

- 얼추 구현이 되었고 `Enemy`의 생성은 되는데 이동은 하지 않는 문제부터 수정 더 하면 될 듯. 어쨌든 최초 목표였던 **리팩토링 후 배치 기능 작동하기** 는 성공적으로 끝냈다.



## 240913
[[240913 정리]]


### 유사 명방
> 가장 먼저 할 일 : 수정된 Stats, Data 들로 기존 Entity, Operator, Enemy 스크립트 수정하기

#### 스탯, 데이터 정리
> 어떤 구조를 만들려니 다소 복잡해지는 감이 있어서, 약간 노가다성이 있더라도 직관적으로 보이게 수정했음. 특정 객체에 들어가는 필드들은 주석으로 표시해둠. 

1. `Stats`은 상위 객체의 구조체를 필드로 가져와서 사용하지만, 해당 필드들로 접근하는 프로퍼티는 별도로 구현(모든 스탯 필드에 동일한 위계에서 접근하기 위함)
2. `ScriptableObject` 간의 상속을 끊고, 모두 개별로 구현.
3. `Entity`에서는 `Stats`을 프로퍼티로 접근하지 않고, `private` 접근자를 가지도록 구현.
	- 프로퍼티로 구조체를 구현할 경우 `Stats.Health` 같은 수정이 불가능하다는 오류가 뜬다. 한 번 복사해서 쓰기 때문인데, 별도의 세터 메서드를 구현해야 해서 번거로운 느낌임.

- [[Unity - 접근자]]

- **이슈 1) BottomPanelDeployableBox에서 아이콘이 초기화되지 않는 문제** 
-> 엔티티의 필드들이 초기화되지 않은 상태에서 시도가 되기 때문으로 보임. `Start()`나 `Awake()`로 빼둬야 하나?
- 이슈 2) Data 필드들이 여전히 인스펙터에서 중복해서 나타남 -> 해결

> 진도가 안나가서 돌아부리겠네~~~


## 240912
[[240912 정리]]
### 유사 명방

#### 리팩토링
- [[Unity - Vector3.MoveTowards]]
- `Enemy, Operator`까지는 정리 완료, 이제 배치 로직 정리 시작
![[Pasted image 20240912230100.png]]
> OperatorData를 살펴보니 이런 식으로 `Stats`가 중복해서 나타나는 현상이 있다. ㅡㅡ

- `Stats`, `Data` 관련 로직들은 다 뜯어 고침. 이들의 상속 구조를 없애고 모두 개별 필드로 정의했다. 이게 제일 쉽겠다. 하..
- 이걸 이용하는 기존 객체 스크립트는 내일 고치자. 후...

## 240911

### 유사 명방

#### 시작 전 구조에 대한 생각
- 커피를 사러 가다가 이런 생각이 들었다. 
- 지금의 프로젝트 구조는 아래의 방식으로 스탯을 사용하고 있다.
```
UnitEntity : UnitStats currentStats
	- DeployableUnitEntity : DeployableUnitStats currentStats
		- Operator : OperatorStats currentStats
```
여기서 피격 로직은  `UnitEntity`에 정의되어 있고 그 메서드는 `UnitStats currentStats`의 필드의 값을 가져와서 사용하는 방식이다. 그러면 메서드를 상속받은 `currentStats`에서는 `UnitStats`을 사용하나? `currentStats`을 사용하나?

> 자식 클래스에서 동일한 변수명을 재정의하고 있기 때문에, 부모 클래스의 `currentStats`은 숨겨진다. 

- **스탯은 `구조체 -> 클래스`로 바꿨음!**

#### 리팩토링
- `Operator.cs` 정리 얼추 됨. `Enemy` 관련 스탯과 `EnemyData` 정리 시작.
- 스탯을 프로퍼티로 관리해야 하는지 여부에 대해서 계속 고민이 많다. 진도가 생각보다 못 나가고 있음.



## 240910

### 유사 명방
[[240910 정리]]
#### 리팩토링
- `DeployableUnitEntity` 및 여러 인터페이스를 기반으로 `Operator, Barricade` 구현
- 기존 `Deployable`을 사용하던 다른 스크립트들도 수정
- [[Unity - 스크립터블 오브젝트]] 하단에 보충 설명 추가.
	- `Stats`은 구조체로 구현하는데, 스탯도 자식 클래스로 가면서 더 많은 것들을 사용해야 해서 어떻게 구현할지 고민했음. **부모 클래스에서 사용하는 구조체의 필드를 자식 클래스에서 사용하는 구조체의 필드로 복사 / 붙여넣기**해서 사용함. 
		- 이렇게 안 하면 `구조체.구조체.구조체.필드` 같이 필드로 접근해야 하고, 어떤 필드가 어떤 구조체에 있는지 파악하는 것 등 여러모로 번거로워짐
		- 각 클래스의 `Initialize`도 추상화하지 않고 각각의 `ScriptableObject`를 초기화하는 방식으로 변경함
		- 이러면 상속의 의미가 조금 애매해지는 거 아닌가? 싶었는데, 부모 클래스에서 자식 클래스로 오버라이드하는 메서드들이 있기 때문에 크게 상관 없을 것 같다. 



## 240909

### 유사 명방

#### 리팩토링
- 리팩토링을 한 번 하기는 했는데, 그 결과물이 그렇게 만족스럽다는 느낌은 아니어서 아예 싹 한번 다시 갈아엎겠음
	- 명방 게임 자체는 장애물 같은 배치 가능한 요소도 그냥 오퍼레이터처럼 처리되게 만든 것 같음. 단, 방향을 지정하는 로직 자체는 없는 듯.
- 일단 타일 위에 배치되는 / 돌아다니는 요소를 위한 `UnitEntity`의 구현부터 시작.
- `DeployableUnitEntity`까지 구현하고, `Operator`나 `Barricade`의 공통된 기능들을 정리
★ 아직 실행 불가능. 최종적으로 배치 로직까지 완전히 적용되어야 완료된다.


## 240906
[[240906 정리]]
### 유사 명방

#### 배치 로직 리팩토링
> 어제 발생한 문제들 수정 중
> - 화면 하단의 패널의 아이콘 색깔들이 흰색으로 되는 현상
> - `IDeployable` 드래그 시, 미리보기가 동작하지 않음
> - 배치 방향 설정 같은 것도 나타나는 듯 보이는데, 실제로 배치될 요소가 나타나거나 하지는 않고 있음.

* 수정 완료
	- 색상 변하는 문제
	- 미리보기 나타나지 않는 문제
	- 하단 패널 / 오퍼레이터 클릭 시 카메라가 이상하게 이동하는 현상
- 새로 발견한 문제 -> 해결 완료
	- 오퍼레이터 퇴각 버튼 눌러도 동작하지 않음 
	- 바리케이드 클릭해도 ActionUI 나타나지 않음

- 이제 장애물 배치하고 나서 적의 경로 바뀌는 구현하면 될 듯? 
- 바리케이드 관련 아직 남은 문제도 있음


## 240905
[[240905 정리]]
### 유사 명방

#### 바리케이드 구현, BottomPanelOperatorBox 리팩토링
- 만들고 복잡해져서 엎기를 수 차례 반복했다..
- 일단 전체적인 과정 자체는 마무리가 됐는데, 여전히 머릿속으로 정리가 되지 않는 것들이 있음. 급하게 가지 말고 차근차근 해야 할 것 같다. 예를 들면 `IDeployable`을 상속받는 `Operator`, `Barricade` 만으로는 약간 부족한 느낌이 듦. 차라리 클래스를 상속받게 하는 게 나을지도.
	- 근데 추상 클래스를 또 구현하면 `Unit` 상속과 충돌이 일어난다. `Unit`은 `Enemy`로 또 이어지기 떄문에, 골치가 아픈 부분.
- IClickable를 IDeployable로 통합.

> 대략적인 수정은 마친 상황에서, 현재 발생중인 문제
> - 화면 하단의 패널의 아이콘 색깔들이 흰색으로 되는 현상
> - `IDeployable` 드래그 시, 미리보기가 동작하지 않음
> - 배치 방향 설정 같은 것도 나타나는 듯 보이는데, 실제로 배치될 요소가 나타나거나 하지는 않고 있음.




## 240904
[[240904 정리]]
### 유사 명방

#### 오류 수정
- 배치 중인 오퍼레이터가 미리보기 상태일 때 `Enemy`가 오퍼레이터를 공격하는 문제 수정
	- `isDeployed` 필드를 `IsDeployed`라는 프로퍼티로 관리

#### 스크립트들 정리
- 어제 작업하면서 이게 왜 여기 있지? 하는 느낌이 드는 부분들이 종종 있었다. 이 부분을 정리해보려고 함.
- 크게 `Unit, Enemy, Operator`를 만지고 있는데, 또 되던게 작동 안하기 시작. ㅡㅡ 
	- `Data` 들을 뜯어고치는 과정에서 `Melee`로 지정되어 있었다. 후... 그래서 `AttackRange` 값이 `0`으로 나타났기 때문에 작동을 안했던 것.
```cs
Operator op = collider.GetComponent<Operator>();
```
> 여기서 `collider`는 자식 오브젝트인 `model`에, `Operator` 스크립트는 부모 오브젝트에 있는데도 동작했다. 왜냐하면 `GetComponent`는 해당 오브젝트에 스크립트가 없다면, 부모 오브젝트로 거슬러 올라가며 뒤지기 때문이다.
> 따라서, 작동은 하지만 (큰 차이는 없더라도) 성능적인 열화가 있을 수 있다. `GetComponentInParent`로 수정.

#### 바리케이트 구현
- `바리케이트` : 타일 위에 배치해서 적의 경로를 비틀 수 있음
- 기존 오퍼레이터와 동일하되 약간의 차이가 있는 구현을 해야 하는데, 이거 설정이 생각보다 까다롭다. 바꿔야 할게 좀 많기 때문이다.
- 근데 기존 깃으로 되돌리기에는 경로 변경 시 수정 사항을 작업해 놓은 게 있다.  바리케이드 스크립트, 오브젝트까지는 냅두고, 나머지 로직들을 원상복구 해놓겠음.




## 240903

### 유사 명방

- 경로 설정 과정에서 `Enemy`의 포지션이 타일 속으로 묻히는 문제가 있었음
	- `targetPosition`의 좌표 설정 시 `Vector3.up * 0.5f`를 더해주면 됨

#### 원거리 적 구현하기
- 공격 범위는 "값"으로 구현하겠음 : 적은 이동하면서 쿨타임이 돌 때마다 **가장 최근에 배치된 적을 공격함**
- `RangedEnemy`라는 클래스를 따로 구현하는 것도 생각해봤는데, 실질적으로 차이는 `EnemyData`에 `EnemyType`을 두고(`Melee, Ranged`) `AttackRange`값의 차이 만으로 실질적인 동작의 차이가 발생할 것 같아서 별도로 구현하지는 않음. 즉, `Enemy` 하나에 근거리, 원거리 동작을 다 포함시킨다.
- 이전에 `Unit`에 근/원거리 여부나, 공격 타입 등이 설정되어 있어서 `EnemyType`을 쓰지 않고 해당 `enum` 타입들을 사용하고 있음.

- 코드를 나중에 한 번 고칠 필요는 있을 것 같다. 상속이 큰 의미가 없는 경우도 있고..

## 240902
[[240902 정리]]
### 유사 명방
- 오퍼레이터 배치 시, 몇몇 하이라이트된 타일에 배치가 불가능한 문제 수정 
	- 예전에 맵을 수정한 적이 있었는데, 거기서 새로운 타일을 생성한 경우, 해당 타일이 하이라이트되지만 그 위에 스냅핑이 되지는 않는다.
	- `OperatorManager.cs`를 살펴보면 `GetHoveredTile` 메서드에서
```cs
    private Tile GetHoveredTile()
    {
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        RaycastHit hit;

        if (Physics.Raycast(ray, out hit, Mathf.Infinity, tileLayerMask))
        {
            return hit.collider.GetComponentInParent<Tile>();
        }

        return null; 
    }
```
> 위와 같음. 즉, `tileLayerMask`라는 레이어를 레이캐스트로 검사한다.
- 실제로 새로 에디터로 만든 타일들에는 `Tile` 레이어가 할당되어 있지 않다. 하이라이트 자체는 잘 작동함.
	- 따라서 타일이 생성될 때 레이어에 `타일` 레이어를 지정하는 것만으로 충분함

- `Map.cs`의 메서드 이름 수정 : 기존엔 메서드의 역할이 불분명하거나 이름만으로 어떤 기능을 하는지 직관적으로 파악하는 게 어려웠음

- 오퍼레이터 배치 동작 시 시간이 느려졌다가 원상복구될 때, 2배속임에도 1배속으로 돌아오는 현상 수정, `OperatorManager`에 있는 시간 관리 메서드들을 `StageManager`로 통합

- 일단 보이는 문제는 다 처리한 듯?

#### 경로 설정하기
- 기존엔 `PathfindingManager`를 이용해서 최단 경로를 찾는 알고리즘으로 구현했다.
- 그런데 실제 명방을 보면, 어떤 위치에서 몇 초 쉰다든가, 아니면 빙글빙글 돈다든가 하는 식으로 개발자가 직접 경로를 설정하는 것으로 보이는 예시가 많았다.
- 그래서 이번엔 경로를 직접 설정하는 방식을 구현해보려고 함.
- 아예 `ScriptableObject`에 `PathData`를 만들고, 여기에 유니티 엔진 상에서 씬 뷰를 클릭해서 해당 타일을 경로에 넣는 방식으로 직접 편집할 수 있게끔 구현하고 있다. 
- 그런데 `Tile` 레이어로 설정하면 `Scene` 뷰에서는 안 보이는데 `Game` 뷰에서는 보이는 문제가 있다. ???? `Culling Mask` 이슈도 아니다.
	- 그냥 `Tile` 레이어를 옮겼다. 나중에 충돌이 나는 사안이 있다면 그때 보자.
- 대기 시간도 설정을 한 상태인데, 대기가 끝나면 다음 노드로 옮겨야 하는데 그러지 못하고 그 자리에서 그대로 끝나버리는 현상이 있었다
	- 인덱스만 잘 추적시켜 놓으면 된다. 


## 240901

### 유사 명방
- 공격 범위에서 적이 벗어나도 계속 공격하는 문제 해결
- `StageManager`에서 `UIManager` 의 역할을 하는 부분을 `UIManager`로 옮김
- 사실 원래 계획은 버튼의 클릭 이벤트가 마우스 버튼다운 때 1번, 마우스 버튼 업 때 1번 총 2번 발생하는 걸 해결하려는 계획이었는데, 정작 이건 해결 못하고 있음.
	- **`ClickDetectionSystem`과의 충돌 때문 아닐까??** 실제로 `MouseButtonDown` 때 `HandleClick` 메서드가 발동되도록 하고 있다.
	- `MouseButtonDown`과 `Click`을 구분했다.

- 머릿속으로 생각하려니 계속 헷갈려서 동작을 정리함 : [[마우스버튼다운, 클릭 동작 정리]]
	- 문제 자체는 해결됐다. 근데 갈수록 스파게티 코드가 되고 있는 것 같다..
	- 며칠 동안 헤맨 문제여서 해결한 것에 의의를 둬야겠음.

- `Button` 컴포넌트의 `OnClick`의 경우, 별도로 구현하지 않더라도 유니티의 UI 시스템에 의해 기본적으로 동작한다. 따라서 `ClickDetctionSystem`에서 굳이 별도로 `onClick.Invoke()`를 구현할 필요는 없다. 이거 구현하면 2번 실행됨.

