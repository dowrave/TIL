## 블로그

## 260126
>[!done]
> - [x] 편집 상태에서 텍스트 긁은 상태로 드래그될 때 버벅임이 생김. 뭐가 동작하는지 모르겠는데 이 동작을 막고 싶다. (즉 긁은 상태로 드래그하더라도 아무 일이 없어야 함)
> - [x] 자기소개 내용 일부 수정
> - [x] 리뷰 모달이 스크롤되지 않는 현상
> - [x] 리뷰 모달 모바일 서식 수정
> 	- 패딩을 만졌음 - `px-1 py-2 sm:px-4 sm:py-4`으로 설정

>[!Warning]
>- 안한 것 : 아카이브 버튼 클릭 시 해당 연도 아카이브 페이지로 날아가는 게 아니라 `ActivityChart`만 바뀌게끔
>	- 왜 : 백엔드를 고쳐야 함(어떤 연도를 조회했을 때 날짜별 게시글 갯수) - 이미지 다시 빌드하고 올리고 넣는 과정이 귀찮다..



### 텍스트 작성 중 글이 선택된 상태로 드래그 시 렉이 발생하는 현상
- 이전에 이미지를 드래그해서 텍스트 내에 넣는 기능을 구현할 때, 전체 텍스트를 돌면서 그 위치를 계산하는 기능을 구현했다.
- `mousemove`마다 마우스 커서의 위치 계산 로직이 들어가기 때문인데, 텍스트 숫자가 늘어날수록 `O(n)`으로 `DOM 레이아웃`을 계산하는 기능이 수행되어서 렉이 걸린다.
	- 그래서 짧은 문서에서는 티가 안 나는데 문서가 길어질수록 티가 난 것.

#### 이전 버전(O(n))
```tsx
// 구버전 : O(n)이라 드래그 발생 시 문서가 긴 경우 렉 걸림
// 드래그 중이 아니거나 Quill 인스턴스가 없으면 종료
if (!quillRef.current || !isDragging) return;

const editor = quillRef.current.getEditor();
// 에디터의 화면 영역 (Bounding Box) 계산
const quillBounds = (editor.scroll.domNode as HTMLElement).getBoundingClientRect();

// 에디터 영역 기준, 마우스 커서의 상대 위치 계산
const relativeY = e.clientY - quillBounds.top;
const relativeX = e.clientX - quillBounds.left;

// 마지막 텍스트 위치를 초기 인덱스로 설정
let leafIndex = editor.getLength() - 1;
// 가장 가까운 텍스트 위치를 저장할 변수
let closestIndex = leafIndex;

let minVerticalDistance = Infinity;
let minHorizontalDistance = Infinity;

while (leafIndex >= 0) {
	// 현재 인덱스의 바운딩 박스 계산
	const bounds = editor.getBounds(leafIndex);
	// 세로 거리 계산 (텍스트 중심과 커서 위치)
	const verticalDistance = Math.abs((bounds.top + bounds.height / 2) - relativeY);

	// 세로 거리가 더 가까운 경우 갱신
	if (verticalDistance < minVerticalDistance) {
		minVerticalDistance = verticalDistance;
		minHorizontalDistance = Math.abs(bounds.left - relativeX);
		closestIndex = leafIndex;
	} else if (verticalDistance === minVerticalDistance) {
		// 같은 줄일 때 가로 거리 비교
		const horizontalDistance = Math.abs(bounds.left - relativeX);
		if (horizontalDistance < minHorizontalDistance) {
			minHorizontalDistance = horizontalDistance;
			closestIndex = leafIndex;
		}
	}

	// 인덱스 감소 (이전 leaf로 이동)
	leafIndex--;
}

// 가장 가까운 위치로 커서 이동
editor.setSelection(closestIndex, 0);
```

#### 수정된 버전(O(1))
- 루프를 제거하고 표준 API로 위치를 잡은 다음 Quill에 맞게끔 인덱스로 바꿔줌
```tsx
if (!quillRef.current || !isDragging) return;

	const editor = quillRef.current.getEditor();
	const x = e.clientX;
	const y = e.clientY;

	let containerNode: Node | null = null;
	let offset = 0;

	// 표준 API 우선 사용 및 타입 안전성 확보
	if (typeof document.caretPositionFromPoint === 'function') {
		const position = document.caretPositionFromPoint(x, y);
		if (position) {
			containerNode = position.offsetNode;
			offset = position.offset;
		}
	} else if (typeof document.caretRangeFromPoint === 'function') {
		// 비표준
		const range = document.caretRangeFromPoint(x, y);
		if (range) {
			containerNode = range.startContainer;
			offset = range.startOffset;
		}
	}

	// 3 & 4. node와 offset을 사용하여 Quill 인덱스 계산
	if (containerNode && editor.root.contains(containerNode)) {
		// Quill.find는 DOM 노드에 대응하는 Blot
		const blot = Quill.find(containerNode);
		if (blot) {
			// blot의 시작 위치 + 노드 내의 offset으로 정확한 인덱스 계산
			const index = editor.getIndex(blot) + offset;
			editor.setSelection(index, 0);
		}
	}
```
> - 여기서 `caretRangeFromPoin`는 `deprecate`되었음. 
> - 대부분 AI에게 기능을 맡기고, IDE에서 나타나는 오류를 전달해서 수정하는 식으로 작업했다. 

#### 테스트
1. 텍스트 드래그 시 렉이 발생하는가? : 긴 문서로 실험 - OK
2. 이미지가 커서 위치에 여전히 잘 들어가는가? - OK

### 리뷰 모달의 스크롤이 되지 않는 현상
- 원래 모바일에서 나타난 현상이었는데 PC에서도 보인다? 뭐지..
- AI에게 물어봤는데 `usePreventScroll` 훅이 문제라고 해서 고쳐봤다. 안 고쳐짐.
- 그러다가 발견 : 테스트 환경에서 `overscroll-contains`을 비활성화했더니 잘 된다.
	- 이건 원본 `usePreventScroll`로 돌려놨을 때도 잘 동작함

- 왜 저게 문제였나?
	- `overscroll-contain`은 스크롤 체이닝을 끊음
	- `스크롤 체이닝`이란, 내부 요소가 더 이상 스크롤될 수 없을 때 외부 요소가 스크롤되게 하는 것. 이 경우는 모달이 문서의 최상단/최하단에 도달하면 다른 요소(리뷰 목록)가 스크롤되도록 하는 동작이 `스크롤 체이닝`인데, `overscroll-contain`이 그걸 막는 역할을 한다.
	- 하지만 특정 조건에서 `overscroll-contain`이 스크롤을 먹통으로 만들 수 있음
		- 높이 계산 오류 : 브라우저가 컨테이너 내용물이 "끝"에 도달했다고 판정하는 경우 `contain` 속성으로 모든 스크롤 입력을 차단한다. `flex-grow` 등으로 컨테이너의 높이가 유동적으로 변하는 경우에도 발생할 수 있음.

- 그러면 `overscroll-chain`을 없앴을 때, 내부 스크롤이 끝에 도달하더라도 외부 메뉴가 움직이는가를 체크해봐야 함 
- **그런 거 없다.** 지우면 됨.





---
