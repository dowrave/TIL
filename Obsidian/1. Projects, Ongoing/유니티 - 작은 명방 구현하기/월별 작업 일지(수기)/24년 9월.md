
## 240930
[[240930 정리]]
### 유사 명방

#### 오늘의 목표
> - 여러 개 배치 가능한 요소를 배치했을 때 짧은 쿨타임 돌리기
> - 여러 개 배치 가능한 요소가 파괴되어도 긴 쿨타임 시작되지 않게 하기
> - 바리케이드까지의 경로 찾기 : enemy가 있는 타일에 바리케이드가 배치되면 targetBarricade는 같은 타일의 바리케이드가 돼야 함
> - 여러 개 배치 가능한 요소는 `Box` 부분에서 남은 갯수가 UI로 나타나야 함

1. 여러 개 배치 가능한 요소는 `Box` 부분에서 남은 갯수가 UI로 나타나게 함
	- 관련 자식 요소를 `DeployableBox`에 추가함.
	- 이외에, 방향을 설정하지 않는 배치 가능한 요소의 경우 단순히 `Deploy` 메서드를 이용했었다. 이를 `DeploybleManager.DeployDeployable`을 사용하도록 수정했음.

2. 여러 개 배치 가능한 요소를 배치했을 때 짧은 쿨타임 돌리기
	- 미리 설정이 잘 되어 있었다.

3. 여러 개 배치 가능한 요소가 1개 파괴되어도 긴 쿨타임 시작되지 않게 하기
	- `OnDeployableRemoved`에서 `Operator`가 파괴됐을 땐 쿨타임이 동작되게 하지만, `Deployable`의 파괴에서는 동작되지 않게 함

4. enemy가 있는 타일에 바리케이드가 배치되면 targetBarricade는 같은 타일의 바리케이드가 되어서 바로 파괴하게끔 반응해야 함
	- `OnBarricadePlaced` 메서드에, 바리케이드가 밟은 타일의 리스트에 이 `Enemy`가 있다면 `targetBarricade`를 해당 바리케이드로 설정함.

> 생각보다 엄청 빨리 끝났다. 1시간도 안 걸린 듯?

#### 추가 목표
> - 원거리 `Enemy`의 경우, 공격 모션 중일 때는 이동하지 않는다. 
> - **공격 모션을 지금 구현하지는 못하더라도** (`Animator`가 지금은 없다.) 공격 중에는 멈추는 동작을 구현함.

- 시작점
	* 공격을 시도했을 때 이동을 멈추는 시간(= 나중에 애니메이션에서 동작 전체가 들어가는 시간) `AttackMotionTime`
	- 다음 공격까지 공격하지 못하는 시간 `AttackCooldown`
- 위 요소들을 `공격 속도`와 연관을 지어야 하겠다. 
1.  `AttackCooldown`의 구현에 `AttackSpeed`값으로 나누는 로직이 들어간다.
2. 그리고 `AttackMotionTime`은 일반적으로 `AttackCooldown`보다는 짧아야 한다. 같다면 이동이 불가능하고, 길다면 모션 중인데 다음 공격이 나갈 수 있기 때문이다. 

- 결과 : [[공격 모션 추가한 설정]] 이런 느낌으로 구현되었음.
	- 기본값으로 `Cooldown`이 1일 때, `Duration`은 0.3 정도로 구현했다. 0.8 정도로 했더니 너무 오래 이동하지 않음.

#### 추가 목표 구현 후 발생 이슈들

> - 투사체의 경우, 날아가는 중에 목표가 사라지면(?) 오브젝트 풀로 돌아가지 않는 현상 발생
> - `Enemy` 기준, 바리케이드 파괴 로직이 동작하지 않는 현상이 있음
> - 근거리 공격에 쿨타임이 없는 듯한 상황

> - 근거리 공격에 쿨타임이 없는 듯한 상황
- 위에서 공격 모션 시간을 넣으면서 `Attack()`메서드의 시작에 `SetAttackTimings()`을 넣었는데, `Enemy.PerformMeleeAttack`의 경우 `Attack` 메서드 외에서도 따로 곧바로 호출되는 케이스가 있음. 
- 따라서 `SetAttackTimings()`를 `PerformMeleeAttack, PerformRangedAttack`의 시작 부분으로 옮김.

- 나머지 2개는 문제가 발생하는 상황을 정확히 캐치하기가 어려운 점이 있다. 
- 그래서 일단 그런 경우가 있다는 걸 인지하고만 있자.




## 240927
[[240927 정리]]
### 유사 명방
- 여러 개 배치할 수 있는 것과, 1개만 배치할 수 있는 것 구분짓기
	- 이거는 스테이지와 연관을 지어야 할 것 같음 : 유저가 편성할 수 있는 요소가 아니라, 스테이지마다 제공되는 요소가 있음
	- 즉 `DeployableManager`에서 `Operator`들의 목록을 기본적으로 가져오지만, 스테이지마다 제공되는 `DeployableUnitEntity`가 별도로 있어야 함
	- 그리고 여러 개 배치할 수 있는 요소는 `Operator`와 구분되는 요소들이 있음
		- 한 번 설치하면 파괴되거나 철수하더라도 갯수가 회복되지 않음
		- 1개를 배치하고 나서 다음 배치까지 쿨타임이 있음
			- 다음 배치까지의 쿨타임에서 DeployableBox에 남은 쿨다운이 표시되어야 함
	- **편성 씬까지 만들 것을 고려해서 `UserSquadManager`를 별도로 구현함**
		- 편성 씬 ~ 인게임 씬 초기화까지 동작. 
		- 최종적으로 `StageManager`에서 관리하는, 스테이지마다 제공되는 `DeployableUnitEntity`와 합쳐서 `DeployableManager`에 요소들을 제공하는 방식으로 구현하려고 함

등등이 있다. 이거 끝나면 다음으로 넘어감. 오늘은 겁나게 집중이 안된다.

#### 야간 작업
> - `Barricade`의 배치는 잘 동작하는데 `Operator`의 배치가 이상해짐
- `ClickDetectionSystem`이랑 `DeployableManager.EndDragging`의 충돌로 보임
- `ClickDetctionSystem.HandleClick` 메서드 수정, 아래 부분 추가
```cs
        // 방향 선택 중이거나 드래깅 중일 때는 DeployableManager에서 처리함
        if (DeployableManager.Instance.IsSelectingDirection || DeployableManager.Instance.IsDraggingDeployable) return;
```

> - `Operator` 배치 정상화시키고 나서 파괴됐을 때 쿨타임 잘 돌아가는지 확인하기 
- `Operator` 자체는 파괴됐을 때 잘 돌아가는 거 확인함.

## 240926

### 유사 명방

[[240926 정리]]
- 오늘의 교훈 : 메서드에서 **이벤트를 발생**시킬 때, (맥락에 따라 물론 달라지겠지만) **일반적으로는 가장 마지막에 놓는다.** 
	- 파괴 이벤트일 경우에는 `Destroy()` 바로 앞에 놓으면 됨
#### 바리케이드 관련
> (O) 다른 경로가 없다면 바리케이드를 공격해야 함
> - 길들이 완전히 막히면 `Enemy`가 정지됨. 그런데 `targetBarricade` 등의 설정은 잘 되는 것 같다.
> 	- 길 찾기 로직에서 목적지 타일이 `IsWalkable = false`가 되어서 그런거 아닌가?로 접근해봄.
> 	- 이 경우에 경로를 계산하는 로직은 바리케이드가 마지막 타일이라면 경로에 포함시키지만, 마지막 타일이 아니라면 경로에서 제외해야 함
> 	- `PathfindingManager.CalculatePath()` 여기서 막혔다. 나중에 다시 ㄱㄱ.

- 위 이슈 해결 시도. 
```cs
foreach (Tile neighbor in GetNeighbors(currentTile))
{
	if (closedSet.Contains(neighbor)) continue; // 이미 포함된 타일
	if (neighbor.HasBarricade()) 
	{
		Debug.Log($"바리케이드가 있는 타일 : {neighbor}");
		if (neighbor == endTile)
		{
			Debug.LogWarning($"바리케이드가 있으면서 마지막인 타일 : {neighbor}");
		}
		else continue; 
	}
```
1. `GetNeighbors` 자체에 `Tile.TileData.isWalkable` 조건이 들어가 있다. 애초부터 걸을 수 없는 타일은 아예 배제됨.
	- 대신 바리케이드로 인해 `Tile.IsWalkable` 프로퍼티가 변할 수는 있다.
2. 그러면 바깥 조건문에서 따질 상황은 타일에 바리케이드가 있을 때, 그 타일이 마지막 타일인지 아닌지 여부만 가리면 됨
	- 그런데 지금처럼 조건을 넣는 경우에 원래 경로에 바리케이드가 생기는 상황에서 바리케이드 타일을 그대로 지나가는 경로가 생성되고 있음.
	- 이건 내가 A* 알고리즘을 잘 이해를 못한 건가? 근데 어쨌든 경로찾기 로직은 일일이 타일을 다 뒤져보잖음?

> 1. `Tile.HasBarricade` 디버깅
- 헐 `false`로 나오네?
- 일단 바리케이드를 무시하고 목적지점까지 달리는 이슈는 얘가 원인이 맞았음 - 즉, 바리케이드를 배치할 때 해당 요소가 배치됨을 타일에 알리지 않았기 때문임

- 아예 `Enemy.cs`에 목적지로 향하는 경로를 찾고 없으면 바리케이드를 지정하는 올인원 메서드를 구현 `FindPathToDestinationOrBarricade` 
- 초기화 때 경로가 이미 막힌 상황일 경우에 움직이지 않는 문제가 있었음. 경로가 없다면 바리케이드를 찾도록 수정(위 메서드를 사용)

> 2. (O)`targetBarricade`에 도달했음에도 바리케이드를 파괴하지 않는 문제
- `Vector3.Distance` 거리 설정 문제. `Barricade`는 `y = 0.1`인데 반해 다른 요소들은 `y = 0.5`로 설정되었기 때문. **거리를 `0.5`로 조절했다.**


> 3. (O)바리케이드를 파괴한 후 모든 `Enemy`가 목적지로 향해야 하지만, **실제로는 일부 `Enemy`만 목적지로 향한다.** -- 이벤트 호출 타이밍 문제?
- `Enemy.OnBarricadeRemoved` 메서드를 `IEnumerator` 반환으로 변경, 메서드의 시작에 `WaitForSeconds(0.1f)`를 추가해 바리케이드가 파괴되는 로직이 작동할 시간을 확보했다.


> 4.(O) 가장 가까운 바리케이드를 찾아 파괴하는 게 원래 구현의도였는데 실제로는 **모든 Enemy가 하나의 바리케이드를 향해 달리고 있다** 
- `PathfindingManager.GetNearestBarricade`
- 여러 바리케이드가 생성되었음에도 `PathfindingManager` 의 바리케이드 위치 정보를 조회하면 1개의 바리케이드만 나타난다. `AddBarricade` 메서드에 뭔가 이상이 있는듯?
- `Barricade`에서 이벤트를 발생시키기 전에 `AddBarricade`와 `RemoveBarricade`를 동작하게끔 변경하니까 잘 동작함.

> 5. (O) 클릭 메서드가 배치 직후의 마우스 버튼 업을 바로 인식해서 ActionUI가 나타나는 이슈
- 이게 배치됨과 동시에 클릭 메서드가 동작하는 걸로 보임
- 오퍼레이터는 방향을 설정해야 하니까 커서 위치를 클릭하는 게 아니라서 `ActionUI`가 나타나지 않았는데, 방향을 설정하는 로직이 없는 모든 상황에서 문제가 발생할 것 같다. 
- `DeployableUnitEntity.cs`에서 `Deploy`될 때의 시간을 기록, `OnClick()` 메서드가 동작할 때 0.1초 이내일 때에는 CancelPlacement를 동작시키도록 함(이미 배치되었기 때문에)
## 240925
[[240925 정리]]
### 유사 명방
#### 바리케이드 관련
- `Enemy`가 나타난 다음, 바리케이드를 배치했을 때 어떤 `Enemy`는 경로 수정이 동작하는데 다른 `Enemy`는 경로 수정이 동작하지 않음. 둘 다 같은 스크립트에 같은 `PathData`를 쓰는데 왜?
	- `Spawner`에서 여러 `Enemy`를 추가해본 결과, 1번째 프리팹만 원하는 대로 동작하고 나머지 프리팹들은 바리케이드 이벤트를 등록했음에도 동작이 이뤄지지 않는다. 
	- (실험은 4개의 프리팹을 사용, 그 중 1, 4번째와 2, 3번째는 같은 프리팹을 사용했다.)
```cs
    private void SetTargetBarricade()
    {
        targetBarricade = PathfindingManager.Instance.GetNearestBarricade(transform.position); // 가장 가까운 바리케이드 설정
        if (targetBarricade != null)
        {
            SetNewPathData(transform.position, targetBarricade.transform.position); // 새로 경로 설정
        }
    }
```
> 여기서 `if (targetBarricade != null)` 부분만 추가했더니 해결됐다. 이거 고치려고 1시간을 헤멤. 
> **예상한 것과 다르게 동작하는 상황에서, Error가 발생하고 있다면 Error부터 해결하고 봐야겠다.** 상관 없어 보이는 Error였는데도 이거 고치니까 멀쩡하게 돌아감;

- 해결할 것들
> (X) 다른 경로가 없다면 바리케이드를 공격해야 함
> - 길들이 완전히 막히면 `Enemy`가 정지됨. 그런데 `targetBarricade` 등의 설정은 잘 되는 것 같다.
> 	- 길 찾기 로직에서 목적지 타일이 `IsWalkable = false`가 되어서 그런거 아닌가?로 접근해봄.
> 	- 이 경우에 경로를 계산하는 로직은 바리케이드가 마지막 타일이라면 경로에 포함시키지만, 마지막 타일이 아니라면 경로에서 제외해야 함
> 	- `PathfindingManager.CalculatePath()` 여기서 막혔다. 나중에 다시 ㄱㄱ.

> (X) 클릭 메서드가 배치 직후의 마우스 버튼 업을 바로 인식해서 ActionUI가 나타나는 이슈


## 240924
[[240924 정리]]
### 유사 명방

#### 바리케이드 배치, 경로 변경, 갈 수 있는 길이 없을 경우 바리케이드 공격

이것들부터 시작함
> (O) Enemy가 생성되기 전에 바리케이드가 경로에 생겨서 진로를 바꿔야 하는 경우

- `PathfindingManager`에 바리케이드 배치 여부를 두고, `Enemy`의 초기화에서 이를 체크하도록 함
- 바리케이드 배치 위치 : 타일 바로 위로 수정
- 바리케이드 공격 로직 관련
- [[Unity - IEnumerator와 Update가 동시에 있음]]

- 코드로만 작성하려니까 안 그려져서 초안을 잡고 가겠음
- **길이 막힌 경우**
	- `IsPathBlocked()`으로 검사
	- 배치된 바리케이드 중 가장 가까운 경로의 바리케이드를 검색
	- 원거리 적의 경우 공격하는 상태를 계속 유지
	- 바리케이드는 원거리 공격으로 파괴되어서 안됨. 공격 거리에 관계 없이 바리케이드에 도달했을 경우에만 바리케이드를 공격함

> 예상이랑 동작이 너무 다른 지점들이 있어서 당황스럽다. 계속 만져야 할 것 같음.

## 240923
[[240923 정리]]
### 유사 명방
- 바리케이드 배치 확인 및 바리케이드 배치 시 Enemy의 경로 변화 확인
	- (O)바리케이드가 `DeployableUnitEntity.cs`의 자식인 만큼, `Data`를 이용해서 일률적으로 관리할 필요가 있을 것 같음. 
> `EntityDataEditor.cs`를 수정, 해당하는 Data 타입이 없으면 부모 Data 타입의 필드들을 인스펙터에 나타나도록 수정. 끌로드 만세 

- 이슈) 바리케이드가 배치됐을 때 경로가 수정되지 않는 문제
	- 바리케이드를 그냥 통과하는 것 자체는 문제가 아니다. 애초에 충돌 구현을 안했으니까.
	- (O)배치됐을 때 경로가 바뀌는 것
		- `PathfindingManager.CalculatePath` 부분의 `neighbor.Data.isWalkable` 을 `neighbor.IsWalkable`로 변경했다. 근데 이러니까 경로가 있는데도 없다고 뜬다.  `FindPath` 부분이 잘 동작하지 못하는 듯?
			- `IsWalkable` 프로퍼티가 각 타일에 할당되지 않았음. `Tile.Awake`에서 할당.

> Enemy가 생성된 상태에서, 바리케이드가 경로 중에 설치된 경우 진로를 바꿔 진행하는 것까지는 구현이 되었다.
> - 앞으로는 Enemy가 생성되기 전에 바리케이드가 경로에 생겨서 진로를 바꿔야 하는 경우
> - 다른 경로가 없다면 바리케이드를 공격해야 함
> 추가로 클릭 메서드가 배치 직후의 마우스 버튼 업을 바로 인식해서 ActionUI가 나타나는 이슈도 수정하면 바리케이드 관련해서는 다 정리될 것 같다.



## 240921
[[240921 정리]]
### 유사 명방
- `Operator`의 타겟 선정 로직 개선 : 남은 거리가 가장 짧은 `Enemy`를 우선 공격함
	- 이를 위해 `Enemy`는 목적지까지 남은 거리값을 가져야 함
	- 일단 이거 자체는 구현했음. 원래 더 하려고 했는데 오늘은 뭔가 매우 나른하다.


## 240920
### 유사 명방
- 공격 대상에 구분을 주기 위해 `IFactionMember` 인터페이스 추가
	- `Ally, Enemy, Neutral`
- `Enemy` 기준, `Operator`의 배치 순위 조정
- [[CSharp - LINQ]]
- 발생 중이었던 문제 수정
	- `Operator`의 `AttackCooldown`이 계속 0으로 뜨는 문제
	- 체력이 0이 됐음에도 `Enemy`가 제거되지 않는 문제
	- `Operator`가 이제 공격도 안하는 문제
	- 모두 `UnitEntity.TakeDamage`에서 `OnHealthChanged.Invoke(CurrentHealth, MaxHealth);`에서 `nullException`이 떴기 때문이었던 것으로 보인다. 이벤트에 널 체크 추가 `?`을 해줘서 해결했음.
	- - 배치 중에, 배치 불가능한 타일에서 커서를 놨음에도 공격 범위가 표시되는 현상
- 탄알집(오브젝트 풀링)
	- 이를 위한 `ObjectPoolManager`를 구현하고 `Operator`, `Enemy` 스크립트 수정

## 240919
[[240919 정리]]
### 유사 명방

- 수정 완료
	- 체력이 0이 됐음에도 `Operator`가 제거되지 않음 + `DirectionIndicator`가 없다는 이슈
		- **`Operator.Initialize()`가 사용되지 않고 있었다. `DeployableManager`에서 사용하도록 수정.**
		- 인스턴스화는 됐는데 초기화는 안 되어서 나타나야 할 요소들이 나타나지 않았던 거임! 
	- 배치 중에는 반투명하게, 배치 후에는 불투명하게 머티리얼 설정 조정
		- [[Unity - 투명 머티리얼 설정]]
	- 타일 하이라이트 설정 조정
	- 배치 불가능한 타일에서 커서를 뗐을 때 공격범위 표시되는 현상 수정

- 그래도 진도 못나가고 있는 지금 사태의 끝이 보인다

## 240918

### 유사 명방
- 배치 자체는 잘 구현되고 있음
- 대신 전투 관련 이슈들이 있어서 그거 수정 중.
	- (O)`Enemy`의 `HP` 초기화 문제
	- (O)쿨타임 없이 무한 원거리 공격을 날리는 `Enemy`
	- (O)`Operator`가 배치된 후에 체력이 초기화가 되지 않는 현상
	- (X) 체력이 0이 됐음에도 `Operator, Enemy`가 제거되지 않는 현상
- [[Unity - 변수 초기화 타이밍]]


## 240916

### 유사 명방
- 리팩토링 전, 정상적으로 작동하던 기능들 돌려놓기
	- `BottomPanelDeployableBox` 초기화 이슈
	- 알았어도 막상 써먹으려면 어려운 기능들
		- [[CSharp - 형 변환(Type Casting)]]
		- [[CSharp - 제네릭]]

- 너무 골치아파요 ㅠㅠ
- `currentStats`으로 초기화하고 거기 프로퍼티로 접근하는 거랑 그걸 `currentStats.detail`로 접근하는 거랑 동작이 다르다?
1. 이왕이면 `currentStats`이라는 프로퍼티 내의 구조체 필드로 직접 접근함. 별도의 정의가 필요한 경우에만 엔티티에 별도로 구현.
2. `deployableUnitEntity`와 `Operator` 간의 다형성이 있지만, 각각의 필드를 사용하는 것에 있어서는 위의 `형 변환`에 의해 별도로 접근하는 게 좋은 것 같다.

> - 주로 문제가 터졌던 곳들이 `ScriptableObject`로 구현했던 것들의 필드를 프로퍼티로 사용했기 때문인데, 이렇게 구현하는 경우 필드에 값을 할당한 직후에 그걸 바로 사용하려고 할 때 Null이 발생하는 문제가 있었음.
> 	- 그냥 `currentStats`이라는 구조체로 퉁쳐서 정리하고 그것의 필드들로 접근하기로 함. 
>- 대신 프로퍼티는 구조체 내에서 정의해서 여러 계층으로 나뉘지 않게 했음.

- 얼추 구현이 되었고 `Enemy`의 생성은 되는데 이동은 하지 않는 문제부터 수정 더 하면 될 듯. 어쨌든 최초 목표였던 **리팩토링 후 배치 기능 작동하기** 는 성공적으로 끝냈다.



## 240913
[[240913 정리]]


### 유사 명방
> 가장 먼저 할 일 : 수정된 Stats, Data 들로 기존 Entity, Operator, Enemy 스크립트 수정하기

#### 스탯, 데이터 정리
> 어떤 구조를 만들려니 다소 복잡해지는 감이 있어서, 약간 노가다성이 있더라도 직관적으로 보이게 수정했음. 특정 객체에 들어가는 필드들은 주석으로 표시해둠. 

1. `Stats`은 상위 객체의 구조체를 필드로 가져와서 사용하지만, 해당 필드들로 접근하는 프로퍼티는 별도로 구현(모든 스탯 필드에 동일한 위계에서 접근하기 위함)
2. `ScriptableObject` 간의 상속을 끊고, 모두 개별로 구현.
3. `Entity`에서는 `Stats`을 프로퍼티로 접근하지 않고, `private` 접근자를 가지도록 구현.
	- 프로퍼티로 구조체를 구현할 경우 `Stats.Health` 같은 수정이 불가능하다는 오류가 뜬다. 한 번 복사해서 쓰기 때문인데, 별도의 세터 메서드를 구현해야 해서 번거로운 느낌임.

- [[Unity - 접근자]]

- **이슈 1) BottomPanelDeployableBox에서 아이콘이 초기화되지 않는 문제** 
-> 엔티티의 필드들이 초기화되지 않은 상태에서 시도가 되기 때문으로 보임. `Start()`나 `Awake()`로 빼둬야 하나?
- 이슈 2) Data 필드들이 여전히 인스펙터에서 중복해서 나타남 -> 해결

> 진도가 안나가서 돌아부리겠네~~~


## 240912
[[240912 정리]]
### 유사 명방

#### 리팩토링
- [[Unity - Vector3.MoveTowards]]
- `Enemy, Operator`까지는 정리 완료, 이제 배치 로직 정리 시작
![[Pasted image 20240912230100.png]]
> OperatorData를 살펴보니 이런 식으로 `Stats`가 중복해서 나타나는 현상이 있다. ㅡㅡ

- `Stats`, `Data` 관련 로직들은 다 뜯어 고침. 이들의 상속 구조를 없애고 모두 개별 필드로 정의했다. 이게 제일 쉽겠다. 하..
- 이걸 이용하는 기존 객체 스크립트는 내일 고치자. 후...

## 240911

### 유사 명방

#### 시작 전 구조에 대한 생각
- 커피를 사러 가다가 이런 생각이 들었다. 
- 지금의 프로젝트 구조는 아래의 방식으로 스탯을 사용하고 있다.
```
UnitEntity : UnitStats currentStats
	- DeployableUnitEntity : DeployableUnitStats currentStats
		- Operator : OperatorStats currentStats
```
여기서 피격 로직은  `UnitEntity`에 정의되어 있고 그 메서드는 `UnitStats currentStats`의 필드의 값을 가져와서 사용하는 방식이다. 그러면 메서드를 상속받은 `currentStats`에서는 `UnitStats`을 사용하나? `currentStats`을 사용하나?

> 자식 클래스에서 동일한 변수명을 재정의하고 있기 때문에, 부모 클래스의 `currentStats`은 숨겨진다. 

- **스탯은 `구조체 -> 클래스`로 바꿨음!**

#### 리팩토링
- `Operator.cs` 정리 얼추 됨. `Enemy` 관련 스탯과 `EnemyData` 정리 시작.
- 스탯을 프로퍼티로 관리해야 하는지 여부에 대해서 계속 고민이 많다. 진도가 생각보다 못 나가고 있음.



## 240910

### 유사 명방
[[240910 정리]]
#### 리팩토링
- `DeployableUnitEntity` 및 여러 인터페이스를 기반으로 `Operator, Barricade` 구현
- 기존 `Deployable`을 사용하던 다른 스크립트들도 수정
- [[Unity - 스크립터블 오브젝트]] 하단에 보충 설명 추가.
	- `Stats`은 구조체로 구현하는데, 스탯도 자식 클래스로 가면서 더 많은 것들을 사용해야 해서 어떻게 구현할지 고민했음. **부모 클래스에서 사용하는 구조체의 필드를 자식 클래스에서 사용하는 구조체의 필드로 복사 / 붙여넣기**해서 사용함. 
		- 이렇게 안 하면 `구조체.구조체.구조체.필드` 같이 필드로 접근해야 하고, 어떤 필드가 어떤 구조체에 있는지 파악하는 것 등 여러모로 번거로워짐
		- 각 클래스의 `Initialize`도 추상화하지 않고 각각의 `ScriptableObject`를 초기화하는 방식으로 변경함
		- 이러면 상속의 의미가 조금 애매해지는 거 아닌가? 싶었는데, 부모 클래스에서 자식 클래스로 오버라이드하는 메서드들이 있기 때문에 크게 상관 없을 것 같다. 



## 240909

### 유사 명방

#### 리팩토링
- 리팩토링을 한 번 하기는 했는데, 그 결과물이 그렇게 만족스럽다는 느낌은 아니어서 아예 싹 한번 다시 갈아엎겠음
	- 명방 게임 자체는 장애물 같은 배치 가능한 요소도 그냥 오퍼레이터처럼 처리되게 만든 것 같음. 단, 방향을 지정하는 로직 자체는 없는 듯.
- 일단 타일 위에 배치되는 / 돌아다니는 요소를 위한 `UnitEntity`의 구현부터 시작.
- `DeployableUnitEntity`까지 구현하고, `Operator`나 `Barricade`의 공통된 기능들을 정리
★ 아직 실행 불가능. 최종적으로 배치 로직까지 완전히 적용되어야 완료된다.


## 240906
[[240906 정리]]
### 유사 명방

#### 배치 로직 리팩토링
> 어제 발생한 문제들 수정 중
> - 화면 하단의 패널의 아이콘 색깔들이 흰색으로 되는 현상
> - `IDeployable` 드래그 시, 미리보기가 동작하지 않음
> - 배치 방향 설정 같은 것도 나타나는 듯 보이는데, 실제로 배치될 요소가 나타나거나 하지는 않고 있음.

* 수정 완료
	- 색상 변하는 문제
	- 미리보기 나타나지 않는 문제
	- 하단 패널 / 오퍼레이터 클릭 시 카메라가 이상하게 이동하는 현상
- 새로 발견한 문제 -> 해결 완료
	- 오퍼레이터 퇴각 버튼 눌러도 동작하지 않음 
	- 바리케이드 클릭해도 ActionUI 나타나지 않음

- 이제 장애물 배치하고 나서 적의 경로 바뀌는 구현하면 될 듯? 
- 바리케이드 관련 아직 남은 문제도 있음


## 240905
[[240905 정리]]
### 유사 명방

#### 바리케이드 구현, BottomPanelOperatorBox 리팩토링
- 만들고 복잡해져서 엎기를 수 차례 반복했다..
- 일단 전체적인 과정 자체는 마무리가 됐는데, 여전히 머릿속으로 정리가 되지 않는 것들이 있음. 급하게 가지 말고 차근차근 해야 할 것 같다. 예를 들면 `IDeployable`을 상속받는 `Operator`, `Barricade` 만으로는 약간 부족한 느낌이 듦. 차라리 클래스를 상속받게 하는 게 나을지도.
	- 근데 추상 클래스를 또 구현하면 `Unit` 상속과 충돌이 일어난다. `Unit`은 `Enemy`로 또 이어지기 떄문에, 골치가 아픈 부분.
- IClickable를 IDeployable로 통합.

> 대략적인 수정은 마친 상황에서, 현재 발생중인 문제
> - 화면 하단의 패널의 아이콘 색깔들이 흰색으로 되는 현상
> - `IDeployable` 드래그 시, 미리보기가 동작하지 않음
> - 배치 방향 설정 같은 것도 나타나는 듯 보이는데, 실제로 배치될 요소가 나타나거나 하지는 않고 있음.




## 240904
[[240904 정리]]
### 유사 명방

#### 오류 수정
- 배치 중인 오퍼레이터가 미리보기 상태일 때 `Enemy`가 오퍼레이터를 공격하는 문제 수정
	- `isDeployed` 필드를 `IsDeployed`라는 프로퍼티로 관리

#### 스크립트들 정리
- 어제 작업하면서 이게 왜 여기 있지? 하는 느낌이 드는 부분들이 종종 있었다. 이 부분을 정리해보려고 함.
- 크게 `Unit, Enemy, Operator`를 만지고 있는데, 또 되던게 작동 안하기 시작. ㅡㅡ 
	- `Data` 들을 뜯어고치는 과정에서 `Melee`로 지정되어 있었다. 후... 그래서 `AttackRange` 값이 `0`으로 나타났기 때문에 작동을 안했던 것.
```cs
Operator op = collider.GetComponent<Operator>();
```
> 여기서 `collider`는 자식 오브젝트인 `model`에, `Operator` 스크립트는 부모 오브젝트에 있는데도 동작했다. 왜냐하면 `GetComponent`는 해당 오브젝트에 스크립트가 없다면, 부모 오브젝트로 거슬러 올라가며 뒤지기 때문이다.
> 따라서, 작동은 하지만 (큰 차이는 없더라도) 성능적인 열화가 있을 수 있다. `GetComponentInParent`로 수정.

#### 바리케이트 구현
- `바리케이트` : 타일 위에 배치해서 적의 경로를 비틀 수 있음
- 기존 오퍼레이터와 동일하되 약간의 차이가 있는 구현을 해야 하는데, 이거 설정이 생각보다 까다롭다. 바꿔야 할게 좀 많기 때문이다.
- 근데 기존 깃으로 되돌리기에는 경로 변경 시 수정 사항을 작업해 놓은 게 있다.  바리케이드 스크립트, 오브젝트까지는 냅두고, 나머지 로직들을 원상복구 해놓겠음.




## 240903

### 유사 명방

- 경로 설정 과정에서 `Enemy`의 포지션이 타일 속으로 묻히는 문제가 있었음
	- `targetPosition`의 좌표 설정 시 `Vector3.up * 0.5f`를 더해주면 됨

#### 원거리 적 구현하기
- 공격 범위는 "값"으로 구현하겠음 : 적은 이동하면서 쿨타임이 돌 때마다 **가장 최근에 배치된 적을 공격함**
- `RangedEnemy`라는 클래스를 따로 구현하는 것도 생각해봤는데, 실질적으로 차이는 `EnemyData`에 `EnemyType`을 두고(`Melee, Ranged`) `AttackRange`값의 차이 만으로 실질적인 동작의 차이가 발생할 것 같아서 별도로 구현하지는 않음. 즉, `Enemy` 하나에 근거리, 원거리 동작을 다 포함시킨다.
- 이전에 `Unit`에 근/원거리 여부나, 공격 타입 등이 설정되어 있어서 `EnemyType`을 쓰지 않고 해당 `enum` 타입들을 사용하고 있음.

- 코드를 나중에 한 번 고칠 필요는 있을 것 같다. 상속이 큰 의미가 없는 경우도 있고..

## 240902
[[240902 정리]]
### 유사 명방
- 오퍼레이터 배치 시, 몇몇 하이라이트된 타일에 배치가 불가능한 문제 수정 
	- 예전에 맵을 수정한 적이 있었는데, 거기서 새로운 타일을 생성한 경우, 해당 타일이 하이라이트되지만 그 위에 스냅핑이 되지는 않는다.
	- `OperatorManager.cs`를 살펴보면 `GetHoveredTile` 메서드에서
```cs
    private Tile GetHoveredTile()
    {
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        RaycastHit hit;

        if (Physics.Raycast(ray, out hit, Mathf.Infinity, tileLayerMask))
        {
            return hit.collider.GetComponentInParent<Tile>();
        }

        return null; 
    }
```
> 위와 같음. 즉, `tileLayerMask`라는 레이어를 레이캐스트로 검사한다.
- 실제로 새로 에디터로 만든 타일들에는 `Tile` 레이어가 할당되어 있지 않다. 하이라이트 자체는 잘 작동함.
	- 따라서 타일이 생성될 때 레이어에 `타일` 레이어를 지정하는 것만으로 충분함

- `Map.cs`의 메서드 이름 수정 : 기존엔 메서드의 역할이 불분명하거나 이름만으로 어떤 기능을 하는지 직관적으로 파악하는 게 어려웠음

- 오퍼레이터 배치 동작 시 시간이 느려졌다가 원상복구될 때, 2배속임에도 1배속으로 돌아오는 현상 수정, `OperatorManager`에 있는 시간 관리 메서드들을 `StageManager`로 통합

- 일단 보이는 문제는 다 처리한 듯?

#### 경로 설정하기
- 기존엔 `PathfindingManager`를 이용해서 최단 경로를 찾는 알고리즘으로 구현했다.
- 그런데 실제 명방을 보면, 어떤 위치에서 몇 초 쉰다든가, 아니면 빙글빙글 돈다든가 하는 식으로 개발자가 직접 경로를 설정하는 것으로 보이는 예시가 많았다.
- 그래서 이번엔 경로를 직접 설정하는 방식을 구현해보려고 함.
- 아예 `ScriptableObject`에 `PathData`를 만들고, 여기에 유니티 엔진 상에서 씬 뷰를 클릭해서 해당 타일을 경로에 넣는 방식으로 직접 편집할 수 있게끔 구현하고 있다. 
- 그런데 `Tile` 레이어로 설정하면 `Scene` 뷰에서는 안 보이는데 `Game` 뷰에서는 보이는 문제가 있다. ???? `Culling Mask` 이슈도 아니다.
	- 그냥 `Tile` 레이어를 옮겼다. 나중에 충돌이 나는 사안이 있다면 그때 보자.
- 대기 시간도 설정을 한 상태인데, 대기가 끝나면 다음 노드로 옮겨야 하는데 그러지 못하고 그 자리에서 그대로 끝나버리는 현상이 있었다
	- 인덱스만 잘 추적시켜 놓으면 된다. 


## 240901

### 유사 명방
- 공격 범위에서 적이 벗어나도 계속 공격하는 문제 해결
- `StageManager`에서 `UIManager` 의 역할을 하는 부분을 `UIManager`로 옮김
- 사실 원래 계획은 버튼의 클릭 이벤트가 마우스 버튼다운 때 1번, 마우스 버튼 업 때 1번 총 2번 발생하는 걸 해결하려는 계획이었는데, 정작 이건 해결 못하고 있음.
	- **`ClickDetectionSystem`과의 충돌 때문 아닐까??** 실제로 `MouseButtonDown` 때 `HandleClick` 메서드가 발동되도록 하고 있다.
	- `MouseButtonDown`과 `Click`을 구분했다.

- 머릿속으로 생각하려니 계속 헷갈려서 동작을 정리함 : [[마우스버튼다운, 클릭 동작 정리]]
	- 문제 자체는 해결됐다. 근데 갈수록 스파게티 코드가 되고 있는 것 같다..
	- 며칠 동안 헤맨 문제여서 해결한 것에 의의를 둬야겠음.

- `Button` 컴포넌트의 `OnClick`의 경우, 별도로 구현하지 않더라도 유니티의 UI 시스템에 의해 기본적으로 동작한다. 따라서 `ClickDetctionSystem`에서 굳이 별도로 `onClick.Invoke()`를 구현할 필요는 없다. 이거 구현하면 2번 실행됨.

