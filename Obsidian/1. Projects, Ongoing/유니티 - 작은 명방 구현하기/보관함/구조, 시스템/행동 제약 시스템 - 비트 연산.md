
#유니티 
>[!example]
>- 이런 상황을 생각해보자
>- 2개의 공격 불가능한 다른 종류의 디버프가 있음. 
>- 1개가 먼저 걸렸고, 나중의 디버프가 먼저 걸린 디버프 도중에 새로 걸린 상태.
>	- **각 유닛이 공격할 수 있는 상태**라는 걸 별도로 관리하고, 디버프가 걸릴 때 저 상태를 `비활성화`했다가 자기가 해제될 때 다시 `활성화`시키면, 나중의 디버프가 있음에도 이전 디버프가 해제시켜서 공격이 가능한 상태가 된다.
>	- 이를 방지하려면 디버프가 해제될 때마다, 걸린 버프 목록을 보고 공격을 불가능하게 하는 플래그가 있는 디버프가 있다면 해제되지 않는 식으로 구현할 수도 있겠음.

아예 이걸 더 간단하게 구현하는 방법이 있다. **`행동 제약 플래그 시스템`**
```cs
[System.Flags]
public enum ActionRestriction
{
    None = 0,          // 제약 없음 00000000
    Stunned = 1 << 0,  // 기절 상태 00000001
    Frozen = 1 << 1,   // 빙결 상태 00000010
    Disarmed = 1 << 2, // 무장 해제 00000100
    Rooted = 1 << 3,   // 속박 (이동만 불가) 00001000
    Casting = 1 << 4,  // 스킬 시전 중 00010000
    // ... 기타 필요한 제약 추가 ...

    // 여러 제약을 묶어서 편리하게 사용할 수 있는 그룹 정의
    CannotAttack = Stunned | Frozen | Disarmed | Casting,
    CannotMove = Stunned | Frozen | Rooted | Casting
}
```

**비트 연산자**가 사용되는데, `00000000` 이라는 비트가 있다면 각 비트는 1개의 상태이상이 걸렸는지 여부를 판단한다. 예를 들면 `00000001`이라면 기절에 걸린 거고 `00000011`이라면 기절과 빙결에 동시에 걸린 것이다.

>[!note]
 참고) `[System.Flags]`을 써두는 의도는 닷넷 프레임워크와 개발 도구에게 "**이 enum은 여러 플래그의 조합으로 사용되므로, `ToString`을 호출하거나 디버거에서 값을 표시할 때 단순한 숫자 값이 아니라 조합된 멤버들의 이름으로 보여달라**"는 의미가 된다. 실제 비트 연산은 저것과 관계 없이 가능함.
>- 예를 들어서 위 예제에서 **기절과 빙결에 동시에 걸렸다**고 하자.
>	- `[System.Flags]`이 없다면 출력 로그는 `3`이 된다. `1|2 = 3`이라서 그렇다.
>	- **`[System.Flags]`이 있다면 출력 로그는 `Stunned, Frozen`** 이 된다. 
>	- 둘 중에 뭐가 알아보기 쉽겠는가? 당연히 후자다. 

> [!note]
> 참고2) Slow 같은 상태 이상을 여기에서 구현할 필요는 없다. 슬로우는 느려지기는 하지만, 이동, 공격 등등을 모두 할 수 있는 상태이기 때문이다.


