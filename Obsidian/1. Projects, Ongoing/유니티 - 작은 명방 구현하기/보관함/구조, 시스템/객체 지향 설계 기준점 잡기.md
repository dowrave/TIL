- 의문점
> 이벤트로 구현하는 방법, 즉 오퍼레이터가 사망했을 때 이벤트를 발생시키고, 스킬에서는 따로 코루틴을 돌리고 있다가 오퍼레이터 사망 소식을 듣고 자신의 코루틴을 중단시키는 구현이 더 객체지향 설계라는 느낌이 아닌가?라는 의문이 들었다. 위 방식은 어쨌든 오퍼레이터에서 스킬이 어떻게 돌아가는지를 알아야 작성할 수 있는 코드니까.

- 객체지향 설계의 핵심 목표
- **캡슐화** : 객체는 자신의 상태, 행동을 내부에 숨기고 외부에는 필요한 기능만 공개한다.
	- 외부에 "이 버튼을 눌러라"고 알리고 세부적인 구현은 내부에서 담당하는 것
- **책임과 역할** : 각 객체는 자신만의 명확한 책임과 역할을 가진다
- **결합도 낮추기** : 객체 간의 의존성을 최소화해서 한 객체의 변경이 다른 객체에 미치는 영향을 줄인다.
- **응집도 높이기** : 한 객체는 서로 밀접하게 관련된 기능들로만 구성된다.

1. **이벤트 기반 설계 방식**
- 위에서 내가 생각한 의문점처럼 구현하는 방식.
- 장점
	- 최상의 캡슐화, 낮은 결합도 : `Operator`에서는 스킬이 어떻게 돌아가는지 알 필요가 없다. 
	- 유연성과 확장성
- 단점 
	- **생명주기 관리의 복잡성** : `ActiveSkill`의 구독 해지 시점은 정확히 어떤 타이밍일까? 스킬이 끝났을때? `Operator`가 죽었을 때? 여기선 후자로 보이지만, 이런 관리가 제대로 되지 않으면 보이 않는 버그의 원인이 된다.
	- **암묵적 의존성 : 의존 관계가 명시적으로 보이지 않는다.** 코드를 처음 보거나 수정할 때 `Operator`가 죽으면 `ActiveSkill`에서 어떤 일이 일어나는지 추적하기 어렵다.

2. **책임 주도 설계 방식**
- `Operator`가 메서드를 호출해 스킬을 사용한다.
- `Skill(지금의 경우 지속시간이 있는 ActiveSkill)`은 설계도`IEnumerator`를 `Operator`에게 준다.
- `Operator`는 설계도를 받아 자신의 책임 하에 코루틴을 시작하고 변수에 저장한다.
- `Operator`가 파괴될 때 자신의 책임 하에 실행 중인 코루틴을 중지시킨다.

- 장점
	- **명확한 책임과 소유권** : 코루틴을 실행하는 주체가 시작과 종료의 책임을 함께 진다. 프로세스의 시작과 끝이 한 클래스 내에 있기 떄문에 코드를 이해하고 관리하기 쉽다.
	- **안전한 생명주기 관리** : `OnDestroy`로 구현했기에 `MonoBehaviour`로 관리되는 유니티의 생명주기 모델과 어울리는 방식이다.
- 단점
	- **상대적으로 높은 결합도** : 1번 방식에 비해서는 캡슐화가 확실히 깨진다. `Operator`가 `BaseSkill`에 종류가 있음을 알고`is ActiveSkill` 그것이 코루틴을 반환할 수 있다는 것을 알고 있어야 한다. 

- 결론 : **프로세스의 실제 소유자가 누구인가?** 를 기준으로 판단하는 게 좋다.

1. `StartCoroutine`은 `MonoBehaviour`의 메서드이며, 코루틴은 그걸 실행시킨 `MonoBehaviour`의 생명주기에 종속된다. 즉, **`MonoBehaviour`가 실행 주체이며 실질적인 소유자이다.**
2. `ActiveSkill`은 스킬의 데이터, 로직을 담은 설계도나 레시피 북에 가깝다.

유니티의 구조 내에서는 프로세스의 실제 소유자인 `Operator`가 시작과 종료를 책임지는 2번 방식이 더 맞다고 할 수 있다. 캡슐화가 약간 깨지지만, 생명주기를 명확하게 관리할 수 있기 때문이다.

- **이벤트 기반** : 서로 다른 시스템(UI, 게임 로직 등)처럼 소유권과 생명 주기가 완전히 분리된 객체들을 연결할 때 매우 강력한 패턴이다.
- **책임 주도** : 한 객체가 다른 객체를 부품처럼 사용해서 자신의 생명주기 내에서 어떤 작업을 수행할 때 더적합하고 안전한 패턴이다.

## 250624 - 짭명방
- 모니터 바꾸고 게임 프로젝트 다시 꺼내는 건 처음인데, 색감이 좀 많이 뿌얘졌다.. ㅋㅋ;
	- 메인 모니터에는 돈을 아끼지 말아야지,,,

- 오늘의 교훈
	- `느슨한 결합`이 보통 권장되는 구조이긴 하다.
	- 하지만 게임의 핵심 로직은 상호작용하는 두 객체의 `public` 메서드를 서로 호출하는 방식이 나중에 유지보수하기 더 편할 수도 있다. 
	- 오늘 애먹었던 저지 로직 같은 경우, "`Operator`가 `Enemy`를 저지할 때 `Enemy`는 자신을 저지하는 `Operator`를 등록한다"는 로직 자체는 이벤트 없이 둘 간의 상호작용으로 구현해도 무방함.
	- 이벤트는 일반적으로 `1:多` 구조에서 사용하면 좋다. 