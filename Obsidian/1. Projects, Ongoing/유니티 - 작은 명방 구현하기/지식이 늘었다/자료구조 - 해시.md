- `C#` 기준의 설명
# 해시 함수
- 어떤 **데이터를 인풋으로 받아서 고정된 길이의 숫자나 문자열로 변환**해주는 함수.

> **`고정된 길이`라는 표현의 의미는 `메모리` 기준의 설명**이다.
> - `int`에서 123이든 1234567이든 -123456이든 메모리 크기는 모두 32비트로 동일하다. 즉 `int` 타입으로 쓰는 한, 저 숫자들을 표현할 때 모두 동일하게 32개의 비트를 쓴다는 의미다.
> - 그렇기 때문에 **해시 함수의 결과물이 반드시 숫자일 필요는 없다.** 예를 들어 `SHA-256` 같은 암호학적 해시 함수는 `256비트` 길이의 데이터를 만들어내고 이를 16진수 문자열로 표현한다.
> 	- 이 경우 사람이 보는 문자열의 길이는 64자로 고정된다. `a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e` 같이.
> 	- 하지만 **이것도 실제로는 아주 큰 2진수 숫자**이다. 
> 		- 예를 들면 `a5`라는 문자열은 `a = 1010` + `5 = 0101` => `a5 = 10100101`이다.
> 	- 이 해시를 갖고 인덱스를 계산해야 한다면 컴퓨터는 이 문자열을 실제로 나타내는 거대한 정수값으로 해석한 다음 나머지 연산을 수행한다. 
> 		- 비트 연산 등의 더 효율적인 방법으로 수행하지만 개념적으로는 동일하다.

- 이 결과 값을 `해시(코드)`라고 부른다. 
	- 해시값은 문자열로 저장될 수도 있고 숫자로 저장될 수도 있지만, 궁극적으로는 **수**로 본다.
- 특징
	- **일관성** : 동일한 입력에 대해 항상 동일한 해시 코드를 반환해야 한다
	- **분산성** : 서로 다른 입력에 대해서는 가급적 다른 해시 코드를 반환해야 한다
	- **비가역성** : 해시 코드만 갖고 원래 데이터를 복원하기는 거의 불가능하다
- `C#`의 모든 객체는 `GetHashCode()`라는 메서드를 갖고 있으며, `HashSet, Dictionary`는 이 메서드를 사용해 객체의 해시코드를 얻는다. 


# 해시 테이블의 구조 : 버킷 배열
![[해시테이블.png]]
- 해시 테이블의 구조는 기본적으로 배열이며, 각 칸을 `버킷Bucket`이라고 부른다.
- **`Buckets` 자체가 1개의 배열**이다.
- `Buckets`의 **각 원소는** `해시 충돌` 때문에 여러 개의 데이터를 담을 수 있는 구조여야 하는데, 일반적으로 **`연결 리스트`로 구현**한다.

# 데이터 저장 과정(O(1)이 어떻게 되는가?)
- `HashSet`에 `Apple`을 저장한다고 가정해보자.

1. 해시코드 계산 : `GetHashCode("Apple") = 12345`가 나왔다고 가정한다.
2. 인덱스 변환 : `12345`를 **해시 테이블(=배열)의 크기로 나눈 나머지 값**을 구한다. 이것이 데이터가 저장될 배열의 **인덱스**가 된다.
	- `인덱스 = 해시코드 % 배열의 크기`
	- `GetHashCode("Apple") % 16 = 5`라고 가정.
3. 데이터 저장 : 계산된 인덱스에 `Apple` 데이터를 저장한다. 

데이터를 숫자로 변환하고 크기로 나눠서 저장될 위치를 즉시 찾아내므로 데이터의 양과 관계 없이 일정한 시간이 걸린다. 

# 데이터 검색 과정
- 찾는 과정도 원리는 동일하다. 해당 위치에 저장된 데이터가 찾고자 하는 값인지에 대한 비교만 추가될 뿐임.
- 전체 데이터를 순회하지 않으므로 검색 속도가 매우 빠르다.

# 해시 충돌과 해결 방법
- `해시 충돌Hash Collision` : 서로 다른 데이터가 우연히 같은 해시 코드를 갖거나, 다른 해시코드라도 배열 크기로 나눈 나머지가 같은 경우가 있다. 
	- `GetHashCode("Banana") % 16 = 5`일 수 있다는 것이다.

- 이 문제를 해결하기 위해 `체이닝Chaining`이라는 방법을 사용한다. **각 버킷을 배열이 아닌 `연결 리스트`나 `리스트`로 만든다.**

그래서 **위처럼 `Apple`이 5번에 저장된 상태에서 `Banana`도 5번에 저장돼야 한다면, `Banana`는 `Apple` 뒤에 저장되는 방식**이다. 그래서 5번 버킷은 `["Apple"] -> ["Banana"]`이 된다.

- 충돌이 발생한 상태에서 `Banana`를 찾으려고 한다면, 5번 버킷에 가자마자 불일치가 발생할 것이다. 이 경우, 그 안의 연결 리스트를 순차적으로 탐색해서 `Banana`를 찾는다. 이 때 성능은 `O(1)`에서 5번 버킷의 데이터의 길이`O(k)`만큼 저하된다.
- 하지만 좋은 해시 함수는 데이터를 버킷에 고르게 분산되므로 각 버킷의 데이터 수는 매우 적게 유지된다. 평균적인 성능은 여전히 `O(1)`에 가깝다. 

# Dictionary와 HashSet의 차이
- `HashSet`은 Key만 저장한다
- `Dictionary`는 `Key`를 사용해 해시 코드를 계산하고 인덱스를 찾는다. 해당 버킷에는 `Key, Value`를 한 쌍으로 저장한다. 

즉 `Dict`은 `HashSet`에 `Value`를 저장할 공간이 추가된 버전이라고 생각할 수 있다. 


# 해시 코드의 길이
- `C#`에서 `GetHashCode()` 메서드는 `int(32비트 정수)`를 반환한다. **-21억 ~ +21억까지 약 42억 개의 고유한 값을 가진다.**
- 해시 코드의 표현 범위가 넓을수록 서로 다른 객체가 같은 해시 코드를 가질 확률이 줄어든다. 일반적으로 해시 코드가 겹칠 경우는 드물게 된다.

## 배열의 길이
- 동적으로 변한다. 메모리 낭비를 막기 위해 처음에는 작은 값의 소수나 `2`의 거듭제곱 수로 시작한다.
- 배열의 길이는 `로드 팩터(Load Factor)`라는 임계값을 통해 관리된다. 보통 75% 정도 차지되면 배열의 크기를 늘린다.
- 배열의 크기가 늘어날 때 `리해싱Rehashing`이라는 과정이 일어난다.

## 리해싱Rehashing
1. **더 큰 새 배열 생성** : 기존 배열보다 약 2배 정도 큰 새로운 배열을 만든다.
2. **모든 요소 재배치** : 기존 배열의 모든 요소를 하나씩 꺼내서 새로운 배열 크기에 맞게 저장될 인덱스를 다시 계산(`해시 코드 % 새로운 배열 크기`)해서 새 배열의 올바른 위치에 재배치한다.

- 리해싱 과정의 비용은 `O(n)`이나, 자주 일어나지 않기 때문에 평균 성능은 여전히 `O(1)`로 유지된다.

> 해시 코드를 계산하는 로직이 일정하다면, 리해싱 과정에서 해시 충돌이 해결될 수도 있겠다. 분모가 달라지니까.
