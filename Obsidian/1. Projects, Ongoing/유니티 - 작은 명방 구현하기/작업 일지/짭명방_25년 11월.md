# 251130

## 짭명방

>[!done]
>1. 치트키 추가 - 스테이지에서 F1 키를 누르면 3성 클리어가 됨
>2. `TutorialCanvas`에서 텍스트가 나오는 박스를 클릭했을 때에도 배경을 클릭한 것처럼 동작하도록 수정 및 구현 과정에서 발생한 오류 수정

- **치트키 추가 : 스테이지에서 F1 키를 누르면 3성 클리어가 바로 되도록 함**
	- 스테이지를 3성으로 빠르게 클리어하기 위한 기능
	- 구현도 심플하다 : `StageManager`에서 `F1` 키를 누르면 `PassedEnemies = 0` & `StartCoroutine(GameWinAfterDelay())`만 추가하니까 잘 동작함.
> 원래 스크립트로 `TestManager`를 따로 구현해서 그때그떄 컸다꼈다했는데 이 방식도 괜찮다. 

- 튜토리얼 진행 시 텍스트 박스 클릭했을 때 넘어가지지 않는 현상 수정
	- `TutorialCanvas`에서 `dialogueBox`에 `Button` 컴포넌트 추가해서 스크립트에서 `onClick`메서드 등록
	- 추가 이슈 ) 클릭 이벤트가 따닥 들어가는 현상이 있어서 한 번 클릭으로 2번 처리됨
		- 정확히는 그게 발생하는 지점이 있음. 테스트로 만들어봤는데 거기선 발생하지 않는다. 
		- `dialogueBox`의 리스너를 해제하지 않은 거 같은 상태로 추가로 리스너가 등록되어서 한 번 클릭했는데 2번 넘어간 듯. 
		- 레이캐스트 문제는 아니었다. 애초에 유니티 UI 단에서 막혀 있으면 그 아래의 것이 처리되지 않기도 하고.
	- 추가 이슈 2 ) 유저가 버튼을 입력하지 않아도 되는 상황에서 `TutorialStep`의 마지막 문구가 출력될 때 `dialogueBox`를 클릭했을 때 다음으로 넘어가지 않는 현상 수정
		- `TutorialCanvas`의 `AddListener` 부분에 `dialogueBox`를 연결함

## 블로그

# 251126

>[!done]
>- 클리어 후 결과 패널 : 클릭해서 로비로 돌아갈 때 별이 다시 쪼그라드는 현상

## 테스트 및 수정

### 클리어 후 결과 패널
- 클릭해서 로비로 돌아갈 때 별이 다시 쪼그라드는 현상
```cs
// GameResultPanel.AnimateStars 의 일부

// 별이 잠시 작아졌다가 
currentStar.transform.DOScale(0.5f, starAnimationDuration * 0.2f);

currentStar.transform.DOKill();

// 스프라이트와 색상을 변경한 후 커지는 애니메이션
Sequence starSequence = DOTween.Sequence().SetUpdate(true).SetAutoKill();

starSequence.AppendCallback(() =>
{
	currentStar.sprite = activeStarSprite;
});

// 최종 크기보다 조금 더 커졌다가
starSequence.Append(currentStar.transform
	.DOScale(1.2f, starAnimationDuration * 0.4f)
	.SetEase(Ease.OutBack));

starSequence.Join(currentStar.DOColor(activeStarColor, starAnimationDuration * 0.4f));

// 최종 크기로 진행
starSequence.Append(currentStar.transform
	.DOScale(1f, starAnimationDuration * 0.4f)
	.SetEase(Ease.OutBounce));

// 시퀀스 완료 대기
yield return starSequence.WaitForCompletion();
```
> 기존 스크립트인데, 위 스크립트의 문제는 
> - 가장 위의 `DOScale`과 그 아래의 `starSequence`가 동시에 진행된다는 것이다. 
> - 보통은 뒤의 시퀀스가 우선권을 갖기에 애니메이션 중에는 정상적으로 보인다.
> - `Time.timeScale = 0f`일 때, 
> 	- 위의 **`starSequence`는 `SetUpdate(true)`가 있으므로 상관 없이 진행**되지만
> 	- 더 위의 **`DOScale()`은 그 설정이 없어서 대기 상태가 된다**
> 	- 이 상태에서 `timeScale`이 다시 `1f`가 되면, 종료된 시퀀스는 진행되지 않으나 **실행되지 않았던 `DOScale(0.5f)`가 동작하면서 별이 쪼그라들어 보이게 된다.**

#### 해결
- 가장 위의 `DOScale` 부분을 시퀀스 안에 포함시키면 됨.
```cs
// 시퀀스와 별도로 동작하는 DOScale 제거
// currentStar.transform.DOScale(0.5f, starAnimationDuration * 0.2f);

// 이전 트윈 충돌 방지를 위한 초기화
currentStar.transform.DOKill();

// 스프라이트와 색상을 변경한 후 커지는 애니메이션
Sequence starSequence = DOTween.Sequence().SetUpdate(true).SetAutoKill();

starSequence.AppendCallback(() =>
{
	currentStar.sprite = activeStarSprite;
});

// DOScale을 시퀀스 내부로 포함시킴
starSequence.Append(currentStar.transform.DOScale(0.5f, starAnimationDuration * 0.2f));
```


# 251121
>[!done]
>- 튜토리얼 테스트 및 튜토리얼 오류 수정
>	- 메인 캔버스의 요소들을 그대로 복붙하지 못하는 현상
>	- **튜토리얼의 시작부터 끝까지 정상적으로 동작되는 것을 확인**
>		- 원래는 배치되는 동작까지 직접 안내하는 구현을 하고 싶었는데 품이 좀 많이 들 것 같다. 일단은 이 쯤에서 컷함.
>	- 복사된 UI 요소는 원본에서 이미지 / 텍스트 등을 참조해서 가져온다
>		- 활성화된 요소를 `Instantiate`하면 나타난 요소를 그대로 가져오지만, 자체 스크립트에 의해 초기화되는 일부 요소들이 있어서 원본을 참조하는 스크립트를 추가함.
>- 기타 이슈
>	- 배치 후에 1배속 고정되는 문제 수정(`DeployableManager.Deploy()`의 배치 이후 로직)

## 튜토리얼 테스트와 오류 수정

### 옮겨진 요소는 형제 오브젝트의 가장 아래에 위치하면 안됨

- 옮겨진 요소는 `TutorialCanvas`의 텍스트 박스보다 아래에 나타나야 함
- 즉 하이어라키에서의 순서는 가장 아래보다는 위여야 함
```cs
// 원본 UI를 복사해서 TutorialCanvas에 생성함
highlightedCopiedObject = Instantiate(highlightedOriginalObject, tutorialCanvas.transform, false);
highlightedCopiedObject.name = targetUI.name;
```
> 기본적으로 `Instantiate`된 요소는 형제 오브젝트 중 가장 아랫쪽에 위치하게 됨

- 이 경우 캔버스의 자식 수를 센 다음
```cs
int childCount = tutorialCanvas.transform.childCount;
```

- 자식이 2개 이상일 때 `transform.SetSiblingIndex(자식갯수-2)`로 설정하면 됨
```cs
if (childCount > 1)
{
	// 마지막 - 1 번째 인덱스로 설정(마지막은 텍스트 패널이 오도록 구성)
    highlightedCopiedObject.transform.SetSiblingIndex(childCount - 2);
}
```

### 튜토리얼 자체는 정상적으로 동작하는 거 확인
- 이제 세부 요소 확인

### 메인 캔버스의 요소들을 그대로 복붙하지 못하는 현상
- 튜토리얼 캔버스로 복사하는 요소들을 `string` 에서 `List<string>`으로 변경

- 이렇게 변경할 경우 지금 구성에서는 아래 문제가 발생함
1. 기존에는 하이라이트된 오브젝트를 넣고, 특정 버튼 입력이 필요한 경우에만 해당 오브젝트에 대한 대기만 그대로 적용하면 됐음
2. 그런데 하이라이트된 오브젝트들을 함께 관리하기로 했다면 이들 중 어떤 요소의 입력을 기다려야 하는지가 모호해지는 현상이 생김
- `ResetHighlightUI`도 수정해야 함.

- **`tutorialStep`에서 특정 버튼/UI의 입력이 필요하다면 해당 요소의 이름을 별도로 구현해둬야 할 듯.** 
	- 즉 하이라이트될 요소와 입력이 필요한 요소를 구분하는 것이다. 
	- 입력이 필요한 요소도 하이라이트될 요소에 100% 들어가겠지만.

- 그래서 여기 작업은
1. 1개의 하이라이트에 적용하는 코드를 여러 요소에도 적용할 수 있게 바꿀 것
2. 하이라이트와 입력을 위한 필드는 구분할 것(입력 필드는 하이라이트에 100% 포함되더라도)

### TutorialCanvas가 사라졌다가 나타나는 구현 수정
- 유저가 광클하는 경우에 의도치 않은 동작이 나타날 수 있음
1. `ResetHighlightUI()` 부분은 `HighlightUI()`의 시작 시점에 동작하지 않게끔 함
2. 한 `Step`이 완료되기 전에는 `tutorialCanvas`가 사라지지 않게 함

### 일부 요소가 튜토리얼 캔버스로 복붙될 때 누락되는 현상
- 지금까지 보이는 요소는 **스킬 버튼의 이미지**밖에 없음 - 이미지가 제대로 복붙되지 않고 초기화 상태의 이미지가 보임. 

- **하이어라키의 오브젝트에 대해 `Instanitate`를 하면 "현재 상태의" 텍스트, 이미지가 모두 정상적으로 복사되는 게 정상이다.**  
	- 다만 복제된 오브젝트가 켜지면서 스크립트 내부 로직이 돌고, 이 과정에서 데이터가 비어 있어서 초기화 이미지를 띄운다는 것

- 따라서 **보여주기 용도로 이미 있는 오브젝트를 복붙해서 만들 때는 자체 스크립트의 동작을 막아줘야 함.**

> - 이전 구현 중 `DeployableBox`에서 직접 구현한 UI 요소라면 해당 요소를 `Initialize`했기 때문에 그 안에 `IsInitialized` 플래그를 추가하는 식으로 초기화된 요소만 `OnEnable`이 동작하는 식으로 구현한 것이 있었다.
> - 근데 얘는 `Initialize`되는 요소가 아니고 패널에 붙어있는 스크립트이면서 `OnEnable`으 동작하게끔 작성되어 있음. 패널들을 실행하는 로직이 `MainMenuManager`의 패널 전환 메서드에 의한 것이고 이는 `GameObject`들을 컨트롤하는 방식이기 떄문에 `TutorialManager`에서 접근하는 방식은 아래 방식을 거치게 된다.
> - AI의 제안
> 1. 가져온 다음에 스크립트를 제거
> 2. 원본 Canvas에 있던 요소를 스크립트로 옮김

- 일단 스킬 아이콘이 나타나는 것까진 구현했음
- 근데 원본과 달리 스킬 이름이 나타나지 않는 현상이 있어서 그거 수정 중
- 이 부분의 전체 스크립트는 아래와 같다. 더 추가할 요소가 있다면 추가해나가면 될 듯.
```cs
private void SyncVisualHierarchy(GameObject copy, GameObject original)
{
	// 1. Image 컴포넌트 동기화
	// GetComponentsInChildren은 계층 구조 순서대로 반환하므로, 구조가 같다면 인덱스가 일치함
	Image[] copiedImages = copy.GetComponentsInChildren<Image>(true);
	Image[] originalImages = original.GetComponentsInChildren<Image>(true);

	if (originalImages.Length == copiedImages.Length)
	{
		for (int i = 0; i < originalImages.Length; i++)
		{
			copiedImages[i].sprite = originalImages[i].sprite;
			copiedImages[i].color = originalImages[i].color;
			copiedImages[i].fillAmount = originalImages[i].fillAmount;
			copiedImages[i].type = originalImages[i].type;
		}
	}

	// 2. TMPro 기반의 텍스트 복사
	TextMeshProUGUI[] originalTexts = original.GetComponentsInChildren<TextMeshProUGUI>(true);
	TextMeshProUGUI[] copiedTexts = copy.GetComponentsInChildren<TextMeshProUGUI>(true);

	if (originalTexts.Length == copiedTexts.Length)
	{
		for (int i = 0; i < originalTexts.Length; i++)
		{
			// 텍스트 내용 복구
			copiedTexts[i].text = originalTexts[i].text;
			copiedTexts[i].color = originalTexts[i].color;

			// 원본이 켜져 있는지 여부에 따라 똑같이 나타남
			copiedTexts[i].gameObject.SetActive(originalTexts[i].gameObject.activeSelf);
		}
	}
}
```
## 기타 이슈

### 배치 후에 2배속 상태임에도 1배속으로 되는 현상
```cs
// DeployableManager.Deploy 메서드 중

// 배치 후 로직을 처리하는 부분에서 아래처럼 되어 있었음
Time.timeScale = 1f; 
```

이제 `StageManager`의 `IsSpeedUp` 필드를 보고 2배속으로 할지 1배속으로 할지 결정함
```cs
Time.timeScale = StageManager.Instance!.IsSpeedUp ? 2f : 1f;
```

# 251120

>[!done]
>- 튜토리얼 이슈 해결하기
>	- `PlayCurrentStep`을 `IEnumerator`로 변경한 후 튜토리얼이 진행되지 않는 현상
>	- 이전 씬에서 만들었던 `tutorialCanvas`가 돌아오고 나서도 남아있는 현상
>	- 스테이지 씬에서 목표로 하는 UI를 찾지 못함
>		- `StageScene`에는 여러 캔버스가 있어서 메인 캔버스를 찾지 못하는 문제였음. 
>		- 루트 오브젝트 검색(비활성화 오브젝트 포함) & 태그 비교 로 해결

## 튜토리얼 이슈 해결하기

### PlayCurrentStep을 IEnumerator로 바꿨더니 다음 TutorialStep으로 넘어가지지 않는 현상
- `AdvanceToNextStep`에서 실행되는 `PlayCurrentStep`을 코루틴으로 실행하지 않아서 발생하는 문제였다.
- `TutorialManager`에서 `CurrentStepCoroutine`을 계속 추적하도록 하고, 한 스텝이 완료될 때마다 코루틴을 해제하는 로직을 추가했음.

### 이전 씬에서 만들었던 tutorialCanvas가 돌아오고 나서 남아있는 현상
- 씬을 불러온 다음 동작하는 `SceneManager.OnSceneLoaded(Scene scene, LoadSceneMode)`가 있듯이
- **씬을 닫을 때 동작하는 `SceneManager.OnSceneUnloaded(Scene scene)`도 있다.**
- `TutorialManager`는 `DontDestroyOnLoad` 인 `GameManagement`의 자식 오브젝트이므로, 위 메서드를 `Awake`에서 등록하고 `OnDestroy`에서 해제하면 됨.
```cs
private void Awake()
{
	SceneManager.sceneLoaded += OnSceneLoaded;
	SceneManager.sceneUnloaded += OnSceneUnloaded;
}

private void OnDestroy()
{
	SceneManager.sceneLoaded -= OnSceneLoaded;
	SceneManager.sceneUnloaded -= OnSceneUnloaded;
}
```

- 메서드는 이렇게 생겼다.
```cs
// 씬이 닫힐 때 호출되는 메서드
private void OnSceneUnloaded(Scene scene)
{
	ResetHighlightUI();

	if (tutorialCanvas != null)
	{
		Destroy(tutorialCanvas.gameObject);
		tutorialCanvas = null;
	}
}
```

### 스테이지 씬에서 목표로 하는 UI를 찾지 못함
```cs
DeployableDeployingUI (UnityEngine.Canvas)에서 StageProgressPanel에 해당하는 Image을 발견하지 못함
```
위 로그가 나타나는데, DeployableDeployingUI가 캔버스가 아닌데 저걸 찾고 있음.
**...이 아니었다!** World Space를 기반으로 한 캔버스들이 MainCanvas 외에도 여러 개 있음. 

그러면 이 부분을 수정해야 함
```cs
private Canvas? FindRootCanvas()
{
	GameObject[] rootObjects = SceneManager.GetActiveScene().GetRootGameObjects();

	// 루트 오브젝트 중, Canvas 컴포넌트를 가진 오브젝트 찾기
	foreach (GameObject obj in rootObjects)
	{
		Canvas? canvas = obj.GetComponent<Canvas>();
		if (canvas != null) return canvas;
	}
	return null;
}
```

1. `Screen Space - Overlay`을 설정하는 캔버스를 찾게 구현하는 방법이 있음
```cs
	if (canvas != null && 
		canvas.gameObject.activeInHierarchy && // 꺼진 캔버스 제외
		(canvas.renderMode == RenderMode.ScreenSpaceOverlay || canvas.renderMode == RenderMode.ScreenSpaceCamera))
	{
		return canvas;
	}
```
> 코드를 크게 고치지 않고 수정할 수 있는 방법인데, 이것보다는 **아래 방법이 더 나아보여서 2번을 채택함.**

2. `Tag`에 `MainCanvas`을 추가하고, 인스펙터에서 각 씬의 메인으로 쓸 캔버스에 `MainCanvas`를 태그로 설정하고, 스크립트로 아래처럼 찾게 하면 됨
```cs
GameObject canvasObj = GameObject.FindGameObjectWithTag("MainCanvas");
```
> 유니티에서 **가장 정석적인 방법**이라고 함

#### 추가 이슈
... 2번 방법으로 진행했는데 `StageScene`에서 메인 캔버스를 찾지 못했다고 함

- **`FindGameObjectWithTag()`는 비활성화된 요소를 찾지 못함**.
- `StageUIManager`를 보면 로딩이 완료된 다음에 캔버스가 나타나도록 구현했기 때문에, 씬 전환 시점의 `Awake`에서 메인 캔버스를 비활성화시켜놨음.

```cs
// StageUIManager.cs
private void Awake()
{
	// ...
	
	// 스테이지 로딩 패널이 완료되고 캔버스가 나타나도록 수정
	mainCanvas.gameObject.SetActive(false);
	
	// ...
}
```

- 따라서 비활성화됐으면서 해당 태그를 찾는 로직을 추가로 구현해줘야 함
```cs
// 1. 루트 오브젝트 중 MainCanvas를 가졌으면서 canvas 컴포넌트를 가진 요소를 찾음
GameObject[] rootObjects = SceneManager.GetActiveScene().GetRootGameObjects();

foreach (GameObject obj in rootObjects)
{
	if (obj.CompareTag("MainCanvas") && obj.TryGetComponent<Canvas>(out var canvas))
	{
		return canvas;
	}
}
```

> 일단은 여기까지. 튜토리얼도 인게임까지는 잘 되고 있고, 전투 후에 다시 로비로 와서 성장 안내 동작이 잘 되는지 보면 될 듯.

#### 궁금증
> [!question]
> 왜 `GetRootGameObjects()`는 비활성화된 오브젝트를 포함하고 `GameObject.FindGameObjectWithTag()`은 비활성화된 오브젝트를 포함하지 않을까?

- `GameObject.Find()` 계열은 비활성화된 오브젝트를 검색 대상에 포함하지 않는다. 유니티에서 그렇게 설정한 이유에 대해 서술함.
1. 성능 최적화
	- 수많은 오브젝트를 뒤지는 연산은 매우 비싼 연산임
	- **활성화된 오브젝트의 경우, 엔진 내부의 업데이트 루프를 돌리기 위한 리스트가 있어서 접근이 상대적으로 용이**하다.
	- 비활성화된 오브젝트는 업데이트 대상에서 제외되어 있다. 인덱싱에서 빠져 있기 때문에 이들을 모두 포함해버리면 탐색 범위가 기하급수적으로 늘어난다.
2. 설계 의도
	- 유니티 개발팀은 **꺼져 있는 오브젝트는 게임 로직에 관여하지 않는 상태**로 본다.
	- 오브젝트를 껐다는 건 지금은 쓰지 않으니 숨겨두겠다는 의미인데, 이들을 억지로 찾아내 반환한다면 숨겨진 오브젝트가 조작되거나 로직을 수행해서 버그가 발생할 수 있다.

- `GetRootGameObjects()`는 검색이라기 보다는 계층 구조의 최상단 목록을 가져오는 `접근자Accessor`에 가깝다.
	- 즉, 씬의 루트에 있는 오브젝트들의 배열을 가져오는 것일 뿐 이들의 내부 컴포넌트를 뒤지거나 이름을 비교하는 연산을 수행하지 않는다.

- 요약 : **유니티 자체에서 배열/리스트로 관리하고 있는 요소들은 가져오고 아니라면 가져오지 않는다.** 비활성화된 요소는 개발자가 의도적으로 꺼둔 것이니 이들의 동작이 일어나면 의도치 않은 상황이 발생할 수 있어서 일부러 검색에서 제외함.

# 251119 

>[!done]
>- 튜토리얼에 UI 하이라이트(?) 추가 후 다듬는 과정
>	- 클릭이 필요한 요소가 없을 경우 외부 레이아웃 클릭 시 다음으로 넘어가지 않는 현상
>- (진행 중) WIP에서 가끔 캔버스로 옮겨지지 않는 문제 해결하다가 막힘

## 튜토리얼 스텝 - 외부 레이아웃 클릭 시 다음으로 넘어가지 않는 현상

```cs
// 클릭해야 하는 특정 버튼이 없는 경우 : 아무거나 클릭해도 다음 스텝으로 넘어가야 함
if (!currentStep.requireUserAction)
{
	if (expectedButtonName == string.Empty)
	{
		// tutorialPanel의 가장 위에 오는 transparentPanel에 리스너를 추가함
		tutorialCanvas.AddClickListener(() => actionReceived = true);

		// 버튼 입력 대기
		while (!actionReceived) yield return null;

		CurrentStepFinish();
	}
	else 
}
```
> 이 부분인 듯?


1. `TutorialStep`은 하이라이트되는 UI 요소의 이름을 갖는다. 
2. 이 하이라이트되는 요소는 유저의 액션을 필요로 하는 버튼이 될 수도 있지만, 단순히 어디뭐가 있다만을 강조하기 위한 요소가 될 수도 있음
3. 2번 때문에 UI 요소의 이름은 `requireUserAction`에 무관하게 들어갈 수도 있고 들어가지 않을 수도 있음

따라서 위 코드는 `expectedButtonName`이라는 조건을 검사할 필요가 없어졌다. 해당 조건문만 제거했음.

## 튜토리얼 스텝 - 슬롯 버튼을 찾을 때도 있고 아닐 때도 있다
- 이거는 내일 진행함 - 감이 안 잡힌다





# 251118
- 프로젝트가 계속 늘어지는 관계로 완료 기준을 정해놓기로 한다.
- [[프로젝트 완료 기준에 대해]]
> - 튜토리얼 UI 하이라이트 개선 + 소리 추가(BGM 2~3개 + SFX 5개 정도? 링크 참조)
> - 이전 스테이지 요소들이 반영된 다음 스테이지 설계 및 밸런스 조절
> - 기타 버그 수정

정도가 되겠음. 더 추가하고 싶은 게 생기더라도 짜투리니까 가장 중요한 일을 해결한 다음에 사이드 프로젝트로 돌려도 됨

>[!done]
>1. 레이아웃이 꺠지는 현상
>	- 복사 - 붙여넣기로 접근
>	- 옮겨진 캔버스에 어떻게 보여지는가에 대한 이슈가 있었다. **원본 캔버스의 좌표를 이용해 새로운 캔버스에 어떻게 나타나야 하는지를 구현했다.**
>	- 원본 UI의 `rectTransform` 설정들을 그대로 반영하는 건 일반적으로는 잘 동작하지만, **`Grid Layout` 같이 동적인 상황에서 문제가 발생했음.**


## 이슈 수정
### 튜토리얼 중 UI가 옮겨지는 과정에서 서식이 깨지는 현상
- '원본 캔버스의 요소를 복붙해서 튜토리얼 캔버스에 넣으면 되지 않을까?' 로 접근
	- 이미 구현된 `Button`을 `Instantiate`로 다른 캔버스에 새로 만들 때, **복사된 버튼에 추가 설정이 필요하다.** 
		1. **원본 `Rect Transform` 설정**을 가져와야 한다
			- 부모가 달라지면 `World Space` 기준으로 재배치되므로 좌표가 어긋남
			- 
		2. 리스너도 제거된 상태로 오기 때문에 **원본 버튼의 리스너가 동작하도록 연결**해줘야 함
			- 유니티의 `Instantiate`된 UI 오브젝트의 `UnityEvent`는 복사되지 않음
```cs
TutorialButton.onClick.AddListener(
	() => {
		actionReceived = true;
		OriginalButton.onClick.Invoke(); // 원본 버튼의 리스너 연결
	});
```

- 일단 튜토리얼 캔버스로 복붙하는 구현은 달성함

> 지금 발생하는 문제는 크게 2가지임
> 1. `Grid Layout` 및 `Scroll Rect`로 관리되는 요소 - 원본 캔버스와 다른 위치에서 버튼이 생성되는 현상
> 2. 레이아웃 클릭, 즉 버튼 클릭을 요하지 않는 부분에서 다음 튜토리얼로 넘어가지 않음

### Grid Layout 및 Scroll Rect로 관리되는 요소의 위치 복사
- AI에게 던져줘서 얻은 코드는 아래와 같다.
- 원본 UI 요소의 좌상단 / 우하단의 위치를 가져와서 거의 비슷하게 동작하는 `RectTransform.offsetMin/Max` 값을 지정하는 방식임.

> 이 코드 자체는 명확하게 작동하지 않았음 
> - `offsetMin, offsetMax` 값 설정 때문인데, 밑에 추가로 적어둠
```cs
    // 1. 원본 UI의 "최종 계산된" 월드 좌표 네 꼭짓점 정보를 가져옵니다.
    Vector3[] originalCorners = new Vector3[4];
    originalRect.GetWorldCorners(originalCorners);

    // 2. 복사본의 앵커를 Stretch 모드로 설정
    copiedRect.anchorMin = Vector2.zero;
    copiedRect.anchorMax = Vector2.one;
    
    // 3. 원본의 월드 좌표를 캔버스 기준 로컬 좌표로 변환
    Vector3 btmLeft = tutorialCanvasRect.InverseTransformPoint(originalCorners[0]);
    Vector3 topRight = tutorialCanvasRect.InverseTransformPoint(originalCorners[2]);

    // 4. 변환된 로컬 좌표를 offset(여백)으로 설정하여 크기와 위치를 맞춤
    copiedRect.offsetMin = btmLeft;
    copiedRect.offsetMax = topRight;
```

- 3번 : `tutorialCanvasRect.InverseTransformPoint(originalCorners[0])`
	- **캔버스의 피벗 위치(중앙)을 기준으로 한 UI의 좌측 하단의 좌표**
		- 원본 UI의 왼쪽 아래 꼭짓점의 절대적인 월드(스크린) 위치를 가져온다 (originalCorners[0]).
		- 이 **절대 위치를 "튜토리얼 캔버스의 좌표계에서는 어떤 값으로 표현될까?"라고 질문**한다 (`InverseTransformPoint`).
		- 그 계산 결과를 `btmLeft`라는 변수에 저장한다.
		- 여기서 **`btmLeft` 값은 튜토리얼 캔버스의 피벗인 `0.5, 0.5`를 기준으로 한 위치**다.
			- 캔버스의 피벗은 정중앙인 `0.5, 0.5`임
- `topRight`도 마찬가지로, `GetWorldCorners`는 `좌하, 좌상, 우상, 우하` 순으로 저장됨

- 4번
	- `offsetMin(Vector2)`
		- `x` : UI의 왼쪽 변두리가 왼쪽 앵커에서 얼마나 떨어져 있는가(왼쪽 마진)
		- `y` : UI의 아래쪽 변두리가 아래쪽 앵커에서 얼마나 떨어져 있는가(아랫쪽 마진)
	- `offsetMax(Vector2)`
		- `x` : UI의 오른쪽 변두리가 오른쪽 앵커에서 얼마나 떨어져 있는가(오른쪽 마진)
		- `y` : UI의 윗쪽 변두리가 위쪽 앵커에서 얼마나 떨어져 있는가(윗쪽 마진)
	- **2번에서 앵커를 `0, 0`과 `1, 1`로 설정해서 화면 전체를 앵커로 사용**하고, `offsetMin/Max`값이 마침 `GetWorldCorners[0], [2]`에서 얻어지는 요소들과 맞아떨어지기 때문에 이런 식으로 구현할 수 있다.

- 그러나 저대로는 제대로 동작하지 않는데, 계산 방식에 문제가 있었다.
	- `btmLeft` : 원본 UI의 좌하단 꼭짓점이 **튜토리얼 캔버스의 로컬 좌표계의 피벗 기준** 으로 어디에 있는지를 나타냄
	- 그런데 `offsetMin` 값은 설명에서 보이듯 **앵커의 위치**가 기준점이 된다. 
	- 2번에서 `anchorMin`을 `0, 0`으로 설정했기 때문에 앵커의 위치는 좌측 하단인 `(0, 0)`이 된다.
	- 따라서 저 값을 그대로 넣으면 기준점이 달라서 원하는 구현대로 되지 않음

- 따라서 기준점을 이동시키면 되는데, 이는 **캔버스의 `RectTransform`의 `rect.min` 값을 뺌으로서 구현할 수 있다.**
	- **`btmLeft`은 중앙 기준 UI의 좌측 하단의 위치**이고
	- **`rect.min` 값은 캔버스의 좌측 하단 모서리의 중앙 기준 위치**가 되므로
	- `btmLeft - tutorialCanavsRect.rect.min` 계산을 수행하면 중앙을 기준으로 한 UI의 좌측 하단의 위치가 계산된다.
	- 마찬가지의 논리로 `topRight`도 그대로 구현할 수 있음.

```cs
// 따라서 4번은 이렇게 수정된다.
copiedRect.offsetMin = new Vector2(btmLeft.x, btmLeft.y) - tutorialCanvasRect.rect.min;
copiedRect.offsetMax = new Vector2(topRight.x, topRight.y) - tutorialCanvasRect.rect.max;
```

> 일단 여기까지. 이것만 해도 시간 많이 썼다. 괜히 시작했나..


# 251117 - 짭명방

>[!done]
>- 튜토리얼 수정
>	- 튜토리얼 패널의 텍스트 수정
>	- 클릭되어야 하거나 설명되는 요소에 하이라이트되는 기능을 추가
>- 기타 이슈 수정
>	- `InStageInfoPanel`에서 이름값 제대로 불러오지 못하는 문제

## 튜토리얼 수정
- 튜토리얼 패널이 나타날 때, 클릭되어야 하는 요소만 하이라이트되게 하고 나머지 요소들은 불투명한 검은 패널의 뒤로 배치시키고 싶음

### 원리
- `Gemini`에게 물어보니
	1. 튜토리얼을 위한 별도의 캔버스를 준비한다.
	2. 이 캔버스에는 `dimPanel`이라고 하는 검은 반투명 이미지가 들어간다.
	3. 원본 캔버스에서 UI 요소를 복제해서 이 캔버스로 이동시킨다. 하이라이트 중단 시 다시 원래 위치로 이동시킨다. 
		- 여기까지 진행하면 기존 요소들은 `dimPanel` 뒤에 가려져서 검게 보이고, 원하는 요소만 하이라이트되는 방식이 된다.

### 유의 사항
- 그런데 현재의 `TutorialManager`는 `DontDestoryOnLoad`로 관리되는 `GameManagement`의 자식 오브젝트다. 
- **`TutorialCanvas`는 매니저의 자식으로 두는 것보다는 씬마다 별도로 관리**하는 게 좋다.
	1. **UI는 씬에 종속적이다.** 
	2. `Canvas`가 생성되면 `EventSystem`이 함께 생성된다. `DontDestroyOnLoad`로 이벤트 시스템이 관리되면 하나의 클릭에 여러 이벤트 시스템이 동시에 동작할 수 있다. 
		- **이벤트 시스템은 씬에 하나만 존재한다.** 
		- 한 씬에 여러 캔버스가 있으면 2번째 캔버스부터는 이벤트 시스템이 생성되지 않지만, 위의 이슈에선 이전의 이벤트 시스템이 다른 씬으로 넘어갈 우려가 있다는 뜻
	- 씬을 만들 때마다 튜토리얼을 위한 캔버스를 별도로 구현하는 것보다는 그냥 **튜토리얼을 위한 캔버스 프리팹을 만드는 게 좋다.** 오브젝트 풀링으로 구현할 필요도 없음.

- 일단 하이라이트를 위한 기능이 어떻게 동작하는지는 파악했음

### 기능 구현
- 이제 기존의 `TutorialManager` 및 `TutorialPanel`과 어떻게 합칠지를 고민함
	-  역시 이 부분이 어렵다. AI 딸깍을 하고 싶지만 직접 하지 않으면 는다는 느낌이 없음.

- 이 "책임" 부분이 다룰 때마다 헷갈린다. 고민한 지점은
- 기존의 `TutorialPanel` (지금은 `TutorialCanvas`)이 어디까지 책임져야 하는가?였음.
	- 어떤 버튼을 하이라이트해야 하는가? 

- **캔버스는 뷰/표시 장치로서의 역할**만 하면 된다.
	- 자신의 텍스트를 어떻게 보여줄 것인가?
	- 자신의 배경 패널이 클릭되면 어떻게 동작할 것인가?

따라서, **어떤 캔버스에서 요소를 이 캔버스로 옮길 때 캔버스 자체가 할 역할은 거의 없다.** 이러한 요소들을 관리하는 매니저에서 처리하면 됨. 

> 이 개념이 좀 헷갈리는데, **`TutorialManager`가 튜토리얼의 흐름을 직접적으로 관리하기 떄문에 어떤 요소를 하이라이트하고 하지 않을지는 `TutorialManager`에서 처리해도 자연스럽다**는 얘기임.


### 과정 밟아가면서 기능 수정
- UI 요소가 애니메이션 등에 의해 활성화 이전 위치와 이후 위치가 달라지는 경우, **활성화 이후 위치인 시점에 튜토리얼 캔버스에 찍혀야 함**





## 기타 이슈 수정
### `CurrentDeployableInfo`에서 `Localization`에서 설정한 키값을 제대로 불러오지 못하는 문제

```cs
nameText.text = GameManagement.Instance!.LocalizationManager.GetText(currentDeployableInfo.operatorData?.EntityID);
```

> 이제 `EntityID`는 해당 요소의 고유한 ID를 의미한다. `EntityNameLocalizationKey`로 언어별 이름을 설정하기로 했는데 그 요소가 반영되지 않았음.






# 251111 - 짭명방

## 튜토리얼
- 인게임 진입했을 때 패널이 나타나지 않음


# 251110 - 짭명방

>[!done]
>- 언어 버전에 따른 텍스트 변경
>	- 이름이나 설명을 별도로 구현한 건 아님 : 오퍼레이터의 이름 정도만 `Guard`와 `가드`처럼 영/한 정도만 들어가 있음
>	- 위 요소가 `GameManagement`에 설정된 `_currentLanguage` 값에 따라 `UI`에 어떻게 나타나는지 달라짐
>- 기타 요소 수정
>	- `SO`에 `public`으로 관리되던 요소들 접근자를 수정하고 프로퍼티 설정
>		- 이게 생각보다 오래 걸리네,,,

## 언어 버전에 따른 텍스트 변경
- 언어에 따른 텍스트들은 어떻게 관리하는지 궁금해서 정리해둠
- 유니티에서 지원하는 `Localization`이라는 패키지가 있다. 이걸 사용하는 편이 훨씬 나음
- [[유니티 언어 관리]]

- 여기서 중요한 건 **데이터와 표현을 분리해야 한다는 점**이다
	- 데이터를 불러오기 위한 데이터의 `고유한 ID` 문자열 필드
	- 사용자에게 보여주기 위한 별개의 문자열 필드
	- 이런 식으로 용도에 맞춰서 별도의 필드를 구현하라는 것.

- 지금까지는 `OperatorData.entityName`에 고유한 오퍼레이터의 이름을 넣었고 이를 UI에 보여주는 방식으로 구현했다. 
- 이제 개발 중에 관리되는 이름을 2가지 트랙으로 관리함
	- `EntityID` : 고유 식별자. 
	- `EntityNameLocalizationKey` : (언어별) 표시를 위한 키값. `UI`에 표시되는 언어는 이 값을 이용해서 `LocalizationManager`에서 불러온다.

> 이거 진행하다가 아래의 `SO` 접근자를 수정하는 과정으로 샜음.

- (아마도) 완료
### 명명 규칙
- [[고유 식별자 명명 규칙]]

## 기타 수정
- `OperatorData`의 `EntityName` 부분에 한국어 이름 필드 추가 설정
	- `OperatorSlot`에 나타나는 글자를 한국어로 사용
	- 다른 언어 텍스트를 추가할 건 아니지만 어떤 식으로 구현하는지 궁금해서 반영해둠(실제 변경은 불가능)

- `SO` 접근자 수정 
	- `SO`에 설정된 `public` 데이터들을 모두 숨기기 + 게터 프로퍼티 설정
# 251107 - 짭명방

>[!done]
>- 튜토리얼 수정
>	- `OperatorSlot` 찾지 못하는 현상 수정
>	- `BlinkingShader` 누락된 현상 수정
>		- 점멸하는 방식이 아니라 위-아래로 움직임을 갖도록 변경함. 이미지가 최초로 나타나는 시점에 꺼져 있을 수도 있어서 점멸하는 방식보다 애니메이션만 보여주는 게 더 나아 보임.

## 튜토리얼 수정

### 1. `OperatorSlot`을 찾지 못하는 현상 수정
- 나타나는 슬롯들의 이름 설정하는 로직을 바꿈 + `OperatorSlot`의 
### 2. `BlinkingShader` 누락된 현상 수정
> 일단 정상 작동하니까 냅두는데, 텍스쳐에 원래 쓰이던 아래 화살표를 두면 이렇게 나타나는 현상이 있다. 
![[Pasted image 20251107172703.png]]
> 원래 텍스쳐는 이거.
![[Pasted image 20251107172737.png]]
이게 깜빡거리는 방식임. 

실제 게임에서는 별 문제 없어서 그냥 넘김


- 근데 게임 뷰에서만 검은 바탕이 함께 나타나는 현상이 있음
	- 셰이더의 **알파 클립을 켜니까 사라졌음.** 

>[!note]
>- 점멸 방식에 대해
>- **셰이더로 알파값이 0과 1을 오가게 설정하면 사용자가 클릭하는 시점에 화살표가 보이지 않을 수도 있음** -> 그래서 "클릭으로 다음으로 넘길 수 있는가?"를 판단하기에 애매할 수 있어 보임

- 그래서 기존의 화살표가 깜빡거리는 방식 대신, 위-아래로 주기적으로 조금씩 움직이게 수정함
	- 근데 위에서 발생한 문제 또 발생함. **씬 뷰에서는 잘 보이는데 게임 뷰에서는 검은 사각형으로 보이는 현상.** 
	- 머티리얼 오버라이드가 켜진 상태에서 알파 클립을 활성화하지 않아서 발생했던 문제. 근데 **그 다음은 게임 뷰에서는 검은색 화살표로 나타난다. 의도는 흰색이었음.**

- 일단 UI에도 `URP/Unlit`을 사용하는 걸 권장
	- `URP/Unlit` 
		- 아무것도 없는 백지 상태에서 시작
		- **`UI/Image`와 상호작용하기 위해 `Vertex Color` 노드를 추가하고 곱해줘야 함**
			- 참고) 셰이더의 `Vertex Color`노드는 유니티 인스펙터에서 설정한 값을 가져온다. 파티클 시스템에서 `Start Color`를 가져왔듯, `Image` 컴포넌트에서도 `Color` 값을 가져옴.
	- `URP/Sprite Unlit Graph`
		- 새로 만들었을 때 `Sprite Color` 같은 특수 노드가 배치됨. 이는 `Sprite Renderer`의 `Color` 속성에서 값을 받아옴
		- `UI/Image`는 `Sprite Renderer`가 아니기 때문에 `Sprite Color`와 정상적으로 통신하지 못함

- 여기서 막혔다. 이게 뭐라고...
- 해결) `Universal`의 `Material`을 `URP - Unlit`에서 `URP - Canvas`로 변경
	- `URP - Unlit`은 개발자가 Canvas의 규칙에 맞춰 셰이더를 설계해야 함
	- `UI/Default(Canvas)`는 Canvas 시스템과 완벽하게 통신함

# 251106 - 짭명방
>[!done]
>- 발견한 이슈
>	- `Sniper` 강타 스킬 터질 때 나타나는 텍스트가 겹침
>	- `DualBlade` 스킬 이펙트(보라색 슬래시 이펙트)가 나타나지 않음
>	- `OperatorSkill`의 VFX 오브젝트들 태그 관리 방법 수정
>	- 오퍼레이터의 스킬을 사용할 때 여기서 `Instantiate`로 실행되는 요소들이 있음
>		- 이것들도 태그 이름을 `Stateless`으로 관리하는 오브젝트 풀링 기반으로 변경
>	- 게임 시작 시 스테이지 배속된 상태로 시작하는 현상 수정
>	- 메인 메뉴 패널 전환 시 부드럽지 않은 느낌 수정

## 이슈 수정

### Sniper 강타 스킬 터질 때의 텍스트 겹치는 현상
![[Pasted image 20251106154111.png]]
> 여기서 뜬 대미지는 488임

그럼 저 앞의 폰트들은 뭐지? 오브젝트 풀 로그를 추적해봄

- `Projectile.HandleHit`에서 자체적으로 띄우고 있었다.
	-> 지금은 **`TakeDamage`에서 대미지 계산 완료 후 해당 텍스트를 보여주는지 여부까지 체크해서 거기서 나타나도록 구현되고 있다. 그래서 여기서 별도로 처리할 필요는 없음.** 그래서 제거.

### DualBlade 스킬 이펙트가 나타나지 않는 현상
> `Operator.PlayMeleeEffect` 
```cs
// [버프 이펙트 적용] 물리 공격 이펙트가 바뀌어야 한다면 바뀐 걸 적용함
// 이 코드의 전제 조건은 "근접 공격 이펙트를 쓰는 다른 버프가 없다"이다. 상황이 바뀌면 코드를 바꿔야 함.
var vfxBuff = activeBuffs.FirstOrDefault(b => b.MeleeAttackEffectOverride != null);
if (vfxBuff != null)
{
	// effectPrefab = vfxBuff.MeleeAttackEffectOverride;
	effectTag = vfxBuff.SourceSkill.GetVFXPoolTag(this, vfxBuff.SourceSkill.meleeAttackEffectOverride);
	Debug.Log($"버프로 인한 물리공격 이펙트 변경 : {effectTag}");
}
```
> 여기서 `vfxBuff`를 가져오는 부분에 `null` 체크가 없어서 추가해봄
 -> 이렇게 해도 안 됨

- 로깅을 해보면 `effectTag`를 가져오지 못하고 있음
- `OperatorSkill`의 근접 공격 관련 로직들을 보면 이전에 `Stateless` 기반으로 구현했던 것들이 들어가 있지 않다. 여기에도 추가해줬음.
```cs
public virtual void PreloadObjectPools(OperatorData ownerData)
{
	// 근접 공격 VFX 변경
	if (meleeAttackVFXOverride != null)
	{
		// MELEE_ATTACK_OVERRIDE_TAG = RegisterPool(ownerData, meleeAttackEffectOverride);
		ObjectPoolManager.Instance.CreatePool(GetMeleeAttackVFXTag(ownerData), meleeAttackVFXOverride, 2);
	}
}

public string GetMeleeAttackVFXTag(OperatorData ownerData) => $"{ownerData.entityName}_{skillName}_MeleeVFX";


```

- 수정 완료
![[Pasted image 20251106164739.png]]

### 일부 오퍼레이터 스킬 Stateless로 관리되지 않고 있었음
- 위 이슈를 수정하면서 알게 된 건데 일부 스킬이 오브젝트 풀링을 이상하게 쓰고 있었음
- 수정 완료
```cs
public string GetSkillControllerTag(OperatorData ownerData) => $"{ownerData}_{skillName}_SkillController";
public string GetSkillRangeVFXTag(OperatorData ownerData) => $"{ownerData}_{skillName}_SkillRangeVFX";
public string GetHitVFXTag(OperatorData ownerData) => $"{ownerData}_{skillName}_HitVFX";

// 스킬 관련 오브젝트 풀 초기화.
public override void PreloadObjectPools(OperatorData ownerData)
{
	base.PreloadObjectPools(ownerData);

	if (skillControllerPrefab != null)
	{
		ObjectPoolManager.Instance.CreatePool(GetSkillControllerTag(ownerData), skillControllerPrefab, 1);
		// FIELD_EFFECT_TAG = RegisterPool(ownerData, fieldEffectPrefab, 2);
	}
	if (skillRangeVFXPrefab != null)
	{
		ObjectPoolManager.Instance.CreatePool(GetSkillRangeVFXTag(ownerData), skillRangeVFXPrefab, skillRangeOffset.Count);
		// SKILL_RANGE_VFX_TAG = RegisterPool(ownerData, skillRangeVFXPrefab, skillRangeOffset.Count);
	}
	if (hitVFXPrefab != null)
	{
		ObjectPoolManager.Instance.CreatePool(GetHitVFXTag(ownerData), hitVFXPrefab, 10);
		// HIT_EFFECT_TAG = RegisterPool(ownerData, hitEffectPrefab, 10);
	}
}
```
> 이 `PreloadObjectPools`은 스테이지가 시작되기 전에 한꺼번에 생성됨

- `OperatorSkill`의 기존 요소들은 제거

> 일단 보이는 것들을 수정 완료했음. 추가로 보이면 더 처리함.
### 스테이지 배속된 상태로 시작하는 현상 수정
- 현상) 스테이지 시작 후 아무 클릭도 하지 않았을 때 2배속으로 게임이 진행됨
	- 클릭만 해도 1배속으로 돌아오긴 함. ??
- 이전에 `Time.timeScale`로 다 다시 수정하는 과정에서 그 값이 `2f`로 설정되어 있었다. `1f`로 복구.

### VFX 일부 효과 마젠타 색으로 나타남
- 이전에 머티리얼을 정리하는 과정에서 일부 VFX들을 제대로 처리하지 못한 듯
- 수정한 요소들
	- `VFX_Hit_Lightning_v1`
	- `Boundary_Caster2ndSkill`

### 패널 페이드인되기 전에 내부 요소들 초기화
- 지금은 페이드인되면서 초기화가 진행되므로 초기화되기 전의 요소들이 보이는 게 어색함
	- 페이드인되면서 **초기화 전 -> 초기화 후로 바뀌는 게 순간적이지만 보여서** 장면 전환이 깔끔하지 않다고 생각함

- 처음에는 `OnEnable`되는 과정에서 UI들이 초기화되기 떄문이라고 생각했는데, 일시정지를 (드디어) `Space` 키로 지정한 다음에 전환 과정을 프레임 단위로 지켜본 결과 `CanvasGroup`이 투명한 상태에서 UI들이 의도한 것과 다르게 보이는 현상이 있음
	- 예를 들면 어떤 `Image`는 흰색이 전혀 없음에도, 알파값이 낮을 때는 흰색이 보이다가 진해지면서 사라지는 것이 보임

- 따라서 이건 초기화 이슈라기보다는 **패널의 알파값이 낮을 때 일어나는 이슈**에 가까운 듯
- 그러면 페이드 인을 알파값이 완전히 0인 상태에서 진행하는 게 아니라 조금 더 높인 상태에서 진행하면 어떨까?
	- 이렇게 접근해봤는데 큰 차이는 없는 듯..

- 전체적인 패널 색을 조금 더 어둡게 통일해봤음
- `OperatorSlot.SkillImage` 부분이 밝았다가 자기 이미지로 변하는 현상이 있음 -> 이 부분이 좀 어색해보이긴 함
	- 저 "밝았다"는 지점이, **`SkillIconBackground`가 있는데 흰색으로 되어 있음. 이걸 검정색으로 바꿔봄.**

1.  **`Background`로 설정된 요소들이 다 흰색이어서, 알파값이 변하는 과정에서 그 부분이 변하는 게 더 두드러져보임**
2. 근데 꼭 1번만으로 다 설명할 수 있는 건 아님 - 근데 일단은 여기까지 

일단 이 정도로 괜찮은 듯 해서 넘김 - 모두 해결한 건 아닌데 너무 많은 시간을 쓰는 것도 아닌 듯 해서.

# 251105 - 짭명방

>[!done]
>- `LoadingScreen` : 로비로 돌아갈 때 페이드아웃되지 않는 현상
>	- 스테이지 종료 시점에 `Time.timeScale = 0f`가 되면서 발생한 현상.
>	- 씬 전환 과정은 시간이 정상적으로 흘러가야 하므로 `LoadScene`의 시작 부분에 `Time.timeScale(1f)`을 달아준다.
>		- `DOTween`의 시퀀스에 `.SetUpdate(true)`을 달아줘도 해결 가능
>- `GameManagement.TimeManager` 제거
>	- `Time` 클래스로 다 처리 가능함
>- `StageSelectPanel`에서 `StageDetailPanel`을 띄울 때의 애니메이션 구현
## LoadingScreen - 로비로 돌아갈 때 페이드아웃되지 않는 현상

- 코드
```cs
    // 검은 화면만 사용할 경우
    public void Initialize()
    {
        ResetState();

        gameObject.SetActive(true);
        stageInfoPanel.gameObject.SetActive(false); // 정보 패널 부분은 비활성화

        Debug.Log("[LoadingScreen]어두운 화면만 나타나는 Initialize");

        // 어두운 패널이 서서히 나타남 - Append 개념은 순차적으로 동작함
        currentSequence = DOTween.Sequence();
        currentSequence.Append(screenFader.DOFade(1f, fadeOutDuration))
            .OnComplete(() =>
            {
                OnFadeInCompleted?.Invoke(); // 이 패널이 완전히 나타난 후 이벤트 발생
            });

        currentSequence.Play();
    }
    
    // 스테이지 진입 시 사용 - 스테이지 이름과 로딩 게이지를 함께 보여줌
    // 로딩 화면을 띄우고 스테이지 매니저의 로딩 완료를 기다림
    public void Initialize(string stageId, string stageName)
    {
        ResetState();

        gameObject.SetActive(true);

        // 스테이지 정보 및 로딩 게이지 활성화 
        stageIdText.text = stageId;
        stageNameText.text = stageName;
        loadingSlider.gameObject.SetActive(true);

        // 어두운 패널이 서서히 나타남 - Append 개념은 순차적으로 동작함
        currentSequence = DOTween.Sequence();
        currentSequence.Append(screenFader.DOFade(1f, fadeOutDuration))
            .OnComplete(() =>
            {
                Debug.Log("[LoadingScreen]페이드인 완료");
                OnFadeInCompleted?.Invoke(); // 이 패널이 완전히 나타난 후 이벤트 발생
            });
        currentSequence.AppendCallback(() =>
        {
            stageInfoPanel.alpha = 1f; // 페이드인 후 인포 패널 등장
        });

        // 시퀀스 실행
        StartCoroutine(WaitStageManagerAndPlaySequence());
    }
```
> 여기서 위의 `Initialize()`는 잘 동작하지 않는 반면 아래의 `Initialize()`는 잘 동작함

- 차이점이라면 아래의 `Initialize`는 스테이지 매니저의 초기화를 기다린 다음 실행된다는 것임

1. **로딩 화면의 페이드인은 버튼을 누른 시점에 진행**되어야 함 
	- 이건 **다음 씬의 로드 완료 후에 동작해야 하는가? 와는 완전히 별개**임
2. 현재 발생 중인 문제점은 시퀀스를 설정하고 곧바로 실행하면 페이드인이 진행되지 않고, 기다리는 시간이 있다면 페이드인이 진행되는 방식

- 그러면 그냥 **한 프레임 기다리고 실행**시켜보자.
```cs
private IEnumerator WaitMomentAndplay()
{
	yield return null;
	currentSequence.Play();
}
```
> 안된다. 

- **`Time.timeScale`의 영향일 가능성이 있다**고 함
	- **이거였다.** 아 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ
	- `SetUpdate(true)`를 추가로 달아주는 방법도 있지만
	- 씬 전환은 시간 스케일에 영향을 받기 떄문에 전환하기 시작하는 시점에 1로 설정해주는 게 좋음 -> `LoadScene`의 시작 부분에서 `Time.timeScale = 1f`을 설정해준다

## TimeManager 제거
- `Time` 클래스의 메서드로 다 처리가 가능한 부분이라 굳이 별도로 `TimeManager`를 둘 필요는 없어보임

## StageSelectPanel의 DetailPanel 애니메이션 추가
- 기존엔 단순히 `SetActive`로 활성화 / 비활성화로만 구현했는데 애니메이션을 추가해서 오른쪽에서 왼쪽으로 슬라이드되듯이 나타나게 하고 싶음
- 구현 완료. 이제 디테일 패널은 항상 활성화되어 있으며, 최초에는 화면 밖에 있다가 활성화되면 화면에 나타나는 방식임
	- 빈 공간을 클릭해서 초기화하는 기능은 `StageButtonContainer`에 이미 `Button`으로 구현되어 있음
	- 그 외에 `StageSelectPanel` 스크립트에서 쓸데없어 보이는 구현들을 제거해둠

## OperatorInventoryPanel - 스쿼드 편집 X 시
- 하단 버튼 레이아웃 이상한 현상 수정
	- 필요없는 버튼들의 비활성화 외에도, 중간 공간`Empty`도 비활성화 해줘야 함
	- 완료

## 패널 전환 페이드 시간 증가
- 인벤토리 패널 -> 오퍼레이터 디테일 패널 진입 시 이전 패널이 계속 남아서 이상해보임
- 패널 전환 로직을 수정함
	- 기존에는 새로운 패널을 페이드인 한 다음 기존 패널을 비활성화했음
	- 지금은 **기존 패널을 비활성화한 후에 페이드인**함

### 추가
- 패널 전환 로직을 1개로 통일함 : `FadeInAndHide`
	- 이름을 `ChangePanel`로 변경
- 크게 어색해보이는 게 없어서 이렇게 진행함

## 오늘의 팁
>[!note]
>1. `SceneManager.SceneLoaded`와 `AsyncOperation`의 관계
>- `AsyncOperation.isDone`이 완료되기 직전에 `SceneLoaded` 이벤트가 호출된다. 



# 251104 - 짭명방

>[!done]
>- 기타 수정
>	- `vfx_hit_explode_v1` : 늦게 떨어지는 파티클들이 어색해보임

>[!wip]
>1. 스테이지 씬 -> 메인메뉴 씬 전환

## 스테이지 씬 -> 메인메뉴 씬 장면 전환
- 똑같이 페이드아웃 후 메인 화면 나타나도록 하면 됨

- **아예 `StageLoader`를 `SceneLoader`로 변경함**
	- 씬 전환 과정을 처리
	- 단 스테이지 로딩 화면과 메인 메뉴로 돌아가는 화면은 달라질 듯
- `StageLoadingScreen`도 `LoadingScreen`으로 변경
	- 초기화 메서드를 2개로 구현한다
		- 기존의 `stageId, stageName`이 있는 방식과 아무 파라미터도 전달하지 않는 방식

> [!info]
> **메서드 이름에 관한 고민**을 해봄
> 	1. `Initialize(param1 param)`과 `Initialize()`
> 	2. `InitializeForPurpose(param1 param)`과 `Initialize()`
> 
> 더 권장되는 방법은 1번이라고 함 - **메서드 이름에 목적이 들어가는 게 권장되진 않음**
> - **메서드 이름은 "무엇을 하는가"에만 초점**을 맞추는 게 좋다. "어떻게 하는가" 혹은 "어떤 목적을 위해 작성되었는가" 등이 들어가면 **비슷한 기능의 메서드가 다른 이름으로 계속 늘어나게 된다.** 
> - 대표적인 예시가 `Debug.Log()`인데, 이 메서드는 `string, int, Vector3` 모두 같은 메서드 이름으로 처리한다. 
> 	- 만약 내가 고민한 2번 방법대로 처리한다면 `Debug.LogString()`, `Debug.LogInt()`, `Debug.LogVector3()` 같이 똑같은 기능을 수행함에도 타입이 달라진다는 이유로 다른 메서드가 있다는 걸 알아야 함. 
> - **개발자가 기억할 메서드의 이름이 적을수록 좋다.**
> 
> - 물론 명백히 다른 기능을 수행한다면 메서드 이름을 구분하는 게 좋다. `FadeIn`, `FadeOut`같이 명확히 차이가 있는 기능을 굳이 `DoScreenEffect(EffectType.FadeIn)` 같은 느낌으로 하나의 메서드로 처리하는 건 오히려 가독성을 해칠 수 있다. 

>[!conclusion]
>- 따라서 `StageLoadingScreen`의 경우, 
>	- **`Initialize()`** :  스테이지 로딩 화면에 필요한 정보들인 스테이지 ID, 이름을 불러오지 않고 **검은 화면의 페이드인만 처리**하는 방식
>	- **`Initialize(stageId, stageName)`** : **스테이지 정보들과 로딩 게이지를 함께 보여주는 방식**

> - 일단 `SceneLoader`에서 다른 씬으로 전환하는 방식으로 메서드 수정은 완료 
> - 스테이지 -> 메인메뉴로 돌아갈 때의 페이드인은 나타나지 않고 있음
- `SceneLoader`에서 페이드인이 진행되고, 완료됐을 때 플래그 상태값이 초기화되지 않은 이슈였던 걸로 보임

- **근데 화면이 안 나타난다.** 전환마다 패널을 인스턴스화하는 방식인데, 애니메이션이 동작하지 않는 건가?

> 일단 여기까지 진행

## 기타 수정 사항 
### VFX_Hit_Explode_v1 수정
- 텍스쳐 시트로 바꾸고 나서 `Beam`의 텍스쳐인 18번을 써야 하는데 6번을 쓰고 있었다. `Impact`인데, 작아서 티가 안났음
- 파티클의 타이밍이 이상해보여서 수정.





# 251103 - 짭명방

## 스테이지 진입 버튼 누를 때 장면 전환
- 스테이지 시작 버튼을 누르면 **화면이 완전히 어두워진 다음에 로딩화면이 나타나도록** 수정

> 1. 처음에는 별도의 `FadeScreen`을 만드는 방식으로 접근
> 	- 이 방법이 겉으로 봤을 때는 가장 깔끔해보인다. `스테이지 진입 버튼 클릭 -> 화면 페이드아웃 -> 스테이지 로딩 현황 -> 완료 -> 스테이지 진입` 과정이 크게 거슬리지 않고 깔끔하게 보임
> 	- 근데 `StageLoadingScreen`이랑 일일이 설정을 맞춰야 하는 번거로움이 있는 듯.
> 2. `StageLoadingScreen`으로 통합해서 진행할 수 있을 것 같아서 다시 접근
> 	- 현재까지는 로딩 패널이 씬 전환 후에 나타나서 페이드 아웃/인이 이상함

>[!objective]
>1. 스테이지 진입 버튼을 누르면 페이드 아웃됨
>2. 씬 로딩을 시작하면 검은 화면에 스테이지 로딩 화면이 나타남
>3. 스테이지 로딩이 완료되면 완료 표시가 나온 후 1초 후에 게임이 시작되며 로딩 패널이 페이드아웃됨

### 해결
- 페이드 인이 완료되는 시점까지 로딩을 막는 방식. `yield return new WaitUntil()`

- `StageLoader.cs`
```cs
private IEnumerator LoadStage()
{
	// ...
	
	// 로딩 화면 보여주기 및 입력 차단
	ShowLoadingScreen();

	// 페이드 인 완료 이벤트를 구독함
	// 메서드는 bool 필드를 true로 바꿔주는 단순한 역할
	if (loadingScreen != null) loadingScreen.OnFadeInCompleted += HandleFadeInComplete;

	// 페이드 인 완료까지 대기
	yield return new WaitUntil(() => isFadeInCompleted);

	// 이벤트 구독 해제
	if (loadingScreen != null) loadingScreen.OnFadeInCompleted -= HandleFadeInComplete;
	
	// ...
}
```

- `StageLoadingScreen.cs`
```cs
public event Action OnFadeInCompleted = delegate { }; // 이 스크린의 페이드인 동작이 완료되었을 때 발생

public void Initialize(string stageId, string stageName)
{
	// ...
	
	// 어두운 패널이 서서히 나타남 - Append 개념은 순차적으로 동작함
	currentSequence = DOTween.Sequence();
	currentSequence.Append(screenFader.DOFade(1f, fadeOutDuration))
		.OnComplete(() =>
		{
			// 이 패널이 완전히 나타난 후 이벤트 발생
			OnFadeInCompleted?.Invoke();
		});
	currentSequence.AppendCallback(() =>
	{
		infoPanel.alpha = 1f;
	});
	
	// ...
}
```

### 기타 이슈
 - [x] 2번째 스테이지 진입부터는 `StageLoadingScreen`이 원하는 대로 동작하지 않음
	- [x] 로딩 화면이 페이드인되지 않음 : `StageLoader`의 상태 이슈
	- [x] 로딩 화면 현황이 텍스트로 나타나지 않음 
		- 해결 시도들
			1) 캔버스 강제 업데이트 - 해결 X
				- 로그를 찍어보면 값들은 제대로 나타나고 있음. 
			2) ★ `LoadingScreen`이 실행 시마다 생성되는 현상과 연관이 있을 듯 해서 그 문제부터 접근
				- `LoadingScreen`을 생성하는 부분은 `LoadStage` 내부로 통합
		- `DontDestroyOnLoad`에 `LoadingScreen`이 쌓이는 현상
			- 이것도 해결됨 - 로딩 화면의 게이지가 업데이트되지 않고 텍스트도 나타나지 않는 현상은 이것과 직접적으로 관계가 있었음
- [x] 스테이지 진입은 되는데 여러 UI가 초기화가 제대로 안 됨
	- 로딩 시퀀스 정리
		- `StageLoadingScreen`과 `StageManager`의 타이밍들을 정리할 필요가 있어보인다. 다시 봤을 때 구조가 헷갈림.
			1. `StageLoader` - `loadingScreen`을 초기화함
			2. 초기화가 완료될 때까지 `StageLoader`에서는 대기.
				- 참고) `asyncLoad.isDone`이 `true`라면 새로운 씬의 활성 오브젝트의 모든 `Awake`까지 실행됐다는 얘기임
					- [[Unity - 씬 전환]] 참고
	- 시퀀스 정리는 됐는데 UI 초기화가 안된다. 적의 전체 수라든가, 배치 가능한 횟수라든가.
		- 이건 타이밍 문제 - `StageManager`에 값들이 할당된 다음에 `UI`로 전달해야 하는데 `UI` 초기화 시점이 `StageManager`의 변수 초기화 시점보다 앞서 있었음.
