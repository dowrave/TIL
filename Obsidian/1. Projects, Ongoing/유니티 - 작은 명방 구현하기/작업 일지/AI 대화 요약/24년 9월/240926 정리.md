1. 바리케이드 파괴 및 경로 재계산 문제:
   - Enemy 클래스에서 바리케이드가 파괴될 때 경로를 재계산하는 로직에 문제가 있었습니다.
   - `OnBarricadeRemoved` 메소드를 코루틴으로 변경하여 약간의 지연 후 경로를 재계산하도록 수정했습니다.

2. `GetNearestBarricade` 메소드 개선:
   - 모든 바리케이드까지의 경로 길이를 출력하도록 메소드를 수정했습니다.
   - LINQ를 사용하여 바리케이드와 경로 길이를 pair로 만들고, 이를 정렬하여 가장 가까운 바리케이드를 찾도록 구현했습니다.

3. 바리케이드 식별 문제:
   - 여러 바리케이드가 존재함에도 하나의 위치의 바리케이드만 나타나는 현상이 발견되었습니다.
   - `Barricades` 리스트에서 바리케이드를 구분하는 기준이 명확하지 않았습니다.

4. 해결 방안 제안:
   - 바리케이드 클래스에 고유 식별자(UniqueID)를 추가하여 각 바리케이드를 구분하도록 제안했습니다.
   - `AddBarricade` 메소드를 수정하여 중복 검사 시 UniqueID를 사용하도록 했습니다.
   - `GetNearestBarricade` 메소드에 더 자세한 디버그 로그를 추가하여 문제 원인을 파악할 수 있도록 했습니다.

5. 추가 고려사항:
   - 바리케이드 생성 및 초기화 과정에서 각 바리케이드가 고유하게 초기화되고 있는지 확인이 필요합니다.
   - 바리케이드의 위치 정보가 정확히 설정되고 있는지 확인이 필요합니다.

> 실제로는 `Barricade`의 배치와 제거 로직에서, 이벤트 발생이 가장 나중에 발생하도록 순서만 바꿔주는 식으로 변경했음

---

## 휴식 후

1. 클릭과 마우스 버튼 다운-업 동작을 구분하는 방법에 대해 논의했습니다.

2. DeployableUnitEntity에 배치 직후 잠시 동안 상호작용을 막는 기능을 추가하기로 했습니다.

3. 이를 위해 `preventInteractingTime`과 `lastDeployTime` 변수를 추가했습니다.

4. `Deploy` 메서드에서 배치 시 `lastDeployTime`을 현재 시간으로 설정하도록 했습니다.

5. `OnClick` 메서드에서 현재 시간과 `lastDeployTime`의 차이를 확인하여, `preventInteractingTime` 이내라면 클릭 동작을 무시하도록 구현했습니다.

6. 최종적으로는 배치 직후 커서가 유닛 위에 있는 상황에서도 상호작용을 막고, DeployableManager의 CancelPlacement 메서드를 호출하여 배치 상태를 취소하도록 구현했습니다.