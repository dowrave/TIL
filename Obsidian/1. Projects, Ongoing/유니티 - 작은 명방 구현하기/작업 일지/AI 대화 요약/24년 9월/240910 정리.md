1. 초기 문제점:
   - 구조체, ScriptableObject, 그리고 이를 사용하는 클래스 간의 복잡한 상속 구조
   - 데이터 접근의 복잡성 (예: `operatorData.operatorStats.deployableStats.baseStats.health`)
   - 구조체에서의 데이터 중복

2. 논의된 해결 방안:
   - 구조체 통합: 모든 필요한 필드를 하나의 구조체에 포함
   - ScriptableObject 계층 구조 유지, 但 데이터 접근 메서드 제공
   - 엔티티 클래스의 계층 구조 유지, 適切한 데이터와 메서드만 노출

3. 최종 선택된 접근 방식:
   - 각 객체에 사용되는 구조체를 별도로 정의하여 Data에 포함
   - Initialize 메서드를 상속하지 않고 각 클래스에서 private으로 구현
   - 각 타입에 맞는 Data와 Stats으로 초기화

4. 선택된 방식의 장단점:
   장점:
   - 각 객체 타입별로 명확한 데이터 구조 정의
   - 구조체 필드의 출처를 명시하여 데이터 흐름 파악 용이
   - 각 클래스가 자신의 초기화 로직을 완전히 제어

   단점:
   - 상속의 이점이 일부 감소
   - 약간의 코드 중복 가능성

5. 주요 교훈:
   - 데이터 구조와 클래스 구조의 균형 중요성
   - 상속과 구성(composition) 사이의 트레이드오프
   - 코드의 명확성과 유지보수성의 중요성

6. 향후 고려사항:
   - 새로운 엔티티 타입 추가 시 확장성
   - 데이터 일관성 유지 방법
   - 성능 최적화 (필요 시)

> 게임 중에 변할 수 있는 값들은 `구조체`로 구현하면 훨씬 편하게 구현할 수 있다. `ScriptableData`에 스탯을 넣으면 각 객체에서 `ScriptableData`에 정의한 필드를 다시 한 번 정의해야 한다. [[Unity - 스크립터블 오브젝트]] 참고.


