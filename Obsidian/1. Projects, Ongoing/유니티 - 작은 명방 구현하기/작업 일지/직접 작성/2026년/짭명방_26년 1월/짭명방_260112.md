
>[!done]
>1. 읽기 전용 인터페이스가 정말 필요할까?
>	- 목적) 컨테이너 외부에서 컨트롤러의 public 메서드를 실행하는 걸 방지하는 것이었음
>	- 우회 방법이 있더라도 그걸 잘 수행하고 있음
>	- 필드의 경우 일일이 컨테이너에 다 구현하지 않아도 됨 - 자주 쓰는 것만 컨테이너에 구현
>2. `Block Controller` 구현

### 쉬는 동안 든 생각 : 읽기 전용 인터페이스
- 읽기 전용 인터페이스가 정말 필요한가?에 대한 생각 정리
	- 기능을 구현하면서 프로퍼티를 컨테이너에 구현하고 있다. 일일이 `컨테이너.컨트롤러.필드`로 접근해서 사용하지 않게 하려고.
	- 근데 이럴 거면 인터페이스가 필요한가? 라는 의문이 들었다.
- 4개의 AI에게 물어봤다. Gemini, ChatGPT, Claude, Grok
- 크게 2가지 질문을 했다.
	1. 읽기 전용 인터페이스가 필요한가? 
	2. 지금의 컨트롤러 분리 방향이 맞는가?

- 선요약) **설계에는 정답이 없으며, 상황에 따라 달라진다.**
	1. **프로젝트 기간, 속도, 기능 구현, 생산성**을 최우선으로 염두에 둘 것.
	2. **리팩토링은 필요할 때 할 것**

>[!done]
>- **읽기 전용 인터페이스를 유지함**
>	- 컨트롤러의 이벤트가 특히 그렇다. 
>- **모든 필드를 컨테이너에 노출시킬 필요는 없다.** 자주 쓰는 것들만 구현해도 충분함.

#### 1. 읽기 전용 인터페이스

- 컨테이너의 프로퍼티로 컨트롤러 접근 필드를 직접 구현하기
	- 장점 : 외부에서 사용하기 편리함
	- 단점 : 컨테이너가 비대해질 수 있음

- 읽기 전용 인터페이스로 컨트롤러의 필드 구현하기
	- 장점 : 컨테이너가 컨트롤러의 세부 필드를 일일이 알 필요 없음
	- 단점 
		- 외부에서 "해당 컨테이너에는 이런 인터페이스가 있다"는 걸 알아야 함
		- 기능을 사용하는 코드가 늘어질 수 있음`Unit.stats.xxx...`

- 우선 알아야 할 건 **어떤 상황에도 다 통하는 좋은 방법은 없다**는 것

- 내 프로젝트의 규모에서는 컨테이너의 프로퍼티로만 필드를 구현해줘도 크게 상관 없는 수준이다.
	- **분리 수준 자체는 인터페이스를 구현하는 게 훨씬 좋다.** 
		- 그래서 장기 프로젝트나 상용 서비스를 해야 하는 상황이라면 이쪽을 지향해야 함
	- 하지만 인터페이스를 구현하는 것도 결국 비용이다.

##### 1-1. 읽기 전용 인터페이스가 정말 필요한가?
- 질문하다보니까 의문이 또 들었다.
- `public` 필드에만 접근할 수 있는 인터페이스가, 굳이 별도로 필요한가? 라는 의문임.

- 읽기 전용 인터페이스가 필요한 경우는
	- 다형성이 필요한 경우(NPC에도 적용할 수 있는 체력 게이지 등)
	- 명시적 계약이 필요한 경우("체력 정보를 읽을 수 있다"를 타입으로 표시)
	- 컨트롤러를 통째로 전달해야 하는 경우

> - 기존에 고민했던 지점을 다시 짚어보면
> - **세부 컨트롤러가 `public`으로 노출됐을 때, "이 컨트롤러의 세터 메서드도 `public`이기 때문에 외부에서 접근할 가능성이 있다"** 였음.
> - 인터페이스로 구현하고 이것만 `public`으로 노출시키면 (타입 캐스팅이 가능하지만 더 번거로움) 외부에서 세터 메서드를 실행하는 걸 방지할 수 있음

- 따라서 위에 해당하는 경우는 없지만 인터페이스 자체는 유지하는 걸로 함.
	- 컨트롤러의 이벤트 노출도 되고, "모든 필드를 컨테이너에 띄운다" 같은 상황만 잘 관리해주면 됨. **컨테이너에는 자주 사용하는 필드만 게터 프로퍼티를 구현**해둔다.


- 참고만 하자) `internal`로 같은 어셈블리 내에서만 호출할 수 있게 구현하는 방식도 있지만 유니티에선 기본적으로 모든 스크립트가 하나의 `Assembly-CSharp.dll`에 컴파일되어서 별 효과는 없음
	- 분리하기 위해 `.asmdef` 파일을 만드는 방식이 있지만, 이건 규모가 클 때에만 사용하는 걸 추천


#### 2. 컨트롤러 분리
- 규모에 상관없이 웬만하면 이런 식으로 세부 기능은 분리하는 걸 추천
- 조심해야 할 점)
	- 경계가 모호한 지점이 생길 수 있고
	- 세부 컨트롤러끼리 다른 컨트롤러에 의존하는 방식은 X

### Block Controller
- 저지 관련 로직들을 `Operator`와 분리해서 구현함

- 기존 구조 관련
>[!question]
>- 2개의 `List<Enemy>`로 `BlockableEnemies`와 `BlockedEnemies`를 관리했다. 
>	- `BlockableEnemies` : 콜라이더가 겹친 상태, 즉 저지 가능한 적들 리스트
>	- `BlockedEnemies` : 실제로 저지 중인 적들.
>
>콜라이더가 겹칠 때 `BlockableEnemies`에 `Enemy`를 추가하는 `RegisterEnemy`라는 메서드를 만들었다고 하자. `BlockedEnemies`에 `Enemy`를 추가하는 `BlockEnemy`는 이 메서드 내부에서 실행되도 좋을까? 아니면 따로 호출해야 할까?

> 왜 이 고민을 했음? : 이전에 책에서 읽었던 것 중에서 "**메서드는 한 가지 기능만 수행해야 한다**"는 얘기 때문에 그렇다. 

> [!note]
> `데이터의 무결성Integrity`을 고려해야 한다.
- `BlockedEnemies`는 반드시 `BlockableEnemies`에 있는 요소 중 일부가 된다.
- 만약 2개의 로직이 분리된다면, `BlockableEnemies`에는 포함되지 않아서 근접하지 않은 상황인데 적이 저지되는 현상이 발생할 수 있다. 이건 논리적으로 봤을 때 분명히 이상한 현상임.
- 따라서 **"범위에서 나가는" 메서드가 동작한다면, 그 적과 관련된 저지 상태도 함께 해제되는 로직을 작성해주는 것이 좋다.**

>[!note]
>- **메서드가 한 가지 기능을 수행한다 != 단 하나의 동작을 수행한다**
>- 중요한 건 **추상화 수준과 목적**이다

- 메서드는 지휘자 역할과 일꾼 역할로 나뉜다.
	- 일꾼 : 아주 구체적인 작업`list.Add(), hp -= 10`을 수행한다.
	- 지휘자 : 여러 일꾼을 불러 하나의 워크플로우를 완성한다.

- 위의 `RegisterEnemy`가 하는 일은, 적이 범위에 들어왔을 때 내부적으로 리스트에 추가하기 + 저지 시도하기 라는 2가지 작업이 필요한 것이다.

- 간단한 판단 기준으로, 메서드의 이름을 정하는 게 있다. And가 붙을수록 서로 관계 없는 일이 억지로 붙어 있을 가능성이 크다.

- 그래서 메서드 이름을 `RegisterEnemy, UnregisterEnemy`보다는 `OnEnemyEnteredBlockRange`, `OnEnemyExitedBlockRange` 같이 정해주는 게 좋다. 세부적인 작업은 별도의 메서드로 분리하거나 최소한 주석이라도 달아주는 식으로 처리하면 됨.

- 이 명명법 관련해서, 컨테이너에서 `_block.OnEnemyEnteredBlockRange` 같이 쓰므로 `block`이 2번 들어가게 된다. 변수 이름이 무엇을 하는지에 대한 정보를 준다면 메서드 이름에서 `Block` 같은 건 제외해도 됨.
- `_attack.OnEnemyEnteredRange`, `_block.OnEnemyEnteredRange`라고만 써도 어떤 처리를 하는지 명확히 보이기 때문이다.

> 위에서 고민하는 시간이 좀 많이 길었다. 다행히 `_block`을 구현하는 건 매우 빨랐음.
> 오늘은 여기까지!
