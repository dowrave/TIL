
>[!done]
>1. `UnitStats`으로 시작되는 `struct`들의 구조 수정
>	- 세터 프로퍼티 제거 & 생성자 추가 & 필드로 초기화하는 것까지 고려
>2. 직렬화와 인스펙터 노출 공부
>3. 스탯 정리 : 공격 속도와 쿨다운 개념 명확하게

## 스탯 정리 : 공격 속도 vs 쿨다운

### 수정 방향 
1. 캐릭터마다의 기본 공격 속도를 `BaseAttackRate`으로 생각
	- 현재의 `AttackSpeed`인데, 이를 `BaseAttackRate`으로 변경
	- 이 `BaseAttackRate`는 불변값
2. 공격 속도 스탯 개념을 추가 : `AttackSpeed`. 
	- 별도의 설정이 없으면 런타임에만 동작하며 `1`에서 시작하는 값
	- 버프로 계수가 추가되는 값
3. 최종 값은 아래의 공식을 따름 - 즉 공격 속도는 분모로 들어감
$$
최종 쿨다운 = \frac{기본쿨다운}{공격속도}
$$

- `BaseAttackRate = 2.0`이라고 하면
- 예시) 공격 속도 50% 증가 
	- 기본 공격 속도는 1이므로 50% 증가는 1.5
	- 원래 최종 쿨다운 : 2
	- 버프 최종 쿨다운 : 1.333

### 반영
1. 기존의 `AttackSpeed` => `BaseAttackCooldown`으로 변경
2. `StatController`에서 관리하는 타입은 `AttackSpeed`로 동일
	- 기본값에 `BaseAttackCooldown`을 넣음
	- 모디파이어에 `AttackSpeed`에 해당하는 값을 넣음
	- `GetStats`에서 나가는 부분만 수정해주면 됨
```cs
public float GetStat(StatType type)
{
	// 1. 오버라이드에 있는 값이라면 최우선으로 나감(덮어쓰기 값)
	// 공격속도 관련해서 생각할 게 있긴 한데 지금까진 공격속도를 덮어쓰는 로직은 없었음
	if (_overrides.TryGetValue(type, out float overrideValue))
	{
		return overrideValue;
	}

	float baseValue = _baseStats.TryGetValue(type, out float val) ? val : 0f;
	float modifierValue = _modifiers.TryGetValue(type, out float mod) ? mod : 0f;
	float calculatedValue;

	if (type == StatType.AttackSpeed)
	{
		// 공격 속도 : 기본 1
		float attackSpeed = (1 + modifierValue);

		// 최종 공격 쿨다운 : 기본 공격 쿨다운 / 공격 속도
		// 공격 속도가 빨라진다 = attackSpeed가 올라간다 = 공격 쿨다운이 줄어든다
		calculatedValue = baseValue / attackSpeed;
	}
	else
	{
		calculatedValue = baseValue * (1 + modifierValue);
	}
	
	return calculatedValue;
}
```
## 스탯 시스템 수정

>[!flow]
>- `struct`로 구현된 스탯 시스템의 각 프로퍼티의 setter 제거
>	- setter를 제거하면서 사용 불가능해진 코드가 발생 : 레벨에 따른 스탯을 갱신하는 부분이 프로퍼티의 세터로 구현되어 있었음 -> 수정 필요
>- `struct`의 생성자를 구현하는 것으로 접근
>	- `struct`는 `UnitStats` -> `DeployableUnitStats` -> `OperatorStats` 처럼 이전의 코드를 재활용하는 부분이 있음
>		- 하위 구조체에서 상위 구조체를 받아 초기화하는 방식으로 구현하는 게 가능함
>		- 하지만 이렇게만 구현하면 쓰는 입장에서, `OperatorStats`을 초기화하기 위해 `UnitStats`와 `DeployableUnitStats`을 초기화한 다음에 `OperatorStats`에 인자로 넣어야 함
>		- 그래서 **각 `struct`의 초기화 메서드는 더 상위 구조체를 받는 것 외에도, 단순히 각 필드를 받는 식의 구현도 추가**해줘야 함(편의 생성자) 

1. 기존의 `SO.UnitStats` 관련 필드들의 프로퍼티의 세터들을 제거

2. 각 `struct`에 생성자 추가
```cs
[System.Serializable]
public struct UnitStats
{
    [SerializeField] private float _health;
    [SerializeField] private float _defense;
    [SerializeField] private float _magicResistance;

    public UnitStats(float health, float defense, float magicResistance)
    {
        _health = health;
        _defense = defense;
        _magicResistance = magicResistance; 
    }

    public float Health => _health;
    public float Defense => _defense; 
    public float MagicResistance => _magicResistance;
}

[System.Serializable]
public struct DeployableUnitStats
{
    [SerializeField] private UnitStats _baseStats;
    [SerializeField] private int _deploymentCost;
    [SerializeField] private float _redeployTime;

    public DeployableUnitStats(UnitStats baseStats, int deploymentCost, float redeployTime)
    {
        _baseStats = baseStats; // UnitStats 자체를 전달해주면 됨
        _deploymentCost = deploymentCost;
        _redeployTime = redeployTime;
    }

    public int DeploymentCost => _deploymentCost;
    public float RedeployTime => _redeployTime;
    public float Health => _baseStats.Health;
    public float Defense => _baseStats.Defense;
    public float MagicResistance => _baseStats.MagicResistance;
}
```

- 그런데 이렇게만 구현하면 `DeployableStats`을 초기화하기 위해 `UnitStats`의 초기화부터 해야 함. `OperatorStats`까지 있으니 **쓰는 입장에서 구조체 초기화만 3번 해야 함**

- 그래서 **`flat`한 필드들을 받는 생성자를 추가해준다. 대신 가장 하위 구조체에서 상위 구조체들을 초기화하는 로직을 넣어주면 됨.**

```cs
// 모든 유닛에 적용되는 스탯 생성자
public UnitStats(float health, float defense, float magicResistance)
{
	_health = health;
	_defense = defense;
	_magicResistance = magicResistance; 
}
// ---

// 상위 구조체를 받아 초기화
public DeployableUnitStats(UnitStats baseStats, int deploymentCost, float redeployTime)
{
	_baseStats = baseStats;
	_deploymentCost = deploymentCost;
	_redeployTime = redeployTime;
}

// 구조체 없이 필드들만 받아 초기화
public DeployableUnitStats(float health, float defense, float magicResistance, int deploymentCost, float redeployTime)
{
	_baseStats = new UnitStats(health, defense, magicResistance);
	_deploymentCost = deploymentCost;
	_redeployTime = redeployTime;
}
// ---

public OperatorStats(
	DeployableUnitStats deployableUnitStats,
	float attackPower,
	float baseAttackCooldown,
	int maxBlockableEnemies,
	float spRecoveryRate
	)
{
	_deployableUnitStats = deployableUnitStats;
	_attackPower = attackPower;
	_baseAttackCooldown = baseAttackCooldown;
	_maxBlockableEnemies = maxBlockableEnemies;
	_spRecoveryRate = spRecoveryRate;
}

public OperatorStats(
	float health,
	float defense,
	float magicResistance,
	int deploymentCost,
	float redeployTime,
	float attackPower,
	float baseAttackCooldown,
	int maxBlockableEnemies,
	float spRecoveryRate
	)
{
	_deployableUnitStats = new DeployableUnitStats(new UnitStats(health, defense, magicResistance), deploymentCost, redeployTime);
	_attackPower = attackPower;
	_baseAttackCooldown = baseAttackCooldown;
	_maxBlockableEnemies = maxBlockableEnemies;
	_spRecoveryRate = spRecoveryRate;
}
```

생성자에 필드를 일일이 나열하는 게 번거롭긴 한데 그걸 빼면 **생각보다 간단하게 구현할 수 있다.** 괜찮은 방법 같음.

>[!question]
>- 지금처럼 `Nested`한 구조를 유지해야 하는가? 아니면 각 `Stats`을 개별 필드로 받아서 곧바로 쓸 수 있는 `Flat`한 구조를 받아줘야 하는가?

>[!answer] 
> - `Flat` 구조는 초기화가 쉽고, 직접 접근이 미세하게 빠르지만 구조적인 의미를 잃고 코드의 중복도 발생한다
> - `Nested` 구조는 계층 구조가 명확하고 재사용성이 좋은 반면, 중첩 생성자 및 약간의 메모리 오버헤드가 생김(사소함)
> - Claude는 `Nested + 편의 생성자`를 쓸 걸 추천

### private [SerializeField] struct에 관해
- 구조가 헷갈려서 정리함. `struct` 내부에서도 필드의 접근자를 정의할 수 있어서.

```cs
// SO의 설정
[SerializeField] protected OperatorStats stats;
    
// OperatorStats    
[System.Serializable]
public struct OperatorStats
{
    [SerializeField] private DeployableUnitStats _deployableUnitStats;
    [SerializeField] private float _attackPower;
    [SerializeField] private float _baseAttackCooldown; // 기본 공격 쿨다운
    [SerializeField] private int _maxBlockableEnemies;
    [SerializeField] private float _spRecoveryRate;
    
    // ...
}
```

1. `직렬화Serialize` : 메모리의 데이터를 파일에 저장 가능한 형태로 변환하고, 나중에 다시 불러올 수 있게 만드는 과정
	- 저장하고 불러올 수 있게 만드는 과정
2. **`struct`는 유니티에서 기본적으로 직렬화되지 않지만, 직렬화 자체는 가능하다.**
	- 이 부분은 구분을 잘 해야 한다 : "직렬화 가능 여부"와 "유니티의 기본 설정"
	- 유니티에서 아무 설정 없이 직렬화할 수 있는 타입들이 있음(예시는 안 듦)
	- `struct`, `class`는 직렬화할 수 있지만, **기본 설정은 "직렬화하지 않는다"** 임
		- 안전성, 성능, 호환성 등의 이슈 때문. 
		- 직렬화하고 싶다면 따로 명시하라는 의미.
	- `Dictionary`나 `Delegate`는 **직렬화 자체가 불가능.**
	- 주의) 여기서 얘기하는 직렬화와 "`struct`가 값 타입이다"는 완전히 별개의 얘기임
		- 즉 "값 타입이므로 직렬화되지 않는다, 참조 타입이니까 직렬화된다" 라는 말이 아니라는 뜻. 
3. **인스펙터에 노출되는 필드** : 아래 요소들을 다 갖춤
	- 직렬화 가능한 타입의 필드이면서
	- `public`이거나 `[SerializeField]` 가 붙은 `protected/private`이며
	- `const, static, 프로퍼티`가 아니며
	- `[HideInInspector], [NonSerialized]`가 없어야 한다.
4. **`[System.Serializable]`은 해당 타입을 직렬화 가능하게 할 뿐**이다. 내부 필드들은 원래의 규칙을 따른다. 
	- `[System.Serializable]`은 타입 자체를 "직렬화 가능하다"라고 등록하는 것임
	- 만약 `[System.Serializable]`이 없는 타입의 필드가 `[SerializeField]`이 붙으면, 직렬화되지 않고 인스펙터에도 나타나지 않는다.
