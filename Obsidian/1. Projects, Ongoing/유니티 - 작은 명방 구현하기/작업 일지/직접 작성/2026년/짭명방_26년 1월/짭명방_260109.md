
>[!wip]
>- `Operator` 기능 분리 시작(기존 코드가 1000줄 정도)
>	- `OperatorAttackController`부터 작업

### OperatorAttackController 작업
- 공격 대상 선정 및 공격에 대한 구현이 들어감
- 스킬은 별도로 구현

#### `MonoBehaviour`로 구현하기 vs 일반 C# 클래스로 구현하기
- `MonoBehaviour`로 구현하는 게 좋은 상황
	- `Unity` 이벤트 사이클이 필요할 떄
	- 코루틴을 직접 돌려야 할 때(스스로 관리하는 게 편할 때)
	- 물리적인 위치/컴포넌트가 중요한 상황일 때
		- 발사 위치 Transform이나 Collider가 필요한 상황 등
	- 에디터 디버깅 / 설정이 필요할 때
- 일반 C# 이 좋은 상황
	- 순수 데이터 처리 로직일 때
	- Update을 자체적으로 돌릴 필요 없이 부모에서 호출해주면 될 때
	- 여러 개를 리스트로 관리해야 할 때
	- 가벼워야 할 때

기존 `Operator.Update` 로직의 거의 대부분이 `AttackController`에 넣을 수 있는 요소라서 고민을 좀 했다. `UnitEntity`에서도 `Collider`나 `Visual`은 `MonoBehaviour`을 상속받게 하는 식으로 구현되었는데, 코루틴을 직접 돌리거나 유니티 컴포넌트를 직접 제어하는 상황이기 때문에 그렇게 구현된 것이다. 

`OperatorAttackController`는 그냥 C#으로 해도 될 듯?

여기에 정리는 못하고 있는데 이것저것 하고 있다. **뇌가 아픈!**
- **`MedicOperator`을 없애는 게 가능할 수도 있겠다.** `AttackController`가 아니라 `ActionController`라는 공통 인터페이스를 만들고, 이를 상속하는 별개의 클래스 2개를 만드는 방식임
	1. `MedicOperator`을 없앰
	2. `OperatorAttackController`을 `OperatorActionController`이라는 공통 조상의 자식으로 뒀음. `OperatorHealController`도 `ActionController`의 자식으로 별도로 구현.
	3. `DualBlade`도 `DualbladeOpereator` 스크립트를 없애고 `OperatorAttackController`의 자식으로 `DualbladeController`을 별도로 구현했다.


- SP도 연결해야 하고 저지도 구현해야 하고 할 게 많다.
- 오늘 한 거 테스트도 못해봤음;

컴파일상의 오류만 다 없애놨다. 일단 오늘은 여기까지. 밤 12시 반이 넘어가고 있다.



