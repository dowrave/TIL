
>[!done]
>1. `OpSkillController` 구현
>2. `OperatorSkill`의 구조 변경 
>	- `OpSkillController`에서 흐름을 볼 수 있게 함.
>	- `OperatorSkill`은 시작 / 중간 / 끝 으로 나누는 식으로 구현

### OpSkillController
- "스킬 실행 중"임을 나타내는 코루틴이 들어간다.

#### 컨트롤러 구조 생각
- 가능한 컨트롤러는 C# 클래스로 구현
	- 컨테이너의 `Awake` 시점에서 컨트롤러들의 클래스가 생성됨
- 유니티의 도움을 받아야 하는 컨트롤러(콜라이더, 코루틴 등)는 `MonoBehaviour`을 상속받음
	- 인스펙터에서 `SerializeField`로 할당되어야 함

> 저 2가지, 런타임 시점에서 생성되는 클래스와 미리 할당해야 하는 클래스 간의 일관성이 신경쓰였다.

##### 결론
- **지금처럼 하면 됨** : **기본 C# 클래스, `MonoBehaviour`가 필요한 경우만 상속받기.**
	- 이미 구현해버렸기도 하고, C# 클래스 만으로 모든 걸 할 수 없기도 하다.
	- 일관성의 측면에서 나중에 봤을 때 헷갈릴 수는 있겠지만... 주석을 잘 써둬야 할 듯.
>[!note]
>1. **코루틴만 필요하다면 컨트롤러를 MonoBehaviour로 설정할 필요는 없다.** 컨트롤러를 갖고 있는 컨테이너가 `MonoBehaviour`을 상속받은 요소이므로, 컨테이너 참조와 코루틴 참조만 컨트롤러에서 갖고 있으면 `Container.StartCoroutine(_coroutine)`으로 사용할 수 있음.
>2. 그런데 **세부적인 설정값들이 필요할 수 있다** 
>	- 참조하고 있는 필드들, 어떤 효과를 위한 기본적인 설정 등등.
>	- 필드를 그냥 컨테이너에 유지시키는 것도 방법이지만 이미 `VisualController`라는 걸 별도로 두기로 했으니까 관련 설정들도 저 안으로 옮겨주는 게 마땅해보임.
##### 안전 구조 작업
- `SerializeField`로 설정하는 코드는 인스펙터에서 설정하고 할당하는 요소이기 때문에, 휴먼 에러를 줄이기 위해 보호 코드를 설정해둠
```cs
[SerializeField] protected BodyColliderController _collider;
[SerializeField] protected VisualController _visual;

protected void Awake() 
{
	_collider ??= GetComponentInChildren<BodyColliderController>();
	if (_collider == null) Logger.LogError($"{gameObject.name}의 _collider가 설정되지 않음");
	_visual ??= GetComponentInChildren<VisualController>();
	if (_visual == null) Logger.LogError($"{gameObject.name}의 _visual이 설정되지 않음");
}
```

#### 다시 OpSkillController
- 거의 다 그대로 옮김
- 인게임 플레이도 큰 이슈는 없어보임
- `skillRange` 관련 로직이 남아 있음 - 이거 처리 필요할 듯


### Skill과 OpSkillController의 역할 관련
- 이렇게 구현하다 보니까 `Skill`의 구체적인 동작을 정리할 필요도 있어보임

```cs
// abstract class인 ActiveSkill의 메서드 호출
caster.StartSkillCoroutine(Co_HandleSkillDuration(caster));
caster.SetSkillOnState(true);
caster.SetCurrentSP(0f);
```

- **스킬의 일련의 동작이 `SkillController`에서 진행되고 보이는 구성이어야 할 것 같은데 지금은 `Skill` 부분에 스킬 동작의 흐름이 몰려 있는 형태**임
- 이 구조를 고쳐봄

#### ActiveSkill
- 이 3개의 메서드로 요약된다
```cs
// 스킬 시작 시에 적용되는 효과
public virtual void OnSkillActivated(Operator caster)
{
	// 예: 버프 적용, 공격력 증가, 특수 공격 등
}

// 매 프레임 호출되어서 지속 효과를 구현
public virtual void OnSkillTick(Operator caster, float elapsedTime, float progress)
{
	// 예 : 지속 힐, 지속 대미지 등
	// 내 경우는 장판을 따로 구현해서 상관은 없을 듯?
}

// 스킬 종료 시 정리 작업
public virtual void OnSkillEnd(Operator caster)
{
	// 예 : 버프 해제, 상태 복원 등
}
```

#### OpSkillController
```cs

// ...

#region skill Flow

public void ActivateSkill()
{
	if (!CanUseSkill()) return;

	if (CurrentSkill is ActiveSkill activeSkill)
	{
		ActivateActiveSkill(activeSkill);
	}
	else
	{
		ActivateGenericSkill();
	}
}

private void ActivateActiveSkill(ActiveSkill skill)
{
	PrepareSkillActivation();

	if (skill.Duration > 0f)
	{
		StartDurationSkill(skill);
	}
	else
	{
		ExecuteInstantSkill(skill);
	}
}

private void ExecuteInstantSkill(ActiveSkill skill)
{
	skill.OnSkillActivated(_owner);
	skill.OnUpdate(_owner);
	skill.OnSkillEnd(_owner);

}

private void PrepareSkillActivation()
{
	_isSkillOn = true;

	// 스킬 준비 후 공격 모션 초기화
   OpActionTimeReset?.Invoke(_owner);
}

private void StartDurationSkill(ActiveSkill skill)
{
	// 스킬 켜졌을 때의 VFX 활성화
	PlayDurationVFX(skill);
	
	// 참고) Shield의 경우 추가 VFX가 있는데 이걸 어떻게 처리할지 생각 필요

	// 코루틴 시작
	if (_activeSkillCoroutine != null)
	{
		_owner.StopCoroutine(_activeSkillCoroutine);
	}

	_activeSkillCoroutine = _owner.StartCoroutine(Co_HandleDurationSkill(skill));
}

private IEnumerator Co_HandleDurationSkill(ActiveSkill skill)
{
	skill.OnSkillActivated(_owner);

	float elapsed = 0f;
	float duration = skill.Duration; 

	while (elapsed < duration)
	{
		// 소유자 파괴 시 중단
		if (_owner == null)
		{
			CleanupSkill();
			yield break;
		}

		elapsed += Time.deltaTime;
		float progress = elapsed / duration;

		// UI용 - SP 시각적 감소
		CurrentSP = MaxSP * (1f - progress);

		// 스킬 틱 호출
		skill.OnSkillTick(_owner, elapsed, progress);

		yield return null;
	}

	// 정상 종료
	CompleteActiveSkill(skill);
}

private void CompleteActiveSkill(ActiveSkill skill)
{
	skill.OnSkillEnd(_owner);
	CleanupSkill();
	OpActionTimeReset?.Invoke(_owner);
}

public void CleanupSkill()
{
	CurrentSP = 0f;
	IsSkillOn = false;
	_activeSkillCoroutine = null;
	CleanupVFX();
}

// ActiveSkill이 아닌 경우의 실행
private void ActivateGenericSkill()
{
	PrepareSkillActivation();
	CurrentSkill.OnUpdate(_owner);

	CurrentSP = 0f;
	// IsSkillOn = false;
}

public void OnUpdate()
{
	HandleSPRecovery();
	CurrentSkill.OnUpdate(_owner);

	if (_owner.HasRestriction(ActionRestriction.CannotAction)) return;

	// 자동 발동 스킬은 조건 체크 후 실행
	HandleSkillAutoActivate();
}

#endregion

// ...
```

이런 식으로 흐름을 컨트롤러에 집약하는 방식으로 정리해놨다.
이외에도 스킬이 켜고 꺼질 때 `_owner`의 `_action` 관련 메서드를 여기서 호출하는 대신 이벤트 기반으로 변경했다.

> 근데 **테스트는 못해봤다** ㅋ; 오늘은 여기까지;


