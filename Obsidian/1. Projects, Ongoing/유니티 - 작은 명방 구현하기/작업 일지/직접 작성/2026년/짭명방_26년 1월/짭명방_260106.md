
> [!done]
> - `DeploymentController` 구현
> 	- 기능 테스트중 에러 확인, 오늘 못 고쳐서 "현재 이슈" 탭으로 빼둠
### DeploymentController 구현
- `DeployableUnitEntity`부터 들어가는 배치 로직 관련 기능을 분리함

#### 1. 초기화 방법 : Initialize vs 클래스 생성자
- 오브젝트 풀링을 쓴다면 유닛이 계속 재활용되는 방식이다.
- 이런 경우 서브 클래스들은 아래처럼 구현하는 게 좋음
	1. `Awake()`에서 생성
	2. `Initialize()`에서 상태만 초기화해서 재활용(클래스를 새로 만들지 않음)

> 이유) 클래스가 계속 생성되면 이전의 클래스는 가비지가 되기 때문이다. 가비지 콜렉션의 발생을 최소화하는 게 중요함.

#### 2. readonly
- C#에서 `readonly`가 붙은 필드는 단 두 곳에서만 값을 할당할 수 있다.
	1. 변수 선언 시점
	2. 생성자 내부
- 그래서 `_owner`는 `readonly`가 가능하지만 `_data`는 `readonly`가 불가능하다. `Awake`에서 실행되는 생성자와 달리, `Initialize()`라는 별도의 메서드에서 할당되어야 하므로 `readonly`에 할당하는 타이밍보다 늦다고 봐야함

#### 3. Deploy()
```cs
public virtual void Deploy(Vector3 position)
{
	if (!IsDeployed)
	{
		_deployment.Deploy(position);
		SetDeployState(true);
		SetColliderState(true); 


		UpdateCurrentTile();
		if (CurrentTile != null)
		{
			CurrentTile.SetOccupied(this);
		}
		SetPosition(position);

		lastDeployTime = Time.time;

		OnDeployed?.Invoke(this);
	}
}
```
> `_deployment.Deploy()`로 옮기기 전의 생각
> - 일단 메서드 자체는 `DeployableUnitEntity`에 남기는 게 맞음 : 콜라이더의 동작도 포함되어 있기 때문이다.
> - 질문
> 1. `CurrentTile`을 직접 호출하는 게 맞는가? 이벤트만 발생시키고 타일이 구독하는 방식은?
> 2. `SetPosition`이 `_deployment` 내부로 들어가는 게 맞나? 위치를 변경하는 로직의 위치는 어디여야 하는가?
> 3. `lastDeployTime`도 애매해보이긴 하는데 그래도 위에 남는 게 맞겠지?

제미나이에게 물어보니
1. 이벤트보다는 직접 호출을 추천
	- **게임의 핵심 상태를 변경하는 로직은 이벤트보다 직접 호출이 안전**하다.
	1.  순서가 보장됨 
		- `Deploy()` 이후에 즉시 타일은 점유된 상태가 되어야 한다. 
		- 이벤트는 구독자에 따라 실행 순서가 모호해지거나 디버깅 시 추적이 어려울 수 있음
	2. 트랜잭션
		- 배치됨 + 타일 점유는 하나의 세트이다. 
		- 배치가 됐지만 타일 점유 코드가 리스너 누락으로 실행되지 않는다면 로직이 꼬인다.
	- 이벤트 사용 예시
		- UI 갱신
		- 이펙트 재생
		- 업적 달성
		- 사운드 재생 
2. `SetPosition`은 좌표 옮기기 + 타일 근처 특정 위치로 스냅하는 기능이 포함됨
	- "어디로 가야 하는가?"는 `Controller`가 작업
	- "실제로 이동한다"는 `Entity`가 작업
	- **`Controller` 내부에서 `_owner.transform.position`을 변경시켜도 무방하다.** `Entity`를 호출해서 위치를 바꾸는 건 함수만 복잡해진다.
3. `lastDeployTime`
	- 컨트롤러가 직접 관리하는 게 맞다. 배치라는 행위의 상태를 제어하기 위한 변수이므로.

> [!note]
> - 1번의 경우 결합도가 높아지지 않는가? 라는 의문이 드는데, 판단 기준을 알아보자.
> 
> **1. 이 객체가 없으면 내 존재 의의가 사라지는가?**
> - `DeploymentController`의 목적은 유닛을 맵 어딘가에 배치하는 것이다.
> - `Tile` 없이 배치가 성립하지 않는다. 게임 규칙 상 유닛은 타일 위에 올라가며, 타일은 "점유됨" 상태가 되어야 한다.
> - 따라서 **`DeploymentController`는 `Tile` 시스템을 반드시 알고 있어야 한다. 이는 필수적인 결합이다.**
> - 불필요한 결합 예시 : `SoundManager`나 `UIManager`를 직접 호출하는 경우 
> 	- 사운드가 나오지 않거나, 이펙트가 나오지 않더라도 유닛 배치는 성공해야 한다. 이런 경우는 이벤트로 풀어낸다.
> 
> **2. 동작 순서와 원자성이 중요한가?**
> - 예시) 유닛을 타일에 올렸는데, `true`로 바뀌지 않은 순간 다른 유닛이 똑같이 배치된다면? 문제가 발생한다.
> - 리스너가 없거나 등록 시점이 늦거나 실행 순서가 꼬이면 타일 점유 코드가 안 돌 수도 있다. 
> - 게임의 규칙을 집행하는 코드는 순차적이고 명시적인 호출로 트랜잭션을 보장해야 한다. "배치 함수 실행 -> 좌표 이동 -> 타일 잠금"은 한 덩어리로 묶여야 안전하다.
> 
> 
> **3. 양방향 결합인가? 단방향 결합인가?**
> - 가장 위험한 건 `상호 참조`지만, 현실적으로 이걸 쓸 수밖에 없는 상황이 있다.
> - 이런 구조를 제대로 관리하려면 **데이터를 변경하는 책임을 한 쪽만 갖고 있어야 한다.**
> - 즉 `DeploymentController`가 `_owner`을 저장하도록 `Tile`에 전달하고, `Tile`은 그 상태만을 갖는다는 것이다. 
> - 한편, `DeploymentController` 자체에서도 `CurrentTile`을 유지할 수 밖에 없다. 그래서 `Tile <=> Controller` 간의 상호 참조가 되는 상황이다.

#### 4. 컨테이너 - 컨트롤러 구조에서
- 위의 `Deploy()` 같은 경우 2개의 컨트롤러 `_collider, _deployment`를 함께 쓰는 구조였다. 
- 그러면 컨테이너의 `Deploy()`에서 2개의 컨트롤러를 호출하는 방식이 나을까? 아니면 `_collider.Deploy()`에서 구현하고 `_deployment`의 기능을 컨테이너를 통해 호출하는 식으로 구현하는 게 나을까?

- **컨테이너가 조율하는 방식이 좋다.**
- `Deploy()`라는 로직이 배치 + 콜라이더 상태의 변화를 모두 동반하는 "고수준의 행위High-Level Action"이라면 각 부품을 총괄하는 컨테이너에서 한꺼번에 볼 수 있게 하는 게 좋음.
	- **하위 컨트롤러 간의 의존성이 생기지 않고,** 
	- **각 컨트롤러는 자신의 로직에만 집중**할 수 있게 된다.

- 일단 여기까지;