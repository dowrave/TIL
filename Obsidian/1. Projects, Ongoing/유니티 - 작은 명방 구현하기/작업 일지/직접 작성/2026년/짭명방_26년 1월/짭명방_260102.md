
>[!done]
>- God Class 개편 계속
>	1. 스탯은 `StatController`로 통합.
>		- 상태 스탯 vs "능력치" 스탯의 관리법이 다르다
>	2. `BuffController`까지 구현해서 `Stat, Buff, Health` 컨트롤러 간의 상호작용을 구현하는 게 목표

### StatController 구현
- 일단 지금의 스탯 구조는 아래와 같음
```cs
// UnitStats
[SerializeField] private float _health;
[SerializeField] private float _defense;
[SerializeField] private float _magicResistance;

// DeployableUnitStats
[SerializeField] private UnitStats _baseStats;
[SerializeField] private int _deploymentCost;
[SerializeField] private float _redeployTime;

// OperatorStats
[SerializeField] private DeployableUnitStats _deployableUnitStats;
[SerializeField] private float _attackPower;
[SerializeField] private float _attackSpeed;
[SerializeField] private int _maxBlockableEnemies;
[SerializeField] private float _spRecoveryRate;

// EnemyStats
[SerializeField] private UnitStats _baseStats;
[SerializeField] private float _movementSpeed;
[SerializeField] private float _attackPower;
[SerializeField] private float _attackSpeed;
[SerializeField] private float _attackRange;
```

`StatController`을 구현한다면 이들을 어떻게 반영할 수 있을까?

---
제미나이와의 질답

- `nullable` 필드들을 넣는 걸 생각했는데, 아래의 단점들이 있다고 함
1. `Null` 체크 지옥 : 값을 쓸 때마다 `.HasValue`나 `?? 0` 처리가 필요함
2. 확장성 부족 : 새로운 유닛 타입이 생겨서 새로운 스탯이 필요해지면 `StatController`을 계속 수정해야 함
3. 버프 시스템과의 연동 : `공격력 증가 버프`를 적용하겠다고 한다면 `StatController` 내에 `AttackPower`가 있는지 없는지 타입 체크를 하거나 리플렉션을 써야 하는 복잡함이 생김

### 스탯 구조에 대해 : State와 On-Demand
- 지금까지도 몰랐던(!) 부분이라 정리해둔다.

- **상태로 관리해야 하는 필드와, 필요할 때마다 계산되는 필드를 구분한다.**
- **`CurrentHealth`는 상태로 관리하지만 `MaxHealth`는 필요할 때마다 계산해서 보여주는 방식**을 취한다. 심지어 `MaxHealth`가 변할 수 있는 값이라고 하더라도.

- **`상태 / 자원`**
	- **소모된다.** 전투 중에 계속 값이 변할 수 있다.
	- **누적된다.**
	- 지금 얼마 남았는지를 기억하기 위한 저장 공간이 필요하다.
- `능력치 / 계수`
	- 소모되지 않는다. 100번 맞아도 방어력은 그대로이다.
	- 계산식의 상수다. 대미지 공식`Damage - Defense`에서 `Defense`는 계속 똑같이 적용되는 규칙이다.
	- 버프를 받아 변할 수 있으나, 이는 규칙이 바뀐 것이며 자원이 쓰인 건 아니다.
	- 따라서 계산식으로 존재하는 게 자연스럽다. 

- 그래서 `StatController`의 맨 위 주석을 달아뒀다.
```cs
// 능력치(즉 소모되지 않는 값이나 규칙)를 다루는 컨트롤러
// - currentHP는 "상태"라서 여기서 관리하지 않지만, MaxHP는 "능력치"라서 여기서 관리한다.
// - 상태와 능력치의 차이 : 상태는 소모되고 누적된다. 능력치는 소모되지 않는다.
public class StatController
```

### 초기화 관련
- 스탯들이 `UnitData`를 상속받는 구조가 아니라 전부 개별이다. 
- 그래서 `Initialize()`를 별도로 둔다. 각 클래스는 자신이 가진 데이터 타입을 아니까(`OperatorData, DeployableUnitData, EnemyData` 등등) 각 클래스에 해당하는 `StatController`의 `Initialize`를 별도로 구현한다
	- 번거롭지만 데이터 구조를 뜯어서 수정하는 것보단 (지금 시점에서는) 싸게 먹힌다. 
	- SO를 수정하면 필드값들도 전부 다시 집어넣어야 하니까...


---
- 일단 `StatSystem`을 구현하고 별도의 `IReadable` 인터페이스도 구현했음
- 그런데 `StatSystem`은 `Buff`로 인한 `Modifier`의 증감을 받기 때문에 `BuffSystem`도 곧바로 구현해야 할 듯.

### BuffController 구현
- 그대로 옮기면 된다..라고 생각했는데 또 어떤 건 로직을 적용하는 방식이 달라지고 해서 복잡해졌다. 흠.
- 예를 들면 `float`로 관리하는 값은 `statController`에서 `Modifier`만 합 연산으로 갖고 있다가 `modifier`가 필요해지면 1을 더하고 곱해서 반환하면 됨
- `StatModifierBuff`에도 여러 가지 상황이 있음 
	- `MaxBlockableEnemies`처럼 값을 곱하는 게 아니라 뒤집어쓴다거나
	- `List<Vector2Int>`로 관리되는 타입이라든가
	- `AttackType`처럼 버프가 걸렸을 때 공격 타입이 변하는 등등

- **모든 데이터를 `StatController`에 억지로 넣을 필요는 없다.**

1. `int`로 관리되는 값들
- 실제로 저지수가 변하는 버프가 있진 않지만 처리해본다.
- 자신이 차지하는 저지 수, 최대로 저지 가능한 적의 수 등인데, 기존에 `Buff`에 값을 넣을 때 "해당 값으로 변한다"는 개념으로 설정했음
- 기존의 `StatSystem`은 `baseStats * modifier` 개념으로 적용되는데, 이런 경우는 어떻게 처리해야 할까?

- **`Override Dict`을 별도로 관리하는 방법이 있다.** 
	1. 버프가 적용될 때 <StatType, float> 값으로 들어감
	2. 값이 필요할 때, 게터는 `Override Dict`을 먼저 체크하고 `StatType` 키값이 있으면 이를 우선으로 해서 반환함. `Override Dict`에 값이 없으면 자신의 스탯을 반환함.
	3. 버프가 끝날 때 Override Dict에서 StatType도 삭제함

### `Restriction`의 중첩 문제 관련
```cs
public void AddRestriction(ActionRestriction restirction)
{
	Restrictions |= restirction; // 비트 OR 연산으로 플래그 추가
}
public void RemoveRestriction(ActionRestriction restirction)
{
	Restrictions &= ~restirction; // AND, NOT 연산으로 플래그 제거
}
```

> - `Buff`에 의해 위처럼 제약이 걸린다고 가정함
> - 2개의 `StunBuff`가 들어와서 적용된다고 하면, 2번째 `StunBuff`가 들어온 후의 스턴 시간만큼 유지되는 게 일반적일 거임
> - 하지만 위처럼만 관리된다면, 1번째 `StunBuff`가 풀리는 시점에 스턴이 풀리게 된다. 비트 연산이기 때문임.

- 이걸 방지하려면 **버프 추가 / 제거할 때마다 현재 활성화된 모든 버프를 돌아서 제약을 재계산**하는 방식이 가장 안전하다.

지금 이걸 쓰는 로직이 딱 하나 있음 : `StunBuff`.
```cs
public override void OnApply(UnitEntity owner, UnitEntity caster)
{
	base.OnApply(owner, caster);
	owner.AddRestriction(ActionRestriction.Stunned);
}

public override void OnRemove()
{
	owner.RemoveRestriction(ActionRestriction.Stunned);
	base.OnRemove();
}
```
적용될 때마다 명령하는 방식인데, 직관적이지만 여러 효과 처리를 계산할 때 복잡한 카운팅 로직이 발생한다.

#### 재계산 패턴
- 버프는 자신이 가진 제한에 대한 정보만 든다
- `BuffController`는 버프들을 순회하면서 자신에게 활성화된 버프를 보고 상태를 갱신한다.

```cs
public abstract class Buff
{
    // ... 기존 필드들 ...

    // 기본적으로는 아무 제약도 없음. 오버라이드해서 사용.
    public virtual ActionRestriction Restriction => ActionRestriction.None;
}
```

```cs
public class StunBuff : Buff
{
    public override bool IsDebuff => true;
    
	// 제약 선언
    public override ActionRestriction Restriction => ActionRestriction.Stunned;

    public StunBuff(float duration)
    {
        buffName = "stun";
        this.duration = duration;
    }

    // OnApply, OnRemove는 비워두거나 VFX용으로만 사용
}
```

```cs
// 모든 버프를 순회하며 제약을 합침(OR 연산)
private void RecalculateRestrictions()
{
	Restrictions = ActionRestriction.None; // 초기화

	foreach (var buff in _activeBuffs)
	{
		Restrictions |= buff.Restriction;
	}

	// 유닛의 영구적인 제약이 있다면 추가로 OR 연산
	// Restrictions |= _owner.PermanentRestrictions;
}
```

- 이제 `AddRestriction, RemoveRestriction` 등은 다 필요 없어짐
- `HasRestriction`은 혹시 조회할 수도 있으니 남겨둠

- 일단 구현은 다 했는데 테스트는 못해봄. 
- **컴파일했을 때 눈에 띄는 오류들만 다 잡고 오늘은 여기까지 진행함.** 피곤하다..

> 리팩토링이 겁나 빡센데 구조적으로 지식이 는다는 느낌이라 재밌긴 하다
> 너무 오래 걸리긴 하는데 기존에 찝찝했던 것들을 해소한다는 느낌으로 접근 중

