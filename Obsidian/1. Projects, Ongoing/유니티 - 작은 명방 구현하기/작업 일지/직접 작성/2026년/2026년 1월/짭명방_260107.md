
>[!done]
>1. 이슈 수정 
>	- (어제 것) 하단 `box` 클릭 시 `DeployableUnitEntity.IsDeployed` 초기화 문제
>	- `Deploy()` 동작하지 않는 문제
>2. 구조 수정
>	- `Onclick()`에서 배치된 유닛을 클릭했을 때의 동작 처리를 이벤트 기반으로 변경


### 이슈 수정

- 어제 이슈 ) 하단 Box 클릭 시 `DeployableUnitEntity.IsDeployed` 초기화 문제
	- 이걸 호출하는 메서드에서 `DeployableUnitEntity`를 호출하는 것 자체가 문제였다. 해당 파라미터는 `nullable`이기 때문에 그 부분만 제거해줌
	- 해당 메서드의 `deployable` 파라미터도 `deployedDeployable`로 수정해서 더 알아보 쉽게 처리

- `Deploy()`가 동작하지 않음
	- `_collider`가 `null`로 처리되어 있는데, 필드 옮기는 과정에서 초기화되어버린 듯;
	- 다시 인스펙터에서 일일이 할당해준다

- `Retreat()` 시에 초기 배치 코스트의 절반이 회수되지 않음
	- 경로를 따라가봤는데 OnRetreat?.Invoke()가 동작이 되는데 정작 저 이벤트를 구독하는 메서드가 동작하지 않음?
	- **이건 내일 해야겠다.**

### 구조 수정
- `DeploymentController.OnClick()` 관련
```cs
public void OnClick()
{
	float preventInteractingTime = 0.1f;

	// 커서를 뗀 시점에 다시 클릭되는 현상 방지
	if (Time.time - _lastDeployTime < preventInteractingTime)
	{
		DeployableManager.Instance!.CancelPlacement();
		return;
	}

	// 배치된 유닛 클릭
	if (IsDeployed &&
		!IsPreviewMode &&
		StageManager.Instance!.CurrentGameState == GameState.Battle
		)
	{
		DeployableManager.Instance!.CancelPlacement();

		if (IsPreviewMode == false)
		{
			DeploymentInputHandler.Instance!.SetIsSelectingDeployedUnit(true);
			StageManager.Instance!.SlowState = true;
			StageUIManager.Instance!.ShowDeployedInfo(_owner);
			ShowActionUI();
		}
	}
}
```
> 여기서 "배치된 유닛 클릭" 부분은 전부 이벤트로 처리하는 게 좋아보인다. 앞으로 기능이 계속 추가되어야 하기 때문

#### 수정 방향
1. 컨테이너 클래스
```cs
public static event Action<DeployableUnitEntity> OnDeployableSelected = delegate { };

// 클릭됐을 때 실행시킬 메서드 - 브릿지 역할
public virtual void OnClick()
{
	_deployment.OnClick();
}

// DeploymentController.OnClick에 의해 실행되는 메서드
public void NotifySelected()
{
	OnDeployableSelected?.Invoke(this);
}
```

2. 배치 컨트롤러
```cs
public void OnClick()
{
	float preventInteractingTime = 0.1f;

	// 커서를 뗀 시점에 다시 클릭되는 현상 방지
	if (Time.time - _lastDeployTime < preventInteractingTime)
	{
		DeployableManager.Instance!.CancelPlacement();
		return;
	}

	// 배치된 유닛 클릭
	if (IsDeployed &&
		!IsPreviewMode &&
		StageManager.Instance!.CurrentGameState == GameState.Battle)
	{
		DeployableManager.Instance!.CancelPlacement();

		if (IsPreviewMode == false)
		{
			_owner.NotifySelected();
			// DeploymentInputHandler.Instance!.SetIsSelectingDeployedUnit(true);
			// StageManager.Instance!.SlowState = true;
			// StageUIManager.Instance!.ShowDeployedInfo(_owner);
			// DeployableManager.Instance!.ShowActionUI(_owner);
			// StageUIManager.Instance!.ShowDeployedInfo(_owner);
		}
	}
}
```
> 재클릭 방지 로직도 이벤트를 구분하는 식으로 포함할 수 있을 것 같긴 한데 일단 보류

3. 위에서 주석처리한 클래스들에 다 이벤트 구독해주면 됨
	- 지금 보니까 심지어 메서드 하나는 중복이었네 ㅋㅋㅋㅋ


