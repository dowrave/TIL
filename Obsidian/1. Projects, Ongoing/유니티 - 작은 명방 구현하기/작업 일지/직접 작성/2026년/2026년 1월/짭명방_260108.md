
>[!done]
>- `Retreat`의 배치 코스트 회복 로직 동작하지 않는 현상 수정
>	- 이벤트 스태틱 기반으로 변경
>- `Operator.Deploy(), Undeploy()` 수정
>- 배운 것
>	- 세터 메서드는 컨트롤러를 외부에 노출하지 않는 게 목적이지 컨테이너의 메서드는 외부에 노출되어도 무방(꽁꽁 감싸는 거라면 다른 방법도 있지만 굳이 그렇게까지?)
>	- 여러 컨트롤러에서 사용할 메서드라면 컨테이너에서 상태를 갖고 있는 것도 방법
### Operator.Deploy() 
- 이후에 `CombatController`로 구현할 부분들은 빼고 거의 구현한 듯
### Retreat 이슈
- `Retreat` 시에 초기 배치 코스트의 절반이 회수되지 않는 현상
	- `_deploy`에 의해 동작하는 `HandleDeploymentInternal()`을 추적해봤는데 아예 동작하지 않음
	- 그러면 `Operator.Deploy()`가 문제인가? `Undeploy()`할 때 서순이 문제인가?

```cs
public void Undeploy()
{
	IsDeployed = false;
	OnUndeployed?.Invoke(_owner);

	// 이거 안에서 _owner 퇴각 시에 동작하는 이벤트가 있음
	DeployableManager.Instance!.OnDeployableRemoved(_owner);
	if (CurrentTile != null)
	{
		CurrentTile.ClearOccupied();
	}
}
```

```cs
// OnDeployableRemoved 중 일부

if (deployable is Operator op)
{
	CurrentOperatorDeploymentCount--;
	InstanceValidator.ValidateInstance(op.OperatorData);
	// op.OnRetreat -= HandleOperatorRetreat;
	Logger.Log($"{op.gameObject.name}의 OnTreat 이벤트에 HandleOperatorRetreat 메서드 해제됨");

	info = GetDeployableInfoByName(op.OperatorData?.EntityID!);
}
```
> - `Operator`의 경우 `OnDeployableRemoved`에서 해당 객체에 대한 구독 해제 ->  이벤트 발생 의 순서를 가지기 때문에 메서드가 동작하지 않았던 것으로 보임

- `DeployableUnitEntity`의 `Deploy`나 `Undeploy` 구현은 잘 된 것 같은데(?), `Operator`에서의 처리 과정이 문제이기 때문에 이 부분을 만져봄
- `DeployableManager`에서 **`DeployableUnitEntity` 관련 이벤트들은 전부 스태틱**으로 다룸
	- 게임 씬 내내 동작할 요소이기 때문. 객체 하나하나의 추적 - 해제를 반복하는 것보다 클래스의 이벤트 자체를 계속 구독하는 방식이 더 관리하기 편하다.
	- 씬 전환 때에 유지되지 않게 하는 것만 신경쓰면 됨. `OnDisable`에 해제 메서드 달아둠.

- 이 부분은 2개로 해결
1. `OnRetreat`을 스태틱으로 구현, `DeployableUnitEntity` 전체에 대해 `DeployableManager`가 추적함
2. 싱글턴 간의 메서드 호출은 굳이 이벤트로 하지 않고 직접 호출함

> - 저 메서드 호출 부분은 "퇴각을 하면 코스트가 회복된다"라는 게임 로직과 직접적으로 연관된 부분이기 때문에 결합도를 신경쓰지 않고 바로 연결하는 편이 나은 듯. 훨씬 직관적이기하고.

#### 구조 생각

>[!question]
>- 지금처럼 컨테이너 + 컨트롤러 방식의 구현을 할 때 이벤트 발생을 어떻게 처리해야 할까?
>- 예를 들어서 지금의 `OnDeploy`, `OnUndeploy` 등의 이벤트는 외부 매니저에서 알아야 하는 요소임
>- 그러면 외부에서 이벤트를 구독할 때에는 "어떤 객체의 컨트롤러의 이벤트"까지 알아야 하는 걸까? 아니면 중간에 "어떤 객체의 이벤트" 정도로만 통합해서 써야 할까?
>1. 컨트롤러의 이벤트를 컨테이너에서 다시 구현하는 건 늘어질 우려가 있다고 생각함.
>2. 그렇다고 컨트롤러의 이벤트로만 남겨둔다? 

- 일반적으로 권장되는 구조는 `컨트롤러 -> (이벤트) -> 컨테이너 -> (이벤트) -> 외부`의 구조임. 
- 컨트롤러의 이벤트를 감추고 싶다면 단순히 컨트롤러의 읽기 전용 인터페이스에 이벤트를 노출시키지 않는 것만으로 충분함
##### 지식이 늘었다 - public class는 캐스팅으로 세터 클래스로도 접근할 수 있음
- 물론 취약점은 있다. `public class`로 구현하는 이상, `IReadableOOO`로 구현했더라도 캐스팅을 하면 접근이 가능하기 때문임
	- `GetComponent`로도 접근 가능함
```cs
IReadableController Deployment = target.Deploy;
Controller _deployment = Deployment as Controller;
```
> 이런 방식으로 `Controller`라는, 외부에 숨기려고 했던 클래스에 접근하는 것 자체는 가능하다.

정말 외부에서 알지 못하게 하려면 `public class` 대신 `internal class`로 구현해야 함
- 어셈블리가 달라지기 때문에 캐스팅이나 `GetComponent`이 불가능해져서 물리적으로 접근이 차단된다.
	- 이건 대형 프로젝트에서 많이 쓴다고 함

**위 예시는 말 그대로 "지식이 늘었다" 수준이라서 내 프로젝트에 적용될 얘기는 아니다.   
일반적인 경우 개발자 간의 약속이 되어 있다면 충분하다.(컨벤션)** 


>[!note]
>- 구조 자체는 `컨트롤러 -> 이벤트 -> 컨테이너 -> 이벤트 -> 외부` 같은 식으로 만듦
>- 하지만 `컨트롤러 - 컨테이너`의 경우, 이벤트로 구현할 필요가 없다고 생각되면 **정상 동작만 확인하도록 `bool`을 반환하는 메서드를 만들어도 될 듯**
>	- 이벤트로 컨트롤러 - 컨테이너 간의 상호작용을 처리하는 방식이 결합성 면에선 좋을 것 같은데, 너무 복잡해지고 여러 컨트롤러가 동작하는 상황이라면 더 머리가 아파서..
>	- **반드시 피해야 할 상황이 하나 있다면, 컨트롤러에서 컨테이너의 메서드를 아는 것**이다. 위 -> 아래는 상관이 없는데 아래 -> 위는 결합도가 높아지므로 별로임
>- **관련 메서드가 모두 정상적으로 작동했는가의 체크는 `컨테이너`에서 담당**을 해줘야 할 것 같다. 이걸 원칙으로 생각하고 작업해봄. 



