
> [!done]
> - 이슈 수정 / 구조 변경
> 	1. `Enemy.Initialize(EnemyData, PathData)` 래퍼 메서드 구현
> 	2. `Operator`의 `Deploy` 이후 스탯이 변하는 문제 수정
> 	3. `Opereator`의 `CurrentHP` 초기화 시점 : `Deploy` -> `Initialize`로 이동
> 	4. `Operator`의 퇴각 시 배치 코스트 회복 로직 : 이벤트 기반으로 변경
> 	5. 사망 로직 : 기존의 `Die`에서 `HandleOnDeath -> Despawn()`으로 연결하는 구조로 변경
> 		- `Die`라는 메서드는 아예 제거되었고 `DieWithAnimation`, `DieInstantly`로 애니메이션 실행 여부만 결정한다.
> - **`UnitEntity`의 리팩토링이 거의 끝남**
> 	- 남은 메서드는 스킬 범위, 공격 대상 정도인데 이건 추후에 다른 컨트롤러들 구현하면서 어떻게 처리할지 결정하겠음
> 	- `UnitEntity`가 300줄 정도로 축소된 상태. 테스트는 더 해봐야겠지만 기존 로직이 크게 다르지 않은 것까지는 확인했음

### Buff, Stat 컨트롤러 동작 테스트
- 플레이 테스트를 해보면서 작동하지 않는 부분들 수리하는 중

### Initialize에 적용할 Wrapper 메서드
- `Enemy.Initialize()`에 `pathData`를 어떻게 전달하지?
	- 기존엔 `Initialize(EnemyData, PathData)` 자체로 전달했는데 지금은 별도의 파라미터를 받지는 않는 상태 `Initialize()`임
	- `Enemy`에 별도의 `PathData`를 초기화하는 패턴도 생각해봤는데 이건 보는 쪽에서  "`PathData`를 초기화해야 한다"라는 규칙을 알아야 하기 때문에 바람직한 방식은 아닌 듯.

- 해결) `Initialize(PathData)`를 `Enemy`에서 다시 만들면 됨 - `Wrapper`
	- `PathData`는 필수적인 개념이기 때문임
	- `Wrapper`에선 단순히 `_enemyData, _pathData`만 할당해주면 된다.

> [!note]
> 1. 주석으로 어떤 메서드인지 표시를 잘 해두자. 설명이 없으니까 '?? 왜 있지' 하고 그냥 지워버렸음..
> 2. `Stat`을 별도의 시스템으로 빼면서, **프로퍼티도 어떤 필드를 참고로 하는지 잘 체크할 필요가 있다.** 별도의 오류가 나타나지 않기 때문에 무심코 지나치기 쉬워보임.

#### 이 과정에서 Enemy의 경우
```cs
// Enemy를 위한 Initialize Wrapper
public virtual void Initialize(EnemyData enemyData, PathData pathData)
{
	if (_enemyData == null)
	{
		_enemyData = enemyData;
	}

	if (pathData == null) Logger.LogError("pathData가 전달되지 않음");

	_pathData = pathData; 

	// UnitEntity.Initialize
	base.Initialize();
}

// base.Initialize에서 실행되는 템플릿 메서드 1
protected override void InitializeUnitData()
{
	// 데이터는 Initialize에서 설정하기 때문에 여기선 스탯 초기화만 진행
	_stat.Initialize(_enemyData);
}
```

이런 느낌이 되었다. 원래는 `InitializeUnitData()`에서 SO를 필드에 할당하고 이를 이용한 초기화까지 진행하려고 했는데, 의도한 것과 다르게 됐음

근데 `Initialize()`의 래퍼를 쓸 수밖에 없는 상황이기 때문에, `InitializeUnitData()`의 이름을 `ApplyUnitData()`로 바꾸고 진행해봄. 이건 앞으로도 계속 바뀔 수 있다.
### Operator Deploy 이후 스탯이 변함
- 일단 프로퍼티를 위한 코드부터 줄인다.
```cs
// 변경 전
public override float Defense
{
	get => currentOperatorStats.Defense;
	set
	{
		if (currentOperatorStats.Defense != value)
		{
			currentOperatorStats.Defense = value;
			OnStatsChanged?.Invoke();
		}
	}
}

// 변경 후
public override float Defense { get => Stat.GetStat(StatType.Defense); }

// 복습) 게터는 Modifier가 적용된 스탯을 반환함
// 세터는 AddStatModifier, RemoveStatModifier 등의 StatController 코드로 구현
// 저 안에 스탯 변화로 인한 이벤트 발생 등도 다 들어가 있음
```

> [!note]
> - `StatController`에서 모든 필드를 관리할 수 없는데, 그것들은 일단 보류함
> - 예를 들면 `List<Vector2Int>`으로 관리되는 공격 범위, `enum`으로 관리되는 공격 타입 등등이 있다. 이것들은 나중에 생각해보자. `CombatController`을 구현할 때 다룰 일이 있을 것이다. 

- 이외에도 `DeploymentCost`의 경우 `Stat`으로 관리되고 있긴 한데, 유닛 자체에서 관리되기보다는 `DeploymentState`라는 외부 상태로 관리되는 게 더 좋아보인다. 
	1. 그 객체가 활용할 스탯은 아니라는 점
	2. 객체 외부에서 해당 객체의 퇴각 / 재배치에 따른 코스트 비용 증가를 위해 사용되는 필드

### Operator.Stat의 초기화가 이상한 문제
- UI에서 봤을 때 Box 상태에서는 스탯이 높다가 배치된 후에 스탯이 낮아지는 현상이 있음
- **`Operator`의 스탯 초기화는 `OperatorData`가 아니라  `OwnedOperator`를 이용해야 함**
- `StatController(OperatorData)` 부터 `OwnedOperator`을 받도록 바꾼다. 

```cs
public void Initialize(OwnedOperator ownedOp)
{
	_baseStats.Clear();

	var stats = ownedOp.CurrentStats;

	// 스탯들 초기화
	_baseStats[StatType.MaxHP] = stats.Health;
	_baseStats[StatType.Defense] = stats.Defense;
	_baseStats[StatType.MagicResistance] = stats.MagicResistance;
	_baseStats[StatType.DeploymentCost] = stats.DeploymentCost;
	_baseStats[StatType.RedeployTime] = stats.RedeployTime;
	_baseStats[StatType.AttackPower] = stats.AttackPower;
	_baseStats[StatType.AttackSpeed] = stats.AttackSpeed;
	_baseStats[StatType.MaxBlockCount] = stats.MaxBlockableEnemies;
	_baseStats[StatType.SPRecoveryRate] = stats.SPRecoveryRate;
}
```
> 이 바꾸는 과정이 매우 간단하다 - 이럴 때 설계가 잘 됐다는 느낌이 드니까 좋음


#### HP 초기화 시점
```cs
protected virtual void Awake()
{
	// 메쉬 색상 설정
	propBlock = new MaterialPropertyBlock();

	// 시스템 생성(껍데기만 생성)
	_stat = new StatController();
	_health = new HealthController(_stat);
	_buff = new BuffController(this);
	
	// ...
	
}
```
> - `Health`의 생성자는 `UnitEntity`의 `Awake` 시점에 이미 생성됨
> - `_health`는 별도로 `Initialize()`를 해줘야 함

- `Operator`에 대한 처리만 고민해보자.
	- 기존엔 `Initialize`가 아니라 `Deploy` 시점에 초기화했다. 
	- `MaxHP`는 "스탯" 개념이기 떄문에 `StatController`에서 초기화되는 건 맞아 보임
	- `CurrentHP`라는 값이 의미를 갖는 건 배치된 이후이기 때문에 고민이 되는데..
	- `Initialize` 시점에 초기화해도 별 문제 없지 않나? `IsDeployed`라는 플래그가 별도로 있어서 미리보기가 나타나더라도 공격받지 않으니 괜찮을 것 같기도 한데?

- 잘 모르겠을 때는 일단 테스트 -> **크게 상관 없어 보이므로 `Initialize`에서 초기화**

### 배치 코스트 회수 로직 관련
- `Operator`의 퇴각 처리 시 배치 코스트를 회수하는 로직 관련
	- 기존) 직접 `DeploymentCost`를 회복하는 메서드를 호출함
	- 수정) `Operator` 퇴각 시에 이벤트 발생
		- `DeployableManager`는 `Operator` 배치 시에 이벤트 구독
		- 이 이벤트를 받아서 `Operator`에 대한 배치 코스트를 계산해서 `int` 값에 대한 이벤트를 다시 발생
		- 최종적으로 `StageManager`가 이 이벤트를 받아서 반영함
	- 구조가 더 복잡하지만 `Operator`에서 직접 호출하는 방식이 이상해서 수정

> 참고) 싱글턴 매니저 간의 이벤트 구독은 `Start`에서 하는 게 좋다. `Awake`는 순서가 보장되지 않기 때문에.

### UnitEntity - VisualController 분리
- 모델이 어떻게 보이는가, 유닛이 어떻게 보이는가, VFX 실행할 것인가 등등
- 원본에서 코루틴 관리를 한다는 점, 값 조절의 용이성 등 때문에 이전처럼 일반 C# 클래스로 구현하지 않고 `MonoBehaviour`을 상속한 구조로 구현함

#### 발생 중인 문제
- 색깔 할당이 되지 않음 : `Barricade`, `Operator`만 그렇다
	- `Enemy`는 잘 됨. ??
- 파괴된 유닛이 사라지지 않음
	- 예시) 바리케이드 : 투명해지긴 하는데 비활성화되지 않는다

### Despawn 구현
- `Despawn`이라는 메서드를 `Deployable`과 `Enemy` 양쪽에서 1개씩 구현함
	- `Operator`의 경우 `DespawnReason`은 `Retreat`, `Defeated`으로.
	- `Enemy`의 경우는 `ReachDestination, Defeated`으로 구현함
- `HandleOnDeath`라는 메서드를 `HP`가 0이 될 때의 메서드로 구현함
- `HandleOnDeath`는 일반적으로 `Despawn(DespawnReason.Defeated)`으로 연결시킴

#### 발생한 문제
- `Operator, Enemy`가 죽고 나서 정상적으로 사라지지 않는 문제
	- `HandleOnDeath()` 메서드는 `UnitEntity`에서는 비어 있다. 이 메서드가 `Despawn(Reason)`을 연결해주는 역할을 함.
	- 이렇게 구현한 이유는 `Operator`와 `Enemy`의 `DespawnReason`을 별도로 구현했기 때문에, `Operator`는 퇴각, 사망 으로 디스폰되고, `Enemy`는 도착, 사망으로 디스폰된다.
