## 260115

>[!done]
>- 버그 수정
>	- `ArcaneField` 
>		- 스킬이 꺼질 때 적이 멈추는 현상
>		- 스킬 범위에 진입 / 이탈 시 적이 진행 반대 방향으로 날아가는 현상
>	- `DoubleShotSkill` 
>		- 스킬 아이콘 클릭 시 나타나는 스택 오버플로우
>	- 일부 스킬 사용 후 SP가 회복되지 않는 현상 
>		- `OpSkillController`의 종료 로직 이슈
>- 스탯 시스템 다시 정리 : `ArcaneField` 만지는 과정에서 정리했음
>	- **`Modifier`의 기준값 : 0**
>- 보류
>	- `Barricade` 배치 시 어떤 상황에서 배치되지 않는 현상
>	- `Operator`의 체력이 다했을 때 사망 처리 X인데 적이 지나가는 현상

### 버그 수정

#### <해결> `ArcaneField` :  스킬이 꺼질 때 적이 멈추는 현상
- 체크 1 : `Enemy.Update.MoveAlongPath` 동작 (갑자기 저지당한다든가 하는 이슈는 아님)

> [!think]
> - 하나씩 점검하려던 중, 번뜩인 게 하나 있다
> - `ArcaneField`는 `SlowBuff`가 포함되어 있음
> - **`SlowBuff`가 풀리는 과정에서 원상 복구가 제대로 안된 거 아닐까?** 
> - 이런 논리로 접근하면 **또다른 이슈인 범위에 진입/이탈 시에 반대로 날아가는 현상도 설명할 수 있을 것 같음**

- `SlowBuff`의 `modifier` 값이 얼마인가 봤다 : `0.3`임. (30% 감소시킨다는 의미)
- 그리고 `Buff`의 메서드들을 보면
```cs
    public void AddModifier(StatType type, float value)
    {
        float actualValue = value - 1.0f;
        
        // ...
    }

    public void RemoveModifier(StatType type, float value)
    {
        float actualValue = value - 1.0f;
        
        // ..
    }
```
> 들어온 계수값에서 1을 빼고 `modifier`에 추가하는 방식임

- `modifier`에서 값이 활용되는 방식은 **`base * (1 + modifier)`임**
- ~~그래서 모든 스탯은 1을 기준으로 생각해야 한다. 30% 증가라면 1.3, 30% 감소라면 0.7..~~

>[!question]
>- 일단 `StatModifier`를 어떻게 관리할지부터 다시 점검해보면 좋을 것 같다. `Modifier` 값은 **1을 기준으로 넣을 것인가? 아니면 0을 기준으로 할까?**

>[!answer]
>- **`0`을 기준으로 하는 게 일반적임**
>- 사용하는 쪽에서는 **저 시스템만 알고, 메서드를 호출할 때 이를 반영**하면 됨

- 예를 들어서 `SlowAmount`라는 값으로 이동 속도를 저하시키는 로직이 있다고 하자. 
- "이동 속도 저하 30%"라는 로직을 구현하겠다면, 0이 기준일 경우 `0.3`이라는 값을 넣으면 됨. 
- 이것의 실제 의미는 "원래 이동속도의 70%로 이동하게 만들겠다"이므로 
- `AddModifier()`에서 넣는 값은 `-slowAmount` 만 넣어주면 된다. 

1. **`BuffController`의 `actualValue` 부분은 전부 제거**
2. `SlowBuff`도 아래처럼 반영
```cs
	// 30%의 SlowAmount는 modifier에서 `-0.3`이 됨
	// modifier는 baseValue * (1 + modifier)이므로 0.7배가 된다
    public override void OnApply(UnitEntity owner, UnitEntity caster)
    {
        base.OnApply(owner, caster);
        owner.AddStatModifier(StatType.MovementSpeed, -slowAmount); 
    }

    public override void OnRemove()
    {
        // owner.SetMovementSpeed(originalSpeed);
        owner.RemoveStatModifier(StatType.MovementSpeed, -slowAmount);
        base.OnRemove();
    }
```

- 이러니까 딱 막히는 지점이 생겼음 : **공격 속도 부분**
	- 이거는 **별도로 빼둠 - 복잡할 듯**
	- 공격 속도 : 1초에 몇 번 때리냐(타수/초)
	- ..를 뒤집으면(초/타수) 1번 때리는 데 몇 초 걸리냐라는 개념이 됨
	- 그래서 **공격 속도와 쿨다운을 구분해서 생각**할 필요가 있고, 별도의 로직도 필요해보인다. 이건 일단 보류.

> 리팩토링하다가 발생한 이슈이긴 하지만
> 일일이 언제 테스트해보나 하고 막막한 순간에 번뜩하고 해결한 이슈라서 오랜만에 쾌감을 느꼈다. 

#### <해결> DoubleShotSkill 클릭 시 스택 오버플로우
- `DoubleShotBuff` 부분을 보면 아래처럼 구현됨
```cs
private IEnumerator PerformDoubleAttack(UnitEntity owner)
{
	if (owner is Operator op)
	{
		UnitEntity? target = op.CurrentTarget;
		if (target == null) yield break;

		float modifiedDamage = op.AttackPower * damageMultiplier;

		op.PerformAction(target, modifiedDamage);
		yield return new WaitForSeconds(delayBetweenShots);

		if (target != null && target.CurrentHealth >= 0)
		{
			op.PerformAction(target, modifiedDamage);
		}
	}
}
```

어제 `DualBlade`에서 고민한 문제와 정확히 동일한 문제다. `PerformAction - PerformChangedAction - PerformAction`이라는 무한히 순환하는 재귀 호출 형태임

1. `PerformAction -> PerformActualAction`으로 구현
2. 이 이슈랑은 관계 없지만 `modifiedDamage`도 아래처럼 수정 - 스탯 자체에 들어간 보정치 값에 스킬의 보정치를 곱함
```cs
float modifiedDamage = op.GetStat(StatType.AttackPower) * damageMultiplier;
```

#### <해결?> 1번 시전 후, SP가 회복되지 않는 스킬이 있음
- `OpSkillController`에서 스킬 실행이 다 종료되고 나서 실행되는 로직이 달랐다
	- 지속시간이 있으면 `CompleteActiveSkill` (내부에 `OnSkillEnd` 포함)
	- 지속시간이 없는 즉발이면 `OnSkillEnd`
- `OnSkillEnd()`을 `CompleteActiveSkill` 외부로 빼서 실행 메서드에서도 흐름을 볼 수 있게 하고, 양쪽 모두 `CompleteActiveSkill()`로 끝나게끔 수정
```cs
    private void ExecuteInstantSkill(ActiveSkill skill)
    {
        skill.OnActivated(_owner);
        skill.OnUpdate(_owner);
        skill.OnEnd(_owner);
        CompleteActiveSkill(skill);
    }
    
    private IEnumerator Co_HandleDurationSkill(ActiveSkill skill)
    {
        skill.OnActivated(_owner);

        float elapsed = 0f;
        float duration = skill.Duration; 

        while (elapsed < duration)
        {
            // 소유자 파괴 시 중단
            if (_owner == null)
            {
                CleanupSkill();
                yield break;
            }

            elapsed += Time.deltaTime;
            float progress = elapsed / duration;

            // UI용 - SP 시각적 감소
            CurrentSP = MaxSP * (1f - progress);

            // 스킬 틱 호출
            skill.OnUpdate(_owner);

            yield return null;
        }

        // 정상 종료
        skill.OnEnd(_owner);
        CompleteActiveSkill(skill);
    }    
```

- 이 문제가 발생하는 스킬에선 동일한 현상 발생 X

#### <간헐적, 보류> Barricade 배치 시 특정 상황에서 배치되지 않음
- 다시 테스트했을 때는 또 잘 된다. 보류.
#### <간헐적, 보류> Operator 체력이 없는데 안 죽고 그냥 지나감
- 얘도 잘 되는데? 흠..

#### <해결> DeployableActionUI - 스킬 버튼 관련
1. 커서 올릴 때 색깔 변하게 하기
2. 스킬 활성화 시에 주황색이 줄어들어야 함
	- **텍스쳐가 누락되면 `Image.filled` 효과가 아예 나지 않음**
	- 이전에 `square_sprite`을 지운 적이 있는데 그것 때문이었다. 로직 자체는 잘 동작하고 있음.
