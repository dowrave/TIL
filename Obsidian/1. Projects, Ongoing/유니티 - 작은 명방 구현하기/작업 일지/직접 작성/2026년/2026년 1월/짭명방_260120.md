
## 260120

>[!done]
>1. 이슈 수정
>	- `ArcaneFieldSkill` : 범위 내에 적이 없다면 사용되지 않게 하기
>	- `OperatorActionUI` : 스킬 사용 버튼 레이아웃에 조건 추가
>- `Enemy`의 공격 + 스킬 기능 분리 중`EnemyActionController`
>	- 근데 스킬이랑 공격도 따로 떼어놓아도 될 듯. 
>	- 이 작업은 내일 진행함.

>[!wip]
>- `Enemy`의 기능 분리

## 이슈 수정
### ArcaneFieldSkill
- 범위 내에 적이 없다면 사용되지 않게 하기

1. `OpSkillController.CanUseSkill()`
```cs
public bool CanUseSkill()
{
	return _owner.IsDeployed && 
		CurrentSP >= MaxSP && 
		!IsSkillOn && 
		CurrentSkill != null &&
		CurrentSkill.CanActivate(_owner); // 추가
}
```

2. `ArcaneFieldSkill`은 `CanActivate`를 오버라이드해서 조건을 추가함
```cs
public override bool CanActivate(Operator caster)
{
	// 조건이 추가로 필요할 수도 있음
	if (caster.CurrentTarget != null)
	{
		return true;
	} 

	return false;
}
```
> 원래 메서드는 `return true`만 있다

### OperatorActionUI

- 이런 상황이 있음 
	- `ArcaneFieldSkill` : SP가 가득 찼지만 `CurrentTarget`이 `null`이라서 스킬을 사용할 수 없는 상황일 떄, 스킬 버튼의 초록색 게이지가 가득찬 채로 사라지지 않음
	- `CanActivate()`라는 조건에 바로 영향을 받는 것으로 보인다. 

- `ActionUI`의 스킬 버튼에 조건을 더 추가해야 할 듯
	1. SP가 차오를 땐 버튼의 아래부터 차오르는 초록색 게이지가 보이게 함
	2. SP가 가득 찼을 땐 스킬 사용 가능 여부만을 판단함
		- 스킬을 쓸 수 있다면 원래 아이콘대로
		- 쓸 수 없다면 어둡게 처리

- 기존 코드
```cs
//DeployableActionUI.cs

// 스킬 버튼의 SP Image 조건(기존)
	if (currentOperator.CanUseSkill())
	{
		SetSPImageActive(false);
		return;
	}
```
> - 여기서 `CanUseSkill()` 은 `_skill.CanActivate()`와 동일함
> - 만약 SP가 가득 찼는데 쓸 수 없는 상황이라면 `CanUseSkill()`은 `false`

```cs
// 스킬 Off이면서 SP가 가득찬 상황
if (currentOperator.CurrentSP == currentOperator.MaxSP)
{
	// 게이지가 가득 찼을 때는 SP Image를 꺼둠
	SetSPImageActive(false);  

	// 스킬 자체의 조건을 체크해서 사용 가능할 때만 밝게 처리	
	// skillImage.color = currentOperator.CanUseSkill() ? turnOnColor : turnOffColor;

	// 처음엔 색으로만 처리했으나 Button.interactable이 더 나은 듯
	skillButton.interactable = currentOperator.CanUseSkill() ? true : false;

	return;
}
```

1. SP가 가득 찼음 + 공격 범위 내에 있을 때 아이콘, `Activate` 활성화
![[Pasted image 20260120161012.png]]

2. 공격 범위에서 벗어났을 때 
![[Pasted image 20260120161051.png]]

어둡게 처리되며 스킬 버튼을 클릭해도 아무 동작을 하지 않음

- `Button.interactable`로 변경 -> SP가 가득 찬 상태에서 사용이 불가능할 때 스킬 버튼을 클릭하더라도 `ActionUI`을 켰을 때 적용되는 속도 저하가 나타나지 않고 상태를 유지할 수 있어서 더 좋은 듯

## Enemy 컴포넌트 분리
### `EnemyAttackController` 구현
1. `Block`의 경우 `Operator`에서 수행하는 기능이므로 `Enemy`는 자신이 저지되었는가 여부랑 제거되었을 때 `Operator`에게 전달한다 정도만 구현하면 됨 -> 별도의 `BlockController`을 만들 필요는 없어 보임
2. `EnemyAttackRangeController`가 이미 있음 : 원거리 적이 공격 범위 내의 적을 판별할 때 쓰는 용도. 

>[!note]
>1. `EnemyActionController`로 구현, 공격과 스킬 사용 기능을 한꺼번에 넣는 방향으로 설정
>	- `Update`에 스킬 부분이 붙어 있어서 이렇게 작업했는데, 생각해보면 굳이? 싶다. 
>	- 예를 들어서 어떤 CC에 걸린 상황이라면 공격이나 스킬 사용은 못하지만 스킬 쿨다운이나 공격 쿨다운은 돌아가고 있어야 함
>	- 기존엔 `Update`라는 로직으로 하나로 붙여놓은 것들인데, 별도의 메서드를 만들어서 자기 상태에 관계없이 `Update`해야 하는 애들은 따로 빼두면 되겠다.

