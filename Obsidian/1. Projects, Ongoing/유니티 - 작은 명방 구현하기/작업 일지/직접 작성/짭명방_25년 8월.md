
# 250830 - 짭명방
>[!done]
>- 보스 스킬 전조 효과 구현
>	- 파티클이 바닥으로 서서히 떨어지는 효과다.
>	- 참고) 아래 gif 파일에서는 파티클 시스템으로 구현했지만, 이동에 따른 파티클 방출 구현 때문에 **실제 오브젝트를 움직이는 스크립트를 별도로 구현해야 함.** 
- 이 GIF 파일은 떨어지는 파티클을 파티클 시스템으로 구현한 거고 **실제로는 자식 파티클 시스템 자체가 움직이면서 파티클을 남길 예정**이라 스크립트로 `Sun` 부분의 움직임을 별도로 컨트롤할 거임.

- 어제 만들었던 `Area_Anticipation`과의 조합
![[BossSkill_Anticipation.gif]]
> 강의에서는 `Burst`를 2번 하고 랜덤한 색 사이를 고르도록 구현했는데, **색깔의 경우 이펙트가 나타날 때마다 랜덤성이 생기는 게 좋은건지 아닌지 아직 확신이 서지 않는다.** 
> 파티클이 튀는 방향 같은 건 몰라도 색깔 같은 건 눈에 띄는 요소이기도 해서, 그냥 **개별 파티클 시스템을 만들고 각 파티클 시스템이 내보내는 색은 항상 일정하게끔 구현했다.** 



# 250829 - 짭명방

>[!Done]
>- 아이콘 제작 : `SlashSkill`
>- 보스 스킬 이펙트 제작 시작
>	- 영역) 전조 이펙트 : 바닥이 깜빡이는 효과
## SlashSkill 아이콘 다시 제작
- 크기는 256으로 넣었다. 
![[SlashSkill_256.png]]

뭔가 꽉 찬 느낌이 안 나서 Muzzle 같은 효과도 넣어보고 했는데 그냥 검기들 크기만 키우고 마무리했다. 지금 보면 좀 쓸데 없는 고민을 너무 길게 한 느낌이 있음.
- **SlashSkill은 이걸로 마무리.** 며칠 걸렸냐 후

## 보스 스킬 이펙트 시작
- 우선 영역 표시부터 시작. 범위 스킬에 사용한 요소들은 `Operator`의 요소만을 받지 않기 때문에 기능은 거의 그대로 넣을 수 있을 것 같다. 

- 바닥 표시 관련
	- 알파값이 커졌다가 작아졌다가를 반복하는 이펙트를 구현할 것
	- 셰이더로 구현하는 건 타이밍 때문에 맞지 않을 거 같음. 파티클 시스템으로 ㄱㄱ
	- **`Color over Lifetime`을 구현할 때 갯수 제한**이 있다. 없는 줄 알았음 ㅋㅋ

### 깜빡이는 효과 구현
- 처음엔 **느리게 깜빡이다가 나중엔 빠르게 깜빡이는 효과를 구현**하고 싶은데, 파티클을 얼마나 구현할지, `lifetime`을 어떻게 설정할지 등이 고민되는 부분임
- `EaseIn`도 알아봤다. 애니메이션 등에서 자연스러운 움직임을 사용할 때 쓰는 함수임
- 이걸 제미나이한테 계산을 맡겨봤는데 마지막 부분에 깜빡이는 효과가 갑자기 너무 급해지는 현상이 있었음.
- 그래서 눈대중으로 보고 이펙트를 구현했다.
	- 대신 `Ease` 시리즈에서 아이디어를 얻은 건 있다 : **초반에 느릿하게 깜빡이는 부분은 큰 변동 없이 여러 번(2~3번) 보여주는 것이 포인트 같음.** 
- 일단은 5단계로 가져감
	- 0.75 -> 0.7 -> 0.6 -> 0.45 -> 0.25
![[Area_Anticipation.gif]]
> 이렇게 구현하면 대충 3초 근처로 전조를 맞출 수 있다. 일단은 여기까지 진행함.

# 250828 - 짭명방

## SlashSkill 완성하기

### 이펙트
- 결국 버전 1을 사용함.

![[Skill_Slash_v1_Final.gif]]

구름이 모이는 효과, 1번째 공격에도 작은 Beam 추가, 각 슬래쉬에 서브 에미터로 파티클 추가 등등의 작업을 추가로 거쳤다.

일단은 이 정도로 하고 실제 효과 구현함.

### 효과
- 기존 `SlashSkill`을 보면...
```cs
protected override void PlaySkillEffect(Operator op)
{
	if (slashEffectPrefab == null) return;

	Vector3 spawnPosition = op.transform.position + op.transform.forward * 0.5f;
	Quaternion spawnRotation = Quaternion.LookRotation(op.FacingDirection);
	GameObject effectObj = Instantiate(slashEffectPrefab, spawnPosition, spawnRotation);

	SlashSkillController controller = effectObj.GetComponent<SlashSkillController>();
	if (controller != null)
	{
		controller.Initialize(op, op.FacingDirection, effectSpeed, effectLifetime, damageMultiplier, skillRangeOffset, op.OperatorData.HitEffectPrefab, op.HitEffectTag);
	}
}
```
> `SlashSkillController`라는 컴포넌트를 가진 이펙트 오브젝트를 하나 생성했다. 
> 이 컨트롤러는 목표 타일 위에 있는 적들에 대해 파티클과 적이 충돌했을 때 대미지를 입히는 방식으로 구현되었다. 1개의 검날 파티클이 앞으로 나아가는 방식으로 구현됐기 때문이다.

- 그런데 지금의 구현은 4개의 타일에 콜라이더를 놓고, 거기에 적이 있다면 **이펙트의 타이밍에 맞춰서 대미지를 넣는 방식으로 구현**하면 된다. 어떻게 보면 `ArcaneField`와 비슷한 면이 있겠음. 

#### 또 컴퓨터가 말썽이다
- 잘 돌아가다가 갑자기 멈추더니 화면들 다 나감. 컴퓨터는 계속 켜진 상태. 반복적으로 발생하는 이슈라서 결국 다시 본체를 열었다.
- 그래픽 카드를 뺐다가 다시 꼈다. 
	- 램 이슈면 차라리 나은데 그래픽 카드는 나사까지 돌려야 하니까 배로 귀찮다. 슬롯에 끼워도 나사 고정 때문에 위치가 조정되는데, 그래서 나사를 조이기 전에 잘 돌아가다가 나사를 조인 후에 또 돌아가지 않는 등의 이슈도 있었다.
	- 한 번에 해결되지 않아서 여러번 뺐다가 꼈다.

- 만약 **컴퓨터를 바꾼다면 9060xt 16gb 정도를 보고 있는데..** 지금 지출하기엔 좀 큰 돈이다.
	- 플레이엑스포 때 네오위즈 부스에서 내 바로 앞에서 다른 사람이 가져간 9070xt가 아른거린다..

#### 아무튼 다시 돌아옴
- 위에서는 "별도의 콜라이더를 만들고 거기에 충돌한 적들에게 대미지를 넣는다"라고 썼다.
- 그런데 공격 범위 타일이 정해져 있다면, **스킬 자체가 콜라이더를 갖는 경우 범위 밖의 적에게도 대미지를 주는 일이 발생할 수 있음.** 의도치 않게 대미지가 들어갈 수 있기 때문에 설명과는 조금 다른 효과를 가질 수 있겠다는 생각이 든다. 
- 그래서 타일 위에 있는 적들을 가져오는 정도로만 구현하면 충분할 것 같음. 별도의 콜라이더를 넣지 않고. 

#### 스크립트 구현과 디테일 설정
- 기존 `SlashSkill`은 `Legacy`로 빼뒀다. 이름 앞 뒤에 Legacy를 붙여서 남겨놨음.
- 이펙트 안에 실제 스킬 효과도 함께 들어갔다.
- 설계도 안에 스킬의 효과를 넣는 구현도 있지만, 설계도는 `MonoBehaviour`를 상속받지 않은 요소이므로 지금처럼 타이밍에 맞춰 대미지를 넣는 코루틴 구현이 불가능하다. 
- 그래서 설계도인 `SlashSkill.cs`는 공격 범위까지만 설정해서 `Controller`에 넘겨주고, `Controller`는 이를 받아 이펙트와 실제 공격 판정 기능을 수행한다.

- 전체적인 구현은 마쳤음.

- **스킬 이펙트는 잘 나타나지만 판정이 제대로 들어가지 않는 이슈** 수정.
	- 수정 완료 : `SlashSkill`에 공격 범위를 안 넣었다 엌ㅋㅋ

- **스킬을 시전하는 동안에는 평타 공격을 멈추는 구현도 추가**해야 할 듯. 
	- 기존의 `ActionRestriction`이 있었다. 이걸 스킬 컨트롤러에서 스킬이 시작할 때 오퍼레이터에게 걸고, 스킬이 끝날 때 해제하는 방식의 구현을 시도해봤음.
		- 기능적으로는 문제가 없지만, **구조상 어떤 제약을 걸고 해제하는 로직은 오퍼레이터 자체에서 이뤄져야 한다**고 한다.
	- ~~그러면 스킬에 공격을 중단해야 하는지를 표시해두고, 오퍼레이터가 스킬을 사용할 때 해당 부분을 체크해서 공격을 중단해야 하는 경우 자신에게 제약을 걸고 스킬이 끝날 때 푸는 방식으로 구현해야겠음.~~
	- 기존 스킬 중 스킬 동작 중에는 공격하지 않는 스킬이 있었다. `ArcaneField`인데, `CannotAttackBuff`를 `Operator`에게 추가해서 공격을 막는 방식이었음.
		- 다만 이 방식은 "여러 오퍼레이터가 같은 스킬을 쓸 때" 문제가 발생할 수 있다고 한다. **별도의 인스턴스를 갖는 개념이 아니기 때문에, `ScriptableObject`에서 상태를 갖는 건 권장되는 방식은 아니라는 듯.** 
		- 즉 다른 캐릭터의 스킬 동작에 의해 기존 캐릭터의 스킬 동작이 덮어씌워질 수 있다는 말임
	- 근데 그러면 어떻게 해제해야 할까?
		- **`UnitEntity`에서 스킬 단위로 버프를 해제할 수 있게 만듦.** 스킬이 끝나는 타이밍에 자신을 보내서 자신과 관련된 버프들을 해제하게 만듦.
		- **각 버프는 생성될 떄 어떤 스킬에 의해 생성되었는지 설정을 추가함**
			- **생성자를 Buff에 구현하지는 않았음.** 자식 생성자에서 대부분의 요소를 일일이 다시 쓰는데 이게 코드가 더러워보여서..

- 기능 구현은 거의 끝남. 저 스킬 사용 중 공격을 막는 로직 구현에 시간을 좀 썼다.
	1. 판정은 0초, 0.3초 0.45초, 0.6초에 발생한다. 그 동안 가드는 공격하지 않음.
	2. 배율은 1타는 공격력의 2배, 3번에 걸쳐 들어가는 대미지들은 각각 1.25배가 들어간다. 

![[Skill_Slash_v1_RealFinal.gif]]
- 이펙트가 지나간 다음에도 피격 이펙트가 나오는게 살짝 어색한 감이 있어서, 판정 간격을 줄여보고 있다. 위 gif는 간격이 0.15초였음.
- 0.1초가 적당해보여서 그렇게 설정함. 오늘은 여기까지! 내일은 아이콘 수정하고 드디어 보스 구현을 시작할 수 있겠다. 더 수정할 게 있나? 모르겟음.

- 비교) 기존 구현
![[Skill_Slash_Legacy.gif]]



### 스킬 아이콘
![[Skill_Slash_128.png]]
- 기존 스킬 아이콘
- 이걸 넣어본 다음에 나노바나나를 써봤는데 말한 대로 반영되지 않는다. 설명을 잘못한 탓일까 ㅋㅋ 어쨌든 스킬의 형태가 달라졌으니 아이콘도 다시 그려야 함


# 250827 - 짭명방

## SlashSkill 이펙트 구현(계속)
- 좌락 스킨 버전 3스킬도 참고해봤다.
- 반쪽짜리 화살표 이펙트가 먼 곳에서 날아와서 꽂히고 마지막에 두루마리가 펼쳐지는 모양임
	- 이 화살표 이펙트들은 0.2초 정도 유지된다.
	- 실제 시간으로 보면 정말 순식간에 지나가니까 보이지 않는 요소인데, 저런 짧은 순간에도 "어디선가 이펙트가 날아온다" 정도의 인식을 할 수 있었음.
- 그러면 지금의 검날 이펙트의 경우도 단순히 나타났다가 사라지는 게 아니라 `Guard`로부터 뻗어나오는 방식으로 연출할 수 있겠다.

### 일단 결과물
- 버전1 : 직진 후 검기
![[Skill_Slash_v1 1.gif]]

- 버전2 : 검기 후 직진
![[Skill_Slash_v2.gif]]

> 개인적으론 버전2가 마음에 드는데, 뭔가를 모으는 이펙트와 검기가 같이 나가는 건 이상하면서 번잡하다는 생각도 든다. 
> 스킬은 누르는 즉시 나가야 하는 걸 생각하면 버전 1이 나을지도 모르겠다. 원본 게임에서도 스킬을 누른 다음에 딜레이가 있는 경우는 거의 없는 걸로 기억함. 그나마 마르실 정도?

### 갑자기 컴퓨터가 사망했다.
다행히 소생시켰다.
- 램 탈착도 해보고 글카 탈착도 해보고 메인보드 배터리도 다시 바꾸는 등 
![[Pasted image 20250827234616.jpg]]

...이기 때문에 일은 마무리. **이펙트랑 스킬 효과 모두 다시 생각해봐야 할 듯.**
이럴 때마다 컴퓨터를 바꿔야 하나 싶지만 100만원 정도 되는 거금을 쓸 걸 생각하면 또 있는 거나 잘 쓰자~로 회귀.

# 250825 - 짭명방

>[!done]
>1. 원본 게임 보면서 분석하기
>2. (못 끝냄) `SlashSkill` 이펙트 구현하기

## 레퍼런스(원본 게임) + 셰이더 공부
- 몰랐는데(!) One UI에서 자체적으로 화면 녹화 기능을 지원한다.
- 그래서 돌도 캐고 나중에 구현할 때 참고도 할 겸 영상을 찍어놨음.
- 윈도우10 미디어 플레이어는 프레임 단위 재생이 되지 않는다. VLC도 받아서 써봤는데 이전 프레임 기능이 없다. 결국 **팟플레이어**를 씀.
	- 이전 프레임은 D, 다음 프레임은 F다.

- 이격 블레이즈의 3스킬인데 좀 궁금한 게 생겼음.

![[Pasted image 20250825144426.png]]
![[Pasted image 20250825144353.png]]
![[Pasted image 20250825144631.png]]
![[Pasted image 20250825144653.png]]
![[Pasted image 20250825144820.png]]
![[Pasted image 20250825144849.png]]

실제 게임에서는 정말 찰나의 순간에 지나가므로 저런 식으로 사라지는 것도 잘 안 보이긴 하지만, 이걸 보면서 궁금한 게 생겼다.

>[!question]
>1. 퍼져나가는 파티클이 사라지는 모양을 보면 단순히 텍스쳐가 작아지는 게 아니라 모양이 변하면서 사라지고 있다. 쉐이더로 구현한다고 가정해도, 그 타이밍을 조절할 수가 있나?
>2. **가운데 폭발 부분**을 보면 `Intensity`가 커졌다가 서서히 작아지고, 사라질 때는 가운데에서부터 퍼져나가면서 사라지고 있다. 겹치는 파티클을 보이지 않게 하는 쉐이더가 있는 건가?

- 쉬고 와서 다시 생각해봄. -> **둘 다 텍스쳐 시트(=애니메이션)로 구현할 수 있는 요소로 보임**


- 1번 
	- 자세히 보면 저 파티클들이 튀는 방향이나 모양이 바뀌는 게 아님. 이것도 **하나의 거대한 텍스쳐 시트로 보인다.** 퍼져나가는 효과는 1개의 거대한 스프라이트 시트를 만들고 사이즈만 서서히 키우는 방식으로 구현할 수 있겠다. 사라지는 건 일일이 작업해야겠지만.
- 2번(중앙 폭발)은 
	- 처음엔 셰이더로 구현한 부분인가?라고 생각했는데 나타나고 사라지는 모양을 보면 이펙트 부분은 항상 동일한 형태로 나타나고 사라짐.
	- 그러면 **시트만으로 구현할 수 있는 요소** 같은데? 
		1. 이미지를 만듦
		2. 번(빛산란) 효과를 서서히 증가시키다가 감소시킴. 각각을 스프라이트로 만들어둠.
		3. 감소시킨 다음에는 가운데 부분부터 서서히 지워나감. 이것도 스프라이트로 만듦.
	- **폭발 이펙트 1개가 0.15초 동안 나옴. 매우 빠르게 재생되는 요소라서 전혀 어색해보이지 않으면서도 서서히 사라지는 효과가 나오고, 저 파티클 밑에 다른 요소들도 있다.** 

뭔가 본격적으로 애니메이션을 만든다는 느낌이 되니까 갑자기 귀찮아지는..




### Additive vs Alpha Blended
- 느낌만 알지 정확히 어떤 원리인지는 몰랐어서 정리해둔다.
- [[셰이더 혼합 개념 정리]]에 정리해둠.
- 용어 정리
	- `Source` : 지금 그리려는 파티클
	- `Destination` : 이미 화면에 그려진 픽셀(배경)
#### Alpha Blend(보간)
- `결과 = (Source 색상 * Source Alpha) + (Destination 색상 * Destination Alpha)`
- **두 색을 혼합**한다. `Source`의 알파 값에 따라 원본과 배경을 얼마나 보여줄지를 결정한다.
- 반투명한 이펙트에 사용된다. 
- 감산 혼합이 아니다. 아래 참조.

#### Additive(가산)
- `결과 = Source 색상 + Destination 색상`
- 두 색의 채널(RGB) 값을 그대로 더한다. 알파값은 `Source`의 색상 강도에만 쓰이고 블렌딩 계산에 관여하지 않는다.
- 빛을 더하는 것과 동일해서 항상 밝아진다. 검은 배경에 더하면 아무 변화가 없고, 밝은 배경 위에 더하면 흰색에 가까워지며 타는 듯한 효과를 낸다.

#### Subtractive Blend(감산)
- `결과 = Destiantion - Source (or Source + Destination - 1)`
- `Source`와 배경이 겹치면 항상 어두워진다. 
- 특수한 목적에서 제한적으로 사용된다. 





## Slash Effect
- `Guard`의 2번째 스킬이다. 
- 기존에는 검기 메쉬를 직진으로 쭉 날리고 그 뒤에 파티클들을 남기는 방식으로 구현했는데
- 찌르는 효과 다음에 검기들이 좌좌좍 나가는? 방식으로 수정해보고 싶음.
- 생각나는 이펙트는 첸의 2스킬 + 좌락의 3스킬
	- 첸의 2스킬이 타격 1번
	- 좌락의 3스킬로 타격 3번을 주는 방식이 되겠다.
	- 때문에 스킬의 로직도 바꿔야 함. 일단은 이펙트부터 구현한다.

### 헐 이거 이제 알았음
- ~~방향에 따른 파티클의 회전은 단순히 `Stretched Billboard`를 쓰는 게 아니라 `Render Alignment - Velocity`로 설정해주면 됨. ~~
- ~~이제 `Billboard`로 개념들이 통일되므로, **모든 텍스쳐는 +y를 보도록 제작**하면 된다.~~
- 이거도 좀 애매한 느낌이다. 특정 방향에선 보이지 않는다든가.. 
- 결국 **Stretched Billboard로 회귀함.** 텍스쳐도 다시 -x 방향을 보도록 수정했다. 후,,

### 메인 검기 구현
- 첸의 2스킬을 참고해서 만들어본다. 
![[Skill_Slash_v1.gif]]
> 일단은 이런 느낌인데 여전히 만질 게 있어 보인다. 오늘은 여기까지만 작업함.



# 250822 - 짭명방

>[!done]
>1. `Caster_AreaEffect` 수정
>2. `MeteorSkill` 이펙트들 구현
>	- `Area` : 발동 시 영역 경계가 잠깐 번쩍이는 효과
>	- `MeteorParticle`
>		- 파티클이 도달하는 위치 이슈 수정
>		- 다른 콜라이더와 충돌해서 먼저 사라지는 이슈 수정
>	- `Hit`
## Caster_AreaEffect 수정
- 번뜩이는게 있어서 구현해봄. 
- 별 건 아니고 예전에 강의 들으면서 완성했던 Lightning 텍스쳐 시트가 있었다. 영역의 벽에 그것들을 붙일 수 있지 않을까? 라는 아이디어에서 출발.

### 텍스쳐 시트를 플레이하는 셰이더
- 기존의 벽이 `Mesh`로 구현되어 있었다. 파티클 시스템을 활용하는 편이 알고 있는 내용이므로 더 빠르게 구현할 수 있겠지만, 이런 생각도 들었다.

>[!question]
>- 셰이더에서 스프라이트 시트나 텍스쳐 시트를 플레이시킬 수 있을까?

- 관련 정보를 찾아보니..
- 유니티 셰이더그래프에서는 `Flipbook`이라는 노드가 있다. 
- 구현도 간단하다.
![[Pasted image 20250822124037.png]]
텍스쳐의 Width, Height를 집어넣고 Tile 인풋으로 속도를 조절하는 방식임.
기존의 Wall 쉐이더에서 시트 기반으로 기능하게끔 Flipbook 관련 노드들만 추가했다.

![[Area_ArcaneField_v1.gif]]

이런 느낌. 텍스쳐가 `Seamless`가 아님 + 언덕 타일에서 영역이 끊어져보인다는 점이 보이지만 지금은 그냥 넘어간다. 

올라오는 전기 아이콘 파티클도 `Vertical Billboard -> Billboard`로 수정했다. 잘 안보이는 것 같아서..

## MeteorSkill 이펙트들 구현

### Area
- 벽 이펙트를 수정함.
- 이 스킬은 일발성 스킬이다. 그래서 스킬의 발동을 알리게끔 번쩍!하고 튀어올랐다가 천천히 가라앉는 느낌으로 구현하려고 함.
- 위에서 캐스터 벽 이펙트로 구현했던 요소를 이용해 스킬이 발동될 때 위에서 경계선이 내려오는 방식으로도 구현해봤음. 
	- 근데 정신없다. 어차피 파티클이 위에서 떨어지는데 경계선까지 위에서 떨어질 이유는 없음.

![[Area_Meteor_v1 1.gif]]
굉장히 정신이 없다. 각 변의 가장자리에서 잠깐 올라왔다가 내려가는 이펙트다. 나오는 타이밍이 정해져 있어야 하므로 **파티클 시스템**으로 구현, 높이를 늘렸다가 줄이는 방식이다.


### Meteor

#### 파티클이 도달하는 위치
- 파티클 자체는 괜찮은데, 파티클이 도달하는 위치가 좀 이상해보였다. 
![[Pasted image 20250822164932.png]]

> 일단 **기절 효과의 마젠타 색깔도 이슈**가 맞지만 그건 지금은 패스하고 저 위치 부분만 봄.

이것저것 만져본 결과, **파티클 오브젝트 자체의 회전값이 `90, 0, 0`으로 들어가는 지점이 문제였던 걸로 보임.** 기존에는 원뿔을 아래 방향으로 맞추기 위해 넣었던 기능으로 보이는데, 지금은 필요 없다. 삭제.
- 왜 그런지는 모르겠지만 회전값이 파티클의 위치에 영향을 준다. 
	- 로컬 좌표계의 원점을 가리키고 있으니 영향을 주지 않아야 정상 아닌가..
	- 피격 대상의 자식 오브젝트로 들어가지만 부모 오브젝트의 영향은 아님.
```cs
// MeteorSkill.cs

// Quaternion.identity로 수정
GameObject meteorObj = Instantiate(meteorPrefab, spawnPos, Quaternion.identity, target.transform);
```

#### 의도하지 않은 콜라이더 충돌 발생
- 또, 원거리 `Enemy`에 한해서 파티클이 도착하지도 않았는데 바로 타격 판정을 발생시키는 현상이 있다. 아마 원거리 적만이 갖는 콜라이더 때문인 듯. 판정 기준을 더 엄격하게 들어가야 한다.
```cs
// MeteorController.cs
    private void OnTriggerEnter(Collider other)
    {
        // 몸통에 닿은 콜라이더에 대해서만 실행되어야 함. 이게 없으면 사거리 콜라이더와 충돌했을 때도 동작함
        BodyColliderController bodyCollider = other.GetComponent<BodyColliderController>();
        
        if (bodyCollider != null)
        {
            UnitEntity tempTarget = other.GetComponentInParent<UnitEntity>();

            // 목표에 닿으면 실행
            if (tempTarget != null && tempTarget == target)
            {
                ApplyDamage();
                ReturnToPool();
            }
        }
    }
```

- 이 부분은 레이어 & 충돌 매트릭스로 특정 레이어끼리의 충돌만 가능하게 하는 방식으로 구현할 수도 있다.
- 근데 **지금의 이슈는 정확히는 `GetComponentInParent`를 바로 썼던 게 문제였음.** `BodyColliderController`인지 체크하고, 이것의 부모 유닛이 `Meteor`의 목표인가?만 점검하면 공격 범위 콜라이더에 걸리는지 여부는 아예 관계가 없는 상황이었다. 
- 그래서 그냥 이렇게 줄일 수 있음. **컴포넌트 점검 로직 자체는 필요하다.**
	- 레이어 & 충돌 매트릭스를 이용하면 성능상 조금 더 좋겠다는 생각은 듦.
```cs
private void OnTriggerEnter(Collider other)
{
	// 몸통에 닿은 콜라이더에 대해서만 실행되어야 함. 이게 없으면 사거리 콜라이더와 충돌했을 때도 동작함
	BodyColliderController bodyCollider = other.GetComponent<BodyColliderController>();
	
	// 목표에 닿으면 실행
	if (bodyCollider != null && bodyCollider.ParentUnit == target)
	{
		ApplyDamage();
		ReturnToPool();
	}
}
```

- 둘 다 정상적으로 동작하는 거 확인함

### Hit
- 어떤 식으로 구현할지 생각 중.
- 바닥에 흔적 남기기

- 결과물
![[Hit_Meteor_v1.gif]]
> 바닥에 `Beam`으로 `Debris`를 남기는 구현이 빠져 있다. 알파값이 0으로 돼있음;


- 타격 이펙트는 `Muzzle` 메쉬를 이용했다. 
	- 메쉬는 여러 개 생기며, 3D 사이즈에 변주가 있음. 
	- 각 파티클은 발생하면 z축으로 커지는 효과를 구현했다.
		- `lifetime`이 너무 길면 어색해보인다. 일단 0.2초는 어색해보였음. 
	- 머티리얼은 `Impact03_Add`를 사용함.
	- 위로 튀는 이펙트, `Muzzle`의 경우 `Alpha Blended` 부분도 구현해봤다.
		- 보통 이런 구현은 `Add` 셰이더보다 살짝 오래 남기는 구현을 가져간다.  그런데 순간적으로 나타났다가 사라지는 이펙트에는 적합해보이지 않음. 눈에 띄긴 하는데, 나쁜 의미다.
		- 그래서 위로 튀는 부분은 AB를 구현했다가 제거했음.

- 바닥에 퍼지는 파티클
	- `Stretched Billboard`를 썼다.
	- 불꽃 이펙트 레퍼런스를 보면서 궁금했던 게 **파티클이 사라질 즈음에 길이가 짧아지는 것이었다.**
	1. **`Length Scale`을 줄일 것**
		- 기본 길이 설정값이다. 이 값이 크면 속도가 줄어도 파티클의 길이가 줄지 않음.
		- 위의 경우 0.01로 설정됨.
	2. **`Velocity Over Lifetime`에서 `Speed Modifier`를 `Curve`로 구현**
		- 위 이펙트의 경우 2개의 커브로 구현됨. **빠른 속도로 퍼져나가되 멀리 퍼지게 하고 싶진 않다면 `Start Speed`를 높이고 `Speed Modifier`가 0이 되는 시점을 빠르게** 가져가면 된다.




## 기타 수정
### SkillRangeVFXController
- **기존**에는 파티클을 바닥에서 올라오게 하고, `Trail`을 남기는 방식으로 구현했음. 이를 위해 `Prewarm`이 필요했고, **`Simulation Speed`를 100으로 올린 다음 1로 되돌리는 방식**을 택했다.
	- 이거 그냥 파티클 시스템에서 `Prewarm`을 켜면 된다.
- 어쩄든 **지금은 해당 기능이 필요없어진 상태고, 굳이 스크립트로 따로 구현할 필요도 없어보인다.** 그래서 삭제.




# 250821 - 짭명방

>[!done]
>1. 셰이더 공부 & 수정
>2. `Wall` 셰이더 구현 및 적용
>3. `MeteorSkill` - 떨어지는 투사체 구현
>	- 타격이랑 범위 이펙트는 내일!
## 셰이더 탐구 : AddScroll과 Trail
- 어제 벽 효과 관련, `AddScroll` 쉐이더랑 `Trail` 쉐이더의 차이점을 알고 싶어졌다. 
	- 원하는 효과는 `Trail`인데, `AddScroll`도 그게 가능하지 않을까 싶어서 테스트해봤는데 그런 느낌이 나지 않았기 때문이다.

### `Trail` 쉐이더
![[Pasted image 20250821124715.png]]
> `Add`로 들어오는 `A`는 `Simple Noise`에 스크롤을 더한 값.

- 분석
	- `One Minus`는 왼쪽이 1, 오른쪽이 0인 행렬
	- `Add`로 노이즈 값들이 더해짐
	- 여기서 왼쪽이 0, 오른쪽이 1인 행렬을 뺌
	- 최종적으로 왼쪽은 1보다 크거나 1에 가까운 값들이 주로 오고 오른쪽은 0에 가까운 값들이 주로 오게 됨. 노이즈에 따라 값 편차는 있겠지만 전체적으로 이런 경향을 따르는 편.

### `AddScroll` 쉐이더
- 원리는 위와 크게 다르지 않다.
- 차이점
	1. `Gradient Noise`를 썼다는 것
	2. `UV`의 R값들을 이용한 `Color` 계산이 들어가지 않았다는 것
- 그래서 상대적으로 텍스쳐를 탄다. 


### 결론
- `AddScroll`로도 구현이 가능하다. 단, 텍스쳐를 탄다.
- `Trail`은 `U`값을 기반으로 한 밝기 설정이 추가로 들어가 있다. 그래서 어떤 텍스쳐를 받아도 방향 설정만 잘 해두면 일렁이는 효과를 낼 수 있다.
- **알파 클립 기능은 이런 경우에는 이용하지 않는 편이 더 좋아보인다.** 물론 케바케지만, 전체적인 알파 값들이 그렇게 밝지 않기 때문에 살짝만 건드려도 이펙트가 어색해보임.
- 불이 일렁이는 듯한 효과는 `Simple Noise`가 일단은 더 그런 느낌으로 보인다. 

![[Pasted image 20250821134243.png]]
> 왼쪽이 `Trail` 쉐이더를 이용한 `Quad`, 오른쪽이 `AddScroll` 쉐이더를 이용한 `Quad`이다.

## 셰이더 수정
- `Trail, AddScroll`에 노이즈에 `Power` 값을 곱하는 프로퍼티 추가
- ~~`AddScroll`의 경우 `Simple Noise`와 `Gradient Noise` 중 선택 가능하게 구현~~
	- `Simple Noise`를 선택하는 경우의 효과가 미미함. 추가적인 세팅이 들어가야 할 것으로 보여서 일단 `Gradient Noise`만 사용 가능하도록 유지함.

### Gradient Noise에 마젠타색이 나타나는 현상
- `Gradient Noise`에 `Power`를 연결했을 때 발생하는 현상.
![[Pasted image 20250821134001.png]]

- 이유)
	- **`Gradient Noise`는 -1 ~ 1 사이의 값을 갖는다.** 
	- 그래서 음수의 거듭제곱을 시도할 때, 예를 들어 `(-2)^5/2` 같은 연산도 발생할 수 있다. 음수의 제곱근은 실수 범위에서 존재하지 않기 때문에 `NaN`을 반환하게 된다.

- 해결)
	- `Gradient Noise`에 `Power`를 사용하려는 경우에는 `Remap`이나 `Saturate(0, 1 사이로 강제 제한)` 등을 연결해서 사용해야 한다.

## Wall 셰이더 만들기
- 텍스쳐의 좌우 스크롤 + 노이즈의 상하 스크롤로 텍스쳐에서 파티클들이 시작해서 서서히 위로 올라가면서 사라지는 듯한 효과를 주려고 함
- 생각보다 쉽진 않다. **텍스쳐의 경계와 노이즈의 경계가 부드럽게 녹아드는 느낌이 잘 안 나기 때문**임. `Lerp`라든가 `SmoothStep`이라든가 다 써보긴 했는데 잘 모르겠다. 스읍..
![[Pasted image 20250821152842.png]]
> 일단은 이런 느낌으로 마무리. 

> 인게임에서 보면 이런 느낌으로 들어갔다. 생각보다 괜찮다. 
> - 연기가 조금더 올라갔으면 하는 생각이 있다. 텍스쳐 모양만 어떻게 잡으면 구현이 될지도 모르겠다.
![[Area_CasterSkill_v1 1.gif]]

## MeteorSkill - 떨어지는 물체 구현
- 특사스의 3스킬이 모티브이긴 한데, Mesh로 구현해야 할까? Billboard로 구현해야 할까?
- `Mesh`로 검 모양을 만들고 모서리마다 윤곽선을 그리는 방식을 시도해봤는데, UV Map 만드는 부분에서 막혔다. **어디를 잘라야 전개도가 잘 그려지는지 감이 안 잡힘.**
- 그래서 텍스쳐만 만들고 빌보드 파티클을 이용하는 방식으로 구현한다.

![[Area_Meteor_v1.gif]]
> `MeteorSkill`은 타겟의 좌표를 정확히 추적하면서 y좌표만 +에서 -로 내리꽂는 방식인데, 이상하게 게임 화면에서는 살짝 뒷쪽으로 떨어지는 듯한 인상이 있다. 
> 근데 뚜렷한 해결법은 모르겠음.

**`Hit` 이펙트랑 `Area` 이펙트는 내일 해야겠다. 오늘 `Hit` 이펙트에 사용할 텍스쳐를 만들어봤는데 잘 모르겠음..**

## 기타 수정
- `Projectile`의 콜라이더 크기 `0.1`로 통일
	- 기존) `0.25` : 오브젝트에 부딪히기 전에 사라지는 것처럼 보여서.

- `MeteorSkill` 스크립트 수정
	- 메테오를 소환하는 로직 수정
		- 기존에는 2개를 만들어 놓은 다음 딜레이 후 1개씩 떨어뜨렸다면
		- 1개를 만듦 -> 딜레이 -> 다시 1개를 만드는 방식으로 수정함
	- `MeteorSkill` 자체는 `ScriptableObject`의 상속이므로 `Coroutine`의 실행이 불가능하다. `Operator`에 실행을 요청하는 방식으로 넣으면 됨. 이 때 `IEnumerator` 메서드는 `public`일 필요는 없는 듯?
```cs
	if (enemyIdSet.Add(enemy.GetInstanceID()))
	{
		// 코루틴은 Monobehaviour을 받는 객체에서만 실행 가능
		// 이 스크립트는 ScriptableObject의 상속임. 실행 가능한 객체에게 요청한다.
		op.StartCoroutine(CreateMeteorSequence(op, enemy));
	}
```


# 250820 - 짭명방

>[!done]
>- 이펙트 구현
>	- `Projectile_Orb_Heal_v1`
>- 기타 수정
>	- `Projectile` 히트 판정 시 메쉬 렌더러도 꺼짐

## VFX_Projectile_OrbHeal_v1
- 메딕이 힐할 때 던지는 투사체. 이게 있다는 걸 잊고 있었다.
- 아이디어 고갈이라 레퍼런스들을 찾아보는 중. 아트스테이션, 핀터레스트, 명일방주.

### 레퍼런스(명일방주)

- 안셀
![[Screenshot_20250820_134650.jpg]]

- 켈시
![[Screenshot_20250820_134749.jpg]]

- 힐이야(스킬OFF)
![[Screenshot_20250820_134801.jpg]]

- 힐이야(스킬ON)
![[Screenshot_20250820_134848.jpg]]

- 파피루스, 실론
![[Screenshot_20250820_134933.jpg]]
> 실론의 경우 Trail을 구성하는 요소가 1개가 아닌 것으로 보였음. 같은 텍스쳐가 여러 번 반복되면서 파도 효과를 내는 방식.

전반적으로 파티클이 두드러지는 느낌보다는 궤적이 더 두드러지는 느낌이 강함.
`TrailRenderer`처럼 궤적이 늘어지는 느낌은 아니었다. 

이것저것 텍스쳐를 구현해봤는데 다 마음에 들지 않는다. 기존에 있던 Trail 쉐이더를 이용함.

- 기존에 튜토리얼을 따라 만든 Trail 쉐이더는 `Trail Shader`에서 색상 설정을 해도 적용되지 않았다. `Color1, 2`만 머티리얼 단위로 인풋을 받았기 때문인데, `Vertex Color`를 곱하게끔 수정함.
	- `Trail Renderer`의 색상 설정 반영도 `Vertex Color`로 설정된다.

- 근데 이상한 버그?가 발생했다. 색깔 선택 기준으로 오른쪽 반원에 해당하는 색들은 잘 나타나는데 왼쪽 반원에 해당하는 색들은 채도가 높을수록 투명해보임
	- 알파 클립 때문에 발생한 문제 같긴 한데... 왜 색깔을 바꿨는데 투명해지는지는 잘 모르겠음. **이거 원인 찾으려고 하면 한나절 걸릴 거 같으니까 이번엔 그냥 넘어간다.** 알파 클립을 0으로 만든 뒤에는 다시 발생하진 않음
	- `Vertex Color`를 반영시키고 색깔도 반영해봤는데 역시 투명해보이는 효과가 있음. 그래서 셰이더는 원본의 그걸 유지한다.

- `Orb`의 형태가 메쉬여서, 충돌이 발생한 후에도 사라지지 않는 문제가 있었다. 이를 수정한 최종 버전.
![[Projectile_Heal_v1.gif]]
> - 이렇게 보니까 Hit이 좀 아쉬운 느낌이 있음. 
> - 레퍼런스를 본 의미가 있나 싶어지는....?

## VFX : Area_Caster2ndSkill 
- 각 변에서 올라오는 이펙트에만 효과를 주고 싶음
- 예전엔 이런 생각을 못했는데, 지금은 이런 생각이 든다 : **바닥에서 올라오는 일렁이는 효과는 `Trail`을 구현하는 거랑 큰 차이가 없지 않을까?** 

![[Pasted image 20250820172509.png]]
이런 느낌으로다가. `Quad`랑 `Trail02` 머티리얼로만 구현했다.
원래의 이펙트가 좌 -> 우 방향인데, `Quad`를 회전시키면 효과도 위처럼 자연스럽게 회전되어서 나타남.

이런 느낌을 전기 버전으로 하나 만들어두면 되지 않을까?

... 싶었는데 생각보다 쉽지 않다. 일단은 아래처럼 구현했음.
![[Area_CasterSkill_v1.gif]]

영역의 가장자리 부분, 즉 벽 부분이 뭔가 심심해서 아쉬운데 다르게 구현할 방법도 딱히 떠오르지 않는다. 능력 부족을 오랜만에 느껴버리는..

## 기타 수정
### Projectile.cs - 타격 시 메쉬 렌더러도 비활성화
- 기존엔 파티클 시스템에 메쉬를 넣어서 구현했는데, 메쉬를 직접 띄울 수 있는 상황도 종종 있어서 추가함.
```cs

	// Initialize()
	// 메쉬로 구현된 요소가 있다면 활성화
	if (renderers != null)
	{
		foreach (MeshRenderer renderer in renderers)
		{
			renderer.enabled = true;
		}
	}

	// HandleHit()
	// 메쉬 렌더러로 구현된 요소들이 있다면 이들을 모두 비활성화
	if (renderers != null)
	{
		foreach (MeshRenderer renderer in renderers)
		{
			renderer.enabled = false;
		}
	}
```



# 250819 - 짭명방

>[!done]
> - 기타 이슈 수정
> 	- `UnitEntity`의 콜라이더 관련 : `0.5, 1, 0.5`로 수정
> 	- 사망 애니메이션 : 자식 메쉬 렌더러가 여러 개일 경우도 고려
> 	- `Operator` 배치 시에 공격 범위 내에 적이 있는데 공격하지 않는 현상 수정
> 	- `Caster` 레벨당 공격력 수정(9.3(??) -> 2.3)

## 기타 이슈 수정

### UnitEntity의 콜라이더 관련
- `Projectile`이 목표물에 명중할 때, 생각보다 좀 일찍 사라지는 느낌이 있음. `Trail`이 사라지는 지점이 목표물에 닿지 않은 지점으로 보이기 때문에 눈에 띈다.
- 특히 `Operator`에게 공격이 들어갈 때가 그렇다. 이는 `Operator`의 콜라이더 사이즈가 `0.8, 1, 0.8`이기 때문임
	- 참고로 `Enemy`는 `.2, 1, .2`를 갖는다
- 일단 `Enemy`의 콜라이더 사이즈가 대체로 캡슐의 사이즈와 비슷해 보인다. 그래서 `Enemy`한테 공격이 들어갈 때는 그렇게 어색하게 보이지 않음.
- 반면 `Operator`에게 공격이 들어갈 때는 메쉬에 닿는 것처럼 보이지 않는데 타격 판정이 발생함

- `Enemy`가 2개의 타일에 걸치는 효과도 고려해야 함.

- 일단 **지금까지 구현한 모든 프리팹에 대해서는 `0.5, 1, 0.5`에서 출발해본다.**
	- 오퍼레이터가 타일 B에 있고, 적이 타일 A에서 B로 넘어갈 때 타일과 타일의 경계에서 저지당하는 느낌이 됨
	- 여전히 캡슐에 비해 피격 범위가 넓어보이긴 할 거임. 
	- 이거 수정하다가 아래 렌더러 이슈 수정하고 왔다. 갑자기 생각나서 ㅎㅎ;
	- 일단 `0.5`로 수정했을 때 대체로 괜찮아 보인다. **오른쪽에서 공격이 들어왔을 때만 살짝 어색해보이는 수준?** 
	- 다른 방법으로 생각난 것들이 아래의 요소들임.
		- 콜라이더를 하나 더 구현해서 판정
		- 기존 구현대로 거리 기반으로 타격 여부 계산하기 -> `Update`를 계속 돌려야 하므로 성능적인 이슈가 있을 수 있음
		- **일단 대체로 괜찮은 느낌이 나오고 있기 때문에 지금 상태를 유지해본다.** 

### 사망 애니메이션 여러 메쉬 렌더러에 대해 동시 재생
- `Enemy_Tanker` 처럼 여러 개의 메쉬 렌더러를 갖는 오브젝트의 사망 시, 모든 렌더러에 대해 사망 애니메이션이 재생되게 해야 함

- 기존 코드
```cs
Renderer renderer = GetComponentInChildren<Renderer>();

// 동일한 머티리얼을 사용하는 모든 객체에 적용되는 걸 막고자 머티리얼 인스턴스를 만들고 진행한다.
if (renderer != null)
{
	Material materialInstance = new Material(renderer.material);
	renderer.material = materialInstance;

	SetMaterialToTransparent(materialInstance);

	// DOTween 사용하여 검정으로 변한 뒤 투명해지는 애니메이션 적용
	// materialInstance.DOColor(Color.black, 0f);
	materialInstance.DOFade(0f, 0.2f).OnComplete(() =>
	{
		OnDeathAnimationCompleted?.Invoke(this); // 사망할 것임을 알리는 이벤트
		Destroy(materialInstance); // 메모리 누수 방지
		Destroy(gameObject);
	});
}
```
> `GetComponentInChildren`으로 구현되므로 1개만 찾는다. 여러 개일 경우에 문제가 됨.

- 수정 방향
	- 우선, 기존의 구현은 애니메이션이 끝나면 머티리얼 인스턴스와 게임 오브젝트를 파괴시키는 방식이었다.
	- **어떻게 `OnComplete`를 여러 개에 대해 실행시킬 수 있을까?** 가 핵심이겠음.
	- **`DOTween`에서는 `Sequence()`라는 기능을 제공**한다. 함수가 호출된 시점에 **애니메이션(트윈)들을 `Join`으로 등록**해놓으면 시스템이 다음 프레임에 시퀀스를 감지해서 실행시키는 방식임.
```cs
// 시퀀스로 만들어 여러 개의 애니메이션을 하나의 그룹으로 묶어서 관리한다
Sequence deathSequence = DOTween.Sequence();

List<Material> materialInstances = new List<Material>();

foreach (Renderer renderer in renderers)
{
	// 1. 머티리얼 인스턴스로 만들어 동일한 머티리얼을 사용하는 다른 객체에 영향을 주지 않게 한다
	Material materialInstance = new Material(renderer.material);
	renderer.material = materialInstance;
	materialInstances.Add(materialInstance);

	// 2. 투명 렌더링 모드로 전환
	SetMaterialToTransparent(materialInstance);

	// 3. 각 렌더러의 머티리얼에 대한 페이드 아웃 트윈을 생성
	Tween fadeTween = materialInstance.DOFade(0f, 0.2f);

	// 4. 시퀀스에 조인함. 
	deathSequence.Join(fadeTween);
}

deathSequence.OnComplete(() =>
{
	OnDeathAnimationCompleted?.Invoke(this);

	foreach (Material mat in materialInstances)
	{
		Destroy(mat);
	}

	Destroy(gameObject);
});
```

### Operator 배치 시에 공격 범위 내에 적이 있는데 공격하지 않는 현상
-  `Enemy`가 저지당하고 있는 상태에서 `Operator`가 배치됐을 때 저지당하고 있는 적이 공격 범위 타일 내에 있는데도 공격하지 않는 현상.
	- 정확한 원인은 몰라도 오퍼레이터가 공격 범위 내에 있는 적들을 제대로 캐치하지 못하는 현상이므로 관련 로직을 보면 될 듯.
	- 일단 `Enemy`가 밟고 있는 타일이 바뀌지 않는 상태여야 함

```cs
UpdateAttackableTiles(); // 방향에 따른 공격 범위 타일들 업데이트
RegisterTiles(); // 타일들에 이 오퍼레이터가 공격 타일로 선정했음을 알림
```
- `Deploy()`에서 실행되는 로직인데, 이 부분의 순서가 바뀌어 있었다. 이걸 바꿔보고

```cs
// 공격 범위 타일들에 이 오퍼레이터를 등록
private void RegisterTiles()
{
	foreach (Vector2Int eachPos in CurrentAttackableGridPos)
	{
		Tile? targetTile = MapManager.Instance!.GetTile(eachPos.x, eachPos.y);
		if (targetTile != null)
		{
			targetTile.RegisterOperator(this);
			
		}
	}
}
```
이 메서드에서 타일들에게 자신을 공격 범위로 삼은 오퍼레이터를 등록했는데, 여기에 추가로 타일들에서 오퍼레이터에게 자신을 밟고 있는 `Enemy`의 정보도 전달해야 할 것으로 보임.

```cs
if (targetTile != null)
{
	targetTile.RegisterOperator(this);

	// 타일 등록 시점에 그 타일에 있는 적의 정보도 Operator에게 전달함
	foreach (Enemy enemy in targetTile.EnemiesOnTile)
	{
		OnEnemyEnteredAttackRange(enemy);
	}
}
```

- 일단 이렇게 수정하니까 **비슷한 현상은 발생하지 않고 있다.**
- 추가로, **걸리적거렸던 것 중에 원거리 오퍼레이터를 배치했는데 왜 바로 공격하지 않지? 라는 게 있었다. 이것도 해결된 것으로 보임.** 





# 250818 - 짭명방

>[!done]
>1. 이펙트 구현
>	- `Hit_Explosion`
>	- `Area - Medic2ndSkill`
>		- `SkillRangeVFXController` 스크립트 수정 
>2. 이슈 수정
>	- `Distortion` 쉐이더의 이슈 
>		- 파티클 시스템에서 게임 뷰에 쓰일 때 검정색의 메쉬가 나오는 현상
>		- 해결할 필요가 없었다. 실제 게임에서는 투명한 메쉬가 잘 나옴. 몇 시간을 헤맸나..

## 이펙트 구현 - Hit_Explosion
- 남은 요소는 크게 2개였다 : 폭발 이펙트와 투명한 충격파 구현하기.

### 투명한 충격파
- `Heat Distortion`이라고 부를 수도 있는 요소인데, 그저께 찾아봤는데 답을 쉽게 얻지 못했다. 
- **센세께서 올려두신 영상이 있었다.** [# Unity VFX Graph - Heat Distortion Effect Tutorial](https://www.youtube.com/watch?v=CXCyVDEplyM)
	- 이 중에서는 쉐이더에 관한 내용만 가져가면 된다. URP와 HDRP의 내용이 다른 부분이 꽤 있기 때문에 URP에 있는 부분만 가져가면 됨.

- 프로젝트의 `Default Render Pipeline`에 해당하는 파일에서, **`Rendering` 탭에 있는 `Depth Texture`, `Opaque Texture`를 켜야 한다.**
	- 이게 꺼져 있으면 셰이더 그래프에서 `Scene Color`를 적용해도 아무 변화가 없음. 반대로 켜져 있으면 해당 메쉬의 뒷쪽이 그대로 투명하게 비친다. 알파값과는 무관함.

- **구현도 간단하다!** [[투명한 왜곡 효과]]에 정리.
![[Pasted image 20250818155210.png]]
- `Scene Color`를 이용하면 배경의 색을 그대로 보여준다. 여기에 변화된 `Screen Position`을 `Scene Color`의 UV 인풋에 보내면 해당 메쉬에는 왜곡된 배경이 나타난다.

#### 이 과정에서 발생한 이슈
- 씬 뷰에서는 투명하게 잘 나타나는데, 게임 뷰에서는 검정색으로 이펙트가 나타남
	- 어떻게 해결해야 하나 한참 찾아 헤맸는데, **실제 게임 & 게임 뷰에서는 아무 이상 없어서 해결하지 않아도 되는 이슈**였음. 몇 시간을 썼는데,,,
### 메쉬
- 블렌더에서 `Torus`를 만들었다. 버텍스 숫자를 좀 줄인 상태로.


- `ExplosionDebris`라는 폭발 흔적 텍스쳐를 하나 만들었고, `Crack01`도 텍스쳐 자체의 밝기? 불투명도를 크게 줄인 버전으로 수정했다.

![[Hit_Explode_v1 1.gif]]
연기가 너무 많나 싶기는 한데..? 일단 인게임 테스트.
여기서 검게 보이는 부분은 인게임에서는 투명해짐. 
- 연기랑 파티클이 너무 높게 올라가는 것처럼 보여서 추가로 수정

![[Hit_Explode_v1_Ingame.gif]]
이런 느낌으로 마무리해본다. gif 파일로 보니까 생각보다 더 괜찮은 것 같음.

## 이펙트 구현 - Area_Medic2ndSkill
- 이건 기존에 파티클 시스템으로 구현되어 있었기 때문에 이번엔 수정만 한다.
- 아마 `Area`마다 다르겠지만 `Medic2ndSkill`의 경우 파티클 1개를 띄워놓고 실행시키는 방식이었는데, 굳이 이렇게 구현할 필요는 없어보인다. `Quad`를 변에 세우고 셰이더만 적용하면 될 거임.

### SkillRangeVFXController 수정
- 그래서 기존에 이러한 타일 기반 범위 이펙트에 구현했던 `SkillRangeVFXController`도 수정한다. 
- 기존 : 파티클 시스템 기반
	- 오브젝트 기반으로 구현하고, 방향에 따라 이펙트를 실행하는 스크립트에서 해당 오브젝트에 파티클 시스템이 있는지를 검사해서 오브젝트를 활성화시키는 방식으로 수정함.
```cs
private void SetUpVisuals(Vector2Int position, HashSet<Vector2Int> effectRange)
{
	// 유효하지 않은 위치는 아무것도 표시하지 않음
	if (MapManager.Instance.CurrentMap == null || !MapManager.Instance.CurrentMap.IsTileAt(position.x, position.y))
	{
		return;
	}

	floorImage.gameObject.SetActive(false);

	// 방향에 따른 타일 검사로 이펙트 실행 여부 결정
	foreach (var direction in directions)
	{
		Vector2Int neighborPos = position + direction;
		bool showEffect = !effectRange.Contains(neighborPos) || !MapManager.Instance.CurrentMap.IsTileAt(neighborPos.x, neighborPos.y);

		var (effectObject, boundary) = directionEffects[direction];

		effectObject.SetActive(showEffect);
		boundary.gameObject.SetActive(showEffect);

		// 파티클 시스템으로 구현된 경우 파티클 시스템을 실행시킴
		ParticleSystem directionParticleSystem = effectObject.GetComponent<ParticleSystem>();
		if (directionParticleSystem != null)
		{
			PrewarmTrailAndPlayVFX(directionParticleSystem); // effect.Play() 포함
		}
	}

	// 언덕 타일 위치 보정
	Tile? currentTile = MapManager.Instance.GetTile(position.x, position.y);
	if (currentTile != null && currentTile.data.terrain == TileData.TerrainType.Hill)
	{
		transform.position += Vector3.up * 0.2f;
	}
}
```

![[Area_Heal_v1.gif]]
> 언덕 타일에서 살짝 띄워져보이는 게 어색해보이긴 한다. 수정해야 할까는 고민 대상인 듯.

일단 오늘은 여기까지!!


# 250816 - 짭명방

> [!done]
> - 이펙트 구현
> 	- `VFX_Projectile_Missile_v1`
> - 기타 이슈 수정


## 이펙트 구현 - Projectile_Missile
- `Artillery`의 평타에 사용될 이펙트.

### Mesh
![[Pasted image 20250816135720.png]]
Gemini에게 Mark Seam을 어떻게 해야 할지를 물어봤다.

- `MarkSeam`은 절제선을 어디로 설정하는가라고 생각하면 쉽다고 함. 해당 엣지들에 가위질을 했을 때 3D 도형을 2D로 펼칠 수 있는가를 생각해보면 된다.
> 물론 말은 쉽다. ㅋㅋㅋㅋㅋ 처음엔 반구와 원기둥 사이의 경계면에만 넣었는데, 추가로 원기둥의 옆면 + 바닥면까지도 포함해야 했음.

- `Mark Seam`을 설정했다면 `Unwrap`을 할 때 `Smart UV Project` 대신 기존에 사용하던 기본적인 `UnWrap`으로 풀어내면 된다. 
> 물론 이 프로젝트에서는 저 메쉬는 단색으로 구현할 거라서 UV Map을 추출해서 사용할 일이 없겠지만, 만들어놨다면 UV Map과 함께 저장해두는 게 좋겠음.

- 원기둥 옆면에 뭔가 노랑/검정 같은 이미지 추가해서 조금 더 눈에 띄게 하고 싶어서 보는데 어디가 윗면이지? ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ
	- UV Map 기준 오른쪽이 윗면이다. ㅋㅋㅋㅋㅋㅋㅋ

![[Missile01.png]]

> 이런 이미지를 만들었음.
![[Pasted image 20250816150619.png]]
 이런 느낌으로 들어간다. 완전 처음 해본 것 치고는 괜찮은 듯.

이걸 추가하니까 머리 부분에 이펙트도 하나 추가해보고 싶다. 기존에 `ProjectileMesh`가 있었고, 이것의 Uv Map이 가운데로 모이는 모양인 걸 참고해서 가운데 부분에만 이미지가 있는 텍스쳐를 하나 쪄봄. `EffectTextureMaker`를 사용해서 만들었다.

![[Projectile_Missile_v1.gif]]

- 추가로 전체적인 파티클의 사이즈들을 줄임
- 여기서 타격 이펙트도 다시 만져볼 계획.

## 이펙트 구현 - Hit_Explosion
- 위 투사체 gif 파일에서 나오는 폭발 이펙트 대신, 새로운 폭발 이펙트를 만들어본다.
- 이런 게임에서 쓰기 좋은 이펙트는 아닌 것 같지만, 투명하지만 배경이 왜곡되는 효과를 구현해보고 싶어서 그걸 테스트해보려고 한다. 사실 그거 외에도 할 건 많지만.
	- 일단 튜토리얼 따라가보긴 했는데 셰이더에 적용이 되지 않는다? 보류.
- 일단 폭발 자체와 투명한 바닥 충격파 부분을 제외한, 현재 구현할 수 있어 보이는 것들은 구현해두겠음.

![[Hit_Explode_v1.gif]]
> 일단은 이 정도로 구현해뒀고, 여기에 추가할 사항으로는 아래 2가지가 있음.
> 1. 입체적인 폭발 이펙트
> 2. 바닥의 ShockWave는 투명하며 배경을 왜곡시키게끔



## 추가 수정
- `Projectile` 생성 위치 : `Operator`가 보는 방향 + 0.5에서 0.25로 줄임. 위 움짤을 보면 너무 앞에서 움직이는 느낌이 있다. 


# 250815 - 짭명방
>[!done]
> - 이펙트 구현
> 	- `vfx_Projectile_Molotov_v1`
> - 이슈 수정
> 	- `Enemy_Ranged`가 새롭게 배치된 `Operator`을 공격하지 않는 현상
> 	- 기타 이슈들

뭔가 적당한 타협이 됐다. 

![[Projectile_Molotov_v1.gif]]

- `Molotov`를 `Mesh`로 구현하는 게 더 나아보이긴 한다..
	- 메쉬로 구현하면 메쉬의 특정 위치에 `Fire` 파티클을 붙일 수 있기 때문인데, 지금은 일단 파티클시스템으로 메쉬 생성하고 이를 감싸는 이펙트들을 구현하는 방식이 됐음.
	- 불 위치가 조금 어색해서 메쉬 대비 +z 쪽으로 위치를 수정했다.

- `Trail` 자체는 `Gabriel Aguiar` 센세의 튜토리얼을 따라 셰이더를 만들고 텍스쳐도 이런 모양을 만들어서 넣었는데, 막상  유니티에서는 모양은 잡히지만 내용물에 알파값이 잡히지 않고 전부 다 흰색으로 인식하는 현상이 있다.  왜 그런 건지 모르겠음.. 지금 모양도 물론 만족스럽긴 하지만, 이 이슈는 한 번 생각해볼 필요는 있어 보인다.
![[ForObsidian_Trail03.png]]
> 이 부분은 궁금해서 더 자세히 테스트를 해봤는데, 아무래도 빛산란에 의한 효과인 듯?
> 애초에 **텍스쳐 자체의 알파값, 혹은 밝기가 그렇게 높으면 안되는 것 같음. 대부분 50 언더로 해야 할 듯?** 낮은 알파값들로 텍스쳐를 만들고, 빛산란으로 더 많이 겹쳐진 부분을 더 밝게 해야 할 듯.
> 강의에서도 여러 번 나왔던 내용이지만, 알파값을 그렇게 높게 설정하지 않고 작업했다. 높아봐야 30% 정도? 
> 뭐가 어디까지 맞고 아닌지 모르겠다!!!!! 알파를 겁나게 낮춰서 넣어도 뭔가뭔가 애매한 느낌이다. 이런 걸 보면 겹쳐 그리는 게 중요한 건가?

## Enemy_Ranged가 공격 몇 번 후 공격하지 않는 현상
- 딱 5번 하고 공격하지 않는다. 왜?
- 이거는 다른 현상일 수도 있다 : **`Operator`가 `Enemy`의 공격 범위 내에 배치됐을 때, `ColliderEnter`가 동작하지 않는 현상일 수 있음.**
- 후자가 맞아보임. 
- 이거 예전에 구현했던 거 같은데 아니었나보다?
	- **새롭게 배치된 유닛 시점에서만 처리했고, 기존 유닛 입장에선 처리하지 않은 듯 하다.**

- `DeployedUnitEntity`의 배치에 관한 static event를 추가하고, 이를 `EnemyAttackRangeController`에서 감지한다.
```cs
private void HandleNewlyDeployed(DeployableUnitEntity target)
{
	if (owner == null || !enabled) return;

	BodyColliderController targetColliderController = target.GetComponent<BodyColliderController>();
	if (targetColliderController != null)
	{
		Collider targetCollider = targetColliderController.BodyCollider;

		if (targetCollider != null)
		{
			// 두 콜라이더가 겹치는지 검사 수행
			bool isOverlapping = Physics.ComputePenetration(
				attackRangeCollider, transform.position, transform.rotation, // 이 콜라이더의 정보
				targetCollider, targetCollider.transform.position, targetCollider.transform.rotation, // 타겟 콜라이더의 정보
				out Vector3 direction, out float dist // 출력 변수 : 사용하지 않음
			);

			if (isOverlapping)
			{
				Debug.Log("새롭게 배치된 유닛이 Enemy의 콜라이더 내에 있어서 공격 대상으로 추가");
				owner.OnTargetEnteredRange(target);
			}
		}
	}
}
```

위의 과정을 구현하면서 이런 생각이 들었다 : `Operator` 입장에서 `enemy`가 생겼을 때도 비슷한 현상이 일어나지 않을까?

- 근데 `BodyColliderController`라는 모든 엔티티에게 있는 요소는 자신이 활성화된 시점에 자신과 겹친 콜라이더를 체크하는 로직을 넣어놨다. 
- `Enemy`의 경우 이 로직에 의해 자신이 생성된 시점에 자신과 겹친 타일과의 충돌 트리거가 발동하고, 해당 타일을 공격범위로 하는 오퍼레이터에 의해 공격 대상으로 지정될 수 있다. 이것과는 다른 로직임.
- 결론은 기억력 이슈지만, 충분히 헷갈릴 수 있는 지점이었다고 생각함. 해결 완료.


## 기타 이슈
1. `Molotov` 투사체의 판정이 발생하지 않음
	- `Rigid Body`, `Sphere Collider`을 넣지 않아서 발생한 문제

2. `Projectile_Arrow`의 `Trail`이 1번 생성된 이후 사라지는 현상
	- **`Trail Renderer`의 `AutoDestruct`가 켜져 있으면 파괴**되기 때문이다. **오브젝트 풀을 이용할 거라면 저 기능은 사용하지 않는 게 좋겠다.**
3. 저지 로직도 이상하게 동작하는 듯?
	- 보통 한 군데서 버그가 생기면 다른 곳에서 이어질 가능성이 있다. 2번부터 체크해봄.



# 250814 - 짭명방

>[!done]
> - 이펙트 구현
> `vfx_hit_fire_v1`

>[!WIP]
>- `Projectile_Enemy` 
>	- 메쉬는 만들었다. 천을 애써서 넣었지만 인게임에선 잘 안 보이는 게 함정.
>	- 막힌 지점은 투사체의 불 이펙트. 텍스쳐 시트의 애니메이션 기능을 이용하자니 뭔가 어색하고 불 파티클도 뭔가 애매한 느낌이고. 좀 고민되는 지점.


## 시작 전
- `Enemy` 투사체, `Artillery` 투사체 및 폭발 이펙트를 구현하게 될 듯
- 전부 화염 관련 이펙트들로 구현할 듯. 
	- `Enemy`의 경우 `Orb`의 팔레트 스왑만을 써도 되겠지만 명방 초반의 리유니온 원거리 적의 화염병 같은 게 있었다. 그런 걸 구현해보고 싶음.

## VFX_Projectile_Molotov

### 화염병 메쉬

![[Pasted image 20250814140444.png]]

유리병은 쉽게 만들 수 있는데, 천을 어떻게 얹느냐가 궁금했던 부분. 검색해보니 생각보다 쉬웠다. 물론 말이 생각보다 쉬웠다는 거고 처음이라서 1시간 넘게 걸림.

1. `Plane`을 만듦. 물리엔진과 애니메이션을 이용해 구부릴 것이므로 `Subdivide`를 많이 넣어준다.
2. 화염병 안에 `Plane`이 들어가게끔 배치시킨다. `Plane`의 가장 아랫 부분을 고정한다.
	- 고정 방법 
		- 가장 아래 버텍스들을 잡고 `Data - Vertex Groups`에 새로운 그룹 `Pin`을 추가한 후 `Assign`
3. `Physics - Cloth` 을 켠다. 2번에서 설정한 `Vertex Group`은 `Shape`의 `Pin Group`으로 넣는다. 
4. 이전에 만들었던 유리병의 `Collider`를 켠다. 
5. `Object Mode`로 놓고 애니메이션을 재생시킨다. 원하는 장면이 나온 시점에서 프레임을 멈춘다.
6. 이전에 적용했던 `Modifier` 들을 적용시킨다. 

다만 `UV Map`이 문제이긴 한데, 지금처럼 디테일하게 들어가지 않고 모형 정도만 필요한 경우에는 크게 상관이 없다. 
더 정교한 작업이 필요하다면 이전에 블렌더 강의에서 봤던 `Mark Seam`을 이용해서 특정 부분들을 자르는 방식을 이용하지만(실사 소주병을 따라 만든다든가..) 지금 같이 메쉬만 필요하고 텍스쳐는 단색으로 처리하려고 하는 경우에는 `Smart UV Project`가 유용할 수 있음.

![[Pasted image 20250814142220.png]]

### 불 효과
- 이게 생각보다 어렵네... 자연스러운 느낌이 안 나서 애 먹는 중.
- 병 자체의 화염 효과는 살짝 미루고 일단 다른 것들부터 구현함
- **으아아 너무 어렵다 일단 보류**

## vfx_hit_fire_v1
- 불 이펙트가 타격했을 때의 효과를 구현해본다. `hit_ice`를 응용해서 만들어봄.
![[Hit_Fire_v1.gif]]
구름 텍스쳐는 아주 요긴하게 써먹고 있다.

> 추가 수정) 
> 1) `Smoke` 파티클들의 경우 y포지션은 `-0.25` 정도로 잡는 게 적당하다. `-0.3` 이하로 내려가면 피격당한 객체의 높이가 `0.3`인 애가 있어서 타일이랑 겹쳐보이는 문제가 발생함
> - 사실 이거는 월드의 오브젝트와 이펙트가 겹쳤을 때 **이펙트가 먼저 보이면 되긴 한다.** `Opaque`랑 `Transparent` 간의 순서로 이미 적용돼야 하는 걸로 알고 있는데 안 되서 모르겠음.
> 2) `Start Delay`를 넣고 싶다면 조심스럽게 접근해야 한다. 적은 움직이고 있기 때문에 이미 지나갔는데 연기가 바닥에서 솟아오르는 건 어색해보일 수 있음. 그래서 일단 `Delay`만 `0.3` 정도로 줄여놨음.

만족스럽진 않은데 일단 여기까지. 



# 250813 - 짭명방

>[!done]
>- 이펙트 구현
>	- `Arrow_Hit`
>	- `Caster` 평타 : `vfx_Projectile_Orb_v1` 작업
>- 이슈 / 수정 사항
>	- `Projectile`의 `Collider` 관련 이슈 수정
>	- `Projectile`에 `needToRotate` 필드 추가 : 회전이 필요한 파티클만 체크

## 이펙트 - VFX_Hit_Ice
- `Sniper`의 평타가 들어갈 때마다 실행될 이펙트.
![[Hit_Icy_v1.gif]]
- 텍스쳐 
	- `EffectTextureMaker`의 `Cross`
	- 가운데가 비어 있는 연기 효과는 `Corona`
	- 연기는 기존에 `Arrow`를 구현하는 과정에서 썼던 걸 다시 썼음.

일단은 이런 느낌 정도로 마무리.
인게임 테스트도 꽤 자연스럽다. 

>[!note]
>- `Stretched Billboard` 설정의 파티클이 날아가다가 궤적이 짧아지는 효과 같은 걸 구현하는 방법
>	- `Velocity over Lifetime`의 `Speed Modifier`을 `Curve`로 구현

## 이펙트 - VFX_Projectile_Orb
- `Sphere` 메쉬를 쓰지 않고 구현할 수 있는가?를 생각해봤는데 솔직히 구현하는 게 훨씬 나을 듯
- 블렌더에서 만드는 건 쉽다. `UV Sphere`를 만들면 `UV Map`도 깔끔하게 뽑히는 구가 나온다. 
	- 대신 이 점은 유의해야 함 : 프로젝트에 사용하는 구


- 메쉬에 사용할 쉐이더 구현
- 어떻게 구, 오브 효과를 위한 쉐이더를 만들 수 있을까?
- 이건 [선생님의 강의](https://www.artstation.com/artwork/NyKnwJ)가 있으니 이걸 따라가본다. 
	- 강의에서는 텍스쳐를 별도로 `MaterialMaker`를 이용해서 만들었는데, `Voronoi` 의 경우 유니티 쉐이더 그래프에서도 지원하는 기능이다. `Tiling And Offset`의 `Tiling`을 줄이면 늘어진 보로노이 효과를 넣을 수 있음.

- 일단 `Orb` 기초를 놓고, `Arcane` 버전을 따로 구현했다. 색놀이 수준이지만.

![[Caster_Attack_v1.gif]]

> UI에 이상한 밑줄 그이는 거는 GIF 파일에서만 보이는 현상이다. 인게임에선 안 나타남.

1. 저기서 `Hit_Lightning` 부분은 `Hit_Arcane`을 따로 구현할지 아니면 그냥 쓸지 고민은 되는 듯?


## 이펙트 - VFX_Hit_Arcane
- 임팩트 프레임같이 검은색이 가운데에 오고 흰색이 밖에 오는 구성으로 겹칠 수 없나? `Alpha Blended`로는 안되는 것 같다. 그냥 `Opaque`로 쳐야 하나?

- 일단은 그냥 진행.
- 위에서 생각한 거 대신 `Particle System` 자체에 있는 `Trail`을 이용해서 모양을 만드는 방식으로 만들었다. 뭔가 이거저거 공은 들어갔고 분명 새로운 걸 시도했는데, 했던 거 재탕하는 느낌이라 석연치 않은 느낌도 조금 있다. 그래도 이렇게 조금씩 늘어가는 거 아닐까?

![[Hit_Arcane_v1.gif]]
> 가운데 모양은 파티클 시스템의 `Trail`과 `Velocity over Lifetime`의 `Orbital`을 이용했다. `World`좌표,  `Orbital y`로 구현함. 파티클 자체는 투명하며, `Trail` 자체가 색을 갖는 식이다.
> 노란색을 넣은 근거는 `Orb`의 흰색을 만드는 요소가 보라색 + 노란색이기 때문이다. 거의 보이지 않지만, 그래서 궤적 파티클도 노란색으로 남겨뒀음.

일단은 이 정도로 만족하고 다음으로 넘어가면 될 듯. **오늘은 여기까지!**



## 이슈 / 수정사항

### 어제의 이슈

> [!note]
> - `Projectile`을 `Collider` 기반으로 변경했는데, `nullReferenceException`이 뜨는 현상

```cs
	// 충돌한 오브젝트가 내 타겟인지 확인
	BodyColliderController hitUnitCollider = other.GetComponent<BodyColliderController>();
	
>   if (hitUnitCollider != null && // 다른 콜라이더는 거름
		hitUnitCollider.ParentUnit == target)
	{
		// OnReachTarget() 대신 새로운 공용 함수 호출
		HandleHit(target.transform.position);
	}
```
> `hitUnitCollider`의 `null`체크 부분이 들어가지 않아서 발생했던 이슈였다.

### 의문점
- 근데 **오류 로그에서 가리키는 지점은 두 줄 위인 hitUnitCollider를 정의하는 부분**이었는데 왜 저걸로 해결되는지는 모르겠음. 아래의 `hitUnitCollider == target`에서 오류가 발생한다고 적어놔야 맞지 않나?

- AI에게 물어보니 크게 2가지로 정리되는데 
	1. **버그를 더 쉽게 찾아주기 위해 `hitUnitCollider`를 선언한 부분을 찍어준다**는 얘기.
		- 만약 오류 발생 지점을 찍는다면 `hitUnitCollider`가 `null`인지 `target`이 `null`인지 이중으로 찾아봐야 한다는 얘기.
	2. **컴파일러에서는 `hitUnitCollider` 선언 -> 사용하는 부분을 하나의 흐름으로 묶어서 처리한다**는 것. 그래서 흐름의 시작점인 선언 부분을 오류 로그로 찍어준다는 것이다.

뭔가 시원하게 알았다는 느낌은 아니긴 하다. 그냥 이렇게 찍어두고 넘어감. 

## 이슈 발견
- `Hit_Lightning` - 피격체의 `Rotation`에 의해 번개가 떨어지는 지점이 변하는 현상이 있음.
	- 근데 인게임에서는 원하는 위치에 잘 나타나서 굳이 수정 안 해도 될 듯?

# 250812 - 짭명방
>[!done]
>- 주로 `Projectile` 스크립트의 수정과 리팩토링을 진행했다.
>1. `Projectile`이 사라진 후에 파티클 남기기
>2. `Projectile` 구조 - 콜라이더 기반으로 변경하기
>	- 단 지금의 "마지막으로 알려진 위치 기반" 로직은 유지해야 한다. 적이 죽었을 때 이미 생성된 투사체는 적의 마지막 위치까지 날아가서 사라지도록 함.
>3. 기타 수정 사항 
>- `Operator`에서 `Projectile`의 생성 위치 수정
>- `Muzzle` 이펙트 오브젝트 풀링 
>

## Projectile 사라진 후에 파티클 남기기
1. `mainParticle.Stop(false)` 적용해봄
	- 안 됨. 
	- 1번째 파라미터는 `withChildren`인데, 파티클의 실행을 중단시킬 때 자식 파티클의 실행도 중단시키는가? 인데, `false`로 지정해도 안 되는 듯.

2. 메인 파티클이 사라지는 시점에 부모-자식 관계를 끊은 다음 메인 파티클의 실행을 중단시키고 오브젝트 풀로 돌아가기 전에 다시 부모 - 자식 관계를 설정하기

...지금 보니까 스크립트 바꿔놓고 인스펙터에서 할당 다시 안해놨다. ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 그리고 `IEnumerator`로 메서드 작성해놓고 `StartCoroutine`으로 안 돌리고 그냥 실행시켰다 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ

- 아무튼 위 요소들을 다 수정하고 다시 테스트해봤다. 1번과 2번이 완전히 구분되는 개념은 아니다. 자식 파티클 중에도 실행되어야 하는 파티클이 있고, 실행되지 말아야 하는 파티클이 있기 때문이다.
- `TrailRenderer`는 크게 상관 없을 것 같다.  오브젝트가 꺼지지 않는 이상 `Trail`은 남는 듯.

### 수정 완료
- 이제 `Projectile`에는 `mainParticle` 외에도 남겨야 하는 파티클을 별도로 구현한다.
```cs
[Header("VFX")]
[SerializeField] private VisualEffect? vfxGraph;
[SerializeField] private ParticleSystem? mainParticle;
[SerializeField] private List<ParticleSystem> remainingParticles; // mainParticle이 사라지더라도 표시되는 파티클
```

- 그리고 파티클이 사라질 때 이 코루틴 메서드를 실행한다.
```cs
private IEnumerator ReturnToPoolAfterSeconds(float seconds)
{

	if (vfxGraph != null)
	{
		vfxGraph.Reinit(); 
	}
	else if (mainParticle != null)
	{
		// 부모-자식 관계를 일시적으로 끊어서 부모 파티클의 실행을 멈춰도 자식 파티클은 계속 재생되게 함
		foreach (var ps in remainingParticles)
		{
			ps.transform.parent = null;
			ps.Stop(true, ParticleSystemStopBehavior.StopEmitting); // 파티클의 추가 생성을 막음
			// ps.Play() // 굳이 필요 없어서 주석 처리해봄
		}

		// 남기지 않아도 되는 파티클들 모두 제거
		mainParticle.Stop(true, ParticleSystemStopBehavior.StopEmittingAndClear);
	}

	yield return new WaitForSeconds(seconds);

	// 다시 부모 파티클에 할당
	foreach (var ps in remainingParticles)
	{
		ps.transform.parent = mainParticle.transform;
	}

	ObjectPoolManager.Instance!.ReturnToPool(poolTag, gameObject);
}
```

- 추가로 이전처럼 투사체가 바로 사라지는 게 아니기 때문에 판정에 대한 플래그도 하나 설정해준다.
```cs
private bool isReachedTarget = false;
```
> `Initialize`에서 `false`로 초기화해주고, `OnReachTarget`이 동작하면 `true`로 바뀐다. `true`로 바뀌면 `OnReachTarget`이 실행되지 않음.

## Projectile 판정 콜라이더 기반으로 변경
- 단 기존의 `Update` 문에 있던 거리 기반 계산 로직은 남겨둔다. 투사체가 날아가는 중에 적이 사라지는 경우도 다뤄야 하기 때문이다.
```cs
private void OnTriggerEnter(Collider other)
{
	// 이미 목표에 도달했거나, 타겟이 없으면 무시
	if (isReachedTarget || target == null) return;

	// 충돌한 오브젝트가 내 타겟인지 확인
	BodyColliderController hitUnitCollider = other.GetComponent<BodyColliderController>();
	if (hitUnitCollider.ParentUnit == target)
	{
		// OnReachTarget() 대신 새로운 공용 함수 호출
		HandleHit(target.transform.position);
	}
}
```

## 기타 수정 사항
### `Projectile`의 생성 위치 수정
```cs
// Vector3 spawnPosition = transform.position + Vector3.up * 0.5f;
Vector3 spawnPosition = transform.position + transform.forward * 0.5f;
```
> 오퍼레이터가 보는 방향 쪽에서 생성. 기존엔 오퍼레이터보다 "위"에서 생성되었는데 화살의 경우 시각적으로 어색해보여서 수정함.

### Muzzle 이펙트가 생성되기만 하고 풀로 되돌아가지 않음
- 처음엔 귀찮아서 `Operator`에서 `Muzzle` 실행시킨 다음 1초 후에 풀로 되돌렸음
- 근데 `Muzzle` 개념은 `Enemy`에서도 쓸 거잖아? 그러니 `MuzzleVFXController`을 별도로 구현하는 게 낫다.
```cs
using UnityEngine;
using System.Collections;
using UnityEngine.VFX;

// 오브젝트 풀로 돌아가는 기능만 수행함
public class MuzzleVFXController : MonoBehaviour
{
    private string poolTag;

    [Header("Settings")]
    [SerializeField] private ParticleSystem ps;
    [SerializeField] private VisualEffect vfxGraph;
    [SerializeField] private float vfxLifetime = 1f;

    public void Initialize(string poolTag)
    {
        this.poolTag = poolTag;

        if (ps != null)
        {
            ps.Play(true);
        }
        else if (vfxGraph != null)
        {
            vfxGraph.Play();
        }

        StartCoroutine(WaitAndReturnToPool(vfxLifetime));
    }

    private IEnumerator WaitAndReturnToPool(float duration)
    {
        yield return new WaitForSeconds(duration);

        ObjectPoolManager.Instance.ReturnToPool(poolTag, gameObject);
    }
}
```
> 사실 오브젝트 풀에서 스폰 -> 컴포넌트 얻기 -> Initialize하기 여서 뭔가 부자연스러운 느낌은 있는 듯 한데, 대안도 없다.

### OnTriggerEnter가 null로 뜨는 이슈
```cs
    private void OnTriggerEnter(Collider other) {
    }
        // 충돌한 오브젝트가 내 타겟인지 확인
        BodyColliderController hitUnitCollider = other.GetComponent<BodyColliderController>();
```
> 위아래는 대충 생략. 저기서 `null` 예외가 발생 중.

근데 타격 판정 자체는 잘 발생했음.  **이거 마무리 못했음!!**

# 250811 - 짭명방


>[!done]
>- 이펙트
>	- `Projectile - Arrow`
>	- `Muzzle_v1`
>- `Projectile` 스크립트 수정

## Projectile - Arrow

### 김이 서리는 효과
- **어제 넣으려다가 못 넣었던 김이 서리는 효과**에 대해서 다시 구현해봤다. 
	- 레퍼런스들을 찾아봐도 너무 차가워서 김이 나는 듯한 효과는 종종 보이기도 하고, 어떻게 구현했는가도 보면서 판단해보기로 함.                                               
- 텍스쳐를 직접 그리진 않았고 `EffectTextureMaker`라는 웹 도구가 있어서 이걸 이용해서 `3x3` 텍스쳐 시트를 만들었다.
- 어제는 애니메이션으로 구현했는데 뭔가 어색해보였음. 
- 스프라이트 시트에서 랜덤한 텍스쳐 하나를 집어서 사용하는 방식이 더 있어보인다.
	- 텍스쳐 자체를 그렇게 밝게 가져가지 않기 때문에 쉐이더와 함께 사용하면 어느 정도 투명하게 나타난다. 
		- `Rotation`을 랜덤으로 주기
		- 서서히 사라지는 효과를 구현하기
		- 서서히 커지게 하기
		- 생성된 자리에서 크게 벗어나지 않기(이거는 케바케일 수 있음)
> 결과물은 아래에서 한꺼번에 정리

### 메쉬 다듬기?
- 어제는 메쉬를 썼기 때문에 `Opaque`를 적용해야 한다는 고정관념이 있었음
- 근데 꼭 `Opaque` 셰이더를 써야 할까? 단순 이펙트니까 `Transparent` 셰이더를 써도 된다. 사실은 이 쪽이 더 권장될 수도 있다. 화면에 잠깐 나타났다가 사라져야 하는 요소니까.
- 또, `Opaque` 셰이더를 쓰면 거의 필연적으로 `Lit`을 쓰게 되는데 이 경우 메쉬의 회전을 구현할 때 그림자가 지는 이슈가 있는데 이게 보기 좋은 요소는 아니다.

- 그러면 어제 구현한 `UV Map`을 보면서 텍스쳐를 새로 그리는 게 나을지도?
	- 시도해봤다. 화살의 꼬리 부분만 조금 더 보이는 식으로.
	- 근데 크게 눈에 띄지 않아서 **텍스쳐를 할당하지 않는 방식으로 바꿈.** 

![[Projectile_Arrow_v1 1.gif]]
> 일단 지금까지의 구현은 이렇다.

### Trail 구현하기

#### 텍스쳐 구현

>[!note]
>- 프로크리에이트에서 `Seamless` 이미지를 만들려면
> 1. 만들려는 이미지의 가로 폭 2배의 캔버스를 준비
 >2. 그리기 가이드 - 좌우 대칭을 켜고 그리기 도우미도 켠다
 >3. 오른쪽 캔버스에 원하는 텍스쳐를 구현(왼쪽에도 좌우 대칭으로 들어감)
 >4. 전체를 가로로 4분할한다고 하면, 2, 3번째 부분만 사용할 거다.
>	- 좌우대칭이므로 3번째 부분의 오른쪽 경계와 2번째 부분의 왼쪽 경계가 자연스럽게 만남.
>
>내 경우 4번을 진행한 다음 텍스쳐를 다듬었는데, 작업은 자르기 전의 상태에서 하는 게 더 나을 듯.  잘라낸 다음에 추가로 작업하는 경우 `빛 산란` 등에서 `Seamless`가 깨질 가능성이 있어보인다. 경계 부분을 특히 조심스럽게 다뤄야 함.


...사실 Krita를 쓰는게 더 간단할지도. 

- `Trail Renderer`는 조금 더 공부해볼 필요는 있겠다. 파티클 시스템 대비 제약이 좀 있어 보인다. 예를 들면 메쉬를 넣지 못하는 걸로 보임.

![[Projectile_Arrow_v1 2.gif]]

> 일단 `Projectile_Arrow`는 이 정도까지만 작업해두겠음. 너무 시간을 많이 먹는 감이 있다.

## Projectile 스크립트 수정
- 기존에 `VFXGraph`용으로만 작성되어 있었기 떄문에 여기서 수정함
- 지금 돌아보면 예전 스크립트는 너무 복잡하게 작성된 감이 있다. 

![[Pasted image 20250811170225.png]]
ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 문워크로 간다

```cs
lastKnownPosition - transform.position
```
> 방향을 설정하는 부분인데, **벡터의 뺄셈 `B-A`는 `A`가 `B`를 보는 방향**이다. 기존엔 반대로 설정되어 있었음. 

이펙트의 크기가 크기 때문에 줄이고, Trail도 화살의 머리부분부터 나오게 해도 이펙트가 괜찮아 보여서 그렇게 수정.

- 추가 수정 중...
1. 타겟에 도달했을 때 잠깐의 유예기간을 준다. 남는 이펙트나 Trail 등이 바로 사라지는 게 어색해보임.
2. 1.과 함께 타겟에 도달했을 때는 파티클의 생성을 막는다.
```cs
	// 새로운 파티클의 생성을 막음
	if (vfxGraph != null)
	{
		vfxGraph.Stop();
	}
	else if (ps != null)
	{
		ps.Stop();
	}

	// 공격자가 사라졌거나, 풀이 제거 예정인 경우
	if (shouldDestroy)
	{
		Destroy(gameObject, WAIT_DISAPPEAR_TIME);
	}
	else
	{
		ReturnToPoolAfterSeconds(WAIT_DISAPPEAR_TIME);
	}
```

> [!warning]
> 다른 이펙트 구현하기 전에 이 부분은 어떤 원리로 동작시킬 수 있는지 알아봐야 할 것 같다. 
> - **투사체 파티클이 사라진 다음에 다른 파티클 시스템들을 어떻게 유지시켜야 하는가? 이를 위해 파티클 시스템은 어떻게 구성해야 하는가?**

## Muzzle_v1 구현
- 이 부분은 강의에서 구현한 것들이 있으니까 메쉬랑 텍스쳐는 그대로 사용하겠음

![[Muzzle01_v1.gif]]
> 뭔가 완전 만족스러운 그림은 아닌데 그대로 사용함
> 너무 화려할 필요도 없다. 평타 개념이라서..


## Muzzle 이펙트는 Operator에 반영해야 함
- `CombatVFXController`로 `Source To Target`으로 설정하면 될 듯.
- 원거리 공격할 때 `Muzzle` 이펙트가 있는지 체크하고 있다면 실행시켜야 함. 기존엔 `Muzzle` 이펙트 실행하는 부분을 구현하지 않았기 때문에 추가.
	- `OperatorData`에 프리팹을 받는 필드 하나 추가
	- 이 구현은 오브젝트 풀과 관련된 설정들도 모두 들어가야 함.

- 중간에 태그 적용 안되는 문제 있었음
	- 태그 이름에 들어가는 값을 `ProjectileTag`을 복붙해서 써놓고 `Projectile`을 `Muzzle`이라는 문자열로 바꾸지 않아서 발생했던 문제ㅋㅋ


- 실제로 게임에 넣어보니까 `Muzzle`에서 튀는 파티클도 좀 과한 느낌이 있어서 제거.
- `Muzzle`의 크기만 줄이고 오늘 내용은 마무리함.
- 일단 내일은 화살만 없애고 연기나 파티클 등 월드에 남는 부분들을 어떻게 남길 것인가부터 시작하면 되겠다. 그 다음은 `Artillery`의 평타 + 폭발 이펙트, `Caster`의 평타 이펙트 등을 수정하면 될 듯.

# 250810 - 짭명방

> [!doing]
> - `Projectile - Arrow` 다시 만드는 중

## Projectile - Arrow
![[Pasted image 20250810142749.png]]
- 메쉬를 새로 만들었다. 이런 느낌. 
- 가장 맨 위의 삼각뿔의 경우 삼각형들이 UV Map에 겹쳐진 모양이다. 이게 부자연스럽게 보일 수는 있겠는데... 일단 방법도 없어서 그냥 이렇게 구현해봄. 

- 메쉬 적용하고 머티리얼 보는데 좀 이상하다. 이 부분 다듬는 건 내일로 미룬다. 메쉬를 새로 만들어야 할 수도 있겠음. 아니면 단순히 UV Map의 문제거나.

- 투사체가 이동하는 과정에서 남기는 파티클도 구현한다. 기존의 `Beam` + `Snowflake`로 만듦. 
	- `Snowflake` 텍스쳐는 ChatGPT한테 따봤는데 배경이 투명한 `PNG` 파일이 아니어서 그거 참고해서 그냥 프로크리에이트에서 직접 만듦.

- `Cloud`를 이용해서 한기를 투사체의 경로에 남기는 방법도 구현해봤는데 그렇게 자연스러운 느낌은 아님. 
	- 차라리 화살촉 끝 부분에 메쉬를 하나 넣고 거기에 어떤 효과를 넣는 구현이 낫겠음

![[Projectile_Arrow_v1.gif]]

> 일단 오늘의 구현은 여기까지 한다. 지금 보이는 문제점으로는
> 1. 화살촉의 회전과 화살꼬리?의 회전이 비슷하게 돌지 않음. 화살 메쉬 자체가 정사각형이 아닌 것으로 보임.
> 2. 색상은 좀 고민되는 듯.. 또 뭐가 있었는데 까먹었다.


# 250808 - 짭명방

>[!done]
>- 이펙트 만들기
>	- 배치 이펙트
>	- `Hit_Lightning_v1` (캐스터 스킬 타격 이펙트)
>- 테스트 환경 수정

## 이펙트 제작 - 배치
- 원본 게임인 명방의 배치 이펙트를 보고 구현했다. 
	- 색깔이나 큰 `Circle`은 나름의 바리에이션.
![[Deploy_v1.gif]]

> - 게임 테스트하면서 알게 된 건데 본 게임에서 스킨이 있거나 한정 오퍼레이터는 배치 이펙트도 달랐다. 배치 이펙트가 워낙 짧은 순간에 지나가기 떄문에 몰랐던 내용인데, VFX 공부하면서 이런 몰랐던 것들이 새로 보이게 되는 게 재밌다. 

- 적용 과정) 
	- 위치 이슈 - 잘못된 거 아니었음. y 포지션이 `0.55`랑 `0.75`가 찍혀서 ?이었는데 타일 스케일까지 고려해서 들어간 값이라 오브젝트 위치만 잘 찾아가면 된다. 
	- 타일 위에 가로세로로 그려지는 파티클의 경우 오브젝트의 위치 자체가 타겟 대비 `-0.4y`이므로 `Shape`에서 추가로 만질 건 없음. 
	- 가로세로위아래 파티클들의 `lifetime`, `start speed`, `color over lifetime` 등을 추가로 만져서 조금 더 부드러운 느낌이 나게 수정했음.


## 테스트 환경 수정
- 위 작업을 진행하면서...
> 테스트 환경이랑 실제 환경이랑 다른가? `Shape - Module Gizmo` 위치 찍었을 때 이펙트가 나타나는 위치랑 기즈모가 표시되는 위치가 미묘하게 다르다. 

라는 생각이 들었다. 

이거는 예전에 각 오브젝트들 만지면서 오브젝트 하나에 컴포넌트를 몰아넣던 구조를 자식 오브젝트들에 배분하는 식의 수정을 거친 적이 있는데, 이 과정에서 VFX 테스트 환경의 오브젝트는 수정하지 않았기 때문이었다. 

- 수정 전)
	- 각 `Operator / Enemy` 오브젝트의 스케일이 `0.25, 0.25, 0.25`
- 수정 후)
	- 오브젝트의 스케일은 `1, 1, 1`
	- 대신 자식 오브젝트로 `Model`을 빼두고, 여기에서 메쉬 렌더링을 담당한다. 얘의 스케일이 `0.25, 0.25, 0.25`
	- 이펙트는 오브젝트를 기준으로 들어간다. 

여기서 `VFXTestScene`은 수정 전의 그것을 따랐고, 실제 스테이지에서는 수정 후를 따랐기 때문에 미묘한 차이가 발생했음.

**따라서** VFX 테스트 씬도 수정 후처럼 `Model`을 자식 오브젝트로 빼고 부모 오브젝트의 스케일을 `1, 1, 1`로 뒀음.

## 이펙트 제작 - Lightning
- `Caster`의 2번째 스킬의 타격 효과. 공격 모션은 따로 없고 공격 판정이 나올 때마다 해당 적의 위치에서 이펙트가 재생되는 방식이다.
- 기존에 `VFX` 그래프로 구현한 게 있는데, 파티클 시스템으로 만들어 봄.
	- 이 때는 아마 `Square`을 어떻게 쪼갰었나? 그랬는데 이번엔 텍스쳐 시트를 만들어서 작업해봄.

![[ForObsidian_Thunder01.png]]

- 이런 느낌으로 레퍼런스 참고해서 만들어봤는데, 번개가 사라지는 효과에 대해서는 조금 징그러운 느낌이 들었다. 
	- **번개가 서서히 사라지는 효과를 구현할 때는 번개 줄기가 얇아지는 효과를 넣어야 더 그럴 듯해 보이는 듯.** 
	- 저런 식으로 넣었더니 **번개가 사라진다기보다는 역병에 걸린 듯한(둥근 반점이 생기면서 없어지는 듯한) 효과에 가까워 보였다.**

일단은 다시 작업하는 것보다는 저걸 갖고 그대로 진행하겠음. `Color over Lifetime`을 적용해서 중간 이후로는 알파값을 0으로 향하게 하면 뒤의 사라지는 효과는 그렇게 두드러지지는 않는다.

![[Hit_Thunder_v1.gif]]

타격 이펙트이므로 이거보다 더 화려해질 필요는 없을 것 같은데
1. 바닥에 남는 검은 이펙트인 `Debris`
2. 튀어오르는 검은 파티클

이 2개는 별도의 텍스쳐 / 메쉬를 사용해보고 싶음. 

### Crack 텍스쳐 

![[ForObsidian_Crack01.png]]

![[ForObsidian_Crack01-1.png]]
> 위 버전을 사용해봤는데 너무 이상해서 아래 버전으로 수정함. 아래가 조금 더 그럴싸해보인다.
> `Crack` 이펙트의 특징은
> 1. 중앙에서 뻗어나가는 선이 굵음, 나머지 서로를 연결하는 선들은 굉장히 얇은 편
> 2. 잔가지를 많이 그릴 필요가 없으며, **굵은 잔가지가 많을수록 균열보다는 나무에 가까워보인다.**
> **선의 굵기가 포인트**인 듯.

쉐이더로 구현하면 이펙트가 가운데서 퍼져나가는 구현도 할 수 있을 듯 하지만 원하는 타이밍을 맞출 수 있는가가 좀 애매한 부분. 가운데서 퍼져나가는 효과가 `Beam`이랑 `Particle`로 나타나고 있기 떄문에 투명했다가 나타나는 것 만으로 생각보다 자연스럽게 나타나는 구현이 가능하다.

이게 정리하면 짧게 걸린 것 같지만 거의 2시간 쓴 듯. 텍스쳐 메이커에 비슷한 느낌의 구현이 보이지 않아서 직접 그렸다.

### Particle_Debris 메쉬로 구현
- 이전에 `Slash` 스킬을 구현할 때 잔해 메쉬를 쓴 기억이 있다. 그걸 활용할 계획.
- `Slash` 스킬을 의외로 파티클 시스템으로 구현했었다? 아무튼 `Debris` 메쉬가 있기 때문에 그걸 활용함.
- `Collision`을 켜서 조금 더 실감나게끔 해봄. 

### (일단) 최종본
![[Hit_Thunder_v2.gif]]
그래도 나름 만족스러운 느낌? 여전히 바닥은 살짝 아쉽지만 얘는 여기까지만 작업해둔다.
색깔을 어떻게 설정해야 할지 감이 안 잡힌다. 



# 250807 - 짭명방
>[!done]
> - 이펙트 만들기 
> 	- `Hit_Impact_v2` - 방향성 관련 추가 구현 
> 		- `Stretched Billboard`를 써보려고 했는데 제약이 있다. 정리해뒀음.
> 	- `Attack_Slash_v1` 
> 		- 기존 `VFX Graph`로 만들었던 메쉬랑 쉐이더가 있다. 그걸 활용해보려고 함.
> - `CombatVFXController`에 `Billboard`의 회전 케이스도 추가.
> 	- 회전 관련 : `FromToRotation` vs `LookRotation`
> - 버그 수정
> 	- 텍스쳐에 그린 적 없는 선이 나타나는 현상

>[!doing]
>- 배치 이펙트 구현 중 일단 중지
## Impact_v2 구현하기
- 어제 `Stretched Billboard`에 대해 알았으니까 적용해보려고 했음
	- 텍스쳐의 방향을 우->좌로 진행하는 걸 알게 됐으니까 회전도 쉽게 적용할 수 있지 않을까? 라는 생각으로 시도해봤다.
- 하지만 **제약이 있다.** 
	- 예를 들면 크기 변경. `Pivot`의 방향으로 **날아가는 파티클**을 구현하는 용도로 만든 거라서 멈춰 있는 파티클의 크기를 변경하면 텍스쳐의 크기가 축소되긴 하는데 이동하면서 축소되는 느낌으로 나타난다.
- 따라서 **`Mesh`를 쓰지 않으면서 방향성이 있는 파티클을 구현하려면 `Billboard + 코드`로 제어하는 게 지금 상황에서는 가장 좋은 방법**인 듯. `Start Rotation` 값을 만지는 방식으로.

- `vfx_Hit_Impact_v2`를 만들었다. 일단은 이 정도에서 만족.

- 게임 테스트) 내부 컴포넌트인 `Particles`과 달리 방향이 돌아가지 않는 문제가 있어서 그거 만지는 중 -> 아래 스크립트 구현으로 완료.

### 결과물
![[Hit_Smash_v2.gif]]

## Attack_Slash_v1 구현하기
- 메쉬는 기존에 만들어놨던 게 있다. UV Map만 어떻게 생겼는지 확인했음.
- 방향 설정에 관한 이슈가 있기는 한데, 기존 쉐이더도 보면 극좌표를 이용해서 정중앙 부분을 밝게, 바깥 부분을 어둡게 구현한 게 있음.
- 이를 참고해서 쉐이더에 극좌표 관련 기능을 추가해서 중앙 부분을 밝게 하고 바깥 부분을 어둡게 만드는 구현만 더하면 되지 않을까 싶다. `AddScroll`에 노이즈 관련 기능은 이미 붙어 있기 때문에 이를 기반으로 쉐이더 그래프를 하나 더 만들었다. 이를 `AddScrollRadial`이라고 표기.

- 이전 예제에서는 텍스쳐 없이 보로노이 노이즈 + 극좌표만을 이용했는데, 이번에 텍스쳐는 새로 그렸다. 

![[ForObsidian_SlashMesh01.png]]

왜 이렇게 만들었냐면 이전에 만들어놓은 메쉬의 UV Map이 아래처럼 생겼기 때문이다.
![[Pasted image 20250807174832.png]]
![[Pasted image 20250807174801.png]]
그래서 나머지 절반 부분의 텍스쳐는 있을 필요가 없고, 왼쪽 절반만 그리고 회전만 맞추면 될 것 같았음.

![[Attack_Slash_v1.gif]]
> `gif` 파일이라 느려 보이는데 실제로는 0.1초 정도만 나타나는 이펙트이므로 매우 빠르게 지나가며, 보로노이 노이즈가 적용된 상황이라 특정한 모양의 도형이 빙글빙글 도는 느낌만 나는 것도 아니다.

생각보다 더 만족스럽게 나왔다. 도형이 도는 문제나 이펙트가 너무 일정해보이는 문제는 `size`, `lifetime`, 텍스쳐의 노이즈 설정 등을 조절해서 해결했음.

휘두르는 방향의 바리에이션은 `3D Start Rotation`의 `Y`값을 바꿔서 설정할 수 있었다. `0 ~ 180`으로 설정.

여기서 문제는, 저 이펙트에 `Alpha Blended`가 적용된 메쉬를 하나 더 띄우려고 할 때인데, `Sub Emitter`에 `Rotation` 설정이 있긴 하지만 그건 이럴 때 쓰는 게 아니다. 

이것도 스크립트로 제어가 가능하다고 함. 근데 너무 품이 많이 드는 것 같아서 일단은 저대로 구현하겠음. 

- 원래는 파티클 튀는 것도 구현했는데, `Hit` 이펙트에 파티클이 이미 튀기 때문에 여기서는 저것과 알파 블렌디드만 적용하고 마무리.
- Ally, Enemy, Magical(DualBlade 스킬)에 대해 이펙트 구현 및 적용 테스트 완료. 


## CombatVFXController - Billboard의 회전도 반영되도록 수정
```cs
// 방향 계산 로직은 이전에 올렸으니 생략
// Billboard의 회전이 필요한 파티클 시스템은 인스펙터에서 등록할 수 있도록 했음.

if (direction != Vector3.zero)
{
	// 파티클 시스템 오브젝트의 회전
	// Quaternion objectRotation = Quaternion.FromToRotation(baseDirection, direction);
	Quaternion objectRotation = Quaternion.LookRotation(direction);
	transform.rotation = objectRotation;

	// 빌보드 파티클의 회전
	// 오브젝트의 Y축 회전값을 라디안으로 변환, startRotationZ값을 업데이트한다. 
	float billboardRotationInRadians = objectRotation.eulerAngles.y * Mathf.Deg2Rad;

	// 캐싱된 모든 모듈의 startRotation에 반영
	for (int i = 0; i < billboardParticles.Count; i++)
	{
		if (billboardParticles[i] != null)
		{
			var ps = billboardParticles[i];
			var mainModule = ps.main;
			mainModule.startRotationZ = new ParticleSystem.MinMaxCurve(billboardRotationInRadians);
		}
	}
}
```
> `FromToRotation`과 `LookRotation`의 차이 : [[Unity - LookRotation vs FromToRotation]]
- 요약) 대부분의 경우 `LookRotation(forward, upwards)`을 쓴다고 생각하면 된다. 로컬 Z축을 `forward` 방향으로 향하게 하면서 `upward`을 가능한 `0, 1, 0`을 보게 하려는 동작이다.

## 기타 버그(?) 수정

### 그린 적 없는 선이 나타남
![[Pasted image 20250807132920.png]]
- 여기서 왼쪽에 나타난 선. 저 부분은 그린 적 없다.
- 해결 방법 : **텍스쳐의 `Wrap Mode - Repeat`가 켜져 있다면 `Clamp`로 바꾸기.** 
# 250806 - 짭명방

> [!done]
> - `CombatVFXController` 수정 
> 	- 이펙트의 방향 설정 가능
> - 기존 이펙트 수정 : 파티클 날아가는 속도, `Simluation Speed` 통일 등등
> - `Slash` 대신 사용할 `Smash` 이펙트 구현
> - 버그 수정 : `Enemy_Tanker`에 `Attack_Smash` 이펙트를 할당했는데 이전에 구현했던 `Slash`가 나가는 현상

> [!review]
> 하 오늘 이펙트 하나밖에 못했네;;

## 이펙트 작업 

### `Smash` 이펙트
![[ForObsidian_Smash01 (3).png]]
> 이런 텍스쳐를 만들었다. 베는 컨셉의 캐릭터가 아니라면 `Slash` 대신 사용할 거임

- 부모 오브젝트에 `Rotation`을 줘도 `Billboard` 설정이라서 텍스쳐가 회전하지는 않는다.
- 일단 `Start Rotation` 값을 설정해서 텍스쳐 자체를 회전시키는 건 가능한데, 게임과 연동해야 함.

- 중요) **텍스쳐와 이펙트의 방향**
>[!done]
>- 방향성이 있는 텍스쳐 + Billboard를 쓸 때는 텍스쳐의 머리 부분이 이미지의 왼쪽을 향하도록 그려야 한다. (완전히 새로운 파티클 시스템을 만들어서 테스트도 해 봄)
1. `Billboard`로 텍스쳐를 띄울 경우 항상 카메라를 보며, 회전은 적용되지 않음
	- 파티클 시스템 내의 `Rotation` 값으로만 설정할 수 있음
2. **`Stretched Billboard`**를 쓸 경우, 방향에 따라 파티클의 회전이 달라짐
	1) 파티클 시스템에서 설정하는 `Rotation` 관련 값들은 적용되지 않음
	2) **텍스쳐의 방향 : -X 방향, 즉 왼쪽을 보도록 그려야 파티클의 이동 방향과 텍스쳐의 머리 방향이 일치하는 걸 확인할 수 있었다.**
		- 이 부분에서 혼동이 많이 왔는데, ChatGPT도 Gemini도 모두 `+y` 방향으로 그리랬다가, `+x` 방향으로 그리랬다가... 테스트해보니까 아래처럼 해야 그나마 맞음.

![[Pasted image 20250806163228.png]]

- [[유니티 파티클 시스템 - 방향성이 있는 텍스쳐]]에도 정리.

#### 실제 적용 시 발생하는 문제
- 오퍼레이터 / 적의 Rotation 값이 적용되지 않은 듯? 이펙트가 계속 +z 방향으로 나간다.
- 이게 어떤 상황이냐면
```cs
case VFXRotationType.sourceToTarget:
	Vector3 hitDirection = (transform.position - attackSource.Position).normalized;
	if (hitDirection != Vector3.zero)
	{
		transform.rotation = Quaternion.LookRotation(hitDirection);
	}
	break;
```
> `transform.position = attackSource.Position` 이라서 방향 계산이 안 된다. 

- 아래 `CombatVFXController` 수정을 다시 수정했음.

- 이펙트의 `Z`값 설정을 만져서 적당히 튀어나가면서 `Hit_Impact`와 겹쳐지게끔 구현함. 



## 프로젝트 적용 시 문제 상황들
- `Hit` 이펙트를 구현하면서 파티클이 튀는 방향을 설정하는 구현 
	- 특정 이펙트는 방향이 적용되어야 하고 다른 이펙트는 기본 설정을 따르게 해야 함

### `CombatVFXController` 수정
- 타격, 피격 이펙트 등에 들어가는 VFX 실행 스크립트. 방향 설정과 재생을 담당한다.

```cs
public enum VFXRotationType
{
    None,
    targetToSource, // 타겟을 향함
    sourceToTarget, // 공격이 온 방향을 바라봄
}
```
을 인스펙터에서 설정할 수 있게 함. 이 값에 따라

```cs
private void PlayPS()
{
	if (ps != null)
	{
		Vector3 baseDirection = Vector3.forward; // 모든 이펙트는 +Z축으로 진행된다고 가정함
		switch (rotationType)
		{
			// 옵션 1) 피격자 -> 공격자 방향의 이펙트 진행
			case VFXRotationType.targetToSource:

				Vector3 directionToSource = (attackSource.Position - targetPosition).normalized;
				if (directionToSource != Vector3.zero)
				{
					Quaternion rotation = Quaternion.FromToRotation(baseDirection, directionToSource);
					transform.rotation = rotation;
				}                
				break;

			// 옵션 2) 공격자 -> 피격자 방향의 이펙트 진행
			case VFXRotationType.sourceToTarget:
				Vector3 directionToTarget = (targetPosition - attackSource.Position).normalized;
				if (directionToTarget != Vector3.zero)
				{
					Quaternion rotation = Quaternion.FromToRotation(baseDirection, directionToTarget);
					transform.rotation = rotation;
				}
				break;

			// 옵션 3) 별도 설정 필요 없음
			case VFXRotationType.None:
				break;
		}

		ps.Play(true); // true 시 모든 자식 이펙트까지 한꺼번에 재생함
	}
}
```
이러한 구현을 따르도록 한다. 

> 일단 대부분의 이펙트는 부모 오브젝트의 회전을 따르기 때문에 크게 상관 없지만, 타격 이펙트의 파티클 튀는 방향을 설정하기 위해서 집어넣은 옵션이다. 대부분 `None`으로 해도 무방함.

## 버그 수정
- `Enemy_Tanker`에 `Smash` 이펙트를 할당했는데 `Slash`가 나가는 현상이 있음
	- `Enemy_Tanker` 프리팹에 할당되는 데이터가 `Enemy_Default`였다.  엌ㅋㅋㅋ 
	- 모델링은 프리팹에 있고 눈에 보이지 않는 데이터만 다른 곳에서 가져오니까 헷갈릴 만 했다.
	- `Enemy_Tanker`로 수정하고 다시 테스트.
	- 수정 완료.

# 250805 - 짭명방

## 이펙트 작업

>[!done]
> - 기본 버프 지속 이펙트(공격, 방어, 힐)
> - 이펙트 적용 위치 스크립트 수정
> - 타격 이펙트 오브젝트 풀 태그 꼬이는 현상 수정
> - 타격 이펙트 : 힐 구현

### 구현된 이펙트들
- `Hit_Heal`
![[Hit_Heal.gif]]


- `Buff_Attack`
![[Buff_Attack.gif]]

- `Buff_Defense`
![[Buff_Defense.gif]]

- `Buff_Heal`
![[Buff_Heal.gif]]
### Rate over time으로 적은 수의 파티클을 다룰 때

[[파티클 시스템 - Rate over Time과 적은 수의 파티클]]에 아래 내용 정리.

>[!done]
>1. **`Burst`는 0초에 파티클을 바로 생기게 할 수 있다.** 
>2. **`Rate over Time`은 1보다 작은 소수값으로도 설정할 수 있다.** 
>	- 1개의 파티클을 유지하고자 한다면 `Start Lifetime * Rate over Time = 1`을 유지하도록 값을 설정하면 됨
>3. **`Rate over Time`으로 적은 수의 파티클을** 다룰 경우, 0초에 파티클이 나타나지 않을 수 있다.
>	- **`Prewarm` 옵션으로 해결**한다. (`Looping`이 켜져 있어야 함)
>		- 단 이 경우 파티클 시스템을 멈추고 `Playback Time`을 다시 테스트할 때 안 보이는 현상이 있다.
>	- `Burst`로 구현해도 가능은 한데 파티클이 겹치는 문제가 있음. 이건 왜인지는 모르겠다.

- 공통 버프 작업을 다시 진행 중인데, `Beam` 이미지가 커졌다가 작아졌다가 하는 식으로 바닥 파티클을 구현하는 중.

![[Pasted image 20250805134300.png]]

여기서 `Size over Lifetime`, `Rate over Time`, `Lifetime` 관련 이슈가 있었다.
- `Rate over Time` : 1초당 생성하는 파티클의 갯수
- `Size over Lifetime` : `Lifetime` 동안 파티클의 크기 변화
- `Lifetime` : 개별 파티클의 지속 시간

`Rate over Time`이 **1초당**에 해당하는 개념이므로, 만약 `Lifetime`이 1초보다 길다면 바닥의 파티클이 겹치는 문제가 발생했다. 그렇다고 `Lifetime`을 줄이자니 `Size over Lifetime`의 변화 속도가 너무 빨라지는 문제도 있다.

제미나이님께 물어보니, **`Rate over Time`은 소수로도 설정할 수 있다.** 예를 들어 `Start Lifetime = 2s`, `Rate over Time = 0.5`로 설정한다면 파티클은 2초에 한 번 생긴다. 

이렇게 설정하고 테스트해보면 파티클 시스템을 재생해도 0 ~ 2초까지는 이펙트가 보이지 않는다.

이 문제는 `Prewarm` 옵션을 켜는 것으로 해결할 수 있다.
- 단순히 `Start Delay`가 있을 때 이펙트가 자연스럽게 실행되도록 할 때만 쓰는 기능인 줄 알았는데, 이럴 때도 쓸 수 있다.

여기서 파티클 시스템의 `Playback Time`을 다시 조작했을 때, **0 ~ 2초 사이의 파티클이 사라지는 현상**이 있다. 이건 **`Playback Time`을 조작할 때 `Prewarm`에 의한 계산은 고려하지 않기 때문이다.**

### 이펙트 풀 공유 문제 수정
- 태그가 계속 꼬여 있는 것 같다.
- 이게 정확히는 이펙트가 잘 재생되다가 갑자기 어느 순간부터 다른 이펙트가 재생된다는 느낌임
- 어제 수정했던 내용인데, 저장 내용이 반영되지 않았던 것으로 보임.
	- 어제 작업 중에 컴퓨터를 절전으로 만들어뒀다가 나중에 다시 켜려니까 그대로 맛이 갔던 현상이 있었다. 
	- 요점은 `UnitEntity`가 갖는 `hitEffectTag`와 `attackSource`가 갖는 `hitEffectTag`을 구분해서 넣어줘야 한다는 거였음. 또 발생하면 다시 언급함.


# 250805 - 짭명방

## 이펙트 작업

>[!done]
> - 기본 버프 지속 이펙트(공격, 방어, 힐)
> - 이펙트 적용 위치 스크립트 수정
> - 타격 이펙트 오브젝트 풀 태그 꼬이는 현상 수정
> - 타격 이펙트 : 힐 구현

### 구현된 이펙트들
- `Hit_Heal`
![[Hit_Heal.gif]]


- `Buff_Attack`
![[Buff_Attack.gif]]

- `Buff_Defense`
![[Buff_Defense.gif]]

- `Buff_Heal`
![[Buff_Heal.gif]]
### Rate over time으로 적은 수의 파티클을 다룰 때

[[파티클 시스템 - Rate over Time과 적은 수의 파티클]]에 아래 내용 정리.

>[!done]
>1. **`Burst`는 0초에 파티클을 바로 생기게 할 수 있다.** 
>2. **`Rate over Time`은 1보다 작은 소수값으로도 설정할 수 있다.** 
>	- 1개의 파티클을 유지하고자 한다면 `Start Lifetime * Rate over Time = 1`을 유지하도록 값을 설정하면 됨
>3. **`Rate over Time`으로 적은 수의 파티클을** 다룰 경우, 0초에 파티클이 나타나지 않을 수 있다.
>	- **`Prewarm` 옵션으로 해결**한다. (`Looping`이 켜져 있어야 함)
>		- 단 이 경우 파티클 시스템을 멈추고 `Playback Time`을 다시 테스트할 때 안 보이는 현상이 있다.
>	- `Burst`로 구현해도 가능은 한데 파티클이 겹치는 문제가 있음. 이건 왜인지는 모르겠다.

- 공통 버프 작업을 다시 진행 중인데, `Beam` 이미지가 커졌다가 작아졌다가 하는 식으로 바닥 파티클을 구현하는 중.

![[Pasted image 20250805134300.png]]

여기서 `Size over Lifetime`, `Rate over Time`, `Lifetime` 관련 이슈가 있었다.
- `Rate over Time` : 1초당 생성하는 파티클의 갯수
- `Size over Lifetime` : `Lifetime` 동안 파티클의 크기 변화
- `Lifetime` : 개별 파티클의 지속 시간

`Rate over Time`이 **1초당**에 해당하는 개념이므로, 만약 `Lifetime`이 1초보다 길다면 바닥의 파티클이 겹치는 문제가 발생했다. 그렇다고 `Lifetime`을 줄이자니 `Size over Lifetime`의 변화 속도가 너무 빨라지는 문제도 있다.

제미나이님께 물어보니, **`Rate over Time`은 소수로도 설정할 수 있다.** 예를 들어 `Start Lifetime = 2s`, `Rate over Time = 0.5`로 설정한다면 파티클은 2초에 한 번 생긴다. 

이렇게 설정하고 테스트해보면 파티클 시스템을 재생해도 0 ~ 2초까지는 이펙트가 보이지 않는다.

이 문제는 `Prewarm` 옵션을 켜는 것으로 해결할 수 있다.
- 단순히 `Start Delay`가 있을 때 이펙트가 자연스럽게 실행되도록 할 때만 쓰는 기능인 줄 알았는데, 이럴 때도 쓸 수 있다.

여기서 파티클 시스템의 `Playback Time`을 다시 조작했을 때, **0 ~ 2초 사이의 파티클이 사라지는 현상**이 있다. 이건 **`Playback Time`을 조작할 때 `Prewarm`에 의한 계산은 고려하지 않기 때문이다.**

### 이펙트 풀 공유 문제 수정
- 태그가 계속 꼬여 있는 것 같다.
- 이게 정확히는 이펙트가 잘 재생되다가 갑자기 어느 순간부터 다른 이펙트가 재생된다는 느낌임
- 어제 수정했던 내용인데, 저장 내용이 반영되지 않았던 것으로 보임.
	- 어제 작업 중에 컴퓨터를 절전으로 만들어뒀다가 나중에 다시 켜려니까 그대로 맛이 갔던 현상이 있었다. 
	- 요점은 `UnitEntity`가 갖는 `hitEffectTag`와 `attackSource`가 갖는 `hitEffectTag`을 구분해서 넣어줘야 한다는 거였음. 또 발생하면 다시 언급함.





# 250804 - 짭명방

## 이펙트 작업

>[!done]
>- 기본 타격 이펙트 구현
>- 방향에 따라 파티클 튀는 방향 조절하는 스크립트 파티클에도 적용
>	- `Projectile`에 `hitEffectTag` 지정 안 해서 피격 이펙트 재생되지 않는 문제 있었음. 
>- 파티클 시스템의 상속 관련 정리


### VFX의 상속 관련
[[파티클 시스템_상속 시 유의사항]]에 정리.

요점은 `over Lifetime` 속성들은 `Inherit`되지 않는 것으로 보이며, 시작 시점에 설정된 값들만 자식 파티클로 전달되는 것으로 보인다. 

- 그리고 `Size` 이거 정상적으로 동작 안 하는 듯? `Size over Lifetime`이 켜져 있긴 한데 이것 떄문일까?

### Beam 관련
- 이펙트가 나타날때 아주 잠깐 팟 하고 나타났다가 사라지는 부분이다
- **남용하니까 화면이 번쩍번쩍 거려서 눈이 피곤해지는 느낌이 있다.** `Beam` 자체의 문제라기보다도 이펙트의 알파값을 조절해야 할 듯?

### 태그 꼬이는 문제
- 재생 관련해서 지금 뭔가가 꼬였다.
	- `Ally`랑 `Enemy`가 반대로 되어 있고
	- 공격 이펙트에 `Hit` 이펙트를 넣는 등 난리가 났다.


### Hit_Slash, Hit_Smash 구현
- 기본적인 작업 완료. Ally / Enemy 별로 색깔 놀이 버전으로 따로 구현해서 추가해뒀다.

# 250724 ~ 250801 - 유니티 VFX 공부
- 유데미에서 예전에 VFX를 넣을 때 유튜브에서 신세를 졌던 센세의 강의를 듣기로 했다.
	- Gabriel Aguiar 센세의 강의 Visual Effects for Games in Unity - Beginner To Intermediate로 공부해보는 중.
	- [[1_유니티VFX_이펙트의 종류]]
	- [[2_유니티VFX_VFX의 기초, 원칙]]
	- [[3_유니티VFX_제작 전]]
	- [[4_유니티VFX_실습 사전 세팅]]
	- [[5_유니티VFX_스파크만들기]]
	- [[6_유니티VFX_범위효과]]
	- [[7_유니티VFX_투사체&주문]]
	- [[8_유니티VFX_성능]]
	- [[컬러 팔레트 참고용]]
	- 깃허브에서는 `Projects/Ongoing`으로 접근할 수 있다. 언제 `Archive`로 옮겨질지는 모르겠지만.
