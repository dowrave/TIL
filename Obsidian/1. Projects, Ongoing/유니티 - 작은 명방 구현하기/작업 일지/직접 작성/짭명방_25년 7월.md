# 250724 ~ 250801 - 유니티 VFX 공부
- 유데미에서 예전에 VFX를 넣을 때 유튜브에서 신세를 졌던 센세의 강의를 듣기로 했다.
	- Gabriel Aguiar 센세의 강의 Visual Effects for Games in Unity - Beginner To Intermediate로 공부해보는 중.
	- [[1_유니티VFX_이펙트의 종류]]
	- [[2_유니티VFX_VFX의 기초, 원칙]]
	- [[3_유니티VFX_제작 전]]
	- [[4_유니티VFX_실습 사전 세팅]]
	- [[5_유니티VFX_스파크만들기]]
	- [[6_유니티VFX_범위효과]]
	- [[7_유니티VFX_투사체&주문]]
	- [[8_유니티VFX_성능]]
	- [[컬러 팔레트 참고용]]
	- 깃허브에서는 `Projects/Ongoing`으로 접근할 수 있다. 언제 `Archive`로 옮겨질지는 모르겠지만.

# 250723 - 짭명방
## 버그 수정

>[!done]
>- 장판 스킬들 범위 이펙트 이슈
>- `MeteorSkill` 1번째 파티클이 너무 빨리 떨어짐
>- 기절 VFX 중첩 문제 + Buff 관련 리팩토링
>- 공용 `Buff VFX` 들은 오브젝트 풀링으로 구현
>	- `VFX`가 달려 있는 부모 오브젝트 파괴 시에 풀로 반환되지 않고 함께 제거되는 문제 수정

### 장판 스킬들 범위 이펙트 이슈
- **풀에 등록할 때의 태그와 사용할 때의 태그를 다른 걸 사용해서 발생했던 문제. 스킬 내에서 전역 태그값을 관리하는 방식으로 변경했다.**


- 스킬이 켜졌을 때 범위 이펙트 관련 프리팹들이 동작하지 않는 것으로 보임. 
	- 스킬을 1번 켜봤을 때 이펙트의 위치 좌표를 보면 모두 `(0, 0)`인 점
	- 그렇다고 이펙트가 엉뚱한 위치에서 보이는 것도 아니었다.
- **오브젝트 풀에 넣을 때의 태그와 풀에서 만들어낼 때의 태그가 다른 듯?** 
	- 이펙트 태그로 스폰하려고 하는데 만들었을 때의 태그와 다르니까 스폰 자체가 불발되는 것으로 보인다. 

- 스킬의 오브젝트 풀 등록에 사용되는 아래의 로직이 반복되고 있다.
```cs
	MELEE_ATTACK_OVERRIDE_TAG = GetVFXPoolTag(caster, meleeAttackEffectOverride);
	if (!ObjectPoolManager.Instance.IsPoolExist(MELEE_ATTACK_OVERRIDE_TAG))
	{
		ObjectPoolManager.Instance.CreatePool(MELEE_ATTACK_OVERRIDE_TAG, meleeAttackEffectOverride);
	}
```
이거를 조금 더 축약해서, `GetVFXPoolTag -> CreatePool`로 이어지는 과정을 메서드화함. `CreatePool` 내에 조건 체크가 있기 때문에` IsPoolExist`도 사실 필요하진 않다.
```cs
/// <summary>
/// 스킬과 관련된 오브젝트 풀을 등록한다. 태그를 반환한다.
/// </summary>
protected virtual string RegisterPool(UnitEntity caster, GameObject prefab, int initialSize = 5)
{
	if (prefab == null) return null;

	string poolTag = GetVFXPoolTag(caster, prefab);
	ObjectPoolManager.Instance.CreatePool(poolTag, prefab, initialSize);
	return poolTag;
}
```

### `MeteorSkill` 1번째 파티클이 너무 빨리 떨어지는 문제
- 1번째 파티클의 시작 지점 높이만 바꿔줬다. `1f`는 생각보다 낮은 듯.

### 기절 이펙트 중첩되는 문제 + Buff 관련 리팩토링

- `Buff` 중에서 기절이 다시 들어갈 때는 이전 버프를 파괴하고 새로운 버프를 등록하는 방식으로 진행했다. 이 파괴와 생성 로직 내에 이펙트를 없애고 다시 만드는 과정도 포함되어 있음.
- 일단 기절 버프가 다시 들어갈 때 "파티클 이펙트를 중지하고 인스턴스를 파괴한다"는 **로직 자체는 디버깅 로그에서 정상적으로 출력되고 있음. 근데 파티클 이펙트가 중지되지 않음.**
1. `ParticleSystem.Clear()`, `VFXGraph.Reinit()`을 넣어봄(새로운 파티클 생성 중지) : 그래도 안 됨.

> 이거 도대체 뭐가 문제임?

- 일단 요인 하나
	- `UnitEntity.AddBuff`를 하면 그 안에 `Buff.OnApply()`가 기본적으로 함께 들어가 있는데, `OnApply`를 따로 구현해놓은 부분이 있음. 이거 제거.
	- **이거 없애니까 해결됐다.**

#### 왜 이런 문제가 발생했는지 정리하고 넘어감
- **AI를 많이 쓰니까 구조 파악이 무뎌지는 느낌이 들어서 직접 정리**해본다.
- 현재의 버프 구조를 보면 아래와 같다.

1. `AddBuff` 
	- `StunBuff`가 있다면 `RemoveBuff`로 해당 버프를 제거함
	- `activeBuffs`에 해당 `buff`를 추가
	- `buff.OnApply()` 실행
		- `VFX` 실행 로직도 여기 있음
	- `OnBuffChanged?.Invoke` 실행

2. `StunBuff`는 `duration`으로 초기화한다.

3. `Buff`에는 공통적으로 `OnUpdate` 로직이 있다. `duration`이 지나면 스스로가 있는 `UnitEntity`에 `RemoveBuff`를 실행시킨다.

4. `RemoveBuff`
	- `buff.OnRemove()` 실행
		- VFX 제거 로직도 여기 있음
	- `OnBuffChanged?.Invoke` 실행

`MeteorSkillController`에서 발생했던 문제는 **1번에서 `AddBuff`를 실행한 다음 별도로 `Buff.OnApply()`를 실행했기 때문이었다.**

```cs
public override void OnApply(UnitEntity owner, UnitEntity caster)
{
	this.owner = owner;
	this.caster = caster;
	elapsedTime = 0f;

	// 적용될 때 VFX 재생
	PlayVFX();
        
	owner.AddRestriction(ActionRestriction.Stunned);
}
```
1. `AddBuff`로 `OnApply`가 먼저 실행됨 -> VFX가 실행됨
2. 1번의 상태에서 다시 `OnApply`가 실행됨 -> 시간이 초기화되고, VFX가 한 개 더 실행됨
3. 시간이 지나고 `RemoveBuff`를 실행시키면 1번에서 실행된 VFX의 참조는 실종된다. 2번에서 다시 실행시켰던 VFX만 제거되게 된다.
4. `StunBuff`가 다시 들어오더라도 1개의 이펙트가 계속 실행되는 상태에서, 추가로 다시 이펙트를 실행하게 됨. 

> `VFX`의 경우 그 자체에서 파라미터를 노출시키는 것보다는 **지금처럼 계속 실행되게 하고 스크립트로 켜고 끄는 걸 조절하는 방법이 더 좋다고 함**
---
- 여기부턴 AI와 함께 정리. 최종적으로 `Buff`에서 `Owner`가 예기치 못한 방식으로 파괴될 때까지를 반영한 `OnDestroyed` 이벤트 구독 처리까지 포함해서 구현했다.
	- 이것까지 구현한 이유는 기절 이펙트 오브젝트 풀을 10개를 만들었는데, 중간에 무슨 문제인지 1개가 사라져서 9개의 오브젝트만 보이는 현상이 있었기 때문이다. 즉, 예상치 못한 상황에서 오브젝트가 파괴되었던 것으로 보임.
```
정상 종료 (시간 초과): OnUpdate -> owner.RemoveBuff() -> OnRemove()
정상 종료 (유닛 사망): owner.OnDeathAnimationCompleted -> HandleOwnerTermination -> OnRemove()
비정상 종료 (강제 파괴, 씬 전환): owner.OnDestroyed -> HandleOwnerTermination -> OnRemove()
위의 모든 경로가 결국 OnRemove라는 단일 정리 메서드로 모입니다.
```
> 대충 이런 것들이 반영되었다~

> 이건 잡설이지만 요즘 제미나이가 사용자를 칭찬하는 방식이 부담스럽다. 옛날에 클로드가 비슷하게 부담스러웠던 기억이 있음.




### 공용 이펙트 오브젝트 풀링으로 구현
- `StunBuff` 같은 경우는 여러 상황에서 사용되므로 **스테이지가 시작되는 시점에 오브젝트 풀을 만들어놓으면 좋을 것 같음.** 
	- 보통 오퍼레이터가 사용하는 오브젝트 풀은 오퍼레이터가 배치되는 시점에 생성된다. 이것과는 차이를 두려고 함.

- 작업 방향
1. `BuffVFXDatabase` : 프리팹 정보를 딕셔너리에 저장하고, 오브젝트 풀도 생성한다.
2. `BuffVFXManager` : `ObjectPoolManager`에서 이펙트 오브젝트를 얻어 반환하는 `ReleaseBuffVFXObject`를 추가한다
3. `Buff`는 `CreateBuffVFXObject`를 호출해서 이펙트를 가져오고 버프라 끝날 때 `ReleaseBuffVFXObject`를 호출해 풀에 반환한다.

- 추가
	- 이펙트 위치 문제. 지금은 `Stun`만 쓰니까 오브젝트의 머리 위에 이펙트를 나타나게 한다. 
	- 만약 슬로우 같은 이펙트를 추가로 구현해야 한다면 오브젝트 아랫쪽에 이펙트가 나타나게 해야 함. 
	- 이를 위해 `BuffVFXDatabase.BuffVFXMapping`을 아래처럼 구현한다.
```cs
    [System.Serializable]
    public struct BuffVFXMapping
    {
        [Tooltip("버프 클래스의 정확한 이름 (네임스페이스 포함)")]
        public string exactBuffClassName;
        public GameObject vfxPrefab;
        [Tooltip("풀의 초기 생성 개수")]
        public int initialPoolSize;
        [Tooltip("타겟을 기준으로 한 VFX의 로컬 위치 오프셋")]
        public Vector3 vfxOffset; 
    }
```
> 여기서 "클래스의 정확한 이름"을 입력해야 하는 이유는
> 1. 유니티의 인스펙터에서 `System.Type`을 필드로 노출해서 드래그&드롭하는 기능을 지원하지 않음
> 2. `string`은 인스펙터에서 매우 쉽게 입력하고 수정할 수 있으며, 직렬화도 용이함. 
> 3. `DB`에서 특정 버프 클래스를 직접 참조하지 않고 문자열을 통해 런타임에 연결되기 때문에 클래스 파일의 위치 등에 의존하지 않는 느슨한 결합

...등이 있다.


#### 부모 오브젝트 파괴 시 풀로 반환되지 않고 함께 파괴되는 문제 수정
- `Owner(UnitEntity)`가 파괴되는 시점에 이펙트들을 먼저 풀로 반환(및 `owner`의 자식에서 탈출)하기 위해 `OnDeathAnimationCompleted` 이벤트를 구독시켜서 탈출함

- 여기서 알아둘 게 2가지 있는데
1. **람다 함수로 구현하기 vs 래퍼 함수로 구현하기**
- `OnDeathAnimationComplted`는 `UnitEntity`를 받아야 하는 액션이다. 반면 `RemoveVFX()`는 파라미터를 받지 않음.
- 이를 구현하는 방법은 2가지다.
1) 람다함수로 구현
```cs
owner.OnDeathAnimationCompleted += (deadOwner) => RemoveVFX();
```
2) 별도의 래퍼 함수 구현
```cs
	owner.OnDeathAnimationCompleted += RemoveVFX;
}

protected void RemoveVFX(UnitEntity owner)
{
	RemoveVFX();
}
```

그런데 여기서 `Buff`의 오브젝트 풀들은 재사용될 수 있는 요소이므로, 구독 해제가 반드시 들어가야 한다.  이 때 차이가 생기는데
1) 람다 함수로 구현
- 여기서는 별도의 함수를 하나 만들어둔 상태이기 때문에, 저 람다함수를 별도의 델리게이트 상태로 갖고 있어야 한다.
```cs
private Action<UnitEntity> onOwnerDeathAction;

// 생성 로직
// 람다를 생성하여 변수에 저장합니다.
onOwnerDeathAction = (deadOwner) => RemoveVFX();

// 저장된 변수를 사용하여 이벤트를 구독합니다.
owner.OnDeathAnimationCompleted += onOwnerDeathAction;

// 해제 로직
owner.OnDeathAnimationCompleted -= onOwnerDeathAction;
onOwnerDeathAction = null; // 참조 정리
```

2) 래퍼 함수로 구현
- 훨씬 간단하다. 이미 따로 정의를 해뒀기 때문에 그것만 그대로 이용하면 됨.
```cs
owner.OnDeathAnimationCompleted -= RemoveVFX;
```

> 참고) 이런 건 안됨
```cs
owner.OnDeathAnimationCompleted -= (deadOwner) => RemoveVFX();
```
> 왜냐하면 등록할 때의 람다 함수와 해제할 때의 람다 함수가 서로 다른 인스턴스이기 때문이다. 람다 함수라는 게 즉석에서 바로 만들어내는 방식인 걸 생각해보면 됨. 
> 똑같이 `(deadOwner) => RemoveVFX();`라는 로직을 가져도 등록할 때와 해제할 때의 2개의 함수는 다르다는 것이다.


2. **구독 해제 메서드 내에 자기 자신을 해제시키는 메서드가 들어간다면, 그 로직은 맨 앞에 놓기**
```cs
    protected virtual void RemoveVFX()
    {
        owner.OnDeathAnimationCompleted -= RemoveVFX;
```
> - 자기 자신의 재실행을 막기 위해, 구독 해제 메서드는 맨 앞에 구현한다. 



# 250722 - 짭명방

## 스킬에서 사용하는 오브젝트 풀 관련
>[!info]
> - 스킬과 버프에 **공격 이펙트가 변경되는 경우에 대비한 필드** 작성
> - 스킬의 오브젝트 풀을 생성하는 메서드는 스킬에 적어놓되 실행은 Operator가 배치되는 시점에 한다.
> - Operator가 파괴되어도 오브젝트 풀이 파괴되지는 않는다. 재배치 등의 상황이 있기 때문에 굳이 지웠다가 다시 생성할 필요는 없다.
> - 오브젝트 풀들은 스테이지가 종료되는 시점에 일괄적으로 파괴된다.
- 일단 마법 공격으로 나가는 SlashEffect는 색깔이 보라색으로 바뀌어서 나가도록 수정함(시각화)

### 구현
>[!done]
>1. `Skill`에서 해당 스킬에 사용되는 이펙트 프리팹들을 필드로 정의한다.
>	- 예시
>		- 변경된 공격 이펙트`SlashEffect`
>		- 장판 이펙트 
>		- 실제 필드 효과 컨트롤러
>		- 피격 이펙트 등등
>	- 이 때 오브젝트 풀을 생성하는 메서드는 `BaseSkill`에서 정의한다. `BaseSkill`에서는 변경되는 공격 이펙트 부분만 구현하며, 나머지는 각각의 스킬에서 오버라이드해서 다시 정의한다.
>2. `Buff`에서는 스킬로부터 오버라이드된 정보를 받는다. 
>3. `Operator`가 배치되는 시점에 오브젝트 풀을 초기화한다. 이 때 현재 갖고 있는 스킬에 대한 초기화도 진행된다. 공격 이펙트가 변경되는 건 여기서 구현하는데, 이 부분만 스크립트 첨부함.

```cs
	// 기본적으로 Operator가 갖고 있는 공격 이펙트를 사용한다.
	GameObject effectPrefab = OperatorData.meleeAttackEffectPrefab;
	string effectTag = meleeAttackEffectTag;

	// [버프 이펙트 적용] 물리 공격 이펙트가 바뀌어야 한다면 바뀐 걸 적용함
	// 공격 이펙트가 바뀌는 버프는 1개만 있다고 가정한다.
	var vfxBuff = activeBuffs.FirstOrDefault(b => b.MeleeAttackEffectOverride);
	if (vfxBuff != null)
	{
		effectPrefab = vfxBuff.MeleeAttackEffectOverride;
		effectTag = vfxBuff.SourceSkill.GetVFXPoolTag(this, effectPrefab);
	}
```





# 250721 - 짭명방

## 보스 구현 아이디어만
- 기본적인 동작은 `Enemy`의 그것과 동일하다. 
- 대신 일반적인 적과 달리 2가지 스킬을 구현할 예정

- 여기선 아이디어만 쏟아내보자. 
- **모든 스킬은 자신의 쿨타임이 돌 때마다 자동으로 나간다.** 

1. 저지 당할 때 (아이디어)
	- **평타에 기절 섞여서 나감**
		- 여기서 "기절"의 효과는 오퍼레이터의 모든 행동을 막는 역할이다. 
		- 만약 저지 중인 적이 있다면 모든 저지 효과가 풀려야 함.
	- 자신을 저지하고 있는 적을 통과함
	- 단순히 대미지만 증가한 평타
2. 저지 당하지 않을 때 : **채널링 후에 13칸 범위 마법 대미지**


## 기타 밸런스 조정
- 보상 설정
	- `1-1` 클리어 시 1정예화에 필요한 재료 2개 -> 3개씩 지급


# 250719 - 짭명방

## 작업 완료
>[!done]
>`Dualblade` 스킬 아이콘 2개 만들기

- 둘 다 기존 아이콘을 기반으로 변화만 살짝 줬다.

![[Skill_MagicalSmash_128.png]]

![[Skill_MagicalAttackupWithStun_128.png]]

# 250718 - 짭명방
- 오늘 스킬 리팩토링은 끝낸다...
- 근데 수정해도 이해하기 좀 빡센 느낌은 있음.
## 작업 완료

>[!done]
> 스킬 리팩토링
> - `AmmoBasedSkill`
> - `DoubleShotSkill`
> - `AreaEffectSkill` 기반 : `Meteor, ArcaneField, AreaHasteHeal`
> - `SlashSkill`
> - `ShieldSkill`

### AmmoBasedSkill
- 탄환 기반의 스탯 강화 스킬이다.
	- 스탯 강화 버프는 이미 구현되어 있다.
	- 여기에 추가로 **"공격 횟수를 세는" 버프만 추가**하면 된다.
		- 이 버프는 자신이 동작할 때 자신과 연결된 다른 버프들을 해제시키기 위해, 동시에 실행되는 다른 버프들도 갖는다.
		- 이건 스킬에서 설정해주면 됨.
- 스킬은 이 두 개의 버프를 조합하는 방식.

1. **기존 `AmmoBasedActiveSkill` 구현**
```cs
using UnityEngine;
using System.Collections;

namespace Skills.Base
{
    // 탄환 수가 제한되어 있고 지속시간이 무한인 스킬의 추상 클래스
    public abstract class AmmoBasedActiveSkill : ActiveSkill
    {
        [Header("Ammo Settings")]
        [SerializeField] protected int maxAmmo;

        [Header("Attack Modifications")]
        [SerializeField] protected float attackSpeedModifier = 1f;
        [SerializeField] protected float attackDamageModifier = 1f;

        protected int currentAmmo;

        protected float originalAttackSpeed;
        protected float originalAttackDamage;

        protected OperatorUI? operatorUI;

        public int CurrentAmmo => currentAmmo;
        public int MaxAmmo => maxAmmo;

        public override void Activate(Operator op)
        {
            caster = op;
            operatorUI = op.OperatorUI;

            if (!op.IsDeployed || !op.CanUseSkill()) return;

            PlaySkillVFX(op);
            PlayAdditionalVFX(op);

            currentAmmo = maxAmmo;

            originalAttackSpeed = op.AttackSpeed;
            originalAttackDamage = op.AttackPower;

            // 스탯 변경 적용 
            op.AttackPower *= attackDamageModifier;
            op.AttackSpeed /= attackSpeedModifier;

            // 스킬 사용 직후에는 공격 속도 / 모션 초기화
            op.SetAttackDuration(0f);
            op.SetAttackCooldown(0f);

            // SPbar UI 업데이트
            operatorUI?.SwitchSPBarToAmmoMode(maxAmmo, currentAmmo);

            op.StartCoroutine(Co_HandleSkillDuration(op)); // 코루틴은 MonoBehaviour에서만 사용 가능함
        }

        public override void OnAfterAttack(Operator op)
        {
            // 스킬이 켜졌을 때에만 동작
            if (!op.IsSkillOn) return; 

            // 공격 후 탄환 소모
            ConsumeAmmo(op);

            // 탄환이 소진되면 스킬 종료
            if (CurrentAmmo <= 0)
            {
                TerminateSkill(op);
            }
            
        }

        protected virtual void ConsumeAmmo(Operator op)
        {
            currentAmmo = Mathf.Max(0, currentAmmo - 1);

            // 탄환 소모 후 UI 업데이트
            UpdateAmmoUI(op);
        }

        protected override void OnSkillEnd(Operator op)
        {
            // 스킬 종료 시 원래 스탯으로 복원
            op.AttackPower = originalAttackDamage;
            op.AttackSpeed = originalAttackSpeed;

            base.OnSkillEnd(op);
        }

        protected virtual void UpdateAmmoUI(Operator op)
        {
            op.OperatorUI?.UpdateAmmoDisplay(currentAmmo);
        }

        public virtual void TerminateSkill(Operator op)
        {
            OnSkillEnd(op);
            operatorUI?.SwitchSPBarToNormalMode();
        }

        public override IEnumerator Co_HandleSkillDuration(Operator op)
        {
            OnSkillStart(op);
            // op.StartSkillDurationDisplay(duration?ㅉ);
            PlaySkillEffect(op);

            while (op.IsSkillOn)
            {
                // 오퍼레이터 파괴 시 동작을 멈춤
                if (op == null) yield break; 

                // 탄환이 떨어지면 스킬 종료
                if (currentAmmo <= 0)
                {
                    TerminateSkill(op); // 종료 로직은 이 안에 구현됨
                    yield break;
                }

                // 기본) 무한 지속
                yield return null;
            }
        }
    }
}
```

2. **`AttackCounterBuff` 구현** : 연결된 버프들을 관리한다. 공격 횟수가 최대 횟수에 도달하면 연결된 버프를 해제하고 UI를 원래 상태로 되돌려놓음.
```cs
using System.Collections.Generic;
using UnityEngine;

public class AttackCounterBuff : Buff
{
    private int maxAttacks;
    private int currentAttacks;

    // 이 버프가 해제될 때 함께 해제될 버프들
    private List<Buff> linkedBuffs = new List<Buff>();

    private OperatorUI operatorUI;

    public AttackCounterBuff(int maxAttacks)
    {
        this.buffName = "Attack Counter";
        this.duration = float.PositiveInfinity;
        this.maxAttacks = maxAttacks;
    }

    public void LinkBuff(Buff buffToLink)
    {
        if (buffToLink != null)
        {
            linkedBuffs.Add(buffToLink);
        }
    }

    public override void OnApply(UnitEntity owner, UnitEntity caster)
    {
        base.OnApply(owner, caster);
        currentAttacks = maxAttacks; // 최대 횟수를 정해놓고 1씩 줄이느

        // UI를 탄환 모드로 전환
        if (owner is Operator op)
        {
            operatorUI = op.OperatorUI;
            operatorUI?.SwitchSPBarToAmmoMode(maxAttacks, currentAttacks);
        }
    }

    public override void OnAfterAttack(UnitEntity owner, UnitEntity target)
    {
        base.OnAfterAttack(owner, target);

        currentAttacks = Mathf.Max(0, currentAttacks - 1);
        operatorUI?.UpdateAmmoDisplay(currentAttacks);
        if (currentAttacks <= 0)
        {
            // 연결된 모든 버프 제거
            foreach (var buff in linkedBuffs)
            {
                owner.RemoveBuff(buff);
            }

            owner.RemoveBuff(this);
        }
    }

    public override void OnRemove()
    {
        operatorUI?.SwitchSPBarToNormalMode();
        
        base.OnRemove();
    }
}
```

3. **`AmmoBasedSkill` 수정**
- 버프가 종료되는 시점에 스킬이 종료돼야 함. 
- 지속시간이 있는 스킬은 자체적으로 `duration`을 갖고 스킬 자체의 코루틴이 돌기 때문에 `OnSkillEnd`가 정상적으로 동작하지만, 지금처럼 지속시간이 무한인 스킬인 경우에는 버프가 종료되는 시점에 `OnSkillEnd`가 실행돼야 한다.
- AI한테 관련 코드를 다 던져줘도 무시해서 한 번 더 물어봄. 역시 무지성 복붙은 좋지 않다.
- 결론은 **`Buff`에서 스킬 종료 시에 이벤트를 발생시키고, 스킬에서 해당 이벤트를 구독**시키는 것.

```cs
// Buff에 아래 델리게이트 추가
    public System.Action OnRemovedCallback; // 버프 종료 시에 호출되는 콜백 함수

// Skill에서 이벤트 구독
	attackCounterBuff.OnRemovedCallback += () => OnSkillEnd(op);
```
> **`OnSkillEnd(op)`가 파라미터를 받고, `OnRemovedCallBack`은 그렇지 않기 때문에 직접 받을 수 없다. 이럴 때 사용할 수 있는 게 람다식.**

- **그리고 이벤트 구독 해제 코드를 별도로 짤 필요는 없다.** 
	1. `Buff`가 해제될 때 `Operator`에게 자신을 참조에서 해제하라는 명령어를 보냄(이게 중요!)
	2. 참조에서 해제됨. 이 상태에서 이 `Buff`는 씬에 있는 어떠한 오브젝트와도 연결된 상태가 아니기 때문에 가비지 콜렉터에 의해 제거될 수 있는 요소가 된다.

- 만약 미사일과 미사일의 피격이벤트를 메서드로 구독하는 GameManager가 있다고 하면, 미사일이 사라질 때 구독 해제를 하지 않았다고 하자. 이 때 미사일 - 게임 매니저를 연결하는 요소가 여전히 남아있기 때문에 이 미사일은 가비지 콜렉터에 의해 해제되지 않는다.

- **UI에 연결하는 것도 이벤트 기반의 로직**으로 수정
	- 1. 버프가 추가/제거될 때마다 `UnitEntity`에서 이벤트를 발생시킴
	- 2. `UI`는 원하는 버프가 오퍼레이터에 추가된 걸 발견하면 `UI`의 초기화`OnApply` 및 업데이트 메서드를 등록시킴


### DoubleShotSkill
- 기존 구현에서 핵심은 `ModifiesAttackAction`이라는 게 있었고, **해당 필드가 활성화**됐을 때 공격 매커니즘이 `Attack`이 아닌 **스킬에 있는 방식을 따르는 것**이었음.
- 이걸 `Buff`로 옮기면 된다. 


### ArcaneFieldSkill
1. **`CannotAttackBuff` 만들기**
- 말 그대로 버프가 켜진 동안에 기본 공격을 하지 않음
- 단 공격 쿨타임은 계속 돌아감 - 아무것도 하지 않는데도 계속 호출될 수 있기 때문에
```cs
public class CannotAttackBuff : Buff
{
    public CannotAttackBuff(float duration)
    {
        this.buffName = "Cannot Attack";
        this.duration = duration;
    }

    public override bool ModifiesAttackAction => true;

    public override void PerformChangedAttackAction(UnitEntity owner)
    {
        // 공격 쿨타임만 돌리고 실질적으로 아무런 기능을 하지 않음을 표시함
        // Buff와 똑같기 때문에 굳이 넣어도 되지 않지만, 가독성을 위해 넣음
        // 쿨타임을 돌리는 이유는 계속된 호출을 방지하기 위함
        base.PerformChangedAttackAction(owner);
    }
}
```

2. `ArcaneFieldSkill` 수정하기
- `CannotAttackBuff`를 자신에게 걸고, `ArcaneFieldController`을 소환하는 기능
- 참고) 이 과정에서 `ActiveSkill -> AreaEffectSkill -> ...`으로 범위를 구현하는 스킬들이었던 `MeteorSkill`, `ArcaneFieldSkill`, `AreaHasteHealSkill` 등을 **단순하게 `ActiveSkill`에서 직접 상속받는 방식으로 변경한다.**
	- 지금 수정되는 방식이 Fire and Forget이므로 Skill은 필요한 객체들을 발사하기만 하고, 생명주기는 각 객체가 스스로 책임지도록 하면 된다. 지금의 `AreaEffectSkill`에서 직접 관리할 필요는 없음.
- `Controller`까지 한번에 싹 수정함. 
- 생각보다 잘 된다.

- 이 부분은 나도 작업하면서 머리가 좀 복잡해지는 내용이어서 정리해봄. 

> [!note]
> **1. 수정 전** 
> - `AreaEffectSkill`이라는 중앙 관리자가 있었다. 범위 스킬들을 묶어서 관리하기 위해 구현했던 건데, 서로 다른 방식으로 동작하는 스킬들(즉발, 지속시간 등)을 범위 스킬이라는 이유만으로 묶어서 관리하려고 했다.
> - 씬에 생성된 모든 효과 객체들을 일일이 추적해서 시전자가 죽으며 직접 청소하는 등의 책임을 졌다.
> 
>**2. 수정 후**
> - 중앙 관리자 `AreaEffectSkill`을 없앴다. 
> - `Skill` : **어떤 효과를 발동시키는 명령자.** `Buff`를 부여하고 `Controller`을 맵에 나타나게 한다.
> - `Buff` : **캐릭터에게 붙어서 특정 상태를 부여**하는 표식 / 지속 효과 등등
> - `Controller` : **씬에 생성되어서 주어진 역할을 하고 사라진다.**

- 구체적인 내용(제미나이 참고, 복붙은 아니고 옮겨적음)
1. `AreaEffectSkill` : 제거됨
- 대신 이것을 상속받던 스킬들 `MeteorSkill, AreaHasteHealSkill, ArcaneFieldSkill`은 `ActiveSkill`을 직접 상속받도록 변경했음
- 왜?
	- **추상화가 잘못됨** : "범위 효과"라는 기준만으로 지속형, 즉발형 스킬을 억지로 묶었다.
	- **불필요한 복잡성** : 상속이 깊어질수록 코드를 이해하고 추적하기 어려워진다.
	- **책임 과다** : 씬 객체 추적, 오브젝트 풀링, 시각화 등의 책임을 한 클래스가 모두 졌다.

2. 효과 추적 및 생명주기 관리
- `Skill`이 `Dict`와 `Event`를 통해 씬의 게임 오브젝트들을 추적하고 정리하는 로직 제거
- 어떻게 : 
	- **부모-자식 관계 활용** : 효과 객체들의 부모를 시전자로 설정해서 시전자가 파괴되면 함께 파괴되도록 수정
	- **코루틴 활용** : 각 컨트롤러는 `Update` 대신 코루틴을 활용해 자신의 생명주기를 직접 관리하도록 변경
- 왜 :
	- 안정성 : 유니티 엔진의 내장된 생명주기 관리 기능 활용 
	- 단순함 : **`Instantiate` 한 줄로 다 정리됨 - 스킬 시전 오브젝트를 부모로 둔 것** 만으로 수많은 이벤트 구독 / 해제 코드가 다 필요없어졌다.
	- 성능 : 수십 개의 객체가 `Update`를 돌리는 것보다 코루틴의 `yield return`이 성능에 더 유리함

3. 시각화 및 효과 생성 로직
- `AreaEffectSkill`에 있던 공통 메서드들이 각 개별 스킬 클래스의 `private` 헬퍼 메서드로 변경됨
- 각 스킬은 자신의 `PlaySkillEffect`에서 각각의 메서드에 정의된 함수들을 호출한다.
- 왜 :
	- 유연성 : 모든 범위 스킬이 똑같은 방식으로 시각화/효과를 생성하지 않는다. 각 스킬은 자신만의 고유한 연출과 로직을 가질 수 있는 자유가 부여됐다.
	- 응집도 향상 : 해당 스킬의 모든 로직은 해당 클래스 파일 내에 있어서 가독성과 유지보수성이 향상됐다. 



### SlashSkill
- `SlashSkill`
	- 일단 `SlashSkillController`에서 **파티클 시스템의 충돌 로직을 사용하고 있는데, 이게 성능적인 부하가 크다고 함.** 
	- 그러나 **실질적으로 일회성으로 나가는 스킬이고 판정되는 경우도 많지 않기 때문에 유지**함
```cs
using System.Collections.Generic;
using Skills.Base;
using UnityEngine;

namespace Skills.OperatorSkills
{
    [CreateAssetMenu(fileName = "New Slash Skill", menuName = "Skills/SlashSkill")]
    public class SlashSkill : ActiveSkill
    {
        [Header("Damage Settings")]
        [SerializeField] private float damageMultiplier = 2f;

        [Header("Skill Settings")]
        [SerializeField] private GameObject slashEffectPrefab = default!;
        [SerializeField] private float effectSpeed = 8f;
        [SerializeField] private float effectLifetime = 0.5f;

        protected override void SetDefaults()
        {
            duration = 0f;
        }

        protected override void PlaySkillEffect(Operator op)
        {
            if (slashEffectPrefab == null) return;

            Vector3 spawnPosition = op.transform.position + op.transform.forward * 0.5f;
            Quaternion spawnRotation = Quaternion.LookRotation(op.FacingDirection);
            GameObject effectObj = Instantiate(slashEffectPrefab, spawnPosition, spawnRotation);

            SlashSkillController controller = effectObj.GetComponent<SlashSkillController>();
            if (controller != null)
            {
                controller.Initialize(op, op.FacingDirection, effectSpeed, effectLifetime, damageMultiplier, skillRangeOffset, op.OperatorData.HitEffectPrefab, op.HitEffectTag);
            }
        }
    }
}
```
> 매우 짧아졌다. 
> 추가로 눈치 못챘던 버그가 있었는데, `Controller`에 `damageMultiplier`가 들어가야 하는데 스킬에서 대미지를 계산해서 직접 넣고 있었다. 즉 대미지 계산 배율이 수백 단위가 된 거임. 이상하게 쎄긴 하더라.



### ShieldSkill
- `ShieldBuff`
```cs
using UnityEngine;
using UnityEngine.VFX;

public class ShieldBuff : Buff
{
    private float shieldAmount;
    private GameObject shieldEffectPrefab;
    private GameObject currentShieldEffect;

    public ShieldBuff(float amount, float duration, GameObject vfxPrefab)
    {
        this.shieldAmount = amount;
        this.duration = duration;
        this.shieldEffectPrefab = vfxPrefab;
        this.buffName = "Shield";
    }

    public override void OnApply(UnitEntity owner, UnitEntity caster)
    {
        base.OnApply(owner, caster);
        if (owner is Operator op)
        {
            op.shieldSystem.OnShieldChanged += HandleShieldChanged;
            op.ActivateShield(shieldAmount);
            PlayShieldVFX(op);
        }
    }

    public override void OnRemove()
    {
        if (owner is Operator op)
        {
            op.DeactivateShield();
            op.shieldSystem.OnShieldChanged -= HandleShieldChanged;
            RemoveShieldVFX();
        }
        base.OnRemove();
    }

    private void PlayShieldVFX(Operator op)
    {
        if (shieldEffectPrefab != null)
        {
            currentShieldEffect = GameObject.Instantiate(shieldEffectPrefab, op.transform.position, Quaternion.identity, op.transform);
            currentShieldEffect.GetComponent<VisualEffect>().Play();
        }
    }

    private void RemoveShieldVFX()
    {
        if (currentShieldEffect != null)
        {
            currentShieldEffect.GetComponent<VisualEffect>()?.Stop();
            GameObject.Destroy(currentShieldEffect, 1f);
        }
    }

    private void HandleShieldChanged(float currentShield, bool isShieldDepleted)
    {
        if (isShieldDepleted)
        {
            owner.RemoveBuff(this);
        }
    }
}
```

- `ShieldSkill`
```cs
using UnityEngine;
using Skills.Base;
using UnityEngine.VFX;

namespace Skills.OperatorSkills
{
    [CreateAssetMenu(fileName = "New Shield Skill", menuName = "Skills/Shield Skill")]
    public class ShieldSkill : ActiveSkill
    {
        [Header("Shield Settings")]
        [SerializeField] private float shieldAmount = 500f;

        [Header("Stat Boost Settings")]
        [SerializeField] private StatModifierSkill.StatModifiers statMods;

        [Header("Shield Visual Effects")]
        [SerializeField] private GameObject shieldEffectPrefab = default!;

        private ShieldBuff? _shieldBuff;
        private StatModificationBuff _statBuff;

        protected override void PlaySkillEffect(Operator op)
        {
            _statBuff = new StatModificationBuff(this.duration, statMods);
            op.AddBuff(_statBuff);

            _shieldBuff = new ShieldBuff(shieldAmount, this.duration, shieldEffectPrefab);
            op.AddBuff(_shieldBuff);
        }

        protected override void OnSkillEnd(Operator op)
        {
            // 지속시간이 다 되어서 끝나는 경우 - 적용된 버프들을 제거함
            if (_statBuff != null) op.RemoveBuff(_statBuff);
            if (_shieldBuff != null) op.RemoveBuff(_shieldBuff);
            _statBuff = null;
            _shieldBuff = null;

            base.OnSkillEnd(op);
        }

    }
}
```
> 이렇게 구현하는 경우 `ShieldBuff`가 깨지더라도 `StatBuff`는 지속시간 동안 유지된다. 
> 만약 `ShieldBuff`가 깨졌을 때 `StatBuff`도 깨지게 하고 싶다면? 아래처럼 구현하면 된다. 여기선 사용하지 않음.
```cs
        protected override void PlaySkillEffect(Operator op)
        {
            _statBuff = new StatModificationBuff(this.duration, statMods);
            op.AddBuff(_statBuff);

            _shieldBuff = new ShieldBuff(shieldAmount, this.duration, shieldEffectPrefab);
            op.AddBuff(_shieldBuff);

            // _shieldBuff.LinkBuff(_statBuff);
            // _shieldBuff.OnRemovedCallback += () => OnSkillEnd(op);
        }
```

- 버프가 제거될 때 아래의 메서드가 호출되고
```cs
    public virtual void OnRemove()
    {
        // 연결된 버프들이 있다면 우선 제거함
        foreach (var buff in linkedBuffs.ToList())
        {
            owner.RemoveBuff(buff);
        }

        // 스킬의 후처리 콜백 호출
        OnRemovedCallback?.Invoke();
        RemoveVFX();
    }
```

- 이를 호출하는 `UnitEntity.RemoveBuff`는
```cs
    public void RemoveBuff(Buff buff)
    {
        if (activeBuffs.Contains(buff))
        {
            buff.OnRemove(); // 만약 연결된 다른 버프들이 있다면 여기서 먼저 제거됨
            if (activeBuffs.Remove(buff))
            {
                OnBuffChanged?.Invoke(buff, false);
            }
        }
    }
```

의 구조를 가진다. 그래서 위처럼 `Shield -> StatModifier`로 연결된 상태이고, 지속시간이 만료되지 않았는데 Shield가 파괴될 상황이라면

1. `ShieldBuff`에 연결된 `StatModiferBuff`부터 제외됨
2. 마지막으로 `ShieldBuff`가 파괴됨
3. `ShieldBuff`에 달아뒀던 `OnSkillEnd(op)`에 의해 스킬 종료 메서드가 실행됨

의 구조를 갖는다.

- 쉴드랑 코스트 회복 잘 되는지 보고 마무리하겠음.
- 스택 오버플로우 이슈가 있었다. 해결함. 근데 `Defender`가 이상하게 단단한 느낌도 있음.




# 250717 - 짭명방

## 작업 완료
>[!done]
>- 스킬 시스템 리팩토링
>	- `CrowdControl`을 `Buff`에 통합
>	- 행동 제약 플래그 반영
>- 버그 수정
>	- `SmashSkill` 관련
>		- 공격 후 SP가 초기화되지 않는 문제
>		- `enumeration` 관련 오류
>	- `StunOnHitEffect` 적용 시 스턴이 들어가지 않는 현상
>	- `StunEffect` 나타나지 않는 현상

### 스킬 / 버프 시스템 수정
- 지금처럼 `Buff` 시스템을 추가했을 때, 어디까지를 **`Buff`로 구현하고 어디까지를 `Skill`로 구현해야 하는가? 에 대한 고민이다.**

#### 리팩토링 : CrowdControl -> Buff 시스템으로 통합
- `Buff`에 `IsDebuff`라는 프로퍼티를 추가, `Stun`이나 `Slow` 등의 기존 `CrowdControl`로 구현된 클래스들을 모두 `Buff` 시스템으로 통합한다.
- 이제 `UnitEntity`는 `Buff`로만 자신에게 적용된 버프, 디버프들을 모두 관리하는 방식.

#### 행동 제약 플래그 시스템 : 비트 기반
[[행동 제약 시스템 - 비트 연산]]에 별도로 정리.

위처럼 행동 제약 시스템을 별도로 구현했다면, `UnitEntity`에서 행동 제약을 추가하고 제거하는 메서드를 만들고, `Buff`에서 이것들을 이용하면 된다.

```cs
[System.Flags] 
public enum ActionRestriction
{
    None = 0,
    Stunned = 1 << 0, // 00000001 (1)

    // 아래는 참고로 쓰라는 예제들
    // Frozen = 1 << 1,   // 빙결 상태 (2)
    // Disarmed = 1 << 2, // 무장 해제 (공격만 불가) (4)
    // Rooted = 1 << 3,   // 속박 (이동만 불가) (8)
    // Casting = 1 << 4,  // 스킬 시전 중 (16)

    CannotAttack = Stunned,
    CannotMove = Stunned, 
}
```
> 실제로 구현한 건 `Stun`밖에 없지만, 내 프로젝트가 아니더라도 다른 곳에서 다룰 걸 대비해서 여기서도 써둔다.

- 위처럼 구현했다면 `UnitEntity`에 아래처럼 구현한다.
```cs
    public ActionRestriction Restrictions { get; private set; } = ActionRestriction.None;
    
    public void AddRestriction(ActionRestriction restirction)
    {
        Restrictions |= restirction; // 비트 OR 연산으로 플래그 추가
    }

    public void RemoveRestriction(ActionRestriction restirction)
    {
        Restrictions &= ~restirction; // AND, NOT 연산으로 플래그 제거
    }
    public bool HasRestriction(ActionRestriction restirction)
    {
        return (Restrictions & restirction) != 0; // 겹치는 비트가 있으면 true, 없으면 false.
    }
```
> 비트 기반의 연산이다~ 하고 생각하면 대충 이해는 될 것이다.

- 그러면 이제 `Buff`에서는 저 메서드들을 이용해 제약 플래그를 추가하거나 제거만 해주면 된다. 아래는 `StunBuff`.
```cs
    public override void OnApply(UnitEntity owner, UnitEntity caster)
    {
        base.OnApply(owner, caster);
        owner.AddRestriction(ActionRestriction.Stunned);
    }

    public override void OnRemove()
    {
        owner.RemoveRestriction(ActionRestriction.Stunned);
        base.OnRemove();
    }
```
> 단순히 `기절`이라는 제약을 추가하고 지워주기만 하면 끝이다. 

> 이제 `HasRestriction`을 조건처럼 쓰면 됨



### 버그 수정
#### SmashSkill 관련
1. 스킬 발동 후 SP가 초기화되지 않음
	- `OnAfterAttack(UnitEntity target)`이라고 설정해놓고 `Operator`에는 공격 대상으로 설정했다. **메서드 자체를 `OnAfterAttack(UnitEntity owner, UnitEntity target)`으로 수정.** 
	- 공격 후에 상대에게 적용할 효과가 있고, 버프를 갖고 있는 이 캐릭터에게 적용할 효과가 별도이기 때문이다.
- 2. `InvalidOperationException: Collection was modified; enumeration operation may not execute.` 오류
```cs
foreach (var buff in activeBuffs)
{
	buff.OnAfterAttack(this, target);
}
```
> - **반복문 안에서 컬렉션을 건드리기 때문에 발생하는 오류**다. 
> - 이전에도 배웠듯 이런 상황에서는 복사본을 만든 다음 진행하는 방법이 간단하게 먹힌다. 성능적인 부하도 크게 우려할 수준은 아니라고 한다. **`activeBuffs -> activeBuffs.ToList()`로 수정.**


#### `StunOnHitBuff`가 적용됐을 때 적에게 스턴을 먹이지 않는 현상

- 명방 업뎃했으니까 돌리고 작업 ㄱ
- 생각보다 빨리 보고 왔다. 염국 배경의 스토리 중에 제일 좋았다.

- 위 문제를 다시 생각해보면, **`Buff` 자체의 `duration`이 설정되지 않기 때문으로 보인다.** 그래서 버프가 켜지자마자 꺼지는 듯.
	- 실질적인 `duration`을 어디에서 관리해야 할까? 
	- 지금의 구현을 보면 `StunBuff`가 있고, `StunOnHitBuff`가 있다.
		- 전자는 기절 자체, 후자는 평타 시 일정 확률로 기절을 부여하는 버프임.

```cs
public class StunOnHitBuff : Buff
{
    private float stunChance;
    private float stunDuration;

    public StunOnHitBuff(float duration, float stunChance, float stunDuration)
    {
        buffName = "Stun On Hit";
        this.duration = duration; // 버프 자체의 지속 시간
        this.stunChance = stunChance;
        this.stunDuration = stunDuration; // 버프로 인한 기절의 지속 시간
    }

    public override void OnAfterAttack(UnitEntity owner, UnitEntity target)
    {
        Debug.Log("공격 후 기절 확률 계산");
        float variation = Random.value;
        Debug.Log($"variation : {variation}, stunChance : {stunChance}, variation <= stunChance : {variation <= stunChance}");
        
        if (variation <= stunChance) // 예를 들어 25%라고 하면 이 조건이 맞음
        {
            if (target != null && target.CurrentHealth > 0)
            {
                StunBuff stunBuff = new StunBuff(stunDuration);
                target.AddBuff(stunBuff);
            }
        }
    }
}
```
> 생성자 자체에서 `duration`을 받도록 수정하면 된다. 이는 `stunDuration`과 구분되는 개념으로, 전자는 버프의 지속시간, 후자는 스킬 효과의 기절 시간이 된다.

#### `StunBuff` 이펙트 관련
이펙트 데이터베이스의 초기화가 아래처럼 이뤄진다.
```cs
public void Initialize()
{
	buffVfxMap = new Dictionary<System.Type, GameObject>();

	foreach (var mapping in effectMappings)
	{
		// 문자열 클래스 이름을 실제 Type으로 변환
		System.Type buffType = System.Type.GetType(mapping.buffClassName);

		if (buffType == null)
		{
			Debug.LogWarning($"버프 이펙트 데이터베이스에 : {mapping.buffClassName}이 없음");
			return;
		}
		if (mapping.vfxPrefab == null)
		{
			Debug.LogWarning($"버프 이펙트 데이터베이스에 : {mapping.vfxPrefab}이 없음");
			return;
		}

		// 실제 buffType이 있고, 이펙트 프리팹도 있다면 추가됨
		if (!buffVfxMap.ContainsKey(buffType))
		{
			buffVfxMap.Add(buffType, mapping.vfxPrefab);
		}
	}
}
```
> 여기서 `GetType`으로 문자열 클래스 이름에 해당하는 실제 타입을 찾기 때문에 해당 타입은 정확하게 넣어야 한다. 예를 들어 `StunBuff`라면 문자열에 `StunBuff`라고 넣어야 한다는 것.
> - 만약 네임스페이스가 있다면 앞의 네임스페이스들도 다 적어줘야 함.

# 250716 - 짭명방

## 작업 중

- `DualBlade` 스킬들 구현
	- 남은 건 아이콘인데 우선 이거 작업하기 전에 AI의 조언부터 생각해보고 넘어가자.

### 스킬 시스템 확장은 계속 진행 중


## 작업 완료

>[!done]
>1. **`AttackSource` 수정 및 스킬로 인한 `AttackType`을 반영하기**
>2. **오브젝트 풀 관리 로직 수정** : `OperatorData, EnemyData` 단위로 관리, 종류에 따른 인스턴스가 최초로 생성될 때 오브젝트 풀 생성, 필요할 때에 풀 확장, 게임 종료 시 오브젝트 풀 파괴
>3. `DualBlade` 스킬 구현 
>	- 1스킬 완료, 아이콘 작업 남음
>	- 2스킬 구현 중, 아이콘 작업 남음
>4. **스킬 시스템 수정 : 실질적인 효과는 버프로, 어떤 버프를 실행시킬 지는 스킬로, 버프를 담는 통은 캐릭터**로
>5. 기타 이슈 수정
>	- `RequestExit` = 수동으로 나가기 버튼을 눌렀을 때의 동작은 `GameOver`로 통합
>	- 로비로 돌아가는 버튼이 1번째 클릭은 동작하지 않는 이슈

### 1. 스킬 등으로 인한 AttackType 변경

>[!note]
>1. `OnBeforeAttack`에 변경하고 싶은 변수를 `ref`로 지정
>2. 기본적으로 `Operator`가 갖는 `attackType`을 지정하되 `OnBeforeAttack`에서 수정되어야 할 요소를 수정하면 됨

- 스킬이 발동하는 상황에서 `AttackType`을 변경하려면

```cs
public virtual void OnBeforeAttack(Operator op, ref AttackType type, ref float damage, ref bool showDamagePopup){ }
```
> 이런 식으로 구현하면 된다. `ref`을 추가하면서 직접 해당 파라미터를 바꿀 수 있게 함.

- 그러면 아래처럼 공격을 시도하기 전, 오퍼레이터가 기본적으로 갖고 있는 타입을 갖고 온 다음 공격 직전에 검사해서 반영시킬 수 있음.
```cs
AttackType finalAttackType = AttackType;

if (CurrentSkill != null)
{
	CurrentSkill.OnBeforeAttack(this, ref damage, ref finalAttackType, ref showDamagePopup);
}
```
> 자세한 구현은 스킬마다 달라지니까 거기서 사용하면 됨
> 예를 들면 SP가 가득 찼을 때 1회성으로 발동되는 스킬이라면 거기서 조건을 넣으면 되고, 버프가 활성화됐을 때 계속 나가는 스킬이이도 마찬가지다.
> - 물론 후자는 오퍼레이터의 공격 타입 자체를 바꿔버리는 방식으로도 구현할 수 있겠다.

### 2. 오브젝트 풀 수정 : 생성은 사용할 때에, 파괴는 스테이지 종료 시에
- 코드 중에 이런 지적사항이 있었다 : **개별 `Enemy`, 즉 인스턴스 ID마다 오브젝트 풀을 관리하는 것보다, 같은 종류의 `Enemy`라면 같은 오브젝트 풀을 사용하게 하고 더 생성하지 않는다**

이 방식의 논리는 이렇다 
- 현재의 구현은 적이 파괴될 때마다 풀이 파괴되므로 비효율적
- 같은 종류의 적들은 같은 프리팹을 사용하므로 여러 적이 공유하는 하나의 오브젝트 풀을 만들고 거기서 꺼내서 사용하면 되는 방식
- **풀의 파괴 시점은 개별 적이 파괴되는 시점이 아니라 스테이지가 종료될 때**
- 풀의 확장 시점은 현재 활성화된 오브젝트가 너무 많아서 추가로 필요할 때에만 한정된다. 적이 생성될 때마다도 아니고 단순히 "오브젝트가 필요한데 부족할때" 뿐임.

- 그러면 `Operator`에 대해서도, 재배치라는 동작이 분명하게 있으니까 똑같은 논리로 적용할 수 있겠다.
	- 즉 생성은 오퍼레이터가 배치되는 시점. 재배치여도 1씩 증가하므로 성능에 큰 부하가 되지 않는다.
	- 파괴는 스테이지가 끝날 때.

- 이펙트도 똑같이 `ObjectPoolManager.CreatePool`에서 관리된다. 중복을 걱정할 필요는 없음.


### 3. DualBlade 스킬 구현

- 1번째 스킬
	- `SmashSkill` 자체에 이제 `AttackType`이 구현 가능하기 때문에 , 같은 스크립트로 다른 스킬을 만들었다. 
		- 기존 스나이퍼는 200% 물리 대미지였다면
		- 이번엔 150% 마법대미지로 구현함. 
- 2번째 스킬
	- `StatModifierSkill`을 사용할 예정이므로 이것의 경우에는 
		- 스킬이 활성화될 때 마법 공격으로 전환
		- 스킬이 비활성화될 때 원래의 물리 공격으로 돌아온다.
	- 추가로 공격 시 일정 확률로 스턴이 들어가는 것도 구현할 것

### 4. Skill 시스템 관련 : "버프" 시스템으로의 확장

> [!note]
> 현재 방식은 스킬 스크립트가 직접 로직을 수행하는 직관적인 구조입니다. 만약 더 복잡한 효과(예: 독, 출혈, 여러 개의 버프/디버프)를 다루게 된다면, "버프/디버프 시스템"을 도입하는 것을 고려해볼 수 있습니다.
> - 스킬이 활성화되면, Operator에게 **"공격 시 기절 효과를 부여하는 버프"**를 추가합니다.
> - Operator의 OnAfterAttack에서는 자신이 가진 모든 버프를 순회하며 "공격 후 효과"를 발동시킵니다.**
>   이 방식은 스킬과 오퍼레이터의 결합도를 낮추고, 다양한 효과를 조합하기 쉽게 만들어주지만, 초기 설계가 더 복잡해집니다. 현재 요구사항에서는 제시해 드린 OnAfterAttack 훅을 직접 오버라이드하는 방식이 가장 간단하고 효율적입니다.

- 이걸 구체적으로 물어봤다. **결론은 스킬과 버프를 분리해서 구현할 수 있다**는 것.
- 크게 3개의 구조가 된다. 캐릭터, 스킬, 버프
- 캐릭터는 버프들을 담는 통이 된다. 
- 스킬은 지속시간 등을 관리하고 어떤 버프를 쓸지에 대한 인스턴스 등을 관리한다. 
- 버프는 실질적인 효과.

- 간략한 예시 

1. 버프 시스템
```cs
// 버프 시스템의 기초
public abstract class Buff
{
    public string buffName;
    public float duration; // 지속 시간. 무한이면 float.PositiveInfinity
    public UnitEntity owner; // 버프 소유 오퍼레이터
    public UnitEntity caster; // 버프 시전자

    public virtual void OnApply(UnitEntity owner, UnitEntity caster)
    {
        this.owner = owner;
        this.caster = caster;
    }

    public virtual void OnRemove() { } // 버프 제거 시에 호출
    public virtual void OnUpdate() { } // 매 프레임마다 업데이트가 필요하면 호출
    public virtual void OnBeforeAttack(UnitEntity target, ref float damage, ref AttackType attackType, ref bool showDamagePopup) { } // 공격 전 호출
    public virtual void OnAfterAttack(UnitEntity target) { } // 공격 후 호출
}

// 공격에 스턴이 묻어나가는 버프
public class StunOnHitBuff : Buff
{
    private float stunChance;
    private float stunDuration;

    public StunOnHitBuff(float chance, float duration)
    {
        buffName = "Stun On Hit";
        stunChance = chance;
        stunDuration = duration;
    }

    public override void OnAfterAttack(UnitEntity target)
    {
        if (Random.value <= stunChance)
        {
            if (target != null && target.CurrentHealth > 0)
            {
                StunEffect stunEffect = new StunEffect();

                if (target is Operator opTarget)
                {
                    stunEffect.Initialize(opTarget, owner, stunDuration);
                    opTarget.AddCrowdControl(stunEffect);
                }
                else if (target is Enemy enemyTarget)
                {
                    stunEffect.Initialize(enemyTarget, owner, stunDuration);
                    enemyTarget.AddCrowdControl(stunEffect);
                }
            }
        }
    }
}
```

2. 스킬 시스템
```cs
namespace Skills.OperatorSkills
{
    [CreateAssetMenu(fileName = "New Stat Modifier Skill", menuName = "Skills/Stat Modifier With OnHit Skill")]
    public class StatModifierWithOnHitSkill : StatModifierSkill
    {
        [Header("On-Hit Effect Settings")]
        [Range(0f, 1f)]
        public float stunChance = 0f;
        public float stunDuration = 1.0f;

        // 스킬이 부여하는 버프를 저장하는 필드
        private StunOnHitBuff stunBuffInstance;

        protected override void PlaySkillEffect(Operator op)
        {
            // 스탯 강화 효과
            base.PlaySkillEffect(op);

            // 스턴 효과 추가
            if (stunChance > 0)
            {
                stunBuffInstance = new StunOnHitBuff(stunChance, stunDuration);
                op.AddBuff(stunBuffInstance); // 버프를 추가하면 Buff.OnAfterAttack에 의해 기절 효과가 묻어나감
            }
        }

        protected override void OnSkillEnd(Operator op)
        {
            op.RemoveBuff(stunBuffInstance);
            base.OnSkillEnd(op);
        }
    }
}
```
> - 버프의 세부 효과는 Buff에 구현되어 있기 때문에, Skill에서는 지속 시간을 관리해서 스킬이 켜질 때 버프들을 캐릭터에 등록하고 스킬이 꺼질 때 버프들을 캐릭터에서 제거시킨다.
> - 이외에도 스킬 지속시간 동안 활성화되는 이펙트라든가, 오퍼레이터의 상태 등등을 관리한다.
> 	- 예를 들어 스킬이 켜져 있다가 꺼졌다면 스킬은 오퍼레이터의 스킬이 켜져 있던 상태를 끄고, 오퍼레이터는 그런 상태의 변화에 따라 또 이벤트를 발생시키거나 직접 SPBar의 색을 변경하는 등의 실행을 시킨다.

- 한편 기존 `SmashSkill` 같은 경우는 어떻게 구현할까? 자동으로 강화된 공격이 나가는 방식이었다.

1. `Operator`에서는 `Update()`에서 스킬의 `OnUpdate()`를 실행시킨다. 
2. 스킬에서는 오퍼레이터의 SP를 보고 있다가, SP 조건이 스킬을 실행할 수 있는 조건이 되면 스킬에 달려 있는 버프를 `Operator`의 버프 리스트에 추가한다.
3. `Buff`에서는 공격 전에 스킬의 효과를 추가하고 공격 후에는 SP를 0으로 만들면서 자신을 해제하는 명령어를 오퍼레이터에 전달한다.


### 5. 기타 이슈 수정
- `RequestExit`의 로직은 `GameOver`로 수정
	- 이 과정에서 `GameOver` 패널이 나타날 때 `ConfirmationReturnToLobbyPanel`은 사라져야 함. 그것도 구현.

- 스테이지 패널에서 로비로 돌아가는 버튼 클릭 시 첫번째 클릭은 동작하지 않는 이슈
	- 세부 구현을 보면
```cs
    private void Awake()
    {
        canvasGroup = GetComponent<CanvasGroup>();
        gameObject.SetActive(false);
    }

    public void Initialize()
    {
        // 전투 중일 때 멈춤으로 전환
        if (StageManager.Instance!.currentState == GameState.Battle)
        {
            StageManager.Instance!.SetGameState(GameState.Paused);
        }

        // 멈춤 오버레이가 활성화된 경우 비활성화
        StageUIManager.Instance!.HidePauseOverlay();
        gameObject.SetActive(true);
```
처럼 구현되어 있었다. 

잘 몰랐을 때에 작성된 스크립트이긴 한데, **이 방식의 문제가 뭐냐면 `Awake`는 최초로 활성화되는 시점에 실행된다는 것이다.** 즉, 개발 과정에서 이 오브젝트가 비활성화된 상태라면 `Awake`가 아예 동작하지 않게 된다. 이 상태에서 아래의 `gameObject.SetActive(true)`로 들어가면 `Awake`가 바로 동작해서 1번째 클릭이 동작하지 않는다.

한편 2번째 클릭은 동작한다. `Awake`가 더 이상 동작하지 않기 때문이다.

따라서 어떤 패널이 활성화되고 활성화되지 않는지에 대한 구현은 개별 패널에서 구현하는 대신, 이들을 통합하는 매니저에서 구현하는 게 좋다. 

결론 ) **`Awake`에서 `gameObject.SetActive`를 다루는 건 좋지 않음.**



# 250715 - 짭명방

## 다음 날로 넘김

>[!todo]
>- DualBlade의 2가지 스킬을 구현
>- 1번째 스킬은 똑같이 강타인데, 강타가 나갈 때는 마법 대미지가 나가는 방식
>- 2번째 스킬은 아이디어 자체를 생각해봐야 함. 
>	- 일단은 별도의 이펙트를 구현하지 않고 만들 방법을 고민 중
>		- 그래서 버프 형식이 될 것 같다. 
>		- 공격력과 공격 속도가 증가하고 스킬이 켜진 동안 공격 타입이 마법이 되는 방식이면 될 듯. 

- 1번째 스킬 구현
	- 기존의 `SmashSkill`과 동일하되, 공격 타입만 바뀌는 방식이어야 함
	- 이 과정에서 **기존의 공격 타입이 `ICombatEntity.AttackType`에 의존했는데, 대신 `AttackSource` 자체에 `AttackType`이 담기도록 변경함.**
		- 그래야 기본적으로 `Physical` 공격을 하는 캐릭터라도 어떤 효과로 인해서 `Magical` 공격을 하도록 구현할 수 있기 때문에
	- 이거 시스템을 건드린 거라서 생각보다 오래 걸릴 수도 있다.
		- 어차피 언젠가 고칠 일이긴 했기 때문에 시간을 들여서 작업 ㄱㄱ
		- 일단 시간이 없어서 여기까지 하는데 세부적으로 남은 것들 정리해봄


## 작업 완료

>[!done]
>**1. 아이콘 계단으로 깨져서 보이는 문제**
>2. 평타가 2번 나갈 때, **1번째 공격으로 적이 죽은 상황이라면 2번째 공격의 처리**를 어떻게 해야 하는가?


### 1. 아이콘 계단으로 깨져서 보이는 문제
>- 아이콘의 해상도를 256 x 256으로 올렸는데도 계속 깨져서 보이는 문제가 있음
>- 가우시안 블러 때문일 수 있겠다.... 싶어서 1024 이미지를 수정한 다음 작업해봄
>- **가우시안 블러 이미지를 다시 선명한 이미지로 놓고, 해상도를 높여봐도 발생하는 문제 동일함.** 왜 이 아이콘에 대해서만 이런 문제가 나타나는지는 모르겠지만 크게 개선될 기미는 안 보인다. **256으로 놓고 유지하겠음**


### 2. 2연속 공격의 2번째 공격의 처리

#### 원본 게임 테스트
- 일단 지금의 구현은 1번째 공격으로 적이 죽었다면 2번째 공격은 나가지 않는 방식임.
- 원본 게임을 뜯어보면 아래와 같다. 테스트는 바이비크와 첸으로 해봤다.
1) 2개의 공격 각각에 온히트 처리를 하지 않고, **2번째 공격이 맞든 맞지 않든 SP는 1씩 참.**
	- 이건 좀 의외다. 소드마스터는 당연히 SP가 2씩 차는 줄 알았음.
2) 1번째 공격으로 적이 죽었을 경우, 2번째 공격의 피격음이 달라진다. 즉, **헛스윙에 대한 분기 자체는 있는 것으로 보임.** 

#### 구현 방향 설정
- 이건 사실 정말 어떻게 구현하느냐에 따른 차이 같긴 한데, 난 온히트로 생각하고 작업을 했으니까..
1. **온히트 효과로 구현. 적이 피격했다면 SP가 올라감**
2. 단 **2회의 공격 이펙트는 항상 나타남.** 적이 맞았는지 여부는 피격 이펙트 재생이 별도로 있으니까 따로 구현하지 않아도 괜찮을 것 같다. 
	- 이거를 하려면 공격 로직에서 적이 없어도 이펙트는 재생돼야겠다.

#### 실제 구현
- 이걸 어디서 구현해야 할까?
	 - 처음엔 `Operator.cs`에서 구현해야 한다고 생각했다. 이중공격을 하는 상황 외에도 헛스윙이 발생할 수 있는 상황이 내가 예상치 못한 곳에서 있지 않을까? 라는 생각으로.
	 - 그런데 **기존 코드가 헛스윙으로 인한 문제가 발생한 적이 없었고, 이중 공격을 하는 상황에서는 헛스윙이 발생할 걸 예측할 수 있는 상황**이므로 거기다 우선적으로 구현해놓는 게 맞다고 한다. 만약 나중에 비슷한 문제가 발생한다면 근본적인 메서드를 고쳐야 할 수는 있겠지만.

- 따라서 `DualBladeOperator`에서 2번째 공격이 빗나갔을 때의 처리를 별도로 정의해둔다.

- 대신 기존의 `Operator.PlayMeleeEffect`는 수정이 필요하다. `UnitEntity` 자체를 받는 걸로 설정이 되어 좌표를 수정하는 방식으로 수정함. 여기에 엮여있는 `CombatVFXController`까지 수정한다.




# 250708 - 짭명방
- `DualBlade`의 클래스 아이콘 이미지 작업.
	- 칼 2개와 명방의 마름모를 넣고 싶다. 마법 공격을 하는 2번째 직군이기도 해서.
![[DualBlade_128.png]]
> 뭔가 단순하고 마법의 맛이 없지만 그냥 이거 쓰기로 함. ChatGPT한테도 맡겨봤는데 스타일이 너무 화려해서 직접 그렸다.

> 여기서 옵시디언으로 볼 때는 괜찮은데 인게임에서 아이콘을 보면 계단현상이 좀 두드러져 보인다. `Artillery`도 비슷한 현상이 있어서, 얘네 둘은 해상도를 256으로 올려서 넣겠음.

- 스킬은 일단 나중에 구현하기로 하고 기초 테스트만 해본다
	- `ScriptableData`로 만들고, Prefab 연결하고, ResourceManager에 연결된 `OperatorIcon`에 아이콘 추가하고. `Prefab`에는 `Operator` 대신  이전에 구현했던 `DualBladeOperator` 스크립트를 연결했다. 
	- **무한 공격 이슈** : `DualBladeOperator`의 이중 공격 부분 다음에 `AttackDuration, AttackCooldown` 설정함.




# 250704 - 짭명방
## 2번 공격하는 근접 직군 구현

- 이름은 `DualBlade`?
- 특징
	- 기본 공격은 1번 공격 시 2회 타격함
	- 모든 스킬은 공격 시 SP가 회복됨
		- 즉 공격 쿨타임이 돌 때마다 2회 공격하고, SP는 때릴 때마다 1씩 총 2가 올라감.
	- 컨셉은 살짝 바꾸겠음. 스킬을 켜지 않았을 때 물리딜을, 켜거나 사용할 때는 마법딜을 넣는 식으로.
	- 1스킬은 강타로 구현하되 마법 타입으로 공격이 바뀌어서 나감
	- 2스킬은 버프로 구현할까?

- 견본이 좀 있나 찾아봤는데 소드마스터 자체가 5성 이하로 별로 없다. 바이비크, 타찬카, 커터 정도.
	- 스탯은 바이비크의 것을 가져옴

- 스크립트 자체는 이런 구현에서 시작.
```cs
public class DualBladeOperator : Operator
{
    // 공격 사이의 간격
    private float delayBetweenAttacks = 0.15f;

    public override void Attack(UnitEntity target, float damage)
    {
        // 2회 공격 로직을 코루틴으로 구현
        StartCoroutine(DoubleAttackCoroutine(target, damage));
    }

    private IEnumerator DoubleAttackCoroutine(UnitEntity target, float damage)
    {
        bool showDamagePopup = false;
        float polishedDamage = Mathf.Floor(damage);

        base.PerformAttack(target, polishedDamage, showDamagePopup);

        yield return new WaitForSeconds(delayBetweenAttacks);

        if (target != null && target.CurrentHealth > 0)
        {
            base.PerformAttack(target, polishedDamage, showDamagePopup);
        }
    }
}
```

> 이거 일단 중지!

## Operator 리팩토링

### Skill - Operator 관계 재정립

- `BaseSkill`의 경우
```cs
	public bool autoRecover = false; // 활성화시 자동 회복, 비활성화 시 공격 시 회복
	public bool autoActivate = false; // 자동발동 여부
	public bool modifiesAttackAction = false; // 공격 액션 변경 여부
```
이런 필드들이 있다. 그러면 이 필드의 값에 따라 SP 회복 로직이 달라진다든가, 입력을 대기하거나 스킬이 자동으로 나간다거나 하는 부분은 전부 Operator 자체에서 일어나야 하는 일이다.

지금의 `SmashSkill` 같은 경우
```cs
protected override void SetDefaults()
{
	autoActivate = true;
}

// 공격에 묻어나가는 로직
public override void OnBeforeAttack(Operator op, ref float damage, ref bool showDamage)
{
	if (op.CurrentSP >= op.MaxSP) 
	{
		damage *= damageMultiplier;
		showDamage = true;
		op.CurrentSP = 0;
	}
	else
	{
		op.CurrentSP += 1;
	}
}
```
이런 식으로 스킬 자체에서 오퍼레이터의 SP를 회복하는 로직이 있는데, 이렇게 구현하지 말고 

- `Operator`에서는 **스킬 -> 오퍼레이터로 전달시켜서 회복시키는 게 아니라 오퍼레이터 자체에서 필드를 확인하고 그에 따른 동작을 수행하는 게 더 맞는 구현**이 된다.

1. `SmashSkill`의 `else` 부분을 제외한다. 회복 동작은 `BaseSkill.autoRecover = false`일 때 `Operator`에서 동작한다.

2. 공격 시 SP 회복 로직은 `Operator.PerformAttack`의 공격 후에서 구현한다.
```cs
    protected virtual void PerformAttack(UnitEntity target, float damage, bool showDamagePopup)
    {
		float spBeforeAttack = CurrentSP;
	    // 공격 전
        if (CurrentSkill != null)
        {
            CurrentSkill.OnBeforeAttack(this, ref damage, ref showDamagePopup);
        }
		
		// 실제 공격 동작
		// ...
		
		// 공격 후
        if (CurrentSkill != null)
        {
            CurrentSkill.OnAfterAttack(this);
            
            // SP 공격 시 회복 로직
            if (!CurrentSkill.autoRecover && !IsSkillOn && spBeforeAttack != MaxSP)
            {
                CurrentSP += 1; // 세터에 Clamp가 있으므로 여기서 하지 않아도 됨.
            }
        }
    }
```
> 추가로, sp가 최대일 때 나간 공격은 `OnBeforeAttack`에서 스킬이 발동되면서 sp가 0이 되므로 해당 공격에서는 SP가 회복되지 않도록 수정했다.

### 잠깐 휴식 전 정리
- 지금 신경쓰이는 거
```cs
protected void HandleSPRecovery()
{
	// ...

	if (CurrentSP != oldSP && operatorUI != null)
	{
		operatorUI.UpdateUI();
		OnSPChanged?.Invoke(CurrentSP, MaxSP);
		
		// ..
	}
}
```
> - 여기서 **OnSPChanged?.Invoke()로 operatorUi.UpdateUI까지 통합해버리는 게 좋아보인다.**
> - 그런데 `OnSpChanged.Invoke` 이벤트를 구독하는 부분은 `DeployableActionUI` 이랑 `DeployableBarUI`이다. `OperatorUI`는 `DeployableBarUI.SetSPBarColor` 를 수정하고 스킬 아이콘 활성화 여부를 결정하는데..
> - 이벤트로 다 묶어버릴 수 있을 것 같음.
> - 문제라면 `DeployableBarUI`가 따로 있다는 것인데.. 이따 생각해보자.

- 휴식 끝!
###  1. Operator - OperatorUI 정리
1. `OperatorUI` 자체는 `Operator` 자체에서 생성과 파괴를 담당
2. HP 변경, SP 변경 등은 이벤트로 관리
	- 왜냐면 `1:多` 관계임. 저 사건들을 사용할 컴포넌트들을 일일이 관리하는 건 번거로움.
	- 하지만 `UI 자체는 오퍼레이터와 1:1 관계`임

- 이런 구조로 바꿨다. 기존엔 이것저것 엉켜있었음.
```
[ Operator ]  <-- (데이터 소스)
     |
     | (이벤트 발생: OnHealthChanged, OnSPChanged, OnSkillStateChanged)
     V
[ OperatorUI ] (컨트롤러: 이벤트 구독 및 로직 분배)
     |
     | (메서드 호출: UpdateHealthBar, SetSPBarColor 등)
     V
[ DeployableBarUI ] (뷰: 단순한 API 제공 및 하위 컴포넌트 관리)
     |
     +--- [ HealthBar ] (실제 뷰)
     |
     +--- [ SPBar ] (실제 뷰)
```

### 2. Skill - Operator - OperatorUI 정리
- 크게 2가지 궁금한 게 있다.
	1. **오퍼레이터의 스킬을 켜고 끄는 걸 어디서 처리해야 할까?**
		- **스킬의 시작과 끝을 처리하는 지점은 스킬 자체**다. 그래서 **어떤 시점에 어떤 동작을 해야 하는지 아는 스킬에서 오퍼레이터의 상태를 함께 관리**한다.
		- 스킬은 `Operator`의 상태를 변경해달라고 요청하면 `Operator`는 요청을 받아 상태를 변경하고 변경된 사실을 외부에 방송한다.
	2. 스킬이 켜졌을 때 SPBar의 동작은 어디에서 관리해야 할까?
		- SPBar가 어떻게 변하는가는 SPBar 자체에서 처리하면 된다. 스킬에서 일일이 관리할 필요 없다.

## 기타 버그
- [x] `Artillery` 공격이 동작했는데도 대미지가 안 들어가는 것처럼 보이는 이슈
	- `Projectile`에서 폭발하는 경우의 콜라이더 처리가 바뀌어야 한다. 원래는 `UnitEntity`를 직접 감지했으나, 이전에 `Body`를 각 객체의 자식 오브젝트로 별도로 구현하고 거기에 `BodyColliderController` 스크립트를 붙였던 적이 있다. 그 컴포넌트를 감지하도록 수정함.

- [x] `MedicOperator`의 공격이 연속적으로 쫘라락 나가는 현상
	- 공격 쿨타임 적용하는 로직을 Attack 내부로 바꾸면서 발생한 문제인 듯.
	- 오버라이드하기에는 살짝 구조가 달라서 `SetAttackDuration, SetAttackCooldown`을 똑같이 `MedicOperator`에 넣었다.

- [x] `Operator`의 저지도 이상하게 동작한다.
	- 상황) Operator가 저지 중인 적을 성공적으로 제거했을 때, 콜라이더가 겹치지 않는 상황인데 해당 적이 저지당하는 현상이 있음. 이전과 달리 근거리, 원거리를 가리지 않음.
	- `blockableEnemies`가 제대로 처리되지 않은 것으로 보인다. 즉, **콜라이더가 겹쳤을 때 저지 후보에는 들어갔는데, 콜라이더에서 이탈했는데도 저지 후보에서 제거되지 않은 것으로 보임**.
	- `Operator`의 `public override void OnBodyTriggerExit(Collider other)`가 `private`으로 돼 있긴 했었다. 체크해보고 다시 실행시켜봄.

- [x] `Operator`가 배치될 때 겹쳐진 적을 저지하지 않는 현상도 있다.
	- 현재 `BodyCollider`로 뺀 상태이고 배치될 때 이를 활성화한다고 하자. 이 때, `OnTriggerEnter`는 이미 겹쳐진 콜라이더에는 동작하지 않는다. 
	- 따라서 활성화 시점에서 겹쳐져 있으므로 동작하지 않고, 그 다음 프레임에도 `OnTriggerEnter`는 이미 겹쳐있으니까 동작하지 않는다. `OnTriggerStay`는 동작함.
	- 성능까지 고려해본다면, 활성화 시점에 겹쳐진 콜라이더를 체크해서 `OnTriggerEnter`로 넘겨주면 되지 않을까?

- `BodyColliderController`를 아래처럼 구현했다.
```cs
// 이 컨트롤러의 콜라이더 활성화 상태 결정
public void SetColliderState(bool enabled)
{
	if (bodyCollider != null)
	{
		bodyCollider.enabled = enabled;

		// 콜라이더가 켜지는 순간에는 수동 겹침 검사 실행
		if (enabled)
		{
			CheckForInitialOverlaps();
		}
	}
}

// 콜라이더가 활성화된 시점에 겹쳐져 있는 코라이더를 찾아 `OnTriggerEnter`처럼 owner에게 전달한다.
private void CheckForInitialOverlaps()
{
	if (owner == null) return;

	// 콜라이더의 타입을 확인해 Overlap 함수를 사용한다.
	if (bodyCollider is BoxCollider box)
	{
		// BoxCollider와 충돌하는 콜라이더들을 찾음
		Collider[] overlappingColliders = Physics.OverlapBox(
			transform.position + box.center,
			Vector3.Scale(box.size, transform.lossyScale) / 2, // 스케일링을 고려한 실제 크기
			transform.rotation,
			-1, // 모든 레이어
			QueryTriggerInteraction.Collide // 트리거 콜라이더와도 충돌하도록 설정
		);

		foreach (var otherCollider in overlappingColliders)
		{
			// 자기 자신은 무시
			if (otherCollider == bodyCollider) return;

			// 감지된 콜라이더를 owner에게 전달
			owner.OnBodyTriggerEnter(otherCollider);
		}
	}
}
```

- [x] 원거리 `Enemy`가 원거리 공격하지 않는 문제
	- 이건 갑자기 왜 그러는 걸까?
	- 얘도 비슷한 문제겠다. 즉, `OnTriggerEnter`에서 감지하는 게 `DeployableUnitEntity`를 직접 감지하는 게 아니라, 본체 트리거 감지 -> 그 부모에 `DeployableUnitEntity`가 있는가? 가 되는 것.
	- **오늘 발생한 대부분의 문제가 이 본체 콜라이더를 자식으로 이동시키면서 발생한 문제들**이다. 

- [x] `EnemyBarUI`의 체력 변화를 이벤트 기반 구독으로 변경
	- `Operator`에 비해 훨씬 쉽다. 체력밖에 없고 고려할 것도 많이 없음
