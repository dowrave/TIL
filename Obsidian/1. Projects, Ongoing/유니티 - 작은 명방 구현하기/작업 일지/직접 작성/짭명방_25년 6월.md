

# 250627 - 짭명방

## 오늘 배운 점

1. `DOTween` 애니메이션을 갖는 메서드는 일종의 코루틴으로 생각해도 될 듯
	- 그래서 애니메이션이 끝나고 어떤 걸 실행시키고 싶다면 `DOTween`의 `OnComplete()` 내에 구현해야 한다. 
	- 메서드 외부에 따로 두고 해당 메서드 밑에 구현하면 애니메이션이 끝나기 전에 동작할 수 있음.

2. **불특정 다수와의 연결을 고려하면 이벤트 기반의 설계가 제일 좋긴 하다.** 무엇보다 기능을 추가하거나 수정할 때 양쪽 객체에 일일이 구현할 필요가 없다. 해당 객체의 이벤트만 구독하는 방식으로 이으면 되니까 유지보수하기 쉽고 확장성도 좋음.

3. ★★ `트리거 기준` - 어떤 오브젝트의 자식 오브젝트에 여러 콜라이더가 있다면, **부모 오브젝트의 트리거 이벤트 감지 로직은 자식 오브젝트의 트리거 이벤트 감지 로직을 모두 감지**한다.
```
Parent (Collider 1, Rigidbody)
- Child (Collider 2)
```
일 경우, **`Parent`의 `OnTriggerEnter`는 `Collider 1, Collider 2`를 모두 감지한다.** 
따라서 이런 경우에는 `Collider 1`만 감지할 자식 오브젝트를 하나 더 둬야 한다.

- 이 때 `Rigidbody`는 부모 오브젝트에 유지하는 게 좋다.
- 즉 **`Rigidbody`는 최상위 오브젝트에 유지하고 콜라이더는 용도에 따라 자식 오브젝트들로 따로 나눠서 구현해야 한다.**
## 작업 중

### 오퍼레이터 하나 추가하겠음
- 지상 3개 / 언덕 4개라서 지상에서 하나 뚫리면 그 다음은 힘들어지는 느낌이 있다.
- 근데 이건 못했다. 


## 작업 완료

### Toast 상단 패딩 설정
- 그냥 컨테이너의 `Pos Y`만 `-20`으로 잡아주면 된다. 

	
### Enemy 사망 타이밍 조절

#### 문제 상황
- 죽는 애니메이션이 끝나기 전에 킬 스코어가 올라가서, 적이 남아있는 것으로 보이는데 게임이 끝나는 현상

#### 원인
```cs
protected override void Die()
{
	StageManager.Instance!.OnEnemyDefeated(); // 사망한 적 수 +1

	// 공격 이펙트 프리팹 제거
	if (BaseData.hitEffectPrefab != null)
	{
		ObjectPoolManager.Instance!.RemovePool("Effect_" + BaseData.entityName);
	}

	// UI 제거
	if (enemyBarUI != null)
	{
		Destroy(enemyBarUI.gameObject);
	}

	base.Die();
}
```
> `base.Die()`에는 사망 애니메이션을 실행하는 메서드가 들어있다. 그 안에서 `UnitEntity`의 파괴 이벤트와 `Destroy()` 모두 동작함.
> 그런데 위의 사망한 적수 +1 로직을 `base.Die()`이후로 뺄 수 없다. 저 안에서 파괴되기 때문에.

#### 생각
- `StageManager`에서 이벤트를 구독하게 만드는 방법을 생각했음.
	- 그런데 지금의 구현에서 `Enemy`만을 구독하게 하긴 어렵고, `UnitEntity`를 통해 구독하고 이벤트 구독 메서드 내에서 `Enemy`에 대한 형 체크를 한 번 더 해야 함
	- 가능은 한데 `Enemy`에 대해서만 동작하면 될 걸 `UnitEntity` 전체를 구독시킬 필요는 없어보인다.

#### 최종?
1. `UnitEntity.PlayDeathAnimation`에서 파괴 이벤트 발생
```cs
materialInstance.DOFade(0f, 0.3f).OnComplete(() =>
{
	OnDeathAnimationCompleted?.Invoke(this); // 사망할 것임을 알리는 이벤트
	// OnDestroyed?.Invoke(this); // 위의 이벤트로 통합
	Destroy(materialInstance); // 메모리 누수 방지
	RemoveAllCrowdControls();
	Destroy(gameObject);
});
```
> `OnDeathAnimationCompleted`는 크게 2가지 갈래로 나간다.
> 1. 기존 `OnDestroyed`에서 작동되던 것들 : 타일에서의 적 제거 로직, 오퍼레이터의 공격 범위 내의 적 / 현재 공격 대상 설정 해제 로직, `Projectile`의 공격자 / 타겟 제거 로직 등등
> 2. **이 이벤트를 구독하는 `Enemy`의 메서드가 있고, 이 메서드에서 다시 이벤트가 발생한다.** 이거 외에도 마음대로 구현하면 됨.

> 추가로, `Destroy(gameObject)`가 애니메이션의 동작 끝에 구현되어 있기 때문에 **파괴 이벤트를 발생시키겠다면 이 앞에서 발생시켜야 한다.** `DOTween`의 애니메이션 메서드는 코루틴처럼 생각하면 편하다. 즉, 코루틴 메서드 아래에 다른 메서드가 온다면 비동기 작업으로 인해 코루틴이 완료되기 전에 다른 메서드가 실행될 수 있다.


2. `Enemy`에서 해당 이벤트를 구독하는 메서드에서 다시 `Enemy`가 사라지는 이벤트를 발생시킨다.
```cs
public enum DespawnReason
{
    Null, // 디폴트
    Defeated, // 처치됨
    ReachedGoal // 목적지 도달
}

protected override void Awake() 
{
	OnDeathAnimationCompleted += HandleDeathAnimationCompleted;
}

// PlayDeathAnimation이 끝나고 호출되는 이벤트에 의해 실행되는 메서드
protected void HandleDeathAnimationCompleted(UnitEntity unitEntity)
{
	// 자기 자신의 이벤트인지 확인
	if (unitEntity == this)
	{
		OnEnemyDespawned?.Invoke(this, currentDespawnReason);
	}

	// 다른 로직도 추가 가능
}

// 

protected void OnDestroy()
{
	// OnEnemyDestroyed?.Invoke(this);
	RemoveObjectPool();

	OnDeathAnimationCompleted -= HandleDeathAnimationCompleted;
}
```
> 이렇게 구현하면 `UnitEntity`에서 1개의 이벤트를 발생시켜서 `Enemy`에 대한 여러 개의 이벤트를 발생시킬 수 있음. 지금은 1개지만.

- `Enemy`의 `Die` 메서드를 구분한다 : 체력이 다해서 죽은 경우와 목적지에 도달한 경우를 구분하며, 어느 쪽이든 사라지는 메서드로 이어진다. 대신 현재 상태만 바꾸는 방식.
```cs
    // 사라지는 로직 관리
    private void Despawn()
    {
        // 공격 이펙트 프리팹 제거
        if (BaseData.hitEffectPrefab != null)
        {
            ObjectPoolManager.Instance!.RemovePool("Effect_" + BaseData.entityName);
        }

        // UI 제거
        if (enemyBarUI != null)
        {
            Destroy(enemyBarUI.gameObject);
        }

        PlayDeathAnimation(); // 내부 이벤트 발생으로 인해 HandleDeathAnimationCompleted도 실행됨.
    }

    protected override void Die()
    {
        // 사망 이벤트 처리
        currentDespawnReason = DespawnReason.Defeated;
        Despawn();
    }

    private void ReachDestination()
    {
        currentDespawnReason = DespawnReason.ReachedGoal;
        Despawn();
    }
```
> 이 구조에서 `HandleDeathAnimationCompleted`이 실행되는 시점은 `UnitEntity`의 `OnComplete` 이후이다.

3. `StageManager`에서는 `OnEnemyDespawned`를 구독, 어떻게 디스폰되었는지에 따라 다르게 설정한다.
```cs
    private void Awake()
    {
		// ...
		
        Enemy.OnEnemyDespawned += HandleEnemyDespawned;
    }

    private void HandleEnemyDespawned(Enemy enemy, DespawnReason reason)
    {
        switch (reason)
        {
            case DespawnReason.Defeated:
                OnEnemyDefeated(enemy);
                break;
            case DespawnReason.ReachedGoal:
                OnEnemyReachDestination(enemy);
                break;
            default:
                Debug.LogError("처리되면 안되는 듯?");
                break;
        }
    }


	private void OnDestroy()
	{
		stageLoadingScreen!.OnHideComplete -= StartStageCoroutine;
		Enemy.OnEnemyDespawned -= HandleEnemyDespawned;
	}
```

- 근데 ㅋㅋㅋㅋ 이렇게 구현하고 나니까 적 체력이 0이 된 시점에도 바로 킬 카운트가 올라가지 않는 점이 거슬린다. 
- 여기에 시간을 좀 오래 쓰긴 했지만(!) `OnDeathAnimationCompleted`을 받아서 다시 이벤트를 발생시키는 대신, `Despawn`에서 `PlayDeathAnimation`을 실행하기 전에 먼저 시작함
- 대신 이전에 생각했던 **`적이 사라지기 전에 게임이 끝나는 문제`는 단순히 `StageManager`에서 관리하는 게임 종료 시점이나 딜레이를 조금 더 주는 방식으로 해결하겠음.**
```cs
// 기존엔 yield return null이었음(한 프레임)
    private IEnumerator GameWinAfterDelay()
    {
        yield return new WaitForSeconds(0.5f); // 적이 사라지는 시간이 0.3초니까 그거보다 조금 더 길게
        GameWin();
    }

    private IEnumerator GameOverAfterDelay()
    {
        yield return new WaitForSeconds(0.5f); // 적이 사라지는 시간이 0.3초니까 그거보다 조금 더 길게
        GameOver();
    }
```

- 아무튼 구조에 대해 더 생각할 수 있었으니 좋았쓰!... 인가? **지금의 이벤트 기반 구조가 더 좋아보이긴 한다.**

- 추가 발생 문제) 적이 도착지점에 도착했을 때 1개 이상 카운트됨
	-> `currentDespawnReason`이 `0`번(`Null`)이 아니라면 `Enemy.Update`를 막음.
```cs
    protected void Update()
    {
        if (StageManager.Instance!.currentState == GameState.Battle && // 전투 중
            currentDespawnReason == DespawnReason.Null // 디스폰되고 있지 않을 때
            )
```


---
### 공격 범위 밖의 적을 공격하는 현상 수정 - 콜라이더 이슈
- 테스트는 `Caster`로 한다.

#### 원인 찾기

- **모든 상황이 발생할 때도 있고 아닐 때도 있어서 정확히 추적하기는 어려운 상황이다.**

1. ~~최초 위치에서의 공격 범위와 재배치한 위치에서의 공격 범위가 다른데 최초 공격 범위에 있는 적을 공격하는 현상~~ **공격범위 밖의 적을 타격하는 현상**
	- 공격 범위 타일 선정 로직 자체에는 문제 없어보임. 재배치했을 때 목록이 깔끔하게 초기화된다.
	- 타일에서도 자신을 공격범위로 설정하고 해제하는 오퍼레이터를 추적하는 로직이 정상적으로 작동하는 것으로 보임.
	- 추측) `Enemy`의 공격 범위 콜라이더인 `AttackRangeCollider`에 얘가 반응 하는 거 아닐까? **근접 `Enemy`에는 반응이 없는데 원거리 `Enemy`에는 반응한다.** 
		- 실제로 그런 것 같은게, `AttackRangeCollider`에 충돌하기만 하면 근접 오퍼레이터든 원거리 오퍼레이터든 관계 없이 다 해당 `Enemy`를 타겟으로 선정하고 있음.
- 추적해보면 공격 범위 밖의 대상을 공격 대상으로 선정하는 로직은 아래의 과정을 거친다.
```
[OPERATOR] Caster(Clone)가 Enemy_Easy_Ranged(Clone)를 공격 가능 리스트(enemiesInRange)에 추가함
UnityEngine.Debug:Log (object)
Operator:OnEnemyEnteredAttackRange (Enemy) (at Assets/Scripts/Entities/Operators/Operator.cs:986)
Tile:EnemyEntered (Enemy) (at Assets/Scripts/Map/Tile.cs:270)
Enemy:OnTriggerEnter (UnityEngine.Collider) (at Assets/Scripts/Entities/Enemy/Enemy.cs:875)
```
> 근데 해당 타일은 오퍼레이터의 공격범위 밖임. ???

- 구체적으로 이해가 가지 않아서 AI한테 `Operator, Enemy, Tile`을 던져줬고 답을 받았다. 
- 요점은 **`OnTriggerEnter`는 모든 자식 오브젝트의 콜라이더에서 발생하는 이벤트를 모두 수신한다는 것.** 즉, `Enemy` 본체에 있는 `BoxCollider` 외에도 공격범위 콜라이더에 있는 `SphereCollider`까지 `Enemy.OnTriggerEnter`에서 처리한다는 것이다.
- 따라서 **`원거리 Enemy`가 밟고 있는 타일로 인식되는 지점은 본체에 있는 `BoxCollider` 외에도 공격 범위를 반지름으로 갖는 구에 충돌하는 모든 타일이다.**
- 이걸 해결하는 가장 심플한 방법 : **2개 이상의 콜라이더를 한 오브젝트 아래에 둔다면 각 콜라이더는 자식 오브젝트로 두라는 것**이다. 

- 지금까지의 구현에서 `UnitEntity` 자체에 본체 충돌 콜라이더를 뒀고, `Enemy`의 경우에만 자식 콜라이더를 하나 둔 상태인데.. **아예 `UnitEntity`부터 고치는 게 나중의 확장성을 고려할 때도 더 맞는 설계가 될 것 같다.** 확장을 얼마나 할지는 모르겠지만.

#### 수정
- **모든 `UnitEntity`의 자식 오브젝트로 `Body`를 두고, 거기서 콜라이더를 관리한다.**
	- `Model`에 구현하는 방법도 있지만 `Body`라는 개별 오브젝트를 관리하는 방식이 더 표준적인 패턴이라고 함
	- **`Rigidbody`는 부모 오브젝트에 유지한다.**
- 자식 오브젝트에는 `BodyColliderController.cs`라는 스크립트와 부모 오브젝트에 있던 `BoxCollider`를 기존 사양에 맞게 붙여둔다. 이 트리거의 `OnTriggerEnter`, `OnTriggerExit`이 동작하면 `UnitEntity`의 `OnBodyTriggerEnter, OnBodyTriggerExit`이 동작하도록 한다.
- 기존 부모 오브젝트들에 있던 `OnTriggerEnter, OnTriggerExit`을 이름만 `OnBodyTriggerEnter, OnBodyTriggerExit`으로 바꾼다. 
- 이 과정에서 컴포넌트 지우고 옮기고 하는 건 수작업이다. 어쩔 수 없음.

#### 결과
- **타일 밖에 있는 원거리 적을 때리는 현상은 사라졌다.**
- 대신 저지가 안되네? -> 
	1. `Enemy` 대신 `BodyColliderController`를 감지시키고, 그걸 갖고 있는 부모 오브젝트가 `Enemy`인지 확인하도록 로직 수정.
	2. 콜라이더가 본체랑 떨어져서 나타나는 이슈가 있었다. 정확히는 프리팹 자체의 위치 설정 문제였고, 수정 완료.
- 이번엔 `DeployableUnitEntity` 클릭이 안되네?
	- `ClickDetectionSystem.HandleObjectClick`을 보면
```cs
    private void HandleObjectClick(RaycastHit hit)
    {
        // 레이캐스트를 맞은 콜라이더의 부모 오브젝트에서 DeployableUnitEntity를 찾도록 수정
        // DeployableUnitEntity? clickable = hit.collider.GetComponent<DeployableUnitEntity>();
        DeployableUnitEntity? clickable = hit.collider.GetComponentInParent<DeployableUnitEntity>();
```
> 원래는 콜라이더의 위치에 `DeployableUnitEntity`가 있었으나 지금은 그것보다 자식 오브젝트가 레이캐스트를 맞는다. 따라서 부모 오브젝트에서 `DeployableUnitEntity`를 찾아야 함.

#### 이외의 복기
```cs
    private bool HandleUIClick(List<RaycastResult> uiResults)
    {
        foreach (var result in uiResults)
        {
			// ... 생략
            // 2. OperatorUI 관련 요소 클릭 처리 - Deployable.OnClick이 동작하도록 수정
            
            DeployableUnitEntity? associatedDeployable = GetAssociatedDeployableUnitEntity(result.gameObject);
            if (associatedDeployable != null )
            {
                associatedDeployable.OnClick();
                return true;
            }
        }

        return false;
    }
```
> - 오랜만에 코드를 보니까 `HandleUIClick`에 왜 `DeployableUnitEntity.OnClick`을 구현했는가? 가 헷갈린다.
> - 왜냐면 `DeployableUnitEntity`가 갖는 `OperatorUI`가 있음 : `HealthBar`라든가, 스킬 활성화 가능 표시 버튼이라든가. 게임 상의 저 요소를 그대로 클릭하면 `DeployableUnitEntity`를 클릭한 것처럼 동작하는 게 아니라 아무 반응도 없음. 왜냐하면 유니티의 이벤트 시스템이 그 UI를 클릭한 것으로 처리하기 때문이다. 
> - 따라서 여기서는 그러한 **UI를 클릭하더라도 해당 `DeployableUnitEntity`를 클릭한 것과 같은 반응을 시키겠다~ 라는 의미로 넣은 코드**다. 없으면 오히려 불편하게 될 거임.



# 250626 - 짭명방

## 오늘 배워가는 점
1. 트리거 기반 콜라이더를 구현할 때, **오브젝트가 파괴되면서 콜라이더가 겹치지 않게 되는 경우 `OnTriggerExit`이 동작하지 않는다.** 이 경우 콜라이더가 겹친 상대에게 해제되었음을 알리는 별도의 수단이 필요하다. `이벤트`라든가.

2. 뭔가를 **해제하거나 중단하는 코드는 `논리적인 사망 지점`과 `생명 주기 상 파괴 시점`에서 이중으로 구현하는 것이 좋다.** 내 경우 `Die`와 `OnDestroy`임.
	- **이미 해제된 이벤트를 다시 해제 시도해도 아무런 오류가 발생하지 않는다.**
	- 일반적으로 구독 / 해제 메서드는 `OnEnable`과 `OnDisable`에 짝을 맞춰 구현한다고 한다. 

3. [[자료구조 - 해시]] : 어떻게 O(1)이 궁금한지 궁금해서 정리했다.
	1. 데이터를 해시 함수를 이용해 해시 코드로 변경한다.
		- 해시 코드는 숫자 개념이다. 나머지 연산을 해야하므로.
		- 문자열처럼 보이는 게 있다면 16진수일 가능성이 높다. 
	2. 해시 코드를 해시 테이블의 길이로 나눈 나머지 값이 해당 데이터가 해시 테이블에 저장될 인덱스값이다.
	3. `해시 충돌, 리해싱` 등도 저 문서에 다뤘음.

4. **`OnDestroy`에서 정리할 것들**
	- 다른 객체와 이어진 것들이 있다면 여기서 해제해주는 게 좋다
	- 해당 오브젝트가 갖고 있는 변수들은 파괴되면서 같이 없어지니까 상관없음.
## 작업 중

### 공격 범위에서 벗어난 타겟 계속 때리는 현상
- 계속 발생하는 현상이 아니다. 가끔 발생하는데 뭐가 원인인지 모르겠음.
## 작업 완료
### Enemy 파괴 스태틱 이벤트로 구현하기
- 그제 하다가 이상해져서 갈아엎었고, 어제 마지막에 하려다가 못했던 내용이다.

> **`OnEnemyDied`가 아니라 `Destroyed`인 이유는 목적지에 도달했을 때는 `Die` 메서드 대신 `ReachDestination`이 동작하기 때문이다.** 

1. `Enemy.OnDestroyed`에서 파괴 이벤트 발생시킴
```cs
	// 스태틱 이벤트 테스트
	public static event Action<Enemy> OnEnemyDestroyed; // 죽는 상황 + 목적지에 도달해서 사라지는 상황 모두 포함

    protected void OnDestroy()
    {
        OnEnemyDestroyed?.Invoke(this);
        RemoveObjectPool();
    }
```

2. `Operator`에서 해당 처리
```cs
    public override void Deploy(Vector3 position)
    {
		// 적 사망 이벤트 구독
        Enemy.OnEnemyDestroyed += HandleEnemyDestroy;
    }

    // 테스트) 적 파괴 이벤트를 받아 오퍼레이터에서의 처리를 작업함
    private void HandleEnemyDestroy(Enemy enemy)
    {
        // 1. 현재 타겟이라면 타겟 해제
        if (CurrentTarget == enemy)
        {
            CurrentTarget = null;
        }

        // 2. 공격 범위 내에 해당 대상이 있다면 범위 내에서 제외
        if (enemiesInRange.Contains(enemy))
        {
            enemiesInRange.Remove(enemy);
        }

        // 3. 저지 가능 대상, 저지 중인 대상일 때 제외
        // OnTriggerExit은 겹친 상태에서의 파괴를 감지하지 못하므로 별도의 처리가 필요함
        if (blockableEnemies.Contains(enemy))
        {
            blockableEnemies.Remove(enemy);
            if (blockedEnemies.Contains(enemy))
            {
                UnBlockEnemy(enemy);
                TryBlockNextEnemy();
            }
        }
    }

// 이벤트 구독 해제는 Die 메서드와 OnDestroyed 메서드에 이중으로 구현했다.
// 씬 전환 같은 상황에서는 Die 메서드가 동작하지 않을 거라서.
```

- 테스트도 잘 동작함

3. `Enemy`의 파괴 이벤트는 `Tile`에서도 활용할 수 있을 거라는 생각이다. 기존엔 `Enemy.Die`에서 접촉 중인 타일들에 대해 이 `Enemy`를 제거하도록 `Enemy`에서 코드가 짜여져 있었음.
- 테스트 완) 여기서도 큰 문제는 없어 보임.



### 적 Health <= 0인데 이동하는 현상
- `Enemy.Update`에 체력이 0이면 아무 동작하지 않도록 수정.
### Artillery - 2번째 스킬 탄환 수 줄어들지 않음
- 이전에 `ActiveSkill`의 구조를 고친 적이 있다. 지속 시간에 관한 코루틴은 `Operator`에서 직접 관리하는 방식이었음. 이게 영향을 준 듯.
- 스킬의 `OnAfterAttack`에 구현되어 있고, `AmmoBasedActiveSkill`에도 잘 구현이 돼 있는데?
	- `OnAfterAttack`이 호출되지 않는 것 같다.
- 발견한 듯?
```cs
// Operator.cs

public void UseSkill()
{
	if (CanUseSkill() && CurrentSkill != null)
	{
		CurrentSkill.Activate(this);

		// 여기서 duration > 0인 부분
		if (CurrentSkill is ActiveSkill activeSkill && activeSkill.duration > 0)
		{
			// ...
		}
	}
}
```
> Artillery의 2스킬은 탄환이 있는 한 무한 지속이라 duration을 따로 설정하지 않았음.

- 그런데 여기서 **`Operator`가 스킬의 종류를 일일이 알고 분기를 정하는 건 확장에 번거로운 면이 있다.** 오퍼레이터는 단순히 스킬을 실행시키고, 스킬이 어떻게 실행되는가는 스킬에서 갖고 있어야 한다.
	- 대신 이전에 다뤘던 것처럼 **오퍼레이터가 해당 코루틴을 관리해야 하는 것도 명백**하다.
	- 결국 기존 구현으로 돌아감. `Operator`에서 실행 중인 코루틴만 관리하면 된다.
### 퇴각 후 재배치했을 때 공격 범위 내에 있는데 공격하지 않는 현상
- `Operator.UnregisterTiles`의 위치가 이상했다. 수정하고 테스트. 
- 일단 저 부분 수정하니까 더 이상 문제가 보이진 않는 듯. 


### NotificationPanel 수정
- 기존 기능) 메인메뉴에서 어떤 동작이 이뤄졌을 때 우측 상단에서 왼쪽으로 미끄러져 들어와서 해당 동작이 잘 완료되었음을 알리고, 다시 오른쪽으로 사라졌다.

- 수정 방향) 
	- 3개의 카드가 나타날 수 있게 하며, 최대 갯수보다 많아지면 먼저 나타난 카드부터 사라진다.
	- 컴포넌트 이름도 바꾼다. 이런 식의 `UI`는 `Toast`라고 불린다고 한다.
	- 이를 전용으로 관리하는 매니저도 추가한다. `NotificationToastManager`
- 아래처럼 구현했을 때 원하는 바가 나왔다.
```cs
// NotificationToastManager.cs
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Playables;

public class NotificationToastManager : MonoBehaviour
{
    public static NotificationToastManager Instance { get; private set; }

    [Header("Settings")]
    [SerializeField] private GameObject notificationToastPrefab = default!;
    [SerializeField] private Transform notificationContainer = default!;
    [SerializeField] private int maxVisibleNotifications = 3;  // 최대 표시 알림 수 
    [SerializeField] private float verticalSpacing = 10f;  // 알림 간 수직 간격
    [SerializeField] private float moveDuration = 0.3f;  // 알림 위치 이동 애니메이션 시간

    private List<NotificationToast> activeToasts = new List<NotificationToast>();
    private float toastHeight = -1f;

    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void ShowNotification(string message)
    {
        if (notificationToastPrefab == null)
        {
            Debug.LogError("NotificationToast 프리팹이 할당되지 않음");
            return;
        }

        if (activeToasts.Count >= maxVisibleNotifications)
        {
            // 가장 오래된 토스트는 리스트의 맨 앞 요소t
            NotificationToast oldestToast = activeToasts[0];
            activeToasts.RemoveAt(0);

            // Dismiss를 호출하면 onToastClosed 콜백이 실행, 리스트에서 자동으로 제거된다. 
            oldestToast.Dismiss();

            UpdateToastPositions();
        }

        if (toastHeight < 0)
        {
            toastHeight = notificationToastPrefab.GetComponent<RectTransform>().rect.height;
        }

        // 새로운 토스트가 등장할 Y좌표를 미리 계산한다. activeToasts.Count가 새 토스트의 인덱스이므로 이를 사용한다.
        float newToastTargetY = -activeToasts.Count * (toastHeight + verticalSpacing);

        GameObject toastObject = Instantiate(notificationToastPrefab, notificationContainer);
        NotificationToast newToast = toastObject.GetComponent<NotificationToast>();

        // 새로운 토스트 추가
        activeToasts.Add(newToast);

        // 새 토스트 초기화(등장 애니메이션 시작)
        newToast.Initialize(message, newToastTargetY, () => OnToastClosed(newToast));
    }

    // 토스트가 나타나거나 사라질 때 모든 토스트의 Y위치를 계산하고 이동시킨다.
    private void UpdateToastPositions()
    {
        // 아래에서부터의 위치 계산
        for (int i = 0; i < activeToasts.Count; i++)
        {
            float targetY = -i * (toastHeight + verticalSpacing);
            activeToasts[i].MoveToY(targetY, moveDuration);
        }
    }

    private void OnToastClosed(NotificationToast toast)
    {
        if (activeToasts.Contains(toast))
        {
            activeToasts.Remove(toast);
            UpdateToastPositions();
        }
    }

}

// NotificationToast.cs
using System;
using DG.Tweening;
using TMPro;
using UnityEngine;

/// <summary>
/// 우측 상단에서 등장했다가 사라지는 알림 표시
/// 알림은 슬라이드 인 애니메이션으로 나타난다
/// </summary>
public class NotificationToast : MonoBehaviour
{
    [SerializeField] private RectTransform panelRect = default!;
    [SerializeField] private TextMeshProUGUI messageText = default!;

    private Sequence? currentSequence;
    private Action? onClosedCallback;
    private bool isDismissing = false; // 중복 호출 방지 플래그

    // OnClosed : 애니메이션이 끝나고 파괴될 때 호출될 콜백
    public void Initialize(string message, float startY, Action OnClosed)
    {
        messageText.text = message;
        onClosedCallback = OnClosed;

        PlayShowAnimation(startY);
    }

    private void PlayShowAnimation(float startY)
    {
        currentSequence?.Kill();

        panelRect.anchoredPosition = new Vector2(400f, startY);

        currentSequence = DOTween.Sequence().SetUpdate(true)
            .Append(panelRect.DOAnchorPosX(-10f, 0.3f).SetEase(Ease.OutBack))
            .AppendInterval(2f)
            .Append(panelRect.DOAnchorPosX(400f, 0.3f).SetEase(Ease.InBack))
            .OnComplete(() =>
            {
                onClosedCallback?.Invoke();
                Destroy(gameObject);
            });
    }

    // 토스틀를 강제로 사라지게 한다.
    public void Dismiss()
    {
        if (isDismissing) return;
        isDismissing = true;

        currentSequence?.Kill();

        // 사라지는 애니메이션 실행
        DOTween.Sequence().SetUpdate(true)
            .Append(panelRect.DOAnchorPosX(400f, 0.1f).SetEase(Ease.InBack))
            .OnComplete(() =>
            {
                onClosedCallback?.Invoke();
                Destroy(gameObject);
            });
    }

    public void MoveToY(float targetY, float duration)
    {
        panelRect.DOAnchorPosY(targetY, duration).SetEase(Ease.OutQuad);
    }

    private void OnDestroy()
    {
        currentSequence?.Kill();
    }

}
```
> 정확히는 최대 갯수를 초과할 때는 누락되는 이슈가 있긴 한데, 그냥 토스트 최대 갯수를 4개로 했음. 

# 250625 - 짭명방
- 어제 보였던 문제는 많았는데 해결된 게 없어서 오늘은 전체적으로 다듬는다.
- 머리가 복잡해지면 될 것도 안되는 것이라..
## 작업 중

### 파괴된 객체가 enemiesInRange에 남아 있는 문제
- `CurrentTarget`의 경우는 계속 이벤트 등록 / 해제를 통해 `Enemy`를 추적했는데, 이 경우는 단순히 공격 범위 내에 `Enemy`가 들어온 상태에서 나가지 않고 제거되어서 `null`로 변한 상황이 된다.
- 일단은 공격 범위 내에 들어온 적의 리스트, `enemiesInRange`에서 `null`인 것들을 제거하고 공격 대상을 선정하는 방식으로 구현할 수 있다.
```cs
CurrentTarget = enemiesInRange
	.Where(e => e != null && e.gameObject != null) // 파괴 검사 & null 검사 함께 수행
	.OrderBy(E => E.GetRemainingPathDistance()) // 살아있는 객체 중 남은 거리가 짧은 순서로 정렬
	.FirstOrDefault(); // 가장 짧은 거리의 객체를 가져옴
```
> `Where` 문만 추가된 부분임.

#### 하지만 결국 어제와 같은 생각에 부딪힌다. 
1. `CurrentTarget`을 선정할 때 **해당 타겟이 죽었을 때 발생하는 이벤트**를 공격자의 메서드가 구독함.
2. 그런데 **공격 범위 내의 대상이 죽었을 때에도 공격 범위에서 제거해야 함**

즉 **`사망`이라는 1가지의 사건을 받아서 2가지의 다른 동작으로 처리**해야 하는 상황이다.

오퍼레이터 입장에서는
1. 해당 적을 공격 대상으로 지정했을 때 이를 해제하는 로직
2. 해당 적이 공격 범위 내에 있을 때 이를 해제하는 로직

1번은 아까 구현했는데, 해당 객체의 사망 이벤트를 구독하는 방식이었다. 

이런 상황이라면 일일이 공격 범위 내에 들어왔을 때 사망 이벤트 구독 / 공격 대상이 됐을 때 사망 이벤트 구독 같은 식으로 구현하게 될 것 같다.
이것보다는 `Enemy`의 사망 이벤트가 발생 -> `Operator`가 이걸 받아서 이 `Enemy`가 공격 범위에 있는가 / 현재 공격 대상인가에 따라 자체적으로 처리하게 하는 게 낫지 않을까?

---
#### 시도는 해봄
- 일단 간단하게 `null`인 부분을 제외하는 부분까지 커밋하고 푸시해서 올려놓음.


### 자기 공격 범위가 아닌데 공격하는 문제
- 이건 지금 정확히 문제인지 아닌지 파악하기 어렵다. 일단 보류함.
## 작업 완료

### 오퍼레이터 파괴 후에도 스킬 코루틴이 돌아가는 문제

#### 원인 분석
현재는 `ActiveSkill.Activate`의 `duration > 0`인 스킬들에 대해  `op.StartCorutine(HandleSkillDuration(op))`이 실행되는 구조이다. 이 때, 코루틴의 실행 주체와 생명 주기는 `Operator` 오브젝트에 귀속된다.  

만약 `Operator`가 죽으면 `Destroy`가 실행되는데, 이 때는 파괴 대기 상태가 된다. 이 때 코루틴은 멈추지 않는데, 파괴가 예약된 프레임이나 바로 다음 프레임에 `while` 루프를 돌려고 시도한다.

그러나 코루틴이 재개되어 `op.{메서드}`를 호출하려는 순간, `op`가 이미 파괴된 유령 상태이므로 내부 참조 UI에 접근하지 못해 오류가 발생한다.

#### 일차적인 접근
`HandleSkillDuration`의 반복문 내에 `if (op == null)` 체크 : 미세한 타이밍 차이가 있을 수 있다. 이걸 막지 못함.

#### 수정
- 요점은 **코루틴을 시작한 주체가 멈출 책임도 함께 지는 것**이다. 

오퍼레이터 자체에서 스킬 지속 시간 동안 돌아가는 코루틴을 관리하게 하면 된다. `OnDestroy`가 동작하면 해당 코루틴을 멈추게 한다. 

1. `ActiveSkill`을 아래처럼 수정한다.
- 원래는 `duration`에 따라 코루틴인 `op.StartCoroutine(HandleSkillDuration(op))`은 여기서 실행됐음.
```cs
public override void Activate(Operator op)
{
	caster = op;

	// 스킬 사용 가능 여부 체크
	if (!op.IsDeployed || !op.CanUseSkill()) return;

	// 기본 이펙트와 추가 이펙트 재생
	PlaySkillVFX(op);
	PlayAdditionalVFX(op);

	// 즉발형 스킬은 여기서 처리
	if (duration <= 0)
	{
		PlayInstantSkill(op);
	}

	// 지속시간이 있는 스킬은 Operator에서 코루틴이 실행된다. Operator.UseSkill 참고.
}

// HandleSkillDuration은 public으로 바꾼다.
```

2. `Operator`을 아래처럼 수정한다.
```cs
// ★관리할 코루틴
private Coroutine _activeSkillCoroutine;

// 스킬 사용 메서드
public void UseSkill()
{
	if (CanUseSkill() && CurrentSkill != null)
	{
		CurrentSkill.Activate(this);

		// ★이 부분 추가
		// 지속시간이 있는 액티브 스킬은 코루틴을 여기서 실행하고 관리함
		if (CurrentSkill is ActiveSkill activeSkill && activeSkill.duration > 0)
		{
			// 기존 코루틴 종료
			if (_activeSkillCoroutine != null)
			{
				StopCoroutine(_activeSkillCoroutine);
			}

			_activeSkillCoroutine = StartCoroutine(activeSkill.Co_HandleSkillDuration(this));

			UpdateOperatorUI();
		}
	}
}

protected void OnDestroy()
{
	// ★오브젝트 파괴 시 실행 중이던 스킬 코루틴을 중지시킨다
	if (_activeSkillCoroutine != null)
	{
		StopCoroutine(_activeSkillCoroutine);
		_activeSkillCoroutine = null;
	}

	RemoveObjectPool();
}
```

#### 그래도 동일 문제 발생
- `OnDestroy()`에 스킬 코루틴을 중지시키는 로직은 최후의 보루 같은 느낌으로 두고, 그것보다 앞인 `Die`에도 동일한 로직을 구현해둔다.
- 추가 : `OperatorUI`는 이벤트 기반으로 없어지지 않고 `Operator.Die`에서 직접 실행시키는 원래 방식으로 되돌림.


#### 이 과정에서 든 객체 지향 설계의 의문점과 기준 잡기
- [[객체 지향 설계 기준점 잡기]]에 동일 내용 복붙해서 정리. 
- 의문점
> 이벤트로 구현하는 방법, 즉 오퍼레이터가 사망했을 때 이벤트를 발생시키고, 스킬에서는 따로 코루틴을 돌리고 있다가 오퍼레이터 사망 소식을 듣고 자신의 코루틴을 중단시키는 구현이 더 객체지향 설계라는 느낌이 아닌가?라는 의문이 들었다. 위 방식은 어쨌든 오퍼레이터에서 스킬이 어떻게 돌아가는지를 알아야 작성할 수 있는 코드니까.

- 객체지향 설계의 핵심 목표
- **캡슐화** : 객체는 자신의 상태, 행동을 내부에 숨기고 외부에는 필요한 기능만 공개한다.
	- 외부에 "이 버튼을 눌러라"고 알리고 세부적인 구현은 내부에서 담당하는 것
- **책임과 역할** : 각 객체는 자신만의 명확한 책임과 역할을 가진다
- **결합도 낮추기** : 객체 간의 의존성을 최소화해서 한 객체의 변경이 다른 객체에 미치는 영향을 줄인다.
- **응집도 높이기** : 한 객체는 서로 밀접하게 관련된 기능들로만 구성된다.

1. **이벤트 기반 설계 방식**
- 위에서 내가 생각한 의문점처럼 구현하는 방식.
- 장점
	- 최상의 캡슐화, 낮은 결합도 : `Operator`에서는 스킬이 어떻게 돌아가는지 알 필요가 없다. 
	- 유연성과 확장성
- 단점 
	- **생명주기 관리의 복잡성** : `ActiveSkill`의 구독 해지 시점은 정확히 어떤 타이밍일까? 스킬이 끝났을때? `Operator`가 죽었을 때? 여기선 후자로 보이지만, 이런 관리가 제대로 되지 않으면 보이 않는 버그의 원인이 된다.
	- **암묵적 의존성 : 의존 관계가 명시적으로 보이지 않는다.** 코드를 처음 보거나 수정할 때 `Operator`가 죽으면 `ActiveSkill`에서 어떤 일이 일어나는지 추적하기 어렵다.

2. **책임 주도 설계 방식**
- `Operator`가 메서드를 호출해 스킬을 사용한다.
- `Skill(지금의 경우 지속시간이 있는 ActiveSkill)`은 설계도`IEnumerator`를 `Operator`에게 준다.
- `Operator`는 설계도를 받아 자신의 책임 하에 코루틴을 시작하고 변수에 저장한다.
- `Operator`가 파괴될 때 자신의 책임 하에 실행 중인 코루틴을 중지시킨다.

- 장점
	- **명확한 책임과 소유권** : 코루틴을 실행하는 주체가 시작과 종료의 책임을 함께 진다. 프로세스의 시작과 끝이 한 클래스 내에 있기 떄문에 코드를 이해하고 관리하기 쉽다.
	- **안전한 생명주기 관리** : `OnDestroy`로 구현했기에 `MonoBehaviour`로 관리되는 유니티의 생명주기 모델과 어울리는 방식이다.
- 단점
	- **상대적으로 높은 결합도** : 1번 방식에 비해서는 캡슐화가 확실히 깨진다. `Operator`가 `BaseSkill`에 종류가 있음을 알고`is ActiveSkill` 그것이 코루틴을 반환할 수 있다는 것을 알고 있어야 한다. 

- 결론 : **프로세스의 실제 소유자가 누구인가?** 를 기준으로 판단하는 게 좋다.

1. `StartCoroutine`은 `MonoBehaviour`의 메서드이며, 코루틴은 그걸 실행시킨 `MonoBehaviour`의 생명주기에 종속된다. 즉, **`MonoBehaviour`가 실행 주체이며 실질적인 소유자이다.**
2. `ActiveSkill`은 스킬의 데이터, 로직을 담은 설계도나 레시피 북에 가깝다.

유니티의 구조 내에서는 프로세스의 실제 소유자인 `Operator`가 시작과 종료를 책임지는 2번 방식이 더 맞다고 할 수 있다. 캡슐화가 약간 깨지지만, 생명주기를 명확하게 관리할 수 있기 때문이다.

- **이벤트 기반** : 서로 다른 시스템(UI, 게임 로직 등)처럼 소유권과 생명 주기가 완전히 분리된 객체들을 연결할 때 매우 강력한 패턴이다.
- **책임 주도** : 한 객체가 다른 객체를 부품처럼 사용해서 자신의 생명주기 내에서 어떤 작업을 수행할 때 더적합하고 안전한 패턴이다.

### 근접 Enemy가 저지당하지 않았는데도 때리고 지나가는 문제
- `Operator`에서는 저지 로직이 정상적으로 동작하고 있음.
- 일시적으로 저지되어서 `Enemy`가 공격하는 게 아닌가 생각했는데 그건 아닌 것 같다.
- 일단 원인은 `Enemy`에 있어보인다. 구체적인 원인은 모르겠음.
---
#### 원인
- 아래의 리팩토링과는 별개로, 이것의 문제는 찾았다 : **`EnemyAttackRangeController`의 이슈임**
```cs
// 콜라이더 = 공격 범위 반경 설정
if (enemyData.AttackRangeType == AttackRangeType.Ranged)
{
	attackRangeCollider.radius = enemyData.stats.AttackRange;
}
else
{
	attackRangeCollider.radius = 0;
}
```
> 콜라이더의 반지름 값에 대해 `Ranged`이면 반지름값을 반영하고 아니라면 `0`을 넣게끔 했음.

- `Enemy.SetCurrentTarget` : 공격할 대상을 선정하는 로직
```cs
public void SetCurrentTarget()
{
	if (CurrentTarget == null)
	{
		// 저지를 당할 때는 자신을 저지하는 객체를 타겟으로 지정
		if (blockingOperator != null)
		{
			CurrentTarget = blockingOperator;
			CurrentTarget.OnDestroyed += OnCurrentTargetDied;
			Debug.LogWarning($"{EntityName}의 CurrentTarget : 저지 중인 ${CurrentTarget}으로 설정");
			NotifyTarget();
			return;
		}

		if (targetsInRange.Count > 0)
		{
			CurrentTarget = targetsInRange
				.OfType<Operator>()
				.OrderByDescending(o => o.DeploymentOrder) 
				.FirstOrDefault();
			// ★ 이 부분
			Debug.LogWarning($"{EntityName}의 CurrentTarget : 공격 범위 내의 ${CurrentTarget}으로 설정");
			// ---
			NotifyTarget();
			return;
		}
	}
}
```
`targetsInRange`는 `EnemyAttackRangeController`의 콜라이더에 들어온 `UnitEntity`들을 추가하는 리스트이다. 그런데 반지름을 0으로 잡은 Enemy에 대해 저 로그가 출력이 된다. 

#### 해결
- 따라서 `radius = 0`으로 잡는 게 아니라, 해당 콜라이더를 비활성화해야 한다.

저 부분을 굳이 `radius = 0`으로 뒀던 이유는 오류가 발생할까봐.. 였는데 콜라이더를 비활성화하면 `EnemyAttackRangeCollider`의 `OnTrigger` 관련 로직들도 동작하지 않으니까 아예 꺼버리는 게 답인 듯.

#### Enemy의 CurrentTarget 선정 로직 리팩토링
1. `CurrentTarget`이 변할 때마다 `OnCurrentTargetDied`라는 메서드를 타겟의 이벤트에 구독시킨다. `OnCurrentTargetDied`는 `CurrentTarget = null`로 만든다.


### 저지 로직 수정
- "콜라이더가 충돌했음에도 저지수를 초과한 상황이라 충돌 로직이 동작하지 않고 있다가 이미 저지 중인 적이 제거돼서 해당 적을 저지하는 상황"을 수정하려고 한다.
- 기존엔 `OnTriggerStay`로 구현됐던 부분임
- 일단 `BlockableEnemies`라는 리스트를 `Operator`에 별도로 추가했음 -> 실제로 저지된 적들과 달리 콜라이더에 들어오면 추가하고 나가면 제거한다.

- 크게 아래처럼 수정
1. 기본적으로 `Enemy`는 `BlockingOperator`를 지정하도록 되어 있음 -> `Die` 시에 `Operator`에게 자신의 사망을 알릴 수 있다.
2. `Operator`는 `Enemy`의 사망을 받아 `BlockableEnemies`와 `BlockedEnemies`에서 해당 `Enemy`를 제거하고, `BlockableEnemies`에서 저지되지 않은 적을 찾아 `BlockedEnemies`에 추가한다.

### Operator가 파괴됐음에도 OperatorUI가 남아있는 문제
- 스킬 실행 가능 아이콘이 여전히 남아있다. 
- 기존의 이벤트 기반 로직에서 직접 전달하는 식으로 바꿨는데 거기에 문제가 있었나?
```cs
protected void DestroyOperatorUI()
{
	// 컴포넌트를 파괴하는 게 아니라 오브젝트를 파괴해야 함
	Destroy(operatorUI.gameObject);
}
```
> 라고 한다.

### attackingEntities 관련
- `이 객체를 공격하는 적들`에 관한 리스트인데, 꼭 필요할까?\
- **필요하다.** 이걸로 구현하지 않겠다면 이벤트 기반으로 구현해도 되지만, 어느 쪽이든 `자신을 공격하는 공격자들`에 대한 리스트를 갖고 있는 건 필요하다. 왜냐하면 **피격 객체가 죽거나, 은신 등으로 인해 공격 범위에서 제외될 수 있다면 이를 공격자에게 알려야 하기 때문이다.** 
# 250624 - 짭명방
- 모니터 바꾸고 게임 프로젝트 다시 꺼내는 건 처음인데, 색감이 좀 많이 뿌얘졌다.. ㅋㅋ;
	- 메인 모니터에는 돈을 아끼지 말아야지,,,

- 오늘의 교훈
	- `느슨한 결합`이 보통 권장되는 구조이긴 하다.
	- 하지만 게임의 핵심 로직은 상호작용하는 두 객체의 `public` 메서드를 서로 호출하는 방식이 나중에 유지보수하기 더 편할 수도 있다. 
	- 오늘 애먹었던 저지 로직 같은 경우, "`Operator`가 `Enemy`를 저지할 때 `Enemy`는 자신을 저지하는 `Operator`를 등록한다"는 로직 자체는 이벤트 없이 둘 간의 상호작용으로 구현해도 무방함.
	- 이벤트는 일반적으로 `1:多` 구조에서 사용하면 좋다. 
## 고칠 때마다 자꾸 어딘가 에러가 나서 일단 원상복구
- 흠...

## 작업 완료

#### 실제 적용 X) 원래 커밋으로 되돌림

- `Enemy`가 죽어서 `null`인데 `SetCurrentTarget`에서 계속 참조하려고 하는 문제
```cs
CurrentTarget = enemiesInRange.OrderBy(E => E.GetRemainingPathDistance()).FirstOrDefault();
```
> 가장 간단하게 해결하는 방식은 `enemiesInRange.RemoveAll(enemy => enemy == null);`을 넣어서 항상 우선 `null`을 제거해주는 식으로 구현하면 됨

더 나은 방식으로 이벤트를 이용하는 방식이 있다.
그런데 나는 
```
1. 이미 스폰된 Enemy들에 대해 모든 배치된 오퍼레이터들에게 해당 이벤트 구독
2. Enemy가 스폰될 때마다 모든 배치된 오퍼레이터들에게 해당 이벤트 구독
3. 오퍼레이터를 배치할 때 이미 스폰된 Enemy들에 대해 해당 이벤트 구독
```
이렇게 작업해야 하는 게 아닌가 생각했는데, **클래스 단위의 이벤트를 구독하는 `static event`를 사용하는 방법이 있다.** [[Unity - 클래스 단위의 이벤트]]
- **`static event`** 로 이벤트를 생성하면, 해당 이벤트는 모든 영역에서 단 1개만 존재하는 이벤트가 된다. 이 경우 외부에서 구독할 때 인스턴스 참조가 필요하지 않고, 클래스 이름으로 직접 접근한다.

- 이거를 기존에 몰랐기 때문에 원래 코드에서 수정할 수 있는 부분도 많을 것 같음. 일단은 보이는 부분만 고친다. `디커플링 작업`임.
	- `Enemy` 사망 시 `Die`에 만든 부분들을 `Operator, Tile`에서 이벤트 구독 메서드에 구현
		- `StageManager`에서도 추가.
	- `Enemy`가 타일에 진입 / 이탈할 때에도 추가.
		- 이 이벤트를 받는 메서드에서는 다시 `Operator`에 전달하기 위한 이벤트를 발생시켜서 해당 `Enemy`가 이 `Tile`에 접근했음을 알린다.
		- `CurrentAttackableTiles`을  `HashSet`으로 바꿈 - `List`에서 쓰는 메서드와 큰 차이도 없다.
			- `HashSet`을 쓸 때, **저장은 List로 하되 런타임에서는 HashSet을 쓰는 게 표준**이다. 
	- `Operator`의 `Enemy` 저지 로직 : 오퍼레이터**가** 적을 저지하는 것이므로 `Operator`에 구현



- 이 과정에서 발생한 문제들
	 - [ ] 저지수 0인데 저지하지 않는 문제
		 - 저지가 동작했는데 적이 그냥 빠져나가는 현상이 있음.
		 - `Melee`의 경우 저지가 됐을 때에만 공격해야 하는데, 저지되지 않고 그냥 지나가는 상황에서 때리고 지나가는 현상도 있음.
		 - AI한테 다시 던져봄. 무려 3분 간의 추론 끝에 나온 결론.
			- **"느슨한 결합은 좋은 구조고 강한 결합은 나쁜 구조다"** 라는 편견은 버리고 진행하는 게 좋다. 
				- 지금의 상황에서 저지 로직은 `Operator`와 `Enemy` 간의 직접적인 상호작용이 일어나는 게 더 직관적이고 바람직한 상황임.
				- **이벤트 기반의 구조가 항상 좋은 건 아니다.** 암시적인 구조이기 때문에 수정이 필요한 상황에선 오히려 더 복잡할 수도 있다. 
			- **이벤트를 활용하는 상황은 `1:多` 상황이라고 생각하면 편할 듯.**
				- 결국 유지보수를 할 때 어떻게 작성해놔야 나중에 수정하기 편할지를 생각해보면 될 것 같다.
		- 따라서 저지 로직은 기존 구현대로 돌려놓는다. 

	- [ ] 킬 카운트 여러개씩 올라가는 문제
		- 1개가 올라갈 때도 있고, 동시에 여러 개가 올라갈 때도 있다.
		- 이건 추정인데 투사체가 체력 0 이하인 `Enemy`에 부딪힐 때 이벤트가 여러번 발생하는 거 아닐까?
		- 일단 `TakeDamage` 메서드가 `CurrentHealth <= 0`일 때는 실행되지 않게 수정함
		- 유사한 문제가 발생하고 있지는 않아서 일단 이렇게 둔다. 위의 이슈가 해결되지 않고 있음.

- **그냥 이전 커밋으로 되돌려놨음** : 저지 로직이 정상적으로 동작하지 않는 이슈가 치명적

- `Melee`라서 본인이 저지당하지 않았을 때는 때리면 안되는데 때리는 현상이 있다.
- 같은 원인으로 보이는데 저지 당할 상태가 아닌데 저지되는 현상이 있다.

# 250620 

## 짭명방
### 작업 중

### 작업 완료
#### 스냅핑이 안되는 문제 또 발생

- 이전에 알아낸 방법으로 시행착오
	1. 이전에 찾아낸 방법처럼 `Reimport All`을 눌러봤다.
		- 안된다. 비상!!!
	2. 에디터를 끄고 라이브러리 지우고 다시 실행
		- 역시 안된다. 하...
	- 또 날 잡겠다.
	- `Tile` 프리팹에 `공격 범위`를 추가했을 때 해당 부분의 레이어가 `Default`로 지정되어 있었다. `Tile`로 수정. 
		- 물론 크게 상관없을 가능성이 높다. 하이라이트되는 타일은 머티리얼을 수정하는 방식이지 레이어가 바뀌진 않을 거임
	- 에디터 다시 불러올 때 처음에 Tile과 관련된 에러들이 뜨는 현상이 있었다. 거기부터 만져봄.

- **과거 깃으로 돌아간 다음 커밋들을 비교해보고** 기능이 동작하지 않는 지점 직전의 커밋에서 수정된 내용들 하나하나 반영하면서 어디서 문제가 발생했는지 테스트해보겠음. 
	- 이전에 갔다 왔을 때 정상적으로 작동하는 브랜치가 있었음.
	- [[git - 과거로 돌아가서 새로운 브랜치로 옮기기]] 에 정리해뒀다. 기존의 `reimport all`이나 라이브러리 삭제로 되지 않아서 결국 이게 맞는 듯...

- 진행
	- `250609`와 `250606` 사이에 문제가 발생한 것으로 보인다. 6월 9일의 커밋에서는 동작하지 않고, 6월 6일의 커밋에서는 스냅핑이 동작하고 있음.
		- 날짜 적어 놓는 거 잘한 듯? 보기 편하다.
	- 그래서 6월 6일로 `checkout`한 다음 `git checkout -b main-fixed`로 시작함.
	- `cherry-pick` 자체는 불가능한 상황이다. 대신 모든 커밋은 깃허브에 오리진으로 커밋했기 때문에, **일일이 변경 사항들 반영**하는 방식으로 진행함. 
	- 6월 6일과 6월 9일 커밋 사이에 발생한 건 Operator와 Enemy의 타겟 선정 로직이었던 걸로 기억하는데.. 저 날의 작업 기록을 참고로 2단계에 걸쳐서 반영해본다. 
		1. 우선 `Operator`의 타겟 선정 로직을 수정했을 때, 스냅핑 동작은 여전히 잘 동작한다.
			- 유니티를 껐다가 켜서 잘 동작하는지까지 확인했음.
			- 아직 `main-fixed`인 상태이기 때문에, 이 상태로 커밋을 저장해봄.
		2. `Enemy`의 타겟 선정 로직 작업
			- `Enemy`의 자식 오브젝트로 `EnemyAttackRangeController`을 추가함. 여기엔 `Sphere Collider`도 같이 들어가 있어서 공격범위에 해당하는 반지름을 설정한다.
			- `Ranged`가 공격하지 않는 문제가 있었지만, 콜라이더의 `Is Trigger`가 꺼져있는 문제였음
			- 수정 직후 실행은 잘 동작함.
			- 유니티를 껐다가 켰을 때에도 잘 동작함. 
		- 250609의 수정사항을 다 반영했는데, 잘 동작한다. ???? 정작 저 커밋으로 돌아갔을 때는 동작하지 않았음.
		- 오리진에 마지막으로 커밋한 것까지 일일이 수정했고, 유니티를 껐다 켰을 때 최종 동작만 확인해봄 : 잘 됨
	- 일단 이 상태로 커밋까지 해두고, 오리진에도 이 브랜치로 덮어씌움.
	- 이랬는데 또 문제 발생하면 ㅡㅡ 하
# 06.12 ~ 14 여행 다녀옴
# 250611 - 짭명방

### 작업 중

#### 코드 정리
- `ClickDetectionSystem`에서 기능 메서드별로 분리 및 메서드 이름 정리

#### 오퍼레이터 스냅핑이 갑자기 되지 않는 현상 해결하기
- [x] 어제 했던 거에서 계속 : 오퍼레이터 스냅핑이 되지 않는 현상
	- 아예 클릭 시스템부터 다시 보겠음. 
		- 클릭 시스템은 이 케이스와는 별개다. `DeployableBox`에서 드래그 중인 상태는 
	- 지금 버전에서는 방법을 못 찾을 것 같다. 그래서 되돌려본 다음 다시 하나하나 짚어나가겠음.

> 일단 지금 발생하고 있는 문제가 없는 브랜치로 돌아가는 명령어는 아래와 같다.
```sh
git checkout  c67d56cab79609f68b278e0393bba0abe573b39a

// 돌아오는 건 git checkout main(현재 브랜치 이름)
```

- 위에서 정상적으로 스냅이 동작하는 브랜치로 되돌렸다가, 다시 최근 브랜치로 돌아왔는데 **갑자기 스냅이 동작한다.** ???????????????????????????????????????
	- 이게 **운으로 해결한 거라서 비슷한 상황을 막으려면 원인이랑 해결책을 알아둘 필요는 있겠다.**
	- 한가지 재밌는 건 직전 커밋은 스냅 이슈가 발생하는 상황이라고 쳐도 그 이전 커밋으로 되돌렸을 때도 스냅이 동작하지 않았다. 스테이지 테스트를 하고 있기 때문에 배치가 안 되는 상황이 발생했다면 이를 최소한 메모라도 해뒀을 거임.

- 안되던 상황 설명 
	- 레이캐스트가 타일 레이어에 지정되어 있고, 타일의 콜라이더의 `Is Trigger`도 켜져 있고, `Queries Hit Triggers`도 켜져 있었는데도 레이캐스트가 타일을 포착하지 못하는 이슈가 있었다. 그래서 모든 오브젝트를 포착하는 레이캐스트를 켜봤는데, 아무런 오브젝트도 포착하지 못했다. 
	- 특이한 건 `Canvas`에 있는 UI 요소는 잘 포착하는 반면 맵에 있는 오브젝트는 포착하지 못했음.
	- **에디터를 껐다가 켜도 해결되지 않았다.**
	- 정상적으로 동작했을 때는 `Operator`와 `Tile`의 레이캐스트 관련 설정은 건드리지도 않았는데 갑자기 스냅이 동작하지 않는 현상이다.

- 무엇이 원인인가?
	- **이전의 작업 과정에서 라이브러리나 캐시 파일이 깨졌을 확률이 높다.**
	- `git checkout`으로 이전 브랜치에 다녀오는 과정에서 유니티가 변경된 파일들을 다시 임포트하고 라이브러리를 재구성하게 되었다.
	- 에디터를 껐다 켜서 해결되는 상황은 메모리를 초기화하면서 해결되는 것인데, 이번 경우는 그렇지 않았기 때문에 저장된 파일 자체에 이슈가 있었다는 의미다.
	- 유니티는 효율성을 위해 라이브러리 폴더의 내용이 유효하다고 생각하고 이를 신뢰하고 재사용하려고 한다.
### 작업 완료

# 250610

### 작업 중

#### 이슈
- [ ] 오퍼레이터 배치 시에 스냅핑이 되지 않는 현상

> 아니 이거 뭐임??? 갑자기 발생했는데 뭐가 원인인지도 모르겠다.
> - 깃허브에서 어제 바꾼 내용들을 봤는데 딱히 이 부분에 영향을 갈 부분을 건드리지는 않았는데? 하루 종일 봐도 모르겠음. 
> - 특이한 건 레이캐스트를 전체 레이어에 대해 진행했을 때, **타일 오브젝트가 있음에도 타일을 레이캐스트하지 못한다는 게 있음.** 
> - 그래도 뭔지 모르겠다. 어제 바꾼 부분에서 여기는 전혀 건드린 게 없는데. 내일 계속함;;

- 시도 1) 해결 X
```cs
// 해결 X
// 타일 콜라이더에 IsTrigger가 켜져 있어서 QueryTriggerInteraction.Collide 사용
if (Physics.Raycast(ray, out hit, Mathf.Infinity, layerMask, QueryTriggerInteraction.Collide))
{
	Debug.Log("타일 정보 : " + hit.collider.name);
	return hit.collider.GetComponentInParent<Tile>();
}
```


### 작업 완료



# 250609

### 작업 중

#### 스테이지 정주행하면서 밸런스 조정
### 작업 완료

#### 리팩토링 / 수정사항
- [ ] `Operator` : 공격 범위 내의 적 선정 로직
	- 기존 구현 : `EnemiesInRange` 리스트를 계속해서 비우고 공격 범위 타일 내의 적을 수집해서 채우고 목적지까지 남은 거리가 가장 짧은 적을 타겟으로 함
	- 그런데 **계속해서 비울 필요가 있을까?** 적이 어떤 타일에 들어가거나 나갈 때 그 타일이 어떤 오퍼레이터의 공격 범위 내라면 해당 적을 `EnemiesInRange`에 넣거나 빼는 식으로 구현할 수 있지 않을까?
	1. `Tile`에 자신을 공격 범위로 하는 오퍼레이터들 리스트를 저장. 적이 타일에 진입하면 타일은 오퍼레이터들에게 공격 범위 내에 적이 들어왔음을 알린다. 나갈 때도 똑같은 원리로 제거함.
	2. 오퍼레이터는 이제 `Update`에서 타일들이 갖고 있는 적들을 가져오지 않고, 타일들이 알려주는 적들을 계속 불러온다. 
	- 이렇게만 하면 **공격 범위 내에 있는 한 타일에서 나갈 때 다른 타일로 들어갈 때 일시적으로 공격 범위에 있는 적을 잃는 현상**이 있음. 
		- 지금 콜라이더의 구현을 보면 적은 두 타일에 모두 존재하는 경우가 있는데도 이런 현상이 나타난다.
		- 그래서 **타일에서 나갈 때 오퍼레이터에서는 자신의 공격 범위 내에 해당 적이 계속 있는지를 검사**하는 방식으로 이를 보완할 수 있다.
		- 그래도 계속 안돼서 헤맸음. 조건문에 대한 생각을 잘못 한 듯.

> `Operator`가 `Enemy`를 감지하는 로직을 업데이트했듯, `Enemy`에서도 `Operator`를 감지하는 로직을 업데이트하겠음.

- [x] `Enemy` : 공격 범위 내의 `Operator` 선정 로직
- 기존 구현 : `Update`마다 `Sphere Collider` 생성 -> 당연히 최적화 문제가 있음
- 과정
	- **공격 범위를 위한 `Sphere Collider`를 추가할 것**이다. `Enemy`가 스폰될 때 `Radius`값만 수정하면 됨.
	- `Enemy`에는 `Box Collider`가 있다 : 이는 `Tile`과의 충돌을 감지해서 해당 타일 위에 `Enemy`가 있음을 나타내기 위한 콜라이더임
	- `Enemy`에 추가로 `Sphere Collider`를 구현할 수 있다. 
		- 하지만 이 경우 모호함이 발생할 수 있다. `OnCollisionEnter, OnTriggerEnter` 등을 쓸 때, 어떤 콜라이더에 의해 발생했는지가 애매하다. **상대방의 콜라이더를 쓰기 때문에 조건을 붙여야 해서 코드가 지저분해진다.**
	- 그래서 이 경우는 자식 오브젝트에 공격 범위용 콜라이더를 하나 구현하는 식으로 수정한다. 이 때, **자식 오브젝트는 부모 오브젝트에게 이벤트를 전달하기 위한 별도의 스크립트를 구현해야 한다.** 

- `Enemy` 중 `Ranged`의 공격 범위 : `3 -> 2`로 하향

# 250606

### 작업 중

### 작업 완료

- [x] 바리케이드 아이콘 추가
![[Barricade_256.png]]
- [x] 모든 `UnitEntity` 상속받는 객체에 대해 `DeathAnimation` 추가
	- 검정색으로 변함 -> 투명해짐
```cs
// UnitEntity.cs
    protected virtual void Die()
    {
        StartCoroutine(DeathAnimation());
    }

    protected IEnumerator DeathAnimation()
    {
        Renderer renderer = GetComponentInChildren<Renderer>();

        // 동일한 머티리얼을 사용하는 모든 객체에 적용되는 걸 막고자 머티리얼 인스턴스를 만들고 진행한다.
        if (renderer != null)
        {
            Material materialInstance = new Material(renderer.material);
            renderer.material = materialInstance;

            // DOTween 사용하여 검정으로 변한 뒤 투명해지는 애니메이션 적용
            materialInstance.DOColor(Color.black, 0f);
            materialInstance.DOFade(0f, 0.5f).OnComplete(() =>
            {
                Destroy(materialInstance); // 메모리 누수 방지
                OnDestroyed?.Invoke(this);
                RemoveAllCrowdControls();
                Destroy(gameObject);
            });
        }
    }
```
- 투명해지는 효과가 구현되지 않고 있음 : 머티리얼 자체가 투명도를 지원하지 않을 가능성이 있다.
	- 머티리얼의 `Surface Type`을 `Transparent`로 바꿔봤는데, **평소에는 `Opaque`였다가 죽을 때만 `Transparent`로 바꾸는 게 나아 보인다.** 관련 코드는 Claude한테 받아서 적용.
	- **검게 변하는 것도 이상하다.** 그냥 투명도만 서서히 낮추는 식으로 하겠음.


# 250605

### 작업 중

#### 1-0 ~ 1-3 정주행하면서 테스트
- `1-3` 스테이지 몹 추가 배치
- 보스는 아직 만들지 않았음

- [ ] 바리케이드 아이콘 추가

### 작업 완료

#### 발견한 이슈들 & 수정 사항
- [x] `BaseSkill`에서 `isOnTest` 필드를 하나 추가
	- 기존 스킬 비용을 나타내는 `SPCost`의 변수 이름을 `spCost`로 변경
	- 변수 `SPCost`는 `isOnTest`에 따라 1이거나 `spCost`를 가리키는 프로퍼티로 변경함.
	- 테스트하려고 SP Cost를 바꾸는 일이 있는데, 원본을 따로 기록해두지 않아서(!) 테스트할 때마다 변동사항이 생겼기 때문에 이렇게 바꿨다. 

- [x] `SPBar`의 회복되는 UI를 보면 낮은 수치일 때는 천천히 오르다가 높은 수치일 때는 빠르게 오르는 듯한 현상이 보임.
```cs
	// spFill.rectTransform.anchorMin = new Vector2(0, 0);
	// spFill.rectTransform.anchorMax = new Vector2(valueRatio, 1);
```
> **이 부분 주석처리로 해결**
> - 저렇게 설정하면 내부 Fill 값이 1이 됐을 때도 슬라이더를 가득 채우지 못함. 딱 중간쯤 온다.

- [x] 튜토리얼 진행 중 `OperatorSlot`을 제대로 찾지 못하는 문제 수정
	- `OperatorInventoryPanel` 에서 슬롯 초기화할 때 원래 슬롯의 이름도 같이 수정했는데 그 부분이 없어졌다. 그 부분을 수정.
	- **`Slot` 자체에서 초기화 시에 이름도 설정하도록 수정 완료**

- [x] `1-1` 스테이지 바리케이드 설명 추가

- [x] 3성 클리어가 아닌데 정예화 아이템이 지급되는 현상 수정
```cs
// 아래처럼 수정 완료
if (stars < 3) return 0f;
else
{
	// 이전에 3성 클리어를 한 적이 없으면 지급
	if (resultInfo == null || resultInfo.stars < 3)
	{
		return 1f;
	}
	throw new InvalidOperationException("FirstClearPromotionItemRate의 예상치 못한 동작");
}
```

- [x] `NormalBuffVFX`의 `Lifetime`이 짧아서 버프가 켜진 중간에 스킬이 잠깐 끊기는 현상이 있음
	- **`Lifetime`을 늘려서 수정 완료**
# 250604

### 작업 중

#### 1-3 스테이지 작업
- 몹 배치
- ~~보스 작업~~

### 작업 완료
#### 범위 이펙트 : 최초 실행 시에 나타나지 않는 문제
- 이슈를 정리해봤음. AI한테 던져주기도 했다.
```
1. 스테이지 씬에서 스킬을 최초로 실행했을 때 범위를 나타내는 이펙트가 나타나지 않음
	1-1. 이펙트가 나타나지 않은 상황에서 스킬이 종료되고, 해당 스킬을 다시 실행했을 때에도 똑같이 범위를 나타내는 이펙트가 나타나지 않음.

2. 스테이지가 종료되고 메인메뉴 씬으로 전환됐다가 다시 스테이지 씬으로 돌아갔을 때에는 범위 이펙트가 최초 실행부터 잘 나타남.

3. 유니티 엔진 상에서 아예 실행을 멈췄다가(Stop) 다시 시작(Play) 버튼을 눌렀을 때, 스테이지 씬에서 범위 이펙트는 최초 실행부터 잘 동작함.

4. 유니티 엔진을 아예 껐다가 켰을 때에는 다시 1번과 1-1번처럼 동작함.
```
- [[셰이더 컴파일, 리소스 초기화 지연 문제]]
	- **셰이더 컴파일, 리소스 초기화** 지연 이슈. 
	- 에디터에서는 셰이더가 필요할 때마다 실시간으로 컴파일되기 때문에 컴파일이 완료되지 않은 상태에서 실행되면 이펙트가 나타나지 않을 수 있음.
	- 즉 에디터 단계에서만 필요한 기능
	- **스테이지 로딩할 때 가지고 있는 이펙트나 파티클 시스템들을 모두 잠깐 실행하는 기능을 구현해봤는데 안됨**
	- 이펙트가 나타나지 않는 게 문제이지 기능은 똑같이 동작하니까 이건 해결하지 않고 보류함.
	- 아니면 스테이지 진입 전에 메인메뉴 씬에서 스킬들을 1번씩 실행시키는 것도 괜찮을 듯

#### 기타 이슈 수정
- [x] `Artillery`의 폭발 이펙트가 여러 개 발생하는 현상 수정
	- `Projectile`로 피격이 발생할 때 범위 콜라이더가 발생 -> 범위 콜라이더에 충돌한 적들에 대해 피격 이펙트가 다시 발생하기 때문
	- ~~`UnitEntity.TakeDamage`에서 `bool playGetHitEffect = true`을 추가, 특별한 경우에만 피격 이펙트를 끄도록 수정함.~~
		- 이건 아예 피격 이펙트가 재생되지 않을 거임
		- `Enemy.TakeDamage`가 `UnitEntity.TakeDamage`를 상속받지만, `base.TakeDamage()`를 이용하는 구조는 아님. 이 구조를 바꿔봐야 할 듯?
			- **`base.TakeDamage()`를 이용하도록 수정.**

- [x] `Enemy.TakeDamage` 부분에서 추가로 구현된 부분은 `Operator`가 공격했을 때 통계 패널을 업데이트하는 부분이었다. `base.TakeDamage` 내에 `virtual` 메서드를 이용하도록 넣고 `virtual` 메서드는 `Enemy`에서 구현하는 식으로 수정.
	- `OnDamageTaken(float actualDamage)`로 사용 중인 게 있었다. 이걸 **`OnDamageTaken(UnitEntity attacker, float actualDamage)`로 바꾸고** `UnitEntity`에선 비우고 **자식 클래스들인 `Operator`와 `Enemy`에서 각각 방어 통계 업데이트와 공격 통계 업데이트하는 식으로 수정함.**

- [x] `OperatorInventoryPanel`
	- **오퍼레이터를 선택해서 들어갔다면 해당 오퍼레이터의 슬롯은 현재 스쿼드에서 사용 중인 스킬로 초기화**돼야 함. 지금은 기본 지정 스킬이 나타난다.
```cs
// 자동으로 선택되는 오퍼레이터의 스킬은 현재 스쿼드에서 사용 중인 스킬로 선택됨
if (operatorToAutoSelect != null && opToShow == operatorToAutoSelect)
{
	selectedSkillIndex = GameManagement.Instance!.UserSquadManager.GetCurrentSkillIndex(operatorToAutoSelect);
}
// 나머지는 오퍼레이터의 기본 선택 스킬을 사용
else
{
	selectedSkillIndex = opToShow.DefaultSelectedSkillIndex;
}
```
> 단일 선택 상황에서만 이런 이슈가 있었고 다중 선택 상황은 스쿼드의 스킬 정보를 이미 가져오는 식으로 구현되어 있었음.

- [x] `TestManager`에서의 테스트를 위한 초기화 환경 개선
	- 모든 오퍼레이터의 정예화, 레벨을 지정해서 초기화하도록 기능 수정


# 250603

### 작업 중
### 작업 완료

#### 기존 스테이지 리밸런싱
- 오퍼레이터가 이제 7명이기 때문에
	- [x] 한꺼번에 동시에 배치 가능한 인원을 **5명 -> 6명**으로 올림
	- [x] 보상 재설정 
		- 기존의 1, 2, 3 구성 중 어디를 바꿀까?
		- 정예화 가능 숫자 기준 `1, 3, 3`이랑 `2, 2, 3` 중에 `2, 2, 3`으로 결정
- `1-1`, `1-2` 스테이지 재설정
	- 동시에 6명을 배치할 수 있게 되면서 스테이지의 난이도를 조금 더 올릴 수 있을 것 같다.
	- ...라고는 해도 큰 수정은 안해도 될 것 같은게, 지상에 배치할 수 있는 오퍼레이터가 3기밖에 없어서 엄청 쉬워진다는 느낌은 아니다. 약간의 적만 추가했음.
- `Tanker` 방어력 550으로 상향
#### SixBulletSkill
- 스킬이 켜진 직후에 공격 속도와 모션을 0으로 만듦(초기화)
	- 즉 평타가 나간 직후에 스킬이 켜지면 바로 공격이 1번 더 나갈 수 있는 구성
#### TestManager 생성
- `PlayerDataManager`에서 테스트를 위한 초기화 부분을 `TestManager`로 별도로 떼어내서 구현함
	- AI한테 던져서 초안만 만들고 디테일은 잡아나가는 식으로 작업
	- `TestManager`는 `GameManagement`의 자식 오브젝트로 처리
#### 기타 이슈 수정
- [x] `StageSelectPanel` : `PromotionItem` 갯수가 1개로 고정되어 표기되는 문제 수정

# 250602 

### 작업 중

### 작업 완료

#### Artillery 2번째 스킬 남은 작업 처리
1. 스킬이 켜졌을 때 UI가 제대로 나타나지 않음
2. 스킬이 켜졌을 때 공격 속도 타이머가 다시 돌아가는 느낌이 있고, 공격 속도가 빨라지는지도 모르겠음.

- 우선 UI 작업부터 다시 진행함.
	- **이전에 AI가 던져준 코드는 폐기. 이해도 안 되고 제대로 동작하지도 않음.**
	- 기존의 `HealthBar`는 `Slider` 내에 들어가는 `Filled` Image만 갖고 컨트롤하는 방식이었음
	- `AmmoMode`를 켜게 되면 `Horizontal Layout Group`을 사용하고 
		- 기존의 `HealthFill`은 비활성화한다.
	- 근데 이거를 `DeployableBarUI` 단위에서 구현할지 `OperatorUI`에서 구현할지가 좀 애매한 지점이 있음. 프리팹 연결도 해제해둔 상태다.
		- `DeployableBarUI`에서 사용할 요소가 아니긴 한데, 스크립트는 `DeployableBarUI`에 구현되어 있다는 게 문제인가?

- 대충 아래처럼 작업할 예정
1. 일단 `OperatorUI`에서 구현을 할 거임
2. `DeployableBarUI`는 `OperatorUI` 외에도 자체적으로 쓰이는 상황이 있기 때문에, 이 경우는 단순하게 인터페이스처럼 동작함
3. `SPBar`를 `HealthBar`와 분리해서 스크립트를 구현함. `SPBar`에만 추가로 쓰이는 것들이 있다.
	- `HealthBar`의 기능 일부를 떼서 `SPBar`에 붙였다. 예를 들면 체력이 감소하는 효과를 나타내는 `DamageOverlay`나 `ShieldFill` 같은 부분은 `SPBar`에서는 필요하지 않으니 제외하고, `SPBar`에만 들어가는 `Ammo` 관련 `UI`들이 추가되었음.

> 발생 중인 이슈
 - [x] 스킬 켜지면 ~~SP Bar의 게이지 높이가 훨씬 커지며~~ `ammoMode`로의 전환도 제대로 안 됨
- [x] 스킬 임의로 껐을 때 기존 이미지들 제거해야 함
- [x] 탄환이 나갈 때 오른쪽에 빈 공간이 나타나는 게 아니라 계속 화면을 가득 채운 채로 현재 갯수만 감소함
	- 이거는 아예 `Child Force Expand`로 설정할 게 아니라 너비값을 설정하고 줄여나가는 식으로 해야 할 듯? 
	- 너무 어렵게 생각했다. 탄환 갯수를 계속 넣는 방식으로 업데이트하니까, **이미지를 비활성화하는 게 아니라 알파값을 0으로 만들어서 투명하게만 만들면 됨.**
	- 패딩 값은 `0.02` 정도로 잡으면 얼추 보이는 걸 알고 있다.

- `DeployableActionUI`  : 스킬 버튼에 중지 표시 구현
# 250601

### 블렌더 공부
- [[블렌더 5. UV 매핑]]

