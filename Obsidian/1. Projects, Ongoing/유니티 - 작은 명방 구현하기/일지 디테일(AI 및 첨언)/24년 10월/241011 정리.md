## currentTarget의 예상치 못한 변경 수정

> `Enemy`의 남은 거리 계산 로직을 수정) `currentNodeIndex`에 한해서는 현재 위치 ~ 다음 노드까지의 거리를 계산하고, 이후로는 노드와 노드 사이의 거리만을 계산한다.

네, 지금까지의 대화 내용을 정리해드리겠습니다:

1. Operator의 공격 범위 및 Enemy 인식 시스템:
   - Operator의 공격 범위는 Tile들로 구성되어 있습니다.
   - Enemy는 자신이 밟은 Tile에 정보를 전달합니다.
   - Operator는 공격 범위 내 Tile들에서 Enemy 정보를 인식합니다.

2. 현재 발생하는 문제:
   - Enemy가 Tile을 이동할 때 순간적으로 Tile 위에 존재하지 않는다고 판정될 수 있습니다.
   - 이로 인해 Operator가 타겟을 자주 변경하는 문제가 발생합니다.

3. 해결 방안 제안:
   a. 타일 전환 시 오버랩 구현:
      - Enemy가 타일을 이동할 때 잠시 두 타일 모두에 존재하도록 처리합니다.
   b. 타겟 우선순위 및 지속성 구현:
      - 현재 타겟에 대한 지속성을 유지하고, 범위를 벗어났을 때만 새 타겟을 선정합니다.
   c. 공격 범위 체크 개선:
      - 실제 거리를 사용하여 공격 범위를 확인합니다.

4. 디버깅을 위한 스크립트 작성:
   - Operator가 포착한 Enemy들과 그들의 목적지까지 남은 거리를 출력하는 스크립트를 제안했습니다.

5. Enemy 인스턴스 구분:
   - 같은 프리팹으로 인스턴스화된 Enemy 오브젝트들은 각각 다른 고유한 인스턴스로 취급됩니다.
   - 이는 Unity의 인스턴스화 시스템과 C#의 참조 타입 특성 때문입니다.
   - `Distinct()` 메서드는 실제로 같은 Enemy 인스턴스가 여러 번 추가된 경우에만 중복을 제거합니다.

6. 디버깅을 위한 코드 수정 제안:
   - 각 Enemy의 InstanceID를 출력하고, `Distinct()` 적용 전후의 enemiesInRange 리스트 크기를 비교하는 코드를 제안했습니다.

이러한 내용들을 바탕으로 Operator의 타겟팅 시스템을 개선하고, Enemy 인식 문제를 해결할 수 있을 것입니다.