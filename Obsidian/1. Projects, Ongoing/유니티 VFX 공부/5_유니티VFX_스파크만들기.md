1. 빈 게임 오브젝트 `vfx_Sparks_Loop`를 만듦
2. `Prefabs/Sparks/` 폴더를 만들고 그 안에 프리팹으로 넣음
3. `Particle System` 컴포넌트를 붙임
4. 머티리얼에 `default-particleSystem` 등을 쓰는 방법도 있지만 셰이더 그래프로 구현

## 1. Additive Shader
- `Shaders/` 폴더에 `ParticleAdditive_HDR`이라는 이름의 `Unlit` 셰이더 그래프 생성
	- ~~빌트인 RP를 사용~~
	- **프로젝트에 맞춰서 셰이더 그래프를 생성**하자.
	- **`Unlit`를 쓰는 이유는 빛 정보가 필요하지 않기 때문**
	- `Main Preview`는 `Quad`로 설정

> [!warning]
> - 아래에서 오류가 발생해서 정리해둔다.
> - **`URP`로 만든 프로젝트라면 `URP` 셰이더의 `Unlit`를, `HDRP`로 만들었다면 `HDRP`의 `unlit`를 써야 한다.**  `HDRP`로 만들고 빌트인 셰이더 그래프를 만들어서 쓰려고 하면 변경 사항이 적용되지 않고 마젠타 색만 보일 거임.


- `Surface`
	- `Opaque` : 나무, 돌 , 철 등에 사용
	- **`Transparent`** : 스파크 효과이므로 이걸 쓴다. 

- `Blend` : 다른 셰이더나 머티리얼이 뒤에 있어서 겹쳐졌을 때 어떻게 보여줄 것인가
	- 여기선 **`Additive`** 를 사용

- `Render Face` : 메쉬의 어느 쪽 면을 쓸지, 혹은 양쪽을 다 쓸지 결정. 
	- 여기선 **`Both`** 사용

>[!warning]
>내 프로젝트에서는 `MainPreview`에 있는 `Quad`에 변경된 셰이더 정보가 반영되지 않는 이슈가 있다. 그거 원인부터 찾아봄.

>[!done]
>- **HDRP로 만든 프로젝트라면 셰이더도 HDRP로 만들어야 한다.** 안 그러면 위처럼 Quad에 셰이더의 정보가 반영되지 않음. 즉 빌트인 셰이더로 셰이더 그래프를 만들었다면 프리뷰에 변경된 내용이 적용되지 않는다. 
>- 단 HDRP의 경우 URP와도 뭐가 좀 많이 달라 보인다. 대충 비슷한 설정 적용하면서 실습 진행함.

- 전체적인 설정은 늘상 하던 그것과 같다. 
	- 프로퍼티 : `Texture2D`와 `Color` 설정
		- `Color`은 `Mode : HDR` 설정
	- `Sample Texture 2D` 노드에 `Texture 2D` 연결
	- `Color`와 `Sample Texture 2D`의 아웃풋을 `Multiply`함
	- `Multipliy`의 아웃풋을 마스터 노드의 `Color`에 연결함

- 이게 **가장 기초적인 `Additive` 셰이더의 설정**이다. 
	- 텍스쳐와 색을 받음.

- 머티리얼 생성 및 설정
	- 위에서 만든 셰이더 그래프를 저장, 머티리얼로 만든다. 이름은 `DefaultParticle_HDR`
	- 그리고 위에서 띄웠던 파티클 시스템에 머티리얼을 연결함.
	- 이 시점에서 머티리얼의 `Color`에 들어가는 `Alpha`를 줄여도 파티클들이 투명해지지는 않음.

- 파티클 시스템 자체에서도 `Start Color`를 바꿀 수 있지만, 이렇게 구현했을 때 **`Start Color`를 바꿔도 파티클의 색은 바뀌지 않는다.**
	- 왜? 현재의 셰이더에서 노출된 프로퍼티는 `Texture2D`와 `Color`이지만, **외부 색상 소스를 고려하지 않은 상태의 구현이기 때문이다.** 

### 파티클 시스템의 `Start Color`가 적용되도록 그래프 수정
- `Start Color`를 받아 파티클의 색에 반영하려면 **`Vertex Color`라는 노드를 셰이더 그래프 내부에 구현**해야 한다. 
- 연결은 단순히 기존의 곱하기 아웃풋에 다시 `Vertex Color`와 곱하는 것.
![[Pasted image 20250724175221.png]]

여기까지 연결했으면 파티클 시스템의 `Color`를 변경했을 때 색 변경과 투명도 변경 모두 반영 가능함
- 대신 `Intensity`는 셰이더 그래프의 설정이기 때문에 거기서 반영해야 한다.
- 그래서 기본적으로 셰이더 그래프는 `Intensity`만 설정하고 색은 흰색으로 놓고, 실제 색상의 변경은 `Particle System`에서 진행하는 방식으로 해도 HDR의 강도 반영이 가능함.


## 2. 내 텍스쳐 만들기
- 구글에서 텍스쳐를 가져오는 것도 테스트 목적으로는 가능하지만 상업적 목적으론 자제하자.

- 이미지 편집 소프트웨어를 이용해본다.
- `1024 x 1024`, 이름은 `Beam01`
- 배경은 까맣게 두고 파티클 시스템과 비슷한 텍스쳐를 하나 만든다(Flare 효과 같은)
- 내 경우 프로크리에이트로 아래 이미지를 만들었음
![[Tut_MyTexture (2).png]]

>[!info]
>단순하게 이런 식으로 구현하는 것 외에도 저 이미지에 여러 변주를 주는 것도 가능하다. 
>- 소용돌이를 준다든가 그 위에 다른 텍스쳐를 덧입힌다든가 등등
>- 프로크리에이트의 경우 `픽셀 유동화`를 활용하면 재밌는 게 많을 것 같음. 일단은 강의 진행.

기존에 만들었던 머티리얼의 이름을 `Beam01_Add`로 변경, 텍스쳐에는 지금 만든 이미지를 할당.
**텍스쳐 이미지의 경우 `Sprite`로 만들지 않고 `Default` 그대로 사용한다.** 
- **`Sprite`는 UI에 쓰는 경우에 사용**하면 될 듯.

## 3. 파티클 시스템 설명
![[Pasted image 20250724181738.png]]
- `Duration` : 파티클이 방출되는 시간. `Looping`을 끄면 1회만 실행.
	- 여기서 팁) `Scene`에서 `Playback Time`을 잡고 왼쪽으로 드래그하면 리와인드할 수 있다.
- `Start Delay` : 최초 방출 전 기다리는 시간.
- `Start Lifetime` : 파티클이 생성되고 난 후 유지되는 시간.
	 - 프로젝트) 이 값의 경우 `Random Between Two Constants`을 사용, 0.7~2초로 설정한다.
- `Start Speed` : 파티클이 갖는 속도.
	- 프로젝트) 역시 랜덤성을 부여, 1~15로 부여.
- `Start Size` : 크기.
	- 프로젝트) 0.1 ~ 0.3
- 

- `Emission` 탭
![[Pasted image 20250724181941.png]]
- `Rate Over Time` : 1초 동안 방출되는 파티클의 양

- `Shape` 탭
![[Pasted image 20250724182407.png]]
- `SceneTools`을 활성화시키면 어떤 모양으로 파티클이 나가는지 기즈모로 볼 수 있음
- `Shape`에 따라 메뉴 구성이 달라지지만, 여기선 `Cone`을 기준으로 본다.
- `Angle` : 꼭짓점에서 밑면의 양 끝 사이의 각도. 좁을수록 파티클은 직선으로 나간다.
	- 여기선 `20`으로 설정.

- 다른 여러 옵션들이 있으나 강의에선 설명하지 않고 지나간다. 직접 테스트해보는 걸 추천.

- `Renderer` 탭
![[Pasted image 20250724182705.png]]
- `Render Mode`
	- 튀는 방향으로 뻗어서 날아간다는 느낌을 주려면 `Stretched Billboard`를 사용한다.
	- 용접이나 그라인더 등의 스파크 이미지들을 보면 튀는 방향으로 파티클들이 늘어지는 듯한 느낌이 있기 때문이다. 레퍼런스 참고도 이래서 중요함.
- `Stretched`를 쓰면
	- `Speed Scale`
	- `Length Scale` 등을 설정할 수 있다. 알아서 설정 ㄱ.

> 이제부터 어떤 옵션을 만졌는지만 적어놓고 넘김

- `Max Particle Size` : 파티클 1개가 뷰포트의 넓이 중 얼마나 큰 크기를 차지할 수 있는가? 
	- 강의에선 3인데 1이 최대인 듯?


- 기본 탭 - `Gravity Modifier`을 1로 설정 
	- 파티클에 중력이 작용한다




![[Pasted image 20250724184030.png]]
- `Collision` 탭 활성화
	- `Type`을 `World`로 변경
	- **만약 충돌이 동작하지 않는다면 그건 부딪히는 오브젝트에 콜라이더가 없기 떄문이다.** 
	- `Bounce` : 바닥에 부딪히고 튀어오르는 정도
	- `Dampen` : 바닥에 부딪혀서 움직이지 않는 정도
		- 각각을 0.5로 설정
	- `Lifetime Loss` : 0으로 유지한다. 1로 두면 바닥에 부딪히지마자 없어짐.

- `Rate Over Time`을 50으로 늘려서 파티클 수를 늘였다.
	- 어떤 플랫폼에서 동작시킬 거냐에 따라 당연히 파티클 수도 고려되어야 한다.
	- 지금 같은 경우는 교육이니까 50으로 설정.

- 색상 설정
	- 스파크의 시작은 주황, 끝날 때는 붉은색이 되면서 사라진다. 
	- `Color Over Lifetime`을 사용. `Start Color`는 다시 흰색으로 돌려놓는다.
	- 이 경우 `Color Over Lifetime` 자체에서는 `HDR` 팔레트로 설정하지 않고 색과 알파의 변화만을 지정, `HDR`은 머티리얼의 그것을 사용하는 방식.
		- 근데 여기서도 설정이 가능했던 것 같은데 어디 있었는지 모르겠음

>[!info]
>
> **반짝이는 이펙트를 위한 트릭 2가지**
> 1. `HDR`의 `Intensity` 설정
> 2. `Bloom` 효과 
> 	- `Volume Profile`의 `Bloom - Intensity` 설정을 늘이면 뿌옇게 보이는 효과가 된다. `Intensity`와 함께라면 이펙트가 더 밝아보이는 효과가 나옴.

- `Size Over Lifetime` 설정
	- 서서히 작아지도록 설정

- `Color Over Lifetime`에서는 `Random Between Two Gradients`라는 설정도 있다.
	- 생성되는 **파티클의 색상 변화가 2가지 옵션 중 하나를 따르도록 설정**하는 것임
	- 이걸 사용하면 조금 더 다채로운 색상 변화가 가능하다.
	- 여기선 기존 그래디언트를 복붙한 다음, 시작 색과 끝 색을 조금 더 다르게 설정하는 식으로 가져감.

- `Prewarm`
	- 활성화 시 이펙트가 시작될 때 이미 재생중이었던 것처럼 실행됨
	- 아니라면 이펙트가 시작되는 시점부터 파티클이 나오기 시작함
	- 여기선 비활성화.

- `Simulation Space`
	- 지금까지의 작업에서 파티클 오브젝트를 잡고 좌우로 움직이면 이미 발사된 파티클이라도 똑같이 따라가게 됨. 
	- 이건 `Simulation Space`가 `Local`이기 때문이다.
	- `World`로 바꾸면 오브젝트가 움직여도 이미 발사된 파티클은 그 위치로 남게 됨.

여기서 누누이 강조하는 것 : **변주를 주는 건 무조건 좋다**



## 4. 스파크에 디테일 더하기
- `Spark`를 복붙해서 `Beam`이라는 파티클 시스템 오브젝트를 하나 더 만든다. 
- 스파크의 중심에서 나오는 빛을 묘사할 거임 

- `Start Lifetime` : `0.2 ~ 0.5`
- `Start Speed` : `0`
- `Start Size` : `0.5 ~ 0.7`
- `Gravity Modifer`  : `0`
- `Simulation Space` : `Local`
- `Rate Over Time` : `5`
- 탭 비활성화 : `Shape`, `Color over Lifetime`, `Size Over Lifetime`, `Collision`
- `Render Mode` : `Billboard`

- `Color Over Lifetime` 다시 활성화 - 스파크의 설정을 복붙했으므로 비슷한 색도 괜찮아 보임.

- **`Size Over Lifetime`**
	- [[2_유니티VFX_VFX의 기초, 원칙]]에서 강조했던 타이밍과 형태의 설정이 여기서 이뤄지므로 이 설정이 중요함. 
	- 키를 여러 개 추가해서, `Size`가 지속적으로 요동치도록 사인커브 비슷한 걸 만들어놓는다. 

![[Pasted image 20250724195417.png]]
현재까지의 구현. 튀어서 날아가는게 `Spark`, 밝게 점멸하는 부분이 `Beam`이다.

- 이 자체로는 `Beam` 자체가 작아보이기 때문에 `Beam`을 다시 복붙해서 또 만든다.
	- 지금까지 1개의 머티리얼, 1개의 텍스쳐로만 작업하고 있다.

- `Shiny`라는 이름으로 생성.
- `Start Lifetime` : `0.3 ~ 0.6`
- **`3D Start Size`를 사용한다.**
	- `Constant` , `2.5, 0.1, 1`
![[Pasted image 20250724195725.png]]
- 원형 이미지를 이렇게 한쪽으로만 길게 늘인 모양이 되면 이런 효과가 나온다.
> 이걸 생각해보면 내가 생각했던 칼로 베는 듯한 피격 VFX의 구현도 그렇게 어렵지는 않을 것 같다. 기존엔 텍스쳐 시트를 만들어야 하나? 생각했는데, 그냥 **피격 대상 위치에 저런 파티클을 보여줘도 되겠다는 생각이 듦.** 물론 아는 것과 실천하는 것은 다르다.

- `Start Rotation` : `-360, 360`
- `Flip Rotation` : `1`
	- 말 그대로 뒤집을 수 있는지 여부.

- 다시 `3D Start Size`는 `2.5, 0.25, 1 ~ 1, 0.1, 1`로 수정한다.
- `Rate Over Time` : `15`
- `Color Over Lifetime` : 1개의 그래디언트만을 사용 `0 -> 255 -> 0`으로 구성하며, 색은 흰색이다.
	- `Start Color`에 색을 설정해서 그것만 사용할 예정. 

![[Pasted image 20250724200401.png]]
이런 식으로 삐쭉빼쭉한 상황임

- `Start Color`도 2가지 색을 사용한다. 
	- 같은 색상에서 하나는 채도 100%, 다른 하나는 채도를 얇게 가져갔음.

![[Pasted image 20250724200710.png]]
> 지금까지 구현한 3가지 파티클 시스템을 모두 켜면 이런 모양이다.

- 추가로, 지금까지 빈 오브젝트 아래에 3개의 파티클 시스템이 있는데 이들을 한꺼번에 실행하려면
- **하나의 파티클 시스템 아래에 다른 파티클 시스템들을 넣어두면 된다.**

![[Pasted image 20250724201000.png]]
이 구조에서
- `Emission Over time`대신 **`Emission Over Distance`** 를 사용하면 `Beam` 오브젝트를 이동시킬 때에만 `Spark`의 파티클들이 발생한다. 
	- 움직일 때만 파티클이 발생하길 원한다면(`Projectile 등`) 이 옵션을 사용한다.
	- `vfx_Sparks_Loop`를 움직여도 변화 없음.


## 5. Loop가 아닌 Spark 구현
- 위에서 만든 `Spark` 오브젝트를 복붙, 프리팹 해제해놨다.

- `Beam` 설정
1. `Looping`을 끈다
2. `Rate over...`도 끈다
3. `Emission - Bursts`에서 설정
	- 1개만 발생
4. `Size Over Lifetime`
	- 위로 볼록한 감소 그래프
5. `Start Color`의 알파값 줄임(너무 밝아서)
6. `Start Lifetime` : `0.4`, `Start Size` : `2`

- `Spark` 설정
- 마찬가지로 루프 끄고 `Burst`로 바꿔서 `30`개 정도 나오게

.... 그냥 강의를 보자. 계속 소장이니까.
여기엔 처음 보거나 몰랐던 거 나오면 기록해두는 용도로 사용하자.


- 추가로 `Beam`을 복붙, 자식 오브젝트를 모두 제거
- `Beam`의 바깥쪽에 더 흐릿하게 나타났다가 사라지는 `Flash`를 구현한다.
	- `StartSize`를 더 크게
	- `StartLifetime`을 더 작게
	- `Start Color`의 알파값을 `5`로 (맥스가 `100`)
![[Pasted image 20250724202633.png]]
- 전체 이펙트
> 바깥의 희미한 원이 `Flash`

## 6. 바리에이션
- 다른 `Color Gradient`를 만들어서 금방 다르게 만들 수도 있음.
![[Pasted image 20250724203049.png]]
![[Pasted image 20250724203321.png]]

등등등..

컬러 팔레트는 [[컬러 팔레트 참고용]]을 보자. 

이런 식으로 다양한 색깔을 넣으면서 여러 종류의 프리팹을 만들면 순식간에 여러 종류의 이펙트를 만들어낸 것이다. 

![[Pasted image 20250724203949.png]]

**비슷한 색을 쓰는 것보다는 여러 색을 조합해보면서 테스트하는 걸 추천.**