#게임프로그래밍패턴

1. [[#책 내용|책 내용]]
	1. [[#책 내용#문제 상황 : 화면이 깜빡인다|문제 상황 : 화면이 깜빡인다]]
	2. [[#책 내용#해결책|해결책]]
	3. [[#책 내용#코드에서의 응용|코드에서의 응용]]
2. [[#유니티에서|유니티에서]]
	1. [[#유니티에서#그래픽 렌더링|그래픽 렌더링]]
	2. [[#유니티에서#물리엔진 FixedUpdate|물리엔진 FixedUpdate]]
	3. [[#유니티에서#로직 응용 : 이번 턴의 대미지 처리|로직 응용 : 이번 턴의 대미지 처리]]
3. [[#유니티에서 사용 시 주의할 점|유니티에서 사용 시 주의할 점]]
	1. [[#유니티에서 사용 시 주의할 점#SyncVar와 네트워크 동기화|SyncVar와 네트워크 동기화]]
	2. [[#유니티에서 사용 시 주의할 점#스크립트 실행 순서|스크립트 실행 순서]]

## 책 내용

### 문제 상황 : 화면이 깜빡인다
컴퓨터가 화면을 그릴 때, 비디오 메모리는 캔버스에 픽셀 하나하나를 칠한다.
모니터는 1초에 60번 캔버스를 훔쳐봐서 화면에 뿌린다.

- 상황
1. 배경을 검은색으로 지움
2. 캐릭터를 그리기 시작함
3. 이 타이밍에 모니터가 화면을 가져감
4. 사용자는 배경은 지워졌는데 캐릭터는 반만 그려진 화면을 보게 됨
> 화면의 절반이 어긋나는 현상이 나타난다고 보면 되겠다.

### 해결책
- 버퍼를 2개 쓴다 
- 캔버스를 2개 준비한다.
	- 프론트 버퍼 : 지금 모니터가 보여주는 완성된 그림
	- 백 버퍼 : 다음 프레임을 그리고 있는 그림

- 작동 방식
	- 컴퓨터는 백 버퍼에 그림을 그린다.
	- 그림이 완성되면 교체해서 두 버퍼를 순식간에 맞바꾼다.
	- 모니터는 항상 완성된 그림만 보여준다.

### 코드에서의 응용
- 이런 원리는 그래픽 외에도 게임 로직(AI, 물리)에서도 쓰인다.
- 예시 상황
	- 규칙 : 주변 세포가 3개면 자신도 살아난다
	- 문제 : `for`문으로 배열들을 돌며 업데이트할 때, `0, 0` 세포를 업데이트해서 상태가 바뀌어버리면, 바로 옆 세포 `(0 , 1)`가 **업데이트할 때 방금 바뀐 값을 참조**하게 됨
	- 결과 : 시뮬레이션이 엉망이 된다. 모든 세포는 동시에 변해야 한다.

- 해결 
	- `currentGrid`와 `nextGrid`를 구분
	- `currentGrid`의 것만 보고 계산해서 `nextGrid`에 쓴다
	- 다 끝나면 두 배열을 교체한다. (메모리 보존 때문인 듯)
## 유니티에서
- 직접 구현할 일은 드물지만, 이 원리가 적용된 시스템을 매일 마주한다.
### 그래픽 렌더링
- 유니티의 렌더링 파이프라인은 기본적으로 이중 버퍼링 / 삼중 버퍼링을 사용한다.
- `Update()`에서 오브젝트를 이동 시켜도 화면에 즉시 반영되지 않고, 프레임의 끝에 렌더링이 일어나는 이유가 바로 백 버퍼에 그림을 그리기 때문이다.

### 물리엔진 FixedUpdate
- 유니티의 물리 엔진 `PhysX`도 내부적으로 이중 버퍼링 개념을 사용한다.
- 연산 중에 충돌 처리로 인해 위치가 바뀌더라도 그 프레임의 다른 물리 계산이나 순서에 영향을 주지 않도록 내부적인 버퍼링을 수행한다.

- 예시) 물결 시뮬레이션
```cs
public class FluidSimulation : MonoBehaviour
{
    public RenderTexture bufferA;
    public RenderTexture bufferB;
    public Material simulationMat;

    void Update()
    {
        // A를 읽어서 B에 그린다
        simulationMat.SetTexture("_ReadTex", bufferA);
        Graphics.Blit(bufferA, bufferB, simulationMat);

        // Swap (A와 B를 교체)
        var temp = bufferA;
        bufferA = bufferB;
        bufferB = temp;
        
        // 이제 화면에는 완성된 bufferA를 보여준다
        GetComponent<Renderer>().material.mainTexture = bufferA;
    }
}
```

### 로직 응용 : 이번 턴의 대미지 처리
- 턴제 게임이나 동기화가 중요한 멀티 플레이 게임에서도 이중 버퍼 개념을 쓴다.
- A가 B를 공격할 때, B도 A를 **동시에** 때린다. 두 타격 모두 죽음에 이른다고 가정한다.
- 하지만 프로그램은 순서가 정해져 있다. 반면 "동시에" 때렸기 때문에 무승부로 비기게 해야 한다.
- 이럴 때도 이중 버퍼를 쓴다.
	1. A 공격 명력 등록, B 공격 명령 등록(버퍼에 저장)
	2. 모든 명령 실행(Resolve)
	3. A, B 동시에 사망
## 유니티에서 사용 시 주의할 점
### SyncVar와 네트워크 동기화
- 멀티플레이 게임`Netcode for GameObjects, Photon 등`에서 `보간Interpolation`을 할 때 이중 버퍼 개념이 쓰인다.
	- 서버 : 현재 위치 `t`를 보냄
	- 클라이언트 : 바로 `t`로 이동하면 끊김
	- 해결 : `From` 버퍼와 `To` 버퍼를 두고, 그 사이를 부드럽게 이동`Lerp`

### 스크립트 실행 순서
- 이중 버퍼를 쓰지 않는 일반적인 유니티 스크립트는 순서 종속적이다.
- `Player.update` vs `Enemy.Update`의 실행 순서에 따라 결과가 달라질 수 있다.
- `Script Exectuion Order` 설정이 제공되지만, **가장 좋은 건 순서에 상관없도록 코드를 짜는 것이다.** 