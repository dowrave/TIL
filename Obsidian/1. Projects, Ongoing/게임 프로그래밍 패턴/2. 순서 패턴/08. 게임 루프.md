#게임프로그래밍패턴

1. [[#책 내용|책 내용]]
	1. [[#책 내용#게임 루프란?|게임 루프란?]]
	2. [[#책 내용#시간의 문제(FPS, 게임 속도)|시간의 문제(FPS, 게임 속도)]]
	3. [[#책 내용#해결책 1 - 고정 시간 간격(Fixed Time Step) - 잠자기|해결책 1 - 고정 시간 간격(Fixed Time Step) - 잠자기]]
	4. [[#책 내용#해결책 2 - 가변 시간 간격(Variable Time Step) - 델타 타임|해결책 2 - 가변 시간 간격(Variable Time Step) - 델타 타임]]
	5. [[#책 내용#해결책 3 - 따라잡기(Fixed Update) - 책 추천|해결책 3 - 따라잡기(Fixed Update) - 책 추천]]
2. [[#유니티에서|유니티에서]]
	1. [[#유니티에서#Update() vs FixedUpdate()|Update() vs FixedUpdate()]]
	2. [[#유니티에서#Time.deltaTime의 비밀|Time.deltaTime의 비밀]]
	3. [[#유니티에서#보간|보간]]
3. [[#유니티에서 활용 및 주의점|유니티에서 활용 및 주의점]]
	1. [[#유니티에서 활용 및 주의점#모바일 게임과 배터리|모바일 게임과 배터리]]
	2. [[#유니티에서 활용 및 주의점#코루틴과 게임 루프|코루틴과 게임 루프]]
	3. [[#유니티에서 활용 및 주의점#물리 버그(Physics Glitch) 방지|물리 버그(Physics Glitch) 방지]]
	4. [[#유니티에서 활용 및 주의점#요약 가이드|요약 가이드]]


## 책 내용

### 게임 루프란?
- 워드, 웹 브라우저 등은 사용자의 키 입력을 기다린다`Event Driven`
- **게임은 사용자가 아무 것도 안해도 무한 루프를 돈다.**
```cpp
while (true) {
	processInput(); // 입력 처리
	update(); // 게임 상태 업데이트(AI, 이동)
	render(); // 화면 그리기
}
```

### 시간의 문제(FPS, 게임 속도)
- 컴퓨터마다 성능이 다른데, 게임의 속도가 하드웨어에 의존적이면 안된다.

### 해결책 1 - 고정 시간 간격(Fixed Time Step) - 잠자기
- 1초에 고정된 간격을 돌라고 강제한다.
- 만약 너무 빨리 돌았다면 의도적으로 `sleep` 타임을 준다.
- 단점) 컴퓨터가 너무 느려서 1/60초인 16ms 안에 처리를 못 한다면 게임이 느려진다.

### 해결책 2 - 가변 시간 간격(Variable Time Step) - 델타 타임
- 지난 프레임에서 시간이 얼마나 지났는지`deltaTime`를 측정해 이동 거리에 곱한다.
- `position += speed * deltaTime;`
- 단점) 물리 엔진, 리플레이 기능은 `결정론적`이어야 하는데 `deltaTime`이 들쑥날쑥하면 미세한 오차가 발생할 수 있다.

### 해결책 3 - 따라잡기(Fixed Update) - 책 추천
- **렌더링은 가변적**으로 하되, **물리/로직 연산은 고정된 간격**으로 몰아서 처리하는 방식이다.
```cpp
double previous = getCurrentTime();
double lag = 0.0;

while (true) {
    double current = getCurrentTime();
    double elapsed = current - previous;
    previous = current;
    lag += elapsed;

    // 1. 로직은 고정된 시간(16ms)만큼 뚝뚝 끊어서 여러 번 실행 (따라잡기)
    while (lag >= MS_PER_UPDATE) {
        update(); // 물리, AI
        lag -= MS_PER_UPDATE;
    }

    // 2. 렌더링은 남은 시간(lag)을 이용해서 부드럽게 보간(Interpolation)해서 그림
    render(lag / MS_PER_UPDATE);
}
```

## 유니티에서
- 유니티는 3번 방식인 `Fixed Update`를 완벽하게 구현하고 있다.

### Update() vs FixedUpdate()
- 유니티 개발자 면접 단골 질문이다.

- `Update()`
	- 가변 시간 간격.
	- 언제 : 매 프레임마다 호출된다. 컴퓨터 성능에 따라 호출 횟수가 다르다.
	- 용도 : 입력 받기`Input`, 타이머 체크, 비물리 이동, 렌더링 관련 처리.
	- 필수 : 이동 시 반드시 `Time.deltaTime`을 곱해야 함.

- `FixedUpdate()`
	- 고정 시간 간격
	- 언제 : 설정된 시간(기본 0.02초, 50fps)마다 호출. 프레임 레이트에 무관하게 일정하다.
	- 용도 : 물리 연산`RigidBody`, 결정론적 로직.
	- 특징 : 컴퓨터가 느려지면 한 프레임에 `FixedUpdate`가 여러번 발생할 수ㅡ 있음(따라잡기)

### Time.deltaTime의 비밀
- `Update()` 내에서 사용 : 지난 프레임 ~ 지금까지 걸린 시간(가변)
- `FixedUpdate()` 내에서 사용 : 0.02초(설정값)로 고정됨(`Time.FixedDeltaTime`과 동일)

### 보간
- 책 마지막에 나오는 `렌더링 보간`은 유니티 `Rigidbody`의 `Interpolate` 옵션으로 제공된다.
- 물리는 0.02초마다 끊겨서 움직이지만 화면이 144hz라서 부드럽게 그려져야 할 때, 유니티가 알아서 중간 위치를 계산해서 부드럽게 보여준다.

## 유니티에서 활용 및 주의점

### 모바일 게임과 배터리
- 모바일 게임에서는 무한 루프가 너무 많이 돌면 전력 소비가 심해짐
- 최적화 : `Application.targetFrameRate = 60;(또는 30)`으로 설정해서 루프 수를 제한해줘야 한다.
- `VSync` : 수직 동기화`QualitySEttings.vSyncCount`를 켜면 모니터 주사율에 맞춰서 루프 속도를 제한한다.

### 코루틴과 게임 루프
- 유니티의 코루틴은 멀티스레드가 아니다. 게임 루프의 특정 지점에서 실행을 `yield`로 멈췄다가 다음 루프에서 이어서 다시 할 수 있다.
- 게임 루프의 흐름을 끊지 않고 시간차 공격, 대기 로직 등을 짤 수 있는 강력한 도구다.

### 물리 버그(Physics Glitch) 방지
- 가끔 게임이 렉이 걸려서 캐릭터가 벽을 뚫고 나가는 현상이 있다.
- 원인 : `FixedUpdate`가 너무 많이 밀려서(Lag) 한 번에 너무 먼 거리를 이동했기 때문
- 해결 : `Edit > Project Settings > Time`에서 `Maximum Allowed Timestep`을 설정해서 렉이 아무리 심해도 한번에 물리 연산을 너무 많이 하지 않도록 제한해줘야 한다.

### 요약 가이드
1. 이동/회전 : `Update`에서 하고 `Time.deltaTime` 곱하기
2. 물리(RigidBody) : 무조건 `FixedUpdate`에서 `AddForce`를 가하기. `deltaTime`은 필요 없음.
3. 입력(Input) : 무조건 `Update`에서 받기. `FixedUpdate`에서 하면 키가 씹힐 수 있다.
4. 최적화 : 모바일은 꼭 타겟 프레임 설정하기.



