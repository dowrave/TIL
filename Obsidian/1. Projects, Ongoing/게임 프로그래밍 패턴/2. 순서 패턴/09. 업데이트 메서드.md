#게임프로그래밍패턴

1. [[#책 내용|책 내용]]
	1. [[#책 내용#문제 상황|문제 상황]]
	2. [[#책 내용#업데이트 메서드 패턴|업데이트 메서드 패턴]]
	3. [[#책 내용#주의 사항|주의 사항]]
2. [[#유니티에서|유니티에서]]
	1. [[#유니티에서#유니티의 매직 메서드 : Message System|유니티의 매직 메서드 : Message System]]
3. [[#유니티에서 활용 및 주의점|유니티에서 활용 및 주의점]]
	1. [[#유니티에서 활용 및 주의점#Update가 너무 많은 경우|Update가 너무 많은 경우]]
	2. [[#유니티에서 활용 및 주의점#실행 순서|실행 순서]]

## 책 내용

### 문제 상황
- 게임 월드의 수많은 객체는 알아서 움직여야 함
- 거대한 게임 루프 객체가 일일이 개별 객체의 이동을 관리해선 안 됨. 유지보수가 불가능함.
```cpp
// 거대한 게임 루프 
while (true) {
    // 1. 주인공 이동
    skeleton.x += 1;
    // 2. 몬스터 이동
    demon.y += 2;
    // 3. 함정 작동
    trap.checkCollision();
    // ... 수천 줄 ...
}
```
### 업데이트 메서드 패턴
1. **추상화** : 모든 객체가 상속받을 공통 인터페이스`Entity`를 정의
2. **메서드 정의** : 그 안에 가상함수 `Update()`을 정의
3. **컬렉션** : 게임 월드는 객체들의 리스트`List<Entity>`만 관리함
4. **위임** : 게임 루프는 리스트를 돌며 "알아서 업데이트하라"고만 함
```cs
void GameWorld::gameLoop() {
    for (Entity* entity : entities) {
        entity->update(); // 다형성(Polymorphism) 덕분에 각자 알아서 행동함
    }
}
```

### 주의 사항
- 삭제 문제 : 업데이트 중에 객체가 죽어서 제거되면? -> 보통 죽었다는 플래그만 켜두고 루프 후에 청소한다.
- 순서 문제 : 움직이는 순서에 따라 결과가 달라질 수 있다.

## 유니티에서

- 알다시피 핵심 아키텍쳐. `MonoBehaviour.Update()`를 작성하면 유니티는 해당 객체를 업데이트가 필요한 목록에 등록한다.
- 반대로 `MonoBehaviour`을 상속받아도 `Update`를 작성하지 않는다면 업데이트 목록에 등록하지 않는다.

### 유니티의 매직 메서드 : Message System
- **유니티의 `Update`는 인터페이스 상속 / 오버라이드가 아니다.** 

```cs
public class MonoBehaviour
{
    // 가상 함수 (자식이 덮어쓸 수 있게 허용)
    public virtual void Update() { }
}

// 자식 클래스 (우리가 짜는 코드)
public class Player : MonoBehaviour
{
    // override 키워드 필수!
    public override void Update() 
    {
        // ...
    }
}
```
> `Update()`가 상속 구조였다면, 반드시 `Override()`가 와야 한다. 그런데 그렇게 쓰고 있지 않음.
> - 이거 되게 당연하게 쓰고 있어서 전혀 깨닫지 못했는데 그러네 ㅋㅋㅋㅋ

- 유니티는 **"이름이 맞으면 실행한다"는 독특한 방식**으로 쓴다.
	- **컴파일/로딩 시점** : 유니티 엔진(C++ 영역)은 스크립트를 분석한다.
	- **검사** : 클래스 내에 `Update`라는 이름의 함수를 발견
	- **캐싱** : 함수 주소를 기억해뒀다가 프레임마다 Update를 호출
	- 이 개념은 **엔진이 특정 이름의 함수를 찾아 콜백으로 등록하는 과정**에 가깝다.
	- `Update`라고만 지으면 리플렉션Reflection이나 내부 연결을 통해 실행된다. 

- 왜 이렇게 구현했는가? 
	- 만약 상속 구조였다면 모든 `MonoBehaviour`는 빈 `Update`를 갖더라도 호출이 되었을 것
	- 이 경우 빈 함수를 호출하는 비용이 발생하게 된다. 
	- 이렇게 구현함으로서 **필요한 요소만 호출하는 최적화**가 가능해졌다.

- 단점) `Update`라는 이름을 정확하게 쓰지 않으면 오류 없이 실행되지 않음
## 유니티에서 활용 및 주의점

### Update가 너무 많은 경우
- `MonoBehaviour` 10000개가 `Update`를 가진다면, 유니티 엔진이 C++ 영역으로 10000번 넘어가야 한다. 이를 `Interop`비용 이라고 한다.

- 이 경우
	1. `MonoBehaviour`의 `Update()`를 지우고, `public void ManualUpdate()`라는 별도의 함수를 만듦.
	2. `GameManager` 1개만 `Update`를 사용
	3. `GameManager`가 배열을 돌며 객체들의 `ManualUpdate()`을 직접 호출한다.

문두에서 좋지 않은 방법이라고 소개한 방식인데, 유닛이 많이 나오는 경우에는 필수적인 최적화 기법이다.

```cs
// 훨씬 빠름! (함수 호출 오버헤드 감소)
void Update() {
    for(int i=0; i < monsters.Count; i++) {
        monsters[i].ManualUpdate();
    }
}
```

### 실행 순서
- 유니티에서는 기본적으로 어떤 스크립트의 `Update`를 먼저 실행할지 보장하지 않는다.
- 해결 : `Project Settings > Script Execution Order`에서 중요한 매니저의 순서를 정해줄 수 있다.




