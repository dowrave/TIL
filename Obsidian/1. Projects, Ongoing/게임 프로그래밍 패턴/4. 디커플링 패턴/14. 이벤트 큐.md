#게임프로그래밍패턴

1. [[#책 내용|책 내용]]
	1. [[#책 내용#문제 상황 : 사운드 시스템|문제 상황 : 사운드 시스템]]
	2. [[#책 내용#해결책 : 큐Queue를 두자|해결책 : 큐Queue를 두자]]
	3. [[#책 내용#링 버퍼 Ring Buffer|링 버퍼 Ring Buffer]]
2. [[#유니티에서|유니티에서]]
	1. [[#유니티에서#사운드 매니저 예제|사운드 매니저 예제]]
	2. [[#유니티에서#업적 시스템|업적 시스템]]
3. [[#유니티에서 사용 시 주의할 점|유니티에서 사용 시 주의할 점]]
	1. [[#유니티에서 사용 시 주의할 점#코루틴과 yield return|코루틴과 yield return]]
	2. [[#유니티에서 사용 시 주의할 점#비동기 로딩 (AsyncOperation)|비동기 로딩 (AsyncOperation)]]
	3. [[#유니티에서 사용 시 주의할 점#큐의 오버플로우|큐의 오버플로우]]
	4. [[#유니티에서 사용 시 주의할 점#요약|요약]]

- 하고 싶은 요청을 바로 하지 않고, 큐에 넣어뒀다가 나중에 순서대로 처리하는 방식.
## 책 내용

### 문제 상황 : 사운드 시스템
- 오디오 엔진은 매우 예민하다. 제때 데이터를 주지 않으면 소리가 끊기거나 찢어진다.
- 반면 게임 로직은 몬스터가 100마리 나오면 느려질 수 있다.
```cpp
void Monster::die() {
    playSound("MonsterDie"); // 1. 파일 로딩하고 2. 디코딩하고 3. 재생하느라 게임이 멈칫함
}
```
- 문제 1 : 동기화 - 소리 재생이 끝날 때까지 게임이 멈추면 안된다.
- 문제 2 : 데드락 - 오디오 스레드와 게임 스레드가 서로 자원을 쓰려고 하다 멈출 수 있다

### 해결책 : 큐Queue를 두자
- 게임 로직은 소리를 틀어달라는 요청만 넣고 자기 할 일을 한다(비동기)
- 오디오 엔진은 여유가 있을 때 큐에서 요청을 하나씩 꺼내서 처리한다

- `Sender` : 큐에 푸쉬(이후 즉시 리턴, 다른 일을 한다)
- `Receiver` : 큐에서 팝(자기 스레드에서 처리)

### 링 버퍼 Ring Buffer
- 큐를 구현할 때 메모리를 계속 할당/해제하면 느려진다.
- 고정된 크기의 배열을 빙글빙글 도는 `원형 큐 Ring Buffer`를 주로 쓴다.

## 유니티에서
- 엔진 내부적으로는 이벤트 큐가 엄청 많이 쓰이지만, C# 스크립트 레벨에서는 코루틴이나 C# Queue로 구현한다.
### 사운드 매니저 예제
- `AudioSource.PlayOneShot`은 이미 비동기지만, 동시에 너무 많은 소리가 나는 걸 방지하거나 우선 순위 관리를 위해선 큐가 필요하다.
```cs
public class SoundManager : MonoBehaviour
{
    // 요청을 담을 큐
    private Queue<AudioClip> audioQueue = new Queue<AudioClip>();
    private AudioSource source;

    public void PlaySound(AudioClip clip)
    {
        // 1. 요청을 큐에 넣고 끝 (즉시 리턴)
        audioQueue.Enqueue(clip);
    }

    void Update()
    {
        // 2. 큐에 쌓인 게 있고, 소리를 낼 수 있는 상황이면 처리
        if (audioQueue.Count > 0 && !source.isPlaying)
        {
            AudioClip clip = audioQueue.Dequeue();
            source.PlayOneShot(clip);
        }
    }
}
```

이렇게 구현해두면 기관총을 1초에 100발 쏴도 소리가 씹히거나 겹치지 않고, 순서대로/정책에 따라 재생되도록 제어할 수도 있다.

### 업적 시스템
동시에 3개의 업적을 달성했다고 가정해보자. 알림창 3개가 겹쳐서 뜨면 안 된다. 하나씩 떠야 하므로, 이럴 때도 이벤트 큐가 필요하다.
```cs
public class AchievementUI : MonoBehaviour
{
    private Queue<string> notificationQueue = new Queue<string>();
    private bool isShowing = false;

    public void ShowNotification(string text)
    {
        notificationQueue.Enqueue(text);
        TryShowNext();
    }

    void TryShowNext()
    {
        if (!isShowing && notificationQueue.Count > 0)
        {
            string text = notificationQueue.Dequeue();
            StartCoroutine(ShowRoutine(text));
        }
    }

    IEnumerator ShowRoutine(string text)
    {
        isShowing = true;
        // UI 애니메이션 실행...
        yield return new WaitForSeconds(3f);
        isShowing = false;
        TryShowNext(); // 다음 거 있나 확인
    }
}
```

## 유니티에서 사용 시 주의할 점

### 코루틴과 yield return
- 유니티의 코루틴 시스템 자체가 일종의 이벤트 큐 처리 방식이다.
- **`StartCoroutine`은 작업을 코루틴 매니저의 큐에 등록하는 행위**다.
- 유니티 엔진은 매 프레임 큐를 확인하고, `yield` 조건이 만족된 것들을 실행시킨다.

### 비동기 로딩 (AsyncOperation)
- 씬 로딩, 애셋 번들 로딩 등도 큐 방식이다.
- `SceneManager.LoadSceneAsync("Game")`을 호출하면 유니티는 로딩 요청을 내부 큐에 넣고 즉시 리턴한다.
- 로딩은 백그라운드에서 조금씩 진행된다.

### 큐의 오버플로우
- 큐는 무한하지 않다.
- 만약 파티클 생성 요청이 처리 속도보다 빨리 들어와서 큐에 10000개가 쌓였다면
- 방법
	1. 무시하기 : 큐가 꽉 차면 새 요청을 버린다(사운드 등의 덜 중요한 것)
	2. 오래된 것 버리기 : 가장 옛날 요청을 버리고 새 걸 넣는다(최신 상태가 중요한 것)
	3. 합치기 : 대미지 1 요청 10개를 대미지 10 요청 1개로 바꾼다

### 요약
- 이벤트 큐는 언제 쓰는가?
	- 지금 당장 하지 않아도 되는 일일 떄
	- 순서대로 처리해야 하는 일일 때(대화창, 튜토리얼 팝업, 업적 알림)
	- 동시에 너무 많이 몰리면 안되는 일일 때(사운드 재생, 네트워크 패킷 전송)
- 도구 : `C#`의 `Queue<T>`면 충분하며, 멀티스레드를 쓸 때는 `ConcurrentQueue<T>`를 써야 한다.
- UI : **팝업창 관리자를 만들 때 이 패턴이 없다면 팝업이 겹치는 현상이 발생**한다. 꼭 큐를 적용하자.
> 사실 꼭 그렇게 하지 않아도 될 것 같지만..? 업계 표준이란 게 있으니까 나온 말이겠지..?

