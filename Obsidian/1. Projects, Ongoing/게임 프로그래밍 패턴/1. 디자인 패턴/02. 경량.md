#게임프로그래밍패턴

1. [[#경량Flyweight|경량Flyweight]]
	1. [[#경량Flyweight#문제 상황|문제 상황]]
	2. [[#경량Flyweight#경량 패턴|경량 패턴]]
	3. [[#경량Flyweight#지형 정보|지형 정보]]
	4. [[#경량Flyweight#성능|성능]]
2. [[#오늘날의 유니티에서는|오늘날의 유니티에서는]]
	1. [[#오늘날의 유니티에서는#엔진 내부적으로 경량 패턴을 사용하고 있음|엔진 내부적으로 경량 패턴을 사용하고 있음]]
	2. [[#오늘날의 유니티에서는#SO : 데이터 공유의 정석|SO : 데이터 공유의 정석]]
	3. [[#오늘날의 유니티에서는#Tilemap|Tilemap]]
	4. [[#오늘날의 유니티에서는#GPU Instancing|GPU Instancing]]
## 경량Flyweight
- `공유Sharing`를 통해 메모리를 절약하는 패턴.

### 문제 상황
- 나무가 1000그루 있는 숲에, 메쉬, 텍스쳐, 위치, 스케일 등의 데이터를 모두 개별적으로 가진다면? 
- 용량이 너무 커진다. 메모리가 충분하더라도 CPU -> GPU로 버스를 통해 전달되는 과정에 활용되기엔 역시 용량이 너무 크다.

### 경량 패턴
- 데이터를 2가지 종류로 구분한다.
1. `고유 상태Extrinsic State` : 인스턴스마다 달라야 하는 데이터.
2. `공유 상태Intrinsic State` : 모든 인스턴스가 공유하는 데이터
	- 예시 : 나무의 메쉬, 껍질 텍스쳐, 잎사귀 텍스쳐 등등

- 패턴 적용 : `TreeModel`이라는 클래스를 별도로 만들어 공유 상태만 저장한다. 이 객체는 메모리에 딱 1개만 있다.
- 실제 객체`Tree`는 무거운 데이터를 직접 드는 대신, `TreeModel`을 가리키는 포인터 하나와 자신의 고유 상태(위치)만 가진다.


### 지형 정보
- 땅을 타일 기반의 거대한 격자라고 가정한다.
- 각 타일은 `Grass, Water, Hill` 등의 속성을 저장한다.
- `enum`을 쓸 수 있지만, 속성이 많아지면 관리가 힘들어진다. 

- 해결책
	- `Terrain`이라는 클래스를 만들고 지형의 속성(이동 비용, 그래픽) 등을 정의한다.
	- `Grass, Water` 등의 인스턴스를 1개씩 만들어둔다.
	- 맵의 각 격자`Grid`는 `Terrain` 객체의 포인터를 저장한다.
		- `(0, 0)`은 `&grass`를, `(0, 1)`은 `&water`를 가리키는 식으로.

### 성능
- 이 패턴은 메모리를 아끼고 캐시 효율에도 영향을 줄 수 있다.
- 하지만 포인터를 타고 들어가는 `Indirection` 과정 떄문에 약간의 CPU 연산 비용이 발생할 수는 있다.
- 그럼에도 줄어든 메모리 사용량으로 전체 성능은 향상될 수 있다. 

## 오늘날의 유니티에서는

### 엔진 내부적으로 경량 패턴을 사용하고 있음
- 프리팹을 1000개 `Instantiate`하더라도 메쉬, 머티리얼 데이터는 복제되지 않음.
- 각 `GameObject`의 `MeshFilter` 컴포넌트는 원본 메쉬 에셋을 참조하고 있다.
- 그래픽 리소스 메모리 문제 때문에 C#으로 경량 패턴을 짤 필요는 없다.

### SO : 데이터 공유의 정석
- 공유 상태를 담는 클래스가 `SO` 개념이다.
- 몬스터의 기본 스탯, 아이템 정보들을 SO로 만들어둔다면, 몬스터가 생성되더라도 이들이 생성될 때 참조하는 SO는 메모리에 1개만 존재한다.
- 유니티 데이터 관리의 핵심 패턴이며, 매우 적극적으로 사용된다.

### Tilemap
- 책의 지형 예제와 일치하는 부분
- `Tile Asset(TileBase)` : 책의 `Terrain` 클래스에 해당한다. 타일의 이미지, 물리 모양 등을 정의하는 경량 객체이다.
- `Tilemap Component` : 책의 월드 그리드로, 각 좌표마다 어떤 `Tile Asset`을 참조하는지 저장한다.

> 이렇게 보니까 내 프로젝트에도 이거 쓸 수 있었을 것 같다. 직접 구현한 상태;


### GPU Instancing
- 책에서는 메모리 절약이 강조되지만, 유니티에선 드로우 콜이 더 큰 이슈다.
- 어쨌든 `GameObject` 1000개를 그리는 건 CPU에 큰 부담이다.
- `GPU Instancing`을 통해 경량 패턴의 개념을 GPU까지 확장했는데
	- 공유 상태의 메쉬를 저 좌표들(고유 상태 배열)에 한꺼번에 그리라고 명령한다.
	- `Graphics.RenderMeshInstanced` 같은 API나 머티리얼의 `Enable GPU Instancing` 같은 기능들이 그 역할을 한다.
- 수천 개의 객체가 필요하다면 `GPU Instancing`이나 `DOTS(ECS)` 기술을 공부하는 게 더 좋음.

