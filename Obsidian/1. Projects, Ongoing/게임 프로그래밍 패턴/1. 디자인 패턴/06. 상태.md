#게임프로그래밍패턴

1. [[#책의 내용|책의 내용]]
	1. [[#책의 내용#추억의 게임 만들기 & FSM이 모두를 구원하리라|추억의 게임 만들기 & FSM이 모두를 구원하리라]]
	2. [[#책의 내용#열거형Enum과 다중 선택문Switch|열거형Enum과 다중 선택문Switch]]
	3. [[#책의 내용#상태 패턴 - 클래스로 만들기|상태 패턴 - 클래스로 만들기]]
	4. [[#책의 내용#입장Enter과 퇴장Exit|입장Enter과 퇴장Exit]]
	5. [[#책의 내용#병행 상태 기계(Concurrent State Machine)|병행 상태 기계(Concurrent State Machine)]]
	6. [[#책의 내용#계층형 상태 기계(Hierarchical State Machine)|계층형 상태 기계(Hierarchical State Machine)]]
	7. [[#책의 내용#푸시 다운 오토마타(Pushdown Automata)|푸시 다운 오토마타(Pushdown Automata)]]
2. [[#유니티에서|유니티에서]]
	1. [[#유니티에서#Animator (Mecanim)|Animator (Mecanim)]]
	2. [[#유니티에서#C# 클래스로 구현하는 FSM(HFSM)|C# 클래스로 구현하는 FSM(HFSM)]]
	3. [[#유니티에서#푸시 다운 오토마타의 활용|푸시 다운 오토마타의 활용]]
3. [[#유니티에서의 활용 및 주의점|유니티에서의 활용 및 주의점]]
	1. [[#유니티에서의 활용 및 주의점#가이드|가이드]]

## 책의 내용

### 추억의 게임 만들기 & FSM이 모두를 구원하리라
- 플랫포머의 주인공을 만든다고 상상해보자. 점프도 하고 엎드리기 버튼도 한다.
- `bool isJumping`, `bool isDucking` 같은 플래그 변수로 관리한다.

- 문제 상황
	- 점프 중에 아래 키를 누르면 - 공중에서 엎드리는 현상 발생
	- `if (isJumping && !isDucking)` 같은 조건문이 생기기 시작한다.
	- 나중에 2단 점프, 다이빙 등을 추가하겠다면 코드를 모두 고쳐야 한다

- 해결책 : **유한 상태 기계(FSM)**
	- **`유한Finite` : 상태의 개수는 정해져 있다(서기, 점프, 엎드리기)**
	- **`상태State` : 캐릭터는 한 번에 1개의 상태만을 가질 수 있다.**
	- **`전이Transition` : 입력, 조건에 따라 상태가 바뀐다.** 


### 열거형Enum과 다중 선택문Switch
- 장점 : 간단하다
- 단점 : 상태가 많아지면 길어지고, 각 상태별 변수를 관리하기 어렵다.

### 상태 패턴 - 클래스로 만들기
- 책에서는 각 상태를 클래스로 만드는 것으로 접근한다.

- 인터페이스 : `handleInput()`, `update()` 메서드를 가진 `State` 인터페이스 정의
- 구현 : `JumpState, DuckState` 클래스 등이 이들을 상속받아 각자의 로직을 구현
- 위임 : 캐릭터는 `State* currentState`만 갖고, 모든 행동을 현재 상태 객체에게 넘긴다.

### 입장Enter과 퇴장Exit
- 상태가 바뀔 때 딱 1번 실행되어야 하는 로직들이 있다.
- `Enter` : 점프 상태가 될 때 - 점프 소리 재생, 점프 애니메이션 시작
- `Exit` : 엎드리기에서 나갈 때 - 히트박스 복구 등

이를 위해 `State` 인터페이스에 `enter()`, `exit()`메서드를 추ㅏ한다.

### 병행 상태 기계(Concurrent State Machine)
- 달리면서 총 쏘는 상황은 어떻게 만듦?
- 상태 1개로는 표현하기 힘들다 - `RunningAndShooting` 상태를 별도로 만들어야 할까?
- 해결 : **2개의 FSM을 동시에 돌린다** 
	- 하체 FSM : 걷기/뛰기
	- 상체 FSM : 대기/사격

### 계층형 상태 기계(Hierarchical State Machine)
- 서 있기, 걷기, 뛰기는 모두 땅 위에 있는 상태이다.
- 점프 버튼을 누르면 점프한다는 로직을 셋 다에 모두 복붙해야 하는가?
- 해결 : `OnGroundState`를 부모 클래스로 만들고 나머지가 상속받게 한다. (상속을 이용한 상태 공유.)

### 푸시 다운 오토마타(Pushdown Automata)
- **FSM은 이전 상태를 기억하지 못한다.**
- 상황 : 적이 순찰하다가 플레이어를 발견해 추적한다. 놓치면 순찰로 돌아가는데, 원래 위치를 모른다.
- 해결 : 상태를 스택에 쌓는다.
	- 추격 시작 : `Push(ChaseState)`
	- 추격 끝 : `Pop()` - 스택 아래에 있던 `PatrolState`가 다시 `Top`으로 나옴.

## 유니티에서
- 유니티에서 상태 패턴은 `C#`으로 직접 짜거나, `유니티 기능을 쓰거나Mecanim` 둘 중 하나다.

### Animator (Mecanim)
- **유니티의 `Animator Controller`는 그 자체가 시각적인 FSM이다.**
	- `State` : 네모난 박스(Idle, Run, Jump)
	- `Transition` : 화살표
	- `Concurrent` : `Layers` 기능으로 구현(Base Layer : 이동 / Upper Body : 공격)
	- `Hierarchical` : `Sub-State Machine` 기능 지원

- 이외에도 `StateMachineBehaviour`를 상속받게 해서 애니메이션 상태에 스크립트를 붙일 수 있다.
```cs
public class JumpBehaviour : StateMachineBehaviour
{
    // Enter: 상태 진입 시 1회 호출
    override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
    {
        SoundManager.Play("Jump");
    }

    // Exit: 상태 탈출 시 1회 호출
    override public void OnStateExit(...) { ... }
}
```

### C# 클래스로 구현하는 FSM(HFSM)
- 애니메이션과 상관 없는 복잡한 로직은 직접 클래스로 짠다.
- AI, 게임 진행 상태 등등.
```cs
// 인터페이스
public interface IState
{
	void Enter();
	void Update();
	void Exit();
}

// 구체적인 상태
public class JumpState: IState
{
	private Player _player;
	public JumpState(Player player) { _player = player; }
	
	public void Enter() { _player.Anim.SetTrigger("Jump"); }
	public void Update() 
	{
		if (_player.IsGrounded) _player.ChangeState(new IdleState(_player));
	}
	public void Exit()
}

// 상태 기계(Context)
public class Player : MonoBehaviour
{
	private IState _currentState;
	void Start() { ChangeState(new IdleState(this)); }
	void Update() { _currentState?.Update(); }
	public void ChangeState(IState newState)
	{
		_currentState?.Exit();
		_currentState = newState;
		_currentState.Enter();
	}
}
```

### 푸시 다운 오토마타의 활용
- 스택 기반의 FSM은 UI 매니저를 만들 때 유용하게 쓰인다.
- `Stack<UIPanel> panelStack`
- 동작
	- 메인 메뉴`Push`
	- 옵션 버튼 클릭 - 옵션 창 열기 `Push` - 메인 메뉴 위에 옵션 창이 뜸
	- 뒤로 가기 - 옵션 창 닫기 `Pop` - 메인 메뉴가 활성화됨
## 유니티에서의 활용 및 주의점

1. `Animator`에 모든 로직(공격 판정, 쿨타임 계산 등)을 넣지 말 것
- 문제점 : 애니메이션 컨트롤러가 너무 복잡해져서 스파게티 코드가 된다.
- 권장
	- 애니메이션 제어는 `Animator` 사용
	- 논리 판단은 `C# 스크립트 FSM` 사용
	- 이 둘을 동기화하는 방식이 좋다.

2. 상태 객체의 관리(메모리)
- 책은 상태 객체를 어디 둬야 할까?라는 질문을 하는데, 유니티는..
- 유니티에서는 `new State()`를 남발하지 않음 : GC가 발생함
	1) 미리 만들어 둠 : `Start`에서 `idle = new idleState();`, `jump = new JumpState()`처럼 다 만들어 둔 다음 돌려쓰기
	2) 싱글턴 / 정적 클래스 : 상태가 데이터를 갖지 않는다면 정적 인스턴스로 공유한다.

### 가이드
1. **필수 패턴 :**  캐릭터 컨트롤러 / AI를 만든다면 필수다. `if-else`가 3중첩을 넘는다면 당장 도입을 검토해보자.
2. **도구 활용** : `Animator`는 훌륭한 시각적 FSM 도구지만 로직까지 너무 많이 넣진 말자.
3. **UI는 스택으로 구현** : 메뉴 - 서브 메뉴 - 팝업 구조는 `푸시 다운 오토마타Stack`을 구현하면 뒤로 가기 기능도 바로 구현할 수 있다.
4. **라이브러리 추천** : 직접 짜기 귀찮다면 `MonsterLove FSM` 같은 검증된 무료 애셋도 있다.

