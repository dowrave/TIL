#게임프로그래밍패턴

1. [[#책 내용|책 내용]]
	1. [[#책 내용#문제 상황|문제 상황]]
	2. [[#책 내용#해결책 : 샌드박스(놀이터) 만들기|해결책 : 샌드박스(놀이터) 만들기]]
	3. [[#책 내용#자식 클래스의 구현|자식 클래스의 구현]]
2. [[#유니티에서|유니티에서]]
	1. [[#유니티에서#스킬 시스템 예제|스킬 시스템 예제]]
	2. [[#유니티에서#템플릿 메서드 패턴과의 관계|템플릿 메서드 패턴과의 관계]]
3. [[#유니티에서 사용 시 주의할 점|유니티에서 사용 시 주의할 점]]
	1. [[#유니티에서 사용 시 주의할 점#상속의 깊이|상속의 깊이]]
	2. [[#유니티에서 사용 시 주의할 점#대안|대안]]

## 책 내용

### 문제 상황
- 게임에 100가지 능력이 있다고 치자.
- 각 초능력 클래스를 직접 만들면 코드가 지저분해진다. 
```cpp
class SkyLaunch {
    void activate() {
        // 1. 소리 재생 (사운드 엔진 직접 호출)
        SoundSystem::instance().play("Launch");
        // 2. 파티클 생성 (파티클 매니저 직접 호출)
        ParticleManager::spawn("Dust", x, y, z);
        // 3. 물리 힘 적용 (물리 엔진 직접 호출)
        physics.applyForce(0, 10, 0);
    }
};
```
문제 1. 모든 초능력 클래스가 사운드, 파티클, 물리 시스템과 강하게 결합함
문제 2. 소리 재생 코드를 100번 복붙해야 함

### 해결책 : 샌드박스(놀이터) 만들기
- 부모 클래스를 만들고, 자식들이 자주 쓰는 기능을 `protected` 메서드로 만듦.
```cpp
class Superpower {
protected:
    // 자식들이 쓸 도구들 (API)
    void playSound(const char* name) { SoundSystem::instance().play(name); }
    void spawnParticle(const char* type) { ParticleManager::spawn(type, ...); }
    void move(double x, double y) { ... }

public:
    virtual void activate() = 0; // 자식은 이것만 구현하면 됨
};
```

### 자식 클래스의 구현
- 자식 클래스는 부모가 준 도구만 갖고 놀면 된다. 
```cpp
class SkyLaunch : public Superpower {
    virtual void activate() {
        playSound("Launch"); // 깔끔!
        spawnParticle("Dust");
        move(0, 10);
    }
};
```

## 유니티에서
- 스킬, 패턴을 만들 때 가장 흔하게 쓰는 도구다.

### 스킬 시스템 예제
- 부모 클래스
```cs
using UnityEngine;

public abstract class SkillBase : MonoBehaviour
{
    // 샌드박스 메서드들 (Helper Methods)
    
    // 1. 소리 재생을 쉽게
    protected void PlaySound(AudioClip clip)
    {
        AudioManager.Instance.PlayOneShot(clip);
    }

    // 2. 이펙트 생성을 쉽게
    protected void SpawnEffect(GameObject prefab, Vector3 pos)
    {
        Instantiate(prefab, pos, Quaternion.identity);
    }

    // 3. 근처 적 찾기를 쉽게
    protected List<Enemy> GetNearbyEnemies(float radius)
    {
        // 복잡한 Physics.OverlapSphere 로직을 여기에 숨김
        return EnemyManager.FindEnemies(transform.position, radius);
    }

    // 자식이 구현해야 할 핵심 로직
    public abstract void Activate();
}
```

- 자식 클래스
```cs
public class FireballSkill : SkillBase
{
    public AudioClip fireSound;
    public GameObject fireEffect;

    public override void Activate()
    {
        // 부모가 준 도구만 사용해서 로직 완성
        PlaySound(fireSound);
        SpawnEffect(fireEffect, transform.position);
        
        var enemies = GetNearbyEnemies(5f);
        foreach(var enemy in enemies) enemy.TakeDamage(10);
    }
}
```

### 템플릿 메서드 패턴과의 관계
- 이 패턴은 템플릿 메서드 패턴과 자주 함께 쓰인다.
- 부모가 전체적인 흐름을 잡고, 자식은 `Activate` 내용만 채우는 방식.

## 유니티에서 사용 시 주의할 점

### 상속의 깊이
- (뜨끔)
- **이 패턴의 치명적인 단점은 상속 지옥에 빠질 수 있다**는 것이다.
- `SkillsBase -> AttackSkill -> MagicSkill -> FireSkill -> ...`
- 부모 클래스가 비대해지고, 자식 클래스는 부모의 기능을 다 쓰지도 않는데 상속받는다.

- 유의할 점은 크게 2가지다.
1. 부모 클래스에 온갖 잡동사니 기능을 다 넣지 말 것. **정말 공통된 것만 넣자.**
2. **상속 깊이를 2~3단계 이상 깊게 가져가지 말 것.**

### 대안
- 현대 유니티 개발에선 **상속보다는 `컴포넌트`나 `C# 확장 메서드`를 선호하는 경향**이 있다.
```cs
public static class GameExtensions 
{
	public static void PlaySound(this MonoBehaviour mb, string soundName)
	{
		AudioManager.Instance.Play(soundName);
	}
}

// 사용
this.PlaySound("Boom");
```