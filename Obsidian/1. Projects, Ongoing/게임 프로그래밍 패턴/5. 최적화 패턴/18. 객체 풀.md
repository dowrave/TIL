#게임프로그래밍패턴 

1. [[#책 내용|책 내용]]
	1. [[#책 내용#문제 상황 : 메모리 단편화와 GC 스파이크|문제 상황 : 메모리 단편화와 GC 스파이크]]
	2. [[#책 내용#해결책 : 재사용하기|해결책 : 재사용하기]]
	3. [[#책 내용#풀이 부족하다면?|풀이 부족하다면?]]
2. [[#유니티에서|유니티에서]]
	1. [[#유니티에서#간단한 오브젝트 풀 구현|간단한 오브젝트 풀 구현]]
	2. [[#유니티에서#유니티 내장 풀 : `UnityEngine.Pool`|유니티 내장 풀 : `UnityEngine.Pool`]]
3. [[#유니티에서 사용 시 주의할 점|유니티에서 사용 시 주의할 점]]
	1. [[#유니티에서 사용 시 주의할 점#언제 써야 할까?|언제 써야 할까?]]
	2. [[#유니티에서 사용 시 주의할 점#OnEnable vs Start|OnEnable vs Start]]
	3. [[#유니티에서 사용 시 주의할 점#더러운 상태Dirty State 주의|더러운 상태Dirty State 주의]]
	4. [[#유니티에서 사용 시 주의할 점#요약|요약]]


- **유니티 개발을 한다면 선택이 아닌 필수 패턴.**
## 책 내용
### 문제 상황 : 메모리 단편화와 GC 스파이크
총알이 빗발치는 슈팅게임을 만든다고 하면
- 총을 쏠 때마다 `new Bullet()` - 메모리 할당
- 총알이 벽에 맞으면 `delete bullet` - 메모리 해제

이 때 발생할 수 있는 **문제점**으로
1. **메모리 단편화`Fregmentation`** : 힙 메모리에 구멍이 나서 나중에는 큰 객체를 넣을 자리가 없어짐
2. **가비지 컬렉션 스파이크`GC Spike`** : 삭제된 객체들을 위해 가비지 컬렉터가 나서는데 이때 게임이 잠깐 멈칫 한다.

### 해결책 : 재사용하기
- 쓰레기통에 버리는 게 아니라, 창고에 넣었다가 다시 쓴다.

- 준비 : 게임 시작시 총알 100개를 미리 만들어서 비활성화 후 창고`Pool`에 넣어둠
- 사용 : 총을 쏘면 창고에서 하나 꺼내서 활성화하고 위치를 초기화함
- 반납 : 총알이 사라질 때는 파괴`Destroy`가 아닌 비활성화`Disable`해서 창고에 넣음

### 풀이 부족하다면?
- 사전에 생성한 총알 100개를 모두 쓰고 있는데 또 총을 쏜다면?

1. 무시하기 - 가장 빠른 방법
2. 강제 회수 - 가장 오래된 총알을 강제로 가져와서 다시 쓴다
3. 확장 - 풀 크기를 200개로 늘린다 (순간적인 렉 발생)
## 유니티에서
- `Instantiate`, `Destroy`가 매우 무겁기 때문에 오브젝트 풀이 필수다.
### 간단한 오브젝트 풀 구현
```cs
public class ObjectPool: MonoBehaviour
{
	public GameObject prefab;
	public int poolSize = 20;
	
	// 창고 : Queue가 쓰기 편하다
	private Queue<GameObject> _pool = new Queue<GameObject>();
	
	void Start() 
	{
		for (int i = 0; i < poolSize; i++)
		{
			GameObject obj = Instantiate(prefab);
			obj.SetActive(false);
			_pool.Enqueue(obj);
		}
	}
	
	public GameObject Get() 
	{
		if (_pool.Count > 0)
		{
			GameObject obj = _pool.Deque();
			obj.SetActive(true);
			return objl
		}
		else 
		{
			// 풀이 비었을 때(주로 모두 사용 중일 때)의 정책
			return Instantiate(prefab);
		}
	}
	
	public void ReturnToPool(GameObject obj)
	{
		obj.SetActive(false);
		_pool.Enqueue(obj);
	}
}
```

### 유니티 내장 풀 : `UnityEngine.Pool`
- 유니티 2021버전부터 엔진 자체적으로 `ObjectPool<T>` 클래스를 제공한다.
```cs
using UnityEngine.Pool;

public class Gun: MonoBehaviour
{
	public GameObject bulletPrefab;
	public IObjectPool<GameObject> _pool;
	
	void Start()
	{
		// 내장 풀 생성 - 생성 함수, 가져올 때, 반납할 때, 파괴할 때 로직 등록
		_pool = new ObjectPool<GameObject>(
			createFunc: () => Instantiate(bulletPrefab),
			actionOnGet: (obj) => obj.SetActive(true),
			actionOnRelease:  (obj) => obj.SetActive(false),
			actionOnDestroy: (obj) => Destroy(obj),
			maxSize: 100
		);
	}
	
	void Fire()
	{
		GameObject bullet = _pool.Get(); // 꺼내기
		// 발사 로직
		// 반납은 _pool.Release(bullet);
	}
}

```

## 유니티에서 사용 시 주의할 점

### 언제 써야 할까?
- 필수 : 총알, 파티클 이펙트, 대미지 텍스트, 몬스터(대량 스폰), 사운드 소스
- 비추천 : 보스 몬스터, UI 팝업창, 플레이어 캐릭터
	- 자주 생성/파괴되지 않는다면 `Instantiate`도 괜찮음

### OnEnable vs Start
- 오브젝트 풀을 쓴다면 활성화/비활성화만 반복한다.
- `Start()`는 최초 생성 시 딱 1번만 실행됨에 유의할 것.
- 총알이 발사될 때마다 초기화해야 하는 로직은 `OnEnable`에 구현해야 한다.

### 더러운 상태Dirty State 주의
- 풀에서 꺼낸 객체는 중고다.
- 이전 총알이 변했다면, 다시 꺼냈을 때도 변한 상태일 수 있다.
- 따라서 꺼낼 때 반드시 색상, 체력, 속도 등을 기본값으로 초기화해줘야 한다.

### 요약
- 무조건 쓰자 - 모바일 게임에서 `Instantiate/Destroy`를 난사하면 100% 렉 걸린다.
- 내장 기능 활용 - 유니티 2021 이상이라면 `UnityEngine.Pool`을 쓰자. 안정적이고 기능이 좋다.
- 초기화 시점 - `Start()` 대신 `OnEnable()`이나 별도의 `Init()` 함수를 따로 만들어 호출할 것.
- 파티클 시스템 - 자체적인 정지 옵션이 있어서 풀링 시스템과 궁합이 맞다. 

> 참고) `Initialize()` vs `Init()`
> - 둘 다 많이 쓴다.
> - `Initialize()` : 명확하다. 초기화한다는 뜻이 분명하고, 자동 완성에서도 잘 뜬다.
> - `Init()` : 짧다. 타이핑하기 편하고 코드가 간결하다. 많은 스튜디오나 오픈소스 라이브러리에서 약어로 애용한다.
> - 어느 쪽이든 **프로젝트 내에서의 일관성이 중요**하며, **"외부에서 데이터를 주입받아 초기화할 때" 사용**한다.

