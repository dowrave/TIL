
#게임프로그래밍패턴 

1. [[#책 내용|책 내용]]
	1. [[#책 내용#문제 상황 : 불필요한 계산|문제 상황 : 불필요한 계산]]
	2. [[#책 내용#해결책 : 더러워졌다는 표기만 해두기|해결책 : 더러워졌다는 표기만 해두기]]
	3. [[#책 내용#장점|장점]]
2. [[#유니티에서|유니티에서]]
	1. [[#유니티에서#Transform 시스템|Transform 시스템]]
	2. [[#유니티에서#UI 레이아웃(Canvas)|UI 레이아웃(Canvas)]]
	3. [[#유니티에서#직접 구현하는 예제(스탯 계산)|직접 구현하는 예제(스탯 계산)]]
3. [[#유니티에서 사용 시 주의할 점|유니티에서 사용 시 주의할 점]]
	1. [[#유니티에서 사용 시 주의할 점#Update vs Event|Update vs Event]]
	2. [[#유니티에서 사용 시 주의할 점#주의점 - 너무 게으르면 안 된다|주의점 - 너무 게으르면 안 된다]]
	3. [[#유니티에서 사용 시 주의할 점#요약 - 개발자를 위한 가이드|요약 - 개발자를 위한 가이드]]


## 책 내용

### 문제 상황 : 불필요한 계산
해적선 게임을 만든다고 하자. 배 위에 돛대, 돛대 위에 깃발이, 깃발 위에 앵무새가 있는 계층 구조를 갖는다.
배가 움직이면 돛대, 깃발, 앵무새가 모두 움직여야 한다.

- 나쁜 접근
```cpp
void Parrot::update() {
    // 매 프레임마다 배의 위치부터 앵무새 위치까지 싹 다 다시 계산함.
    // 배가 가만히 있어도 계속 계산함. (낭비)
    recalculateWorldPosition(); 
}
```

### 해결책 : 더러워졌다는 표기만 해두기
- **값이 바뀌었을 때 바로 계산하지 않고, "나 바뀌었다!!!"는 깃발만 들어올린다.**
- 정말 값이 필요할 때(=누가 물어볼 때) 깃발을 확인하고 계산한다.

1. 변경 시 - `isDirty = true` (표시만)
2. 요청 시 
	- `if (isDirty)` -> 계산 후 `isDirty = false`로 전환한 다음, 값 리턴
	- `else` -> 저장해둔 값(캐시) 바로 리턴

### 장점
- **불필요한 연산 제거** : 값이 100번 바뀌었더라도 아무도 안 물어보면 계산을 한 번도 안 한다.
- **몰아서 처리** : 값이 100번 바뀌고 나서 물어보면, 마지막의 1번만 계산하면 된다.
## 유니티에서
- 직접 패턴을 구현하기도 하고 엔진의 긴으을 통해 간접적으로 사용하기도 한다.

### Transform 시스템
- `transform.position`이 더티 플래그 패턴의 대표적인 예시다.
1. 부모 오브젝트를 옮기면 자식 오브젝트의 월드 좌표를 즉시 계산하지 않음
2. 대신 자식 오브젝트들에겐 더티 플래그만 켜둠
3. 나중에 자식의 `transform.position`을 읽으려고 할 때, 행렬 곱셈을 해서 좌표를 계산함

> 참고) 렌더링 : 위치값을 물어보는 행위이므로 렌더링 중이라면 더티 플래그가 거의 바로 해제된다. 


### UI 레이아웃(Canvas)
- 유니티 UI(UGUI)도 더티 플래그 덩어리다.
- `SetDirty()` : 텍스트 내용을 바꾸거나 크기를 바꾸면 레이아웃 시스템에 다시 그려야 된다고 알린다.
- 프레임 끝에 캔버스가 더티 플래그가 켜진 요소들만 다시 그린다.


### 직접 구현하는 예제(스탯 계산)

```cs
public class CharacterStats : MonoBehaviour 
{
	private int _baseDamage = 10;
	private int _weaponDamge = 5;
	
	// 캐싱된 값 - 매번 계산하기 싫어서 저장해둠
	private int _cachedTotalDamage;
	
	// 더티 플래그
	private bool _isDirty = true;
	
	public void EquipWeapon(int damage)
	{
		_weaponDamage = damage;
		_isDirty  = true; // 무기가 바뀌었으니 나중에 다시 계산하라는 의미
	}
	
	public int GetTotalDamage() 
	{
		if (_isDirty)
		{
			_cachedTotalDamage = _baseDamage + _weaponDamage;
			_isDirty = false;
			Debug.Log("공격력 재계산됨!");
		}
		
		// 깨끗하면 저장값 바로 리턴, 더러우면 계산 후 리턴
		return _cachedTotalDamage;
	}
}
```
> 이렇게 구현할 경우 `GetTotalDamage()`가 매번 호출되어도 실제로 무기가 바뀌지 않는 한 연산 비용은 0에 가깝다. (함수 호출 비용은 물론 있겠지만.)
## 유니티에서 사용 시 주의할 점

### Update vs Event
-  더티 플래그 패턴은 폴링(Polling, 계속 물어보기)보다는 이벤트 방식과 결합했을 때 더 강력하다.
	- 값이 바뀔 때 `OnValueChanged` 이벤트를 날려서 `isDirty = true`로 만드는 식.

### 주의점 - 너무 게으르면 안 된다
- 더티 플래그 처리에 시간이 너무 오래 걸리면(ex : 맵 전체 다시 그리기) 프레임 드랍이 발생할 수 있다.
- 이럴 때는 한 프레임에 다 하지 말고, 조금씩 나눠서`Time Scaling` 처리하는 기법과 섞어 써야 한다.

### 요약 - 개발자를 위한 가이드
- 최적화의 첫걸음 : **무거운 계산이 있다면 무조건 더티 플래그를 고려**하자.
- UI 최적화 : `Canvas.ForceUpdateCanvases()` 같은 함수는 강제로 더티 플래그를 처리하게 만드는 무거운 함수이므로 남발하지 말자.
- **Transform** : 유니티 `Transform` 계층 구조가 너무 깊으면 더티 플래그 전파 비용으로 인해 성능이 떨어질 수 있다. 계층 구조는 적당히 평평하게 유지하는 게 좋다. 
