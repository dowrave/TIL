- 26년 1월부터는 날짜별로 마크다운(옵시디언) 파일을 따로 만들어서 정리 중
## 개요

>[!note]
>
>  **"흐름"으로 설명하는 것 외에도 "원리"도 곁들이면 좋다**
> - 지금은 "어떤 이슈가 발생해서 어떻게 해결했더라"로 정리했다면
> - 추가로 **이슈가 '왜' 발생했는지**까지 정리해두면 나중에 볼 때 다시 헷갈리지 않을 수 있음
> 
> 모든 코드를 일일이 기억하는 건 불가능함! 나중에 봤을 때 '이러면 되겠다'는 감이 바로 잡히도록 메모해보자.

>[!objective]
>- 프로젝트가 계속 늘어지는 관계로 완료 기준을 정해놓기로 한다.
>- [[프로젝트 완료 기준에 대해]]
> 	- 소리 추가(BGM 2~3개 + SFX 5개 정도? 링크 참조)
> 	- 1-3 스테이지 구현 및 밸런스 조정
> 	- 진행에 치명적인 버그 수정
> - 완료 후에는 프로젝트에 관한 글도 적어두면 좋을 듯
> 	- 무엇을 구현했는지
> 	- 왜 늘어졌는지 등등

>[!plan]
>- (진행 중)`UnitEntity` 리팩토링 : `God Class` -> `퍼서드Facade` 패턴
>1. 스테이지 밸런싱 진행하면서
>2. 경로 로직 관련 현재 간헐적으로 발생하는 이슈들 보이면 처리
>	- 경로가 막혔을 때 바리케이드를 제거하지 않고 그대로 지나가는 현상
>	- 경로가 바뀔 때 살짝 뒤로 빼는 현상. 
>		- 최단 경로를 찾기 때문에 뒤로 빼는 현상이 나오면 안됨.

>[!issue]
> 간헐적인 이슈들
> - 적이 이미 사라졌는데 계속 해당 위치를 공격하는 현상
> - `ArcaneFieldSkill` : 스킬을 썼음에도 효과가 제대로 적용되지 않는 현상
> 	- 위치가 애매하게 걸쳐지는 경우가 있나? 의심은 있는데 상황을 재현하기 어려움
> - `Enemy`가 사라질 때 풀 태그의 키가 없다는 오류 

## 현재 이슈

- `PathNavigator`의 구현 관련 
	- `Enemy`나 `PathIndicator`에 구현된 필드가 너무 많아서 굳이 서브 컴포넌트로 빼둔 의미를 잘 못 느끼겠음
- `CombatController`
	- 적군 구현 필요
- `Sniper`의 투사체에 맞고 `Enemy`가 저 멀리 날아가버리는 현상 발생
- `UnitEntity.ExecuteSkillSequence`을 `SkillController`에 통합하기
- `ArcaneField` 관련
	- 외부에서 적이 범위에 진입할 때 부딪힌 듯 반대로 날아가버리는 현상
	- 스킬이 꺼질 때 적이 멈추는 현상

## 일지

## 260114
>[!done]
>- 버그 해결
>	- `Operator`가 죽었는데 `Enemy`가 움직이지 않고 멈추는 현상
>	- 범위 스킬이 실행되지 않는 현상
>	- `ArcaneFieldSkill` 등, 스킬을 켰을 때 평타가 나가면 안되는데 나가는 현상
### `Operator`가 죽었을 때 `Enemy`가 멈춤
>[!question]
>"자신을 공격하는 엔티티들"이라는 리스트를 관리할 필요가 있나?
- 기존에 사용한 방식 : **객체가 사라질 때 자신을 공격하는 적들에게 자신이 사라졌음을 알림**
- 단순히 공격하는 입장에서 타겟을 선정할 때 "현재 타겟이 비활성화되었다면 null 처리"하는 것만으로 충분하지 않을까?

- 일반적으로 **폴링(매 프레임 유효성 체크) + 알리는 방식을 함께 사용**한다고 함 
- ~~근데 지금 내 상황에서 필요한 것 같지는 않아서 제외함~~
	- ~~`SetCurrentTarget`에서 계속 타겟 체크를 하고 있기도 하고, 코드가 복잡해보이기도 하다.~~

- 타겟의 유효성 체크는 확실히 해둬야 한다.
- 체력이 다했을 때 `IsDead` 플래그를 쓰는 방식도 있고
- 활성화 여부로만 점검한다면 `activeInHierarchy`를 씀
```cs
if (target != null && target.gameObject.activeInHierarchy)
```

- **그냥 `attackingEntites`을 유지하기로 함** 
	- 공격 대상에서 제외하기, 저지 대상에서 제외하기 등등 **한꺼번에 처리될 요소들이 있기 때문에 유지하는 게 더 나은 것 같음**

>[!done]
>- 해결 : 유닛이 사라졌을 때 `blockingOperator`을 해제하지 않아서 발생한 이슈

---
### 범위 스킬이 실행되지 않는 현상
- `ArcaneFieldSkill`, `MeteorSkill` 등등
- 기존의 `Skill.Activate` 대신 `OnSkillActivated, OnUpdate, OnSkillEnd`을 구현
- 일단 `Activate`로 실행되던 것들의 잔재가 남아 있어서 이것부터 수정함

- 저 3개의 메서드를 사용하는 구조는 `BaseSkill`로 옮겼다.

#### 제네릭 패턴으로 구현하기

>[!question]-
>- `OnUpdate(UnitEntity)`를 부모에서 구현했는데 자식 클래스에선 `OnUpdate(Operator)`로 구현하고 싶다면 어떤 식으로 코드를 짜야 하는지 궁금해짐 

- 기존엔 이런 방식을 썼음
```cs
// 스킬 시작 시에 적용되는 효과
public virtual void OnSkillActivated(UnitEntity caster)
{
	// 예: 버프 적용, 공격력 증가, 특수 공격 등
}

// 상속받는 자식은 OnSkillActivate(UnitEntity)를 오버라이드 하고, 이를 OnSkillActivate(Operator)에 전달하는 식
```
> **오버라이드 + 타입 캐스팅(형 변환)인데, 너무 귀찮고 늘어짐**

>[!check]
>**제네릭 구조**라는 게 있습니다
>- 있다는 건 아는데 왠지 손이 안 간다. 알아두면 많이 쓸 것 같긴 한데.

```cs
public abstract class Skill<TCaster> : ScriptableObject where TCaster: UnitEntity
{
	public abstract void Execute(Tcaster caster);
}

public class OperatorSkill: Skill<Operator> 
{
	public override Execute(Operator caster) 
	{
		// 구체적인 구현
	}
}
```
> `TCaster`는 `UnitEntity`를 상속받는 모든 객체에 쓸 수 있다. 

- 추가로 1번째 상속받는 `OperatorSkill: BaseSkill` 같은 경우만 `OperatorSkill: BaseSkill<Operator>`로 처리해주면 됨

#### virtual vs abstract

>[!question]
>- `OnSkillActivated`, `OnUpdate`, `OnSkillEnd` 
>- `virtual`로 구현하기 vs `abstract`로 구현하기
>>[!answer]
>> - **`virtual`을 추천**
>> - `abstract`는 모든 자식이 모든 메서드를 구현해야 하므로 번거롭다.
>> - "일부만 사용한다"는 개념이 많다면 `virtual`이 낫다. 

#### 현재 상황
- 일부 스킬은 써지고`MeteorSkill, SlashSkill` 일부 스킬은 안 써짐`ArcaneFieldSkill`
- 써지는 스킬도 재사용이 안되는 듯`MeteorSkill`

- `ArcaneFieldSkill` 
- [x] 스킬이 써지지 않는 문제
	- `DurationVFXPrefab`이 없는 경우에는 `PlayDurationVFX`이 실행되지 않아야 함
- [ ] 스킬 범위에 진입하는 적이 진행 반대 방향으로 날아가는 현상
- [x] 스킬을 켰을 때 평타가 나가는 현상
	- 공격이 변경되는 로직은 이전에 `Buff`를 구현하면서 `Buff`로 이동되었음
	- `CannotAttackBuff`라는 개념으로 버프에 추가되고 있음
		- 완전히 잊고 있었다;;
	- 그리고 버프에서는 `PerformChangedAttackAction()`이라는 이름으로 동작함

- `OpAttackController.PerformAction`에 buff들 중 공격이 바뀌는 동작부터 검사함
```cs
public override void PerformAction(UnitEntity target, float damage)
{
	// 공격이 나가는 시점에 쿨타임이 돌게 수정
	// 공격을 하든 변조되든 턴을 소모하는 점에서 동일하게 취급(수정 가능)
	SetActionDuration();
	SetActionCooldown();

	// 1. 공격이 바뀌는 버프가 있는지 검사, 있다면 해당 액션이 나감
	var modifyBuff = _owner.ActiveBuffs.FirstOrDefault(b => b.ModifiesAttackAction);
	if (modifyBuff != null)
	{
		modifyBuff.PerformChangedAttackAction(_owner);
		return; 
	}

	// 2. 변경 사항이 없다면 기존 로직 수행
	bool showDamagePopup = false;
	float polishedDamage = Mathf.Floor(damage);
	PerformAttack(target, polishedDamage, showDamagePopup);
}
```
> - 추가로 `PerformChangedAction`으로 이름 수정 & `UnitEntity target`도 받도록 수정
> - 공격을 하지 않으면 `target`을 받더라도 사용하지 않으면 그만임

- 쿨타임 도는 부분이랑 버프로 다른 모션이 나가는 과정은 부모 클래스로 뺐음

- `PerformAction`이랑 `PerformActualAction`을 분리
	- `PerformAction`은 쿨타임 설정 + 버프 검사 후 다른 공격이 나가야 하는 경우 다른 공격이 나가도록 설정
	- `PerformActualAction`은 각 컨트롤러가 기본적으로 수행하는 동작
	- 왜 구분함? - `DualBladeAttackController`처럼 실제 공격 쿨다운이 아닌, 자체 공격 간격을 갖는 2타가 나가는 경우 **"공격 동작 자체"만 분리할 필요가 있음**
```cs
    public override bool PerformAction(UnitEntity target, float value, bool showPopup = false)
    {
        if (base.PerformAction(target, value, showPopup))
        {
            float polishedDamage = Mathf.Floor(value);
            _owner.StartCoroutine(DoubleAttackCoroutine(target, polishedDamage));
        }
        return true;
    }
    
	private IEnumerator DoubleAttackCoroutine(UnitEntity target, float damage)
{
	float polishedDamage = Mathf.Floor(damage);
	Vector3 targetPos = target != null ? target.transform.position : _owner.transform.position;

	// 1타 (부모의 기본 공격 로직 활용)
	base.PerformActualAction(target, polishedDamage);

	yield return new WaitForSeconds(_delayBetweenAttacks);

	// 2타
	if (target != null && target.Health.CurrentHealth > 0)
	{
		base.PerformActualAction(target, polishedDamage);
	}
	else
	{
		// 타겟 사망 시 헛스윙 처리 (이펙트만 재생)
		// PlayMeleeAttackEffect 등도 접근 가능해야 함
		AttackSource missSource = new AttackSource(
			attacker: _owner, 
			position: _owner.transform.position, 
			damage: 0, 
			type: _owner.AttackType, 
			isProjectile: false, 
			hitEffectTag: null, 
			showDamagePopup: false
		);
		
		// _owner를 통해 이펙트 재생 (Operator에 public 메서드로 열려있다면)
		_owner.PlayMeleeAttackEffect(targetPos, missSource);
	}
}
```
> `PerformActualAction`은 건드리지 않아서 기본 평타 동작을 수행

일단 **평타 나가는 건 수정 완료**

---
