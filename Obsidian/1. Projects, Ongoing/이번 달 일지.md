
## 개요

>[!note]
>
>  **"흐름"으로 설명하는 것 외에도 "원리"도 곁들이면 좋다**
> - 지금은 "어떤 이슈가 발생해서 어떻게 해결했더라"로 정리했다면
> - 추가로 **이슈가 '왜' 발생했는지**까지 정리해두면 나중에 볼 때 다시 헷갈리지 않을 수 있음
> 
> 모든 코드를 일일이 기억하는 건 불가능함! 나중에 봤을 때 '이러면 되겠다'는 감이 바로 잡히도록 메모해보자.

>[!objective]
>- 프로젝트가 계속 늘어지는 관계로 완료 기준을 정해놓기로 한다.
>- [[프로젝트 완료 기준에 대해]]
> 	- 소리 추가(BGM 2~3개 + SFX 5개 정도? 링크 참조)
> 	- 1-3 스테이지 구현 및 밸런스 조정
> 	- 진행에 치명적인 버그 수정
> - 완료 후에는 프로젝트에 관한 글도 적어두면 좋을 듯
> 	- 무엇을 구현했는지
> 	- 왜 늘어졌는지 등등

>[!wip]
>0. `UnitEntity` 관련 리팩토링 시작 : 모놀로직 -> 기능을 컴포넌트 단위로 분리
>1. 스테이지 밸런싱 진행하면서 
>2. 경로 로직 관련 현재 간헐적으로 발생하는 이슈들 보이면 처리
>	- 경로가 막혔을 때 바리케이드를 제거하지 않고 그대로 지나가는 현상
>	- 경로가 바뀔 때 살짝 뒤로 빼는 현상. 
>		- 최단 경로를 찾기 때문에 뒤로 빼는 현상이 나오면 안됨.

>[!issue]
> 간헐적인 이슈들
> - 적이 이미 사라졌는데 계속 해당 위치를 공격하는 현상
> - `ArcaneFieldSkill` : 스킬을 썼음에도 효과가 제대로 적용되지 않는 현상
> 	- 위치가 애매하게 걸쳐지는 경우가 있나? 의심은 있는데 상황을 재현하기 어려움
> - `Enemy`가 사라질 때 풀 태그의 키가 없다는 오류 

## 현재 이슈
- `260108` 작업 후
	- `PathNavigator`의 구현 관련 
		- `Enemy`나 `PathIndicator`에 구현된 필드가 너무 많아서 굳이 서브 컴포넌트로 빼둔 의미를 잘 못 느끼겠음
	- `CombatController`
		- 아군, 적군 모두
	- `SkillController`
	- `Sniper`의 투사체에 맞고 `Enemy`가 저 멀리 날아가버리는 현상이 발생했음

## 일지

## 260109 
>[!wip]
>- `Operator` 기능 분리 시작(기존 코드가 1000줄 정도)
>	- `OperatorAttackController`부터 작업

### OperatorAttackController 작업
- 공격 대상 선정 및 공격에 대한 구현이 들어감
- 스킬은 별도로 구현

#### `MonoBehaviour`로 구현하기 vs 일반 C# 클래스로 구현하기
- `MonoBehaviour`로 구현하는 게 좋은 상황
	- `Unity` 이벤트 사이클이 필요할 떄
	- 코루틴을 직접 돌려야 할 때(스스로 관리하는 게 편할 때)
	- 물리적인 위치/컴포넌트가 중요한 상황일 때
		- 발사 위치 Transform이나 Collider가 필요한 상황 등
	- 에디터 디버깅 / 설정이 필요할 때
- 일반 C# 이 좋은 상황
	- 순수 데이터 처리 로직일 때
	- Update을 자체적으로 돌릴 필요 없이 부모에서 호출해주면 될 때
	- 여러 개를 리스트로 관리해야 할 때
	- 가벼워야 할 때

기존 `Operator.Update` 로직의 거의 대부분이 `AttackController`에 넣을 수 있는 요소라서 고민을 좀 했다. `UnitEntity`에서도 `Collider`나 `Visual`은 `MonoBehaviour`을 상속받게 하는 식으로 구현되었는데, 코루틴을 직접 돌리거나 유니티 컴포넌트를 직접 제어하는 상황이기 때문에 그렇게 구현된 것이다. 

`OperatorAttackController`는 그냥 C#으로 해도 될 듯?

여기에 정리는 못하고 있는데 이것저것 하고 있다. **뇌가 아픈!**
- **`MedicOperator`을 없애는 게 가능할 수도 있겠다.** `AttackController`가 아니라 `ActionController`라는 공통 인터페이스를 만들고, 이를 상속하는 별개의 클래스 2개를 만드는 방식임
	1. `MedicOperator`을 없앰
	2. `OperatorAttackController`을 `OperatorActionController`이라는 공통 조상의 자식으로 뒀음. `OperatorHealController`도 `ActionController`의 자식으로 별도로 구현.
	3. `DualBlade`도 `DualbladeOpereator` 스크립트를 없애고 `OperatorAttackController`의 자식으로 `DualbladeController`을 별도로 구현했다.


- SP도 연결해야 하고 저지도 구현해야 하고 할 게 많다.
- 오늘 한 거 테스트도 못해봤음;

컴파일상의 오류만 다 없애놨다. 일단 오늘은 여기까지. 밤 12시 반이 넘어가고 있다.


## 260108

>[!done]
>- `Retreat`의 배치 코스트 회복 로직 동작하지 않는 현상 수정
>	- 이벤트 스태틱 기반으로 변경
>- `Operator.Deploy(), Undeploy()` 수정
>- 배운 것
>	- 세터 메서드는 컨트롤러를 외부에 노출하지 않는 게 목적이지 컨테이너의 메서드는 외부에 노출되어도 무방(꽁꽁 감싸는 거라면 다른 방법도 있지만 굳이 그렇게까지?)
>	- 여러 컨트롤러에서 사용할 메서드라면 컨테이너에서 상태를 갖고 있는 것도 방법
### Operator.Deploy() 
- 이후에 `CombatController`로 구현할 부분들은 빼고 거의 구현한 듯
### Retreat 이슈
- `Retreat` 시에 초기 배치 코스트의 절반이 회수되지 않는 현상
	- `_deploy`에 의해 동작하는 `HandleDeploymentInternal()`을 추적해봤는데 아예 동작하지 않음
	- 그러면 `Operator.Deploy()`가 문제인가? `Undeploy()`할 때 서순이 문제인가?

```cs
public void Undeploy()
{
	IsDeployed = false;
	OnUndeployed?.Invoke(_owner);

	// 이거 안에서 _owner 퇴각 시에 동작하는 이벤트가 있음
	DeployableManager.Instance!.OnDeployableRemoved(_owner);
	if (CurrentTile != null)
	{
		CurrentTile.ClearOccupied();
	}
}
```

```cs
// OnDeployableRemoved 중 일부

if (deployable is Operator op)
{
	CurrentOperatorDeploymentCount--;
	InstanceValidator.ValidateInstance(op.OperatorData);
	// op.OnRetreat -= HandleOperatorRetreat;
	Logger.Log($"{op.gameObject.name}의 OnTreat 이벤트에 HandleOperatorRetreat 메서드 해제됨");

	info = GetDeployableInfoByName(op.OperatorData?.EntityID!);
}
```
> - `Operator`의 경우 `OnDeployableRemoved`에서 해당 객체에 대한 구독 해제 ->  이벤트 발생 의 순서를 가지기 때문에 메서드가 동작하지 않았던 것으로 보임

- `DeployableUnitEntity`의 `Deploy`나 `Undeploy` 구현은 잘 된 것 같은데(?), `Operator`에서의 처리 과정이 문제이기 때문에 이 부분을 만져봄
- `DeployableManager`에서 **`DeployableUnitEntity` 관련 이벤트들은 전부 스태틱**으로 다룸
	- 게임 씬 내내 동작할 요소이기 때문. 객체 하나하나의 추적 - 해제를 반복하는 것보다 클래스의 이벤트 자체를 계속 구독하는 방식이 더 관리하기 편하다.
	- 씬 전환 때에 유지되지 않게 하는 것만 신경쓰면 됨. `OnDisable`에 해제 메서드 달아둠.

- 이 부분은 2개로 해결
1. `OnRetreat`을 스태틱으로 구현, `DeployableUnitEntity` 전체에 대해 `DeployableManager`가 추적함
2. 싱글턴 간의 메서드 호출은 굳이 이벤트로 하지 않고 직접 호출함

> - 저 메서드 호출 부분은 "퇴각을 하면 코스트가 회복된다"라는 게임 로직과 직접적으로 연관된 부분이기 때문에 결합도를 신경쓰지 않고 바로 연결하는 편이 나은 듯. 훨씬 직관적이기하고.

#### 구조 생각

>[!question]
>- 지금처럼 컨테이너 + 컨트롤러 방식의 구현을 할 때 이벤트 발생을 어떻게 처리해야 할까?
>- 예를 들어서 지금의 `OnDeploy`, `OnUndeploy` 등의 이벤트는 외부 매니저에서 알아야 하는 요소임
>- 그러면 외부에서 이벤트를 구독할 때에는 "어떤 객체의 컨트롤러의 이벤트"까지 알아야 하는 걸까? 아니면 중간에 "어떤 객체의 이벤트" 정도로만 통합해서 써야 할까?
>1. 컨트롤러의 이벤트를 컨테이너에서 다시 구현하는 건 늘어질 우려가 있다고 생각함.
>2. 그렇다고 컨트롤러의 이벤트로만 남겨둔다? 

- 일반적으로 권장되는 구조는 `컨트롤러 -> (이벤트) -> 컨테이너 -> (이벤트) -> 외부`의 구조임. 
- 컨트롤러의 이벤트를 감추고 싶다면 단순히 컨트롤러의 읽기 전용 인터페이스에 이벤트를 노출시키지 않는 것만으로 충분함
##### 지식이 늘었다 - public class는 캐스팅으로 세터 클래스로도 접근할 수 있음
- 물론 취약점은 있다. `public class`로 구현하는 이상, `IReadableOOO`로 구현했더라도 캐스팅을 하면 접근이 가능하기 때문임
	- `GetComponent`로도 접근 가능함
```cs
IReadableController Deployment = target.Deploy;
Controller _deployment = Deployment as Controller;
```
> 이런 방식으로 `Controller`라는, 외부에 숨기려고 했던 클래스에 접근하는 것 자체는 가능하다.

정말 외부에서 알지 못하게 하려면 `public class` 대신 `internal class`로 구현해야 함
- 어셈블리가 달라지기 때문에 캐스팅이나 `GetComponent`이 불가능해져서 물리적으로 접근이 차단된다.
	- 이건 대형 프로젝트에서 많이 쓴다고 함

**위 예시는 말 그대로 "지식이 늘었다" 수준이라서 내 프로젝트에 적용될 얘기는 아니다.   
일반적인 경우 개발자 간의 약속이 되어 있다면 충분하다.(컨벤션)** 


>[!note]
>- 구조 자체는 `컨트롤러 -> 이벤트 -> 컨테이너 -> 이벤트 -> 외부` 같은 식으로 만듦
>- 하지만 `컨트롤러 - 컨테이너`의 경우, 이벤트로 구현할 필요가 없다고 생각되면 **정상 동작만 확인하도록 `bool`을 반환하는 메서드를 만들어도 될 듯**
>	- 이벤트로 컨트롤러 - 컨테이너 간의 상호작용을 처리하는 방식이 결합성 면에선 좋을 것 같은데, 너무 복잡해지고 여러 컨트롤러가 동작하는 상황이라면 더 머리가 아파서..
>	- **반드시 피해야 할 상황이 하나 있다면, 컨트롤러에서 컨테이너의 메서드를 아는 것**이다. 위 -> 아래는 상관이 없는데 아래 -> 위는 결합도가 높아지므로 별로임
>- **관련 메서드가 모두 정상적으로 작동했는가의 체크는 `컨테이너`에서 담당**을 해줘야 할 것 같다. 이걸 원칙으로 생각하고 작업해봄. 




## 260107

>[!done]
>1. 이슈 수정 
>	- (어제 것) 하단 `box` 클릭 시 `DeployableUnitEntity.IsDeployed` 초기화 문제
>	- `Deploy()` 동작하지 않는 문제
>2. 구조 수정
>	- `Onclick()`에서 배치된 유닛을 클릭했을 때의 동작 처리를 이벤트 기반으로 변경


### 이슈 수정

- 어제 이슈 ) 하단 Box 클릭 시 `DeployableUnitEntity.IsDeployed` 초기화 문제
	- 이걸 호출하는 메서드에서 `DeployableUnitEntity`를 호출하는 것 자체가 문제였다. 해당 파라미터는 `nullable`이기 때문에 그 부분만 제거해줌
	- 해당 메서드의 `deployable` 파라미터도 `deployedDeployable`로 수정해서 더 알아보 쉽게 처리

- `Deploy()`가 동작하지 않음
	- `_collider`가 `null`로 처리되어 있는데, 필드 옮기는 과정에서 초기화되어버린 듯;
	- 다시 인스펙터에서 일일이 할당해준다

- `Retreat()` 시에 초기 배치 코스트의 절반이 회수되지 않음
	- 경로를 따라가봤는데 OnRetreat?.Invoke()가 동작이 되는데 정작 저 이벤트를 구독하는 메서드가 동작하지 않음?
	- **이건 내일 해야겠다.**

### 구조 수정
- `DeploymentController.OnClick()` 관련
```cs
public void OnClick()
{
	float preventInteractingTime = 0.1f;

	// 커서를 뗀 시점에 다시 클릭되는 현상 방지
	if (Time.time - _lastDeployTime < preventInteractingTime)
	{
		DeployableManager.Instance!.CancelPlacement();
		return;
	}

	// 배치된 유닛 클릭
	if (IsDeployed &&
		!IsPreviewMode &&
		StageManager.Instance!.CurrentGameState == GameState.Battle
		)
	{
		DeployableManager.Instance!.CancelPlacement();

		if (IsPreviewMode == false)
		{
			DeploymentInputHandler.Instance!.SetIsSelectingDeployedUnit(true);
			StageManager.Instance!.SlowState = true;
			StageUIManager.Instance!.ShowDeployedInfo(_owner);
			ShowActionUI();
		}
	}
}
```
> 여기서 "배치된 유닛 클릭" 부분은 전부 이벤트로 처리하는 게 좋아보인다. 앞으로 기능이 계속 추가되어야 하기 때문

#### 수정 방향
1. 컨테이너 클래스
```cs
public static event Action<DeployableUnitEntity> OnDeployableSelected = delegate { };

// 클릭됐을 때 실행시킬 메서드 - 브릿지 역할
public virtual void OnClick()
{
	_deployment.OnClick();
}

// DeploymentController.OnClick에 의해 실행되는 메서드
public void NotifySelected()
{
	OnDeployableSelected?.Invoke(this);
}
```

2. 배치 컨트롤러
```cs
public void OnClick()
{
	float preventInteractingTime = 0.1f;

	// 커서를 뗀 시점에 다시 클릭되는 현상 방지
	if (Time.time - _lastDeployTime < preventInteractingTime)
	{
		DeployableManager.Instance!.CancelPlacement();
		return;
	}

	// 배치된 유닛 클릭
	if (IsDeployed &&
		!IsPreviewMode &&
		StageManager.Instance!.CurrentGameState == GameState.Battle)
	{
		DeployableManager.Instance!.CancelPlacement();

		if (IsPreviewMode == false)
		{
			_owner.NotifySelected();
			// DeploymentInputHandler.Instance!.SetIsSelectingDeployedUnit(true);
			// StageManager.Instance!.SlowState = true;
			// StageUIManager.Instance!.ShowDeployedInfo(_owner);
			// DeployableManager.Instance!.ShowActionUI(_owner);
			// StageUIManager.Instance!.ShowDeployedInfo(_owner);
		}
	}
}
```
> 재클릭 방지 로직도 이벤트를 구분하는 식으로 포함할 수 있을 것 같긴 한데 일단 보류

3. 위에서 주석처리한 클래스들에 다 이벤트 구독해주면 됨
	- 지금 보니까 심지어 메서드 하나는 중복이었네 ㅋㅋㅋㅋ



## 260106

> [!done]
> - `DeploymentController` 구현
> 	- 기능 테스트중 에러 확인, 오늘 못 고쳐서 "현재 이슈" 탭으로 빼둠
### DeploymentController 구현
- `DeployableUnitEntity`부터 들어가는 배치 로직 관련 기능을 분리함

#### 1. 초기화 방법 : Initialize vs 클래스 생성자
- 오브젝트 풀링을 쓴다면 유닛이 계속 재활용되는 방식이다.
- 이런 경우 서브 클래스들은 아래처럼 구현하는 게 좋음
	1. `Awake()`에서 생성
	2. `Initialize()`에서 상태만 초기화해서 재활용(클래스를 새로 만들지 않음)

> 이유) 클래스가 계속 생성되면 이전의 클래스는 가비지가 되기 때문이다. 가비지 콜렉션의 발생을 최소화하는 게 중요함.

#### 2. readonly
- C#에서 `readonly`가 붙은 필드는 단 두 곳에서만 값을 할당할 수 있다.
	1. 변수 선언 시점
	2. 생성자 내부
- 그래서 `_owner`는 `readonly`가 가능하지만 `_data`는 `readonly`가 불가능하다. `Awake`에서 실행되는 생성자와 달리, `Initialize()`라는 별도의 메서드에서 할당되어야 하므로 `readonly`에 할당하는 타이밍보다 늦다고 봐야함

#### 3. Deploy()
```cs
public virtual void Deploy(Vector3 position)
{
	if (!IsDeployed)
	{
		_deployment.Deploy(position);
		SetDeployState(true);
		SetColliderState(true); 


		UpdateCurrentTile();
		if (CurrentTile != null)
		{
			CurrentTile.SetOccupied(this);
		}
		SetPosition(position);

		lastDeployTime = Time.time;

		OnDeployed?.Invoke(this);
	}
}
```
> `_deployment.Deploy()`로 옮기기 전의 생각
> - 일단 메서드 자체는 `DeployableUnitEntity`에 남기는 게 맞음 : 콜라이더의 동작도 포함되어 있기 때문이다.
> - 질문
> 1. `CurrentTile`을 직접 호출하는 게 맞는가? 이벤트만 발생시키고 타일이 구독하는 방식은?
> 2. `SetPosition`이 `_deployment` 내부로 들어가는 게 맞나? 위치를 변경하는 로직의 위치는 어디여야 하는가?
> 3. `lastDeployTime`도 애매해보이긴 하는데 그래도 위에 남는 게 맞겠지?

제미나이에게 물어보니
1. 이벤트보다는 직접 호출을 추천
	- **게임의 핵심 상태를 변경하는 로직은 이벤트보다 직접 호출이 안전**하다.
	1.  순서가 보장됨 
		- `Deploy()` 이후에 즉시 타일은 점유된 상태가 되어야 한다. 
		- 이벤트는 구독자에 따라 실행 순서가 모호해지거나 디버깅 시 추적이 어려울 수 있음
	2. 트랜잭션
		- 배치됨 + 타일 점유는 하나의 세트이다. 
		- 배치가 됐지만 타일 점유 코드가 리스너 누락으로 실행되지 않는다면 로직이 꼬인다.
	- 이벤트 사용 예시
		- UI 갱신
		- 이펙트 재생
		- 업적 달성
		- 사운드 재생 
2. `SetPosition`은 좌표 옮기기 + 타일 근처 특정 위치로 스냅하는 기능이 포함됨
	- "어디로 가야 하는가?"는 `Controller`가 작업
	- "실제로 이동한다"는 `Entity`가 작업
	- **`Controller` 내부에서 `_owner.transform.position`을 변경시켜도 무방하다.** `Entity`를 호출해서 위치를 바꾸는 건 함수만 복잡해진다.
3. `lastDeployTime`
	- 컨트롤러가 직접 관리하는 게 맞다. 배치라는 행위의 상태를 제어하기 위한 변수이므로.

> [!note]
> - 1번의 경우 결합도가 높아지지 않는가? 라는 의문이 드는데, 판단 기준을 알아보자.
> 
> **1. 이 객체가 없으면 내 존재 의의가 사라지는가?**
> - `DeploymentController`의 목적은 유닛을 맵 어딘가에 배치하는 것이다.
> - `Tile` 없이 배치가 성립하지 않는다. 게임 규칙 상 유닛은 타일 위에 올라가며, 타일은 "점유됨" 상태가 되어야 한다.
> - 따라서 **`DeploymentController`는 `Tile` 시스템을 반드시 알고 있어야 한다. 이는 필수적인 결합이다.**
> - 불필요한 결합 예시 : `SoundManager`나 `UIManager`를 직접 호출하는 경우 
> 	- 사운드가 나오지 않거나, 이펙트가 나오지 않더라도 유닛 배치는 성공해야 한다. 이런 경우는 이벤트로 풀어낸다.
> 
> **2. 동작 순서와 원자성이 중요한가?**
> - 예시) 유닛을 타일에 올렸는데, `true`로 바뀌지 않은 순간 다른 유닛이 똑같이 배치된다면? 문제가 발생한다.
> - 리스너가 없거나 등록 시점이 늦거나 실행 순서가 꼬이면 타일 점유 코드가 안 돌 수도 있다. 
> - 게임의 규칙을 집행하는 코드는 순차적이고 명시적인 호출로 트랜잭션을 보장해야 한다. "배치 함수 실행 -> 좌표 이동 -> 타일 잠금"은 한 덩어리로 묶여야 안전하다.
> 
> 
> **3. 양방향 결합인가? 단방향 결합인가?**
> - 가장 위험한 건 `상호 참조`지만, 현실적으로 이걸 쓸 수밖에 없는 상황이 있다.
> - 이런 구조를 제대로 관리하려면 **데이터를 변경하는 책임을 한 쪽만 갖고 있어야 한다.**
> - 즉 `DeploymentController`가 `_owner`을 저장하도록 `Tile`에 전달하고, `Tile`은 그 상태만을 갖는다는 것이다. 
> - 한편, `DeploymentController` 자체에서도 `CurrentTile`을 유지할 수 밖에 없다. 그래서 `Tile <=> Controller` 간의 상호 참조가 되는 상황이다.

#### 4. 컨테이너 - 컨트롤러 구조에서
- 위의 `Deploy()` 같은 경우 2개의 컨트롤러 `_collider, _deployment`를 함께 쓰는 구조였다. 
- 그러면 컨테이너의 `Deploy()`에서 2개의 컨트롤러를 호출하는 방식이 나을까? 아니면 `_collider.Deploy()`에서 구현하고 `_deployment`의 기능을 컨테이너를 통해 호출하는 식으로 구현하는 게 나을까?

- **컨테이너가 조율하는 방식이 좋다.**
- `Deploy()`라는 로직이 배치 + 콜라이더 상태의 변화를 모두 동반하는 "고수준의 행위High-Level Action"이라면 각 부품을 총괄하는 컨테이너에서 한꺼번에 볼 수 있게 하는 게 좋음.
	- **하위 컨트롤러 간의 의존성이 생기지 않고,** 
	- **각 컨트롤러는 자신의 로직에만 집중**할 수 있게 된다.

- 일단 여기까지;
## 260105

> [!done]
> - 이슈 수정 / 구조 변경
> 	1. `Enemy.Initialize(EnemyData, PathData)` 래퍼 메서드 구현
> 	2. `Operator`의 `Deploy` 이후 스탯이 변하는 문제 수정
> 	3. `Opereator`의 `CurrentHP` 초기화 시점 : `Deploy` -> `Initialize`로 이동
> 	4. `Operator`의 퇴각 시 배치 코스트 회복 로직 : 이벤트 기반으로 변경
> 	5. 사망 로직 : 기존의 `Die`에서 `HandleOnDeath -> Despawn()`으로 연결하는 구조로 변경
> 		- `Die`라는 메서드는 아예 제거되었고 `DieWithAnimation`, `DieInstantly`로 애니메이션 실행 여부만 결정한다.
> - **`UnitEntity`의 리팩토링이 거의 끝남**
> 	- 남은 메서드는 스킬 범위, 공격 대상 정도인데 이건 추후에 다른 컨트롤러들 구현하면서 어떻게 처리할지 결정하겠음
> 	- `UnitEntity`가 300줄 정도로 축소된 상태. 테스트는 더 해봐야겠지만 기존 로직이 크게 다르지 않은 것까지는 확인했음



### Buff, Stat 컨트롤러 동작 테스트
- 플레이 테스트를 해보면서 작동하지 않는 부분들 수리하는 중

### Initialize에 적용할 Wrapper 메서드
- `Enemy.Initialize()`에 `pathData`를 어떻게 전달하지?
	- 기존엔 `Initialize(EnemyData, PathData)` 자체로 전달했는데 지금은 별도의 파라미터를 받지는 않는 상태 `Initialize()`임
	- `Enemy`에 별도의 `PathData`를 초기화하는 패턴도 생각해봤는데 이건 보는 쪽에서  "`PathData`를 초기화해야 한다"라는 규칙을 알아야 하기 때문에 바람직한 방식은 아닌 듯.

- 해결) `Initialize(PathData)`를 `Enemy`에서 다시 만들면 됨 - `Wrapper`
	- `PathData`는 필수적인 개념이기 때문임
	- `Wrapper`에선 단순히 `_enemyData, _pathData`만 할당해주면 된다.

> [!note]
> 1. 주석으로 어떤 메서드인지 표시를 잘 해두자. 설명이 없으니까 '?? 왜 있지' 하고 그냥 지워버렸음..
> 2. `Stat`을 별도의 시스템으로 빼면서, **프로퍼티도 어떤 필드를 참고로 하는지 잘 체크할 필요가 있다.** 별도의 오류가 나타나지 않기 때문에 무심코 지나치기 쉬워보임.

#### 이 과정에서 Enemy의 경우
```cs
// Enemy를 위한 Initialize Wrapper
public virtual void Initialize(EnemyData enemyData, PathData pathData)
{
	if (_enemyData == null)
	{
		_enemyData = enemyData;
	}

	if (pathData == null) Logger.LogError("pathData가 전달되지 않음");

	_pathData = pathData; 

	// UnitEntity.Initialize
	base.Initialize();
}

// base.Initialize에서 실행되는 템플릿 메서드 1
protected override void InitializeUnitData()
{
	// 데이터는 Initialize에서 설정하기 때문에 여기선 스탯 초기화만 진행
	_stat.Initialize(_enemyData);
}
```

이런 느낌이 되었다. 원래는 `InitializeUnitData()`에서 SO를 필드에 할당하고 이를 이용한 초기화까지 진행하려고 했는데, 의도한 것과 다르게 됐음

근데 `Initialize()`의 래퍼를 쓸 수밖에 없는 상황이기 때문에, `InitializeUnitData()`의 이름을 `ApplyUnitData()`로 바꾸고 진행해봄. 이건 앞으로도 계속 바뀔 수 있다.
### Operator Deploy 이후 스탯이 변함
- 일단 프로퍼티를 위한 코드부터 줄인다.
```cs
// 변경 전
public override float Defense
{
	get => currentOperatorStats.Defense;
	set
	{
		if (currentOperatorStats.Defense != value)
		{
			currentOperatorStats.Defense = value;
			OnStatsChanged?.Invoke();
		}
	}
}

// 변경 후
public override float Defense { get => Stat.GetStat(StatType.Defense); }

// 복습) 게터는 Modifier가 적용된 스탯을 반환함
// 세터는 AddStatModifier, RemoveStatModifier 등의 StatController 코드로 구현
// 저 안에 스탯 변화로 인한 이벤트 발생 등도 다 들어가 있음
```

> [!note]
> - `StatController`에서 모든 필드를 관리할 수 없는데, 그것들은 일단 보류함
> - 예를 들면 `List<Vector2Int>`으로 관리되는 공격 범위, `enum`으로 관리되는 공격 타입 등등이 있다. 이것들은 나중에 생각해보자. `CombatController`을 구현할 때 다룰 일이 있을 것이다. 

- 이외에도 `DeploymentCost`의 경우 `Stat`으로 관리되고 있긴 한데, 유닛 자체에서 관리되기보다는 `DeploymentState`라는 외부 상태로 관리되는 게 더 좋아보인다. 
	1. 그 객체가 활용할 스탯은 아니라는 점
	2. 객체 외부에서 해당 객체의 퇴각 / 재배치에 따른 코스트 비용 증가를 위해 사용되는 필드

### Operator.Stat의 초기화가 이상한 문제
- UI에서 봤을 때 Box 상태에서는 스탯이 높다가 배치된 후에 스탯이 낮아지는 현상이 있음
- **`Operator`의 스탯 초기화는 `OperatorData`가 아니라  `OwnedOperator`를 이용해야 함**
- `StatController(OperatorData)` 부터 `OwnedOperator`을 받도록 바꾼다. 

```cs
public void Initialize(OwnedOperator ownedOp)
{
	_baseStats.Clear();

	var stats = ownedOp.CurrentStats;

	// 스탯들 초기화
	_baseStats[StatType.MaxHP] = stats.Health;
	_baseStats[StatType.Defense] = stats.Defense;
	_baseStats[StatType.MagicResistance] = stats.MagicResistance;
	_baseStats[StatType.DeploymentCost] = stats.DeploymentCost;
	_baseStats[StatType.RedeployTime] = stats.RedeployTime;
	_baseStats[StatType.AttackPower] = stats.AttackPower;
	_baseStats[StatType.AttackSpeed] = stats.AttackSpeed;
	_baseStats[StatType.MaxBlockCount] = stats.MaxBlockableEnemies;
	_baseStats[StatType.SPRecoveryRate] = stats.SPRecoveryRate;
}
```
> 이 바꾸는 과정이 매우 간단하다 - 이럴 때 설계가 잘 됐다는 느낌이 드니까 좋음


#### HP 초기화 시점
```cs
protected virtual void Awake()
{
	// 메쉬 색상 설정
	propBlock = new MaterialPropertyBlock();

	// 시스템 생성(껍데기만 생성)
	_stat = new StatController();
	_health = new HealthController(_stat);
	_buff = new BuffController(this);
	
	// ...
	
}
```
> - `Health`의 생성자는 `UnitEntity`의 `Awake` 시점에 이미 생성됨
> - `_health`는 별도로 `Initialize()`를 해줘야 함

- `Operator`에 대한 처리만 고민해보자.
	- 기존엔 `Initialize`가 아니라 `Deploy` 시점에 초기화했다. 
	- `MaxHP`는 "스탯" 개념이기 떄문에 `StatController`에서 초기화되는 건 맞아 보임
	- `CurrentHP`라는 값이 의미를 갖는 건 배치된 이후이기 때문에 고민이 되는데..
	- `Initialize` 시점에 초기화해도 별 문제 없지 않나? `IsDeployed`라는 플래그가 별도로 있어서 미리보기가 나타나더라도 공격받지 않으니 괜찮을 것 같기도 한데?

- 잘 모르겠을 때는 일단 테스트 -> **크게 상관 없어 보이므로 `Initialize`에서 초기화**

### 배치 코스트 회수 로직 관련
- `Operator`의 퇴각 처리 시 배치 코스트를 회수하는 로직 관련
	- 기존) 직접 `DeploymentCost`를 회복하는 메서드를 호출함
	- 수정) `Operator` 퇴각 시에 이벤트 발생
		- `DeployableManager`는 `Operator` 배치 시에 이벤트 구독
		- 이 이벤트를 받아서 `Operator`에 대한 배치 코스트를 계산해서 `int` 값에 대한 이벤트를 다시 발생
		- 최종적으로 `StageManager`가 이 이벤트를 받아서 반영함
	- 구조가 더 복잡하지만 `Operator`에서 직접 호출하는 방식이 이상해서 수정

> 참고) 싱글턴 매니저 간의 이벤트 구독은 `Start`에서 하는 게 좋다. `Awake`는 순서가 보장되지 않기 때문에.

### UnitEntity - VisualController 분리
- 모델이 어떻게 보이는가, 유닛이 어떻게 보이는가, VFX 실행할 것인가 등등
- 원본에서 코루틴 관리를 한다는 점, 값 조절의 용이성 등 때문에 이전처럼 일반 C# 클래스로 구현하지 않고 `MonoBehaviour`을 상속한 구조로 구현함

#### 발생 중인 문제
- 색깔 할당이 되지 않음 : `Barricade`, `Operator`만 그렇다
	- `Enemy`는 잘 됨. ??
- 파괴된 유닛이 사라지지 않음
	- 예시) 바리케이드 : 투명해지긴 하는데 비활성화되지 않는다

### Despawn 구현
- `Despawn`이라는 메서드를 `Deployable`과 `Enemy` 양쪽에서 1개씩 구현함
	- `Operator`의 경우 `DespawnReason`은 `Retreat`, `Defeated`으로.
	- `Enemy`의 경우는 `ReachDestination, Defeated`으로 구현함
- `HandleOnDeath`라는 메서드를 `HP`가 0이 될 때의 메서드로 구현함
- `HandleOnDeath`는 일반적으로 `Despawn(DespawnReason.Defeated)`으로 연결시킴

#### 발생한 문제
- `Operator, Enemy`가 죽고 나서 정상적으로 사라지지 않는 문제
	- `HandleOnDeath()` 메서드는 `UnitEntity`에서는 비어 있다. 이 메서드가 `Despawn(Reason)`을 연결해주는 역할을 함.
	- 이렇게 구현한 이유는 `Operator`와 `Enemy`의 `DespawnReason`을 별도로 구현했기 때문에, `Operator`는 퇴각, 사망 으로 디스폰되고, `Enemy`는 도착, 사망으로 디스폰된다.



## 260102
>[!done]
>- God Class 개편 계속
>	1. 스탯은 `StatController`로 통합.
>		- 상태 스탯 vs "능력치" 스탯의 관리법이 다르다
>	2. `BuffController`까지 구현해서 `Stat, Buff, Health` 컨트롤러 간의 상호작용을 구현하는 게 목표

### StatController 구현
- 일단 지금의 스탯 구조는 아래와 같음
```cs
// UnitStats
[SerializeField] private float _health;
[SerializeField] private float _defense;
[SerializeField] private float _magicResistance;

// DeployableUnitStats
[SerializeField] private UnitStats _baseStats;
[SerializeField] private int _deploymentCost;
[SerializeField] private float _redeployTime;

// OperatorStats
[SerializeField] private DeployableUnitStats _deployableUnitStats;
[SerializeField] private float _attackPower;
[SerializeField] private float _attackSpeed;
[SerializeField] private int _maxBlockableEnemies;
[SerializeField] private float _spRecoveryRate;

// EnemyStats
[SerializeField] private UnitStats _baseStats;
[SerializeField] private float _movementSpeed;
[SerializeField] private float _attackPower;
[SerializeField] private float _attackSpeed;
[SerializeField] private float _attackRange;
```

`StatController`을 구현한다면 이들을 어떻게 반영할 수 있을까?

---
제미나이와의 질답

- `nullable` 필드들을 넣는 걸 생각했는데, 아래의 단점들이 있다고 함
1. `Null` 체크 지옥 : 값을 쓸 때마다 `.HasValue`나 `?? 0` 처리가 필요함
2. 확장성 부족 : 새로운 유닛 타입이 생겨서 새로운 스탯이 필요해지면 `StatController`을 계속 수정해야 함
3. 버프 시스템과의 연동 : `공격력 증가 버프`를 적용하겠다고 한다면 `StatController` 내에 `AttackPower`가 있는지 없는지 타입 체크를 하거나 리플렉션을 써야 하는 복잡함이 생김

### 스탯 구조에 대해 : State와 On-Demand
- 지금까지도 몰랐던(!) 부분이라 정리해둔다.

- **상태로 관리해야 하는 필드와, 필요할 때마다 계산되는 필드를 구분한다.**
- **`CurrentHealth`는 상태로 관리하지만 `MaxHealth`는 필요할 때마다 계산해서 보여주는 방식**을 취한다. 심지어 `MaxHealth`가 변할 수 있는 값이라고 하더라도.

- **`상태 / 자원`**
	- **소모된다.** 전투 중에 계속 값이 변할 수 있다.
	- **누적된다.**
	- 지금 얼마 남았는지를 기억하기 위한 저장 공간이 필요하다.
- `능력치 / 계수`
	- 소모되지 않는다. 100번 맞아도 방어력은 그대로이다.
	- 계산식의 상수다. 대미지 공식`Damage - Defense`에서 `Defense`는 계속 똑같이 적용되는 규칙이다.
	- 버프를 받아 변할 수 있으나, 이는 규칙이 바뀐 것이며 자원이 쓰인 건 아니다.
	- 따라서 계산식으로 존재하는 게 자연스럽다. 

- 그래서 `StatController`의 맨 위 주석을 달아뒀다.
```cs
// 능력치(즉 소모되지 않는 값이나 규칙)를 다루는 컨트롤러
// - currentHP는 "상태"라서 여기서 관리하지 않지만, MaxHP는 "능력치"라서 여기서 관리한다.
// - 상태와 능력치의 차이 : 상태는 소모되고 누적된다. 능력치는 소모되지 않는다.
public class StatController
```

### 초기화 관련
- 스탯들이 `UnitData`를 상속받는 구조가 아니라 전부 개별이다. 
- 그래서 `Initialize()`를 별도로 둔다. 각 클래스는 자신이 가진 데이터 타입을 아니까(`OperatorData, DeployableUnitData, EnemyData` 등등) 각 클래스에 해당하는 `StatController`의 `Initialize`를 별도로 구현한다
	- 번거롭지만 데이터 구조를 뜯어서 수정하는 것보단 (지금 시점에서는) 싸게 먹힌다. 
	- SO를 수정하면 필드값들도 전부 다시 집어넣어야 하니까...


---
- 일단 `StatSystem`을 구현하고 별도의 `IReadable` 인터페이스도 구현했음
- 그런데 `StatSystem`은 `Buff`로 인한 `Modifier`의 증감을 받기 때문에 `BuffSystem`도 곧바로 구현해야 할 듯.

### BuffController 구현
- 그대로 옮기면 된다..라고 생각했는데 또 어떤 건 로직을 적용하는 방식이 달라지고 해서 복잡해졌다. 흠.
- 예를 들면 `float`로 관리하는 값은 `statController`에서 `Modifier`만 합 연산으로 갖고 있다가 `modifier`가 필요해지면 1을 더하고 곱해서 반환하면 됨
- `StatModifierBuff`에도 여러 가지 상황이 있음 
	- `MaxBlockableEnemies`처럼 값을 곱하는 게 아니라 뒤집어쓴다거나
	- `List<Vector2Int>`로 관리되는 타입이라든가
	- `AttackType`처럼 버프가 걸렸을 때 공격 타입이 변하는 등등

- **모든 데이터를 `StatController`에 억지로 넣을 필요는 없다.**

1. `int`로 관리되는 값들
- 실제로 저지수가 변하는 버프가 있진 않지만 처리해본다.
- 자신이 차지하는 저지 수, 최대로 저지 가능한 적의 수 등인데, 기존에 `Buff`에 값을 넣을 때 "해당 값으로 변한다"는 개념으로 설정했음
- 기존의 `StatSystem`은 `baseStats * modifier` 개념으로 적용되는데, 이런 경우는 어떻게 처리해야 할까?

- **`Override Dict`을 별도로 관리하는 방법이 있다.** 
	1. 버프가 적용될 때 <StatType, float> 값으로 들어감
	2. 값이 필요할 때, 게터는 `Override Dict`을 먼저 체크하고 `StatType` 키값이 있으면 이를 우선으로 해서 반환함. `Override Dict`에 값이 없으면 자신의 스탯을 반환함.
	3. 버프가 끝날 때 Override Dict에서 StatType도 삭제함

### `Restriction`의 중첩 문제 관련
```cs
public void AddRestriction(ActionRestriction restirction)
{
	Restrictions |= restirction; // 비트 OR 연산으로 플래그 추가
}
public void RemoveRestriction(ActionRestriction restirction)
{
	Restrictions &= ~restirction; // AND, NOT 연산으로 플래그 제거
}
```

> - `Buff`에 의해 위처럼 제약이 걸린다고 가정함
> - 2개의 `StunBuff`가 들어와서 적용된다고 하면, 2번째 `StunBuff`가 들어온 후의 스턴 시간만큼 유지되는 게 일반적일 거임
> - 하지만 위처럼만 관리된다면, 1번째 `StunBuff`가 풀리는 시점에 스턴이 풀리게 된다. 비트 연산이기 때문임.

- 이걸 방지하려면 **버프 추가 / 제거할 때마다 현재 활성화된 모든 버프를 돌아서 제약을 재계산**하는 방식이 가장 안전하다.

지금 이걸 쓰는 로직이 딱 하나 있음 : `StunBuff`.
```cs
public override void OnApply(UnitEntity owner, UnitEntity caster)
{
	base.OnApply(owner, caster);
	owner.AddRestriction(ActionRestriction.Stunned);
}

public override void OnRemove()
{
	owner.RemoveRestriction(ActionRestriction.Stunned);
	base.OnRemove();
}
```
적용될 때마다 명령하는 방식인데, 직관적이지만 여러 효과 처리를 계산할 때 복잡한 카운팅 로직이 발생한다.

#### 재계산 패턴
- 버프는 자신이 가진 제한에 대한 정보만 든다
- `BuffController`는 버프들을 순회하면서 자신에게 활성화된 버프를 보고 상태를 갱신한다.

```cs
public abstract class Buff
{
    // ... 기존 필드들 ...

    // 기본적으로는 아무 제약도 없음. 오버라이드해서 사용.
    public virtual ActionRestriction Restriction => ActionRestriction.None;
}
```

```cs
public class StunBuff : Buff
{
    public override bool IsDebuff => true;
    
	// 제약 선언
    public override ActionRestriction Restriction => ActionRestriction.Stunned;

    public StunBuff(float duration)
    {
        buffName = "stun";
        this.duration = duration;
    }

    // OnApply, OnRemove는 비워두거나 VFX용으로만 사용
}
```

```cs
// 모든 버프를 순회하며 제약을 합침(OR 연산)
private void RecalculateRestrictions()
{
	Restrictions = ActionRestriction.None; // 초기화

	foreach (var buff in _activeBuffs)
	{
		Restrictions |= buff.Restriction;
	}

	// 유닛의 영구적인 제약이 있다면 추가로 OR 연산
	// Restrictions |= _owner.PermanentRestrictions;
}
```

- 이제 `AddRestriction, RemoveRestriction` 등은 다 필요 없어짐
- `HasRestriction`은 혹시 조회할 수도 있으니 남겨둠

- 일단 구현은 다 했는데 테스트는 못해봄. 
- **컴파일했을 때 눈에 띄는 오류들만 다 잡고 오늘은 여기까지 진행함.** 피곤하다..

> 리팩토링이 겁나 빡센데 구조적으로 지식이 는다는 느낌이라 재밌긴 하다
> 너무 오래 걸리긴 하는데 기존에 찝찝했던 것들을 해소한다는 느낌으로 접근 중


