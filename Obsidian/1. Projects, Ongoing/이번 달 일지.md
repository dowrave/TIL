
## 개요

>[!note]
>
>  **"흐름"으로 설명하는 것 외에도 "원리"도 곁들이면 좋다**
> - 지금은 "어떤 이슈가 발생해서 어떻게 해결했더라"로 정리했다면
> - 추가로 **이슈가 '왜' 발생했는지**까지 정리해두면 나중에 볼 때 다시 헷갈리지 않을 수 있음
> 
> 모든 코드를 일일이 기억하는 건 불가능함! 나중에 봤을 때 '이러면 되겠다'는 감이 바로 잡히도록 메모해보자.

>[!objective]
>- 프로젝트가 계속 늘어지는 관계로 완료 기준을 정해놓기로 한다.
>- [[프로젝트 완료 기준에 대해]]
> 	- 소리 추가(BGM 2~3개 + SFX 5개 정도? 링크 참조)
> 	- 1-3 스테이지 구현 및 밸런스 조정
> 	- 진행에 치명적인 버그 수정
> - 완료 후에는 프로젝트에 관한 글도 적어두면 좋을 듯
> 	- 무엇을 구현했는지
> 	- 왜 늘어졌는지 등등

>[!wip]
>0. `UnitEntity` 관련 리팩토링 시작 : 모놀로직 -> 기능을 컴포넌트 단위로 분리
>1. 스테이지 밸런싱 진행하면서 
>2. 경로 로직 관련 현재 간헐적으로 발생하는 이슈들 보이면 처리
>	- 경로가 막혔을 때 바리케이드를 제거하지 않고 그대로 지나가는 현상
>	- 경로가 바뀔 때 살짝 뒤로 빼는 현상. 
>		- 최단 경로를 찾기 때문에 뒤로 빼는 현상이 나오면 안됨.

>[!issue]
> 간헐적인 이슈들
> - 적이 이미 사라졌는데 계속 해당 위치를 공격하는 현상
> - `ArcaneFieldSkill` : 스킬을 썼음에도 효과가 제대로 적용되지 않는 현상
> 	- 위치가 애매하게 걸쳐지는 경우가 있나? 의심은 있는데 상황을 재현하기 어려움
> - `Enemy`가 사라질 때 풀 태그의 키가 없다는 오류 

## 현재 신경쓰이거나 곧 진행할 이슈
- `PathNavigator`의 구현 관련 
	- `Enemy`나 `PathIndicator`에 구현된 필드가 너무 많아서 굳이 서브 컴포넌트로 빼둔 의미를 잘 못 느끼겠음
- `CombatController`
	- 아군, 적군 모두
- `SkillController`
- `DeployableController`
	- 배치할 수 있는 요소들에 대한 컨트롤러
	- 필요할지 아닐지 아직은 모르겠다. 구현하면서 알아보자.
## 일지

## 260105

> [!done]
> - 이슈 수정 / 구조 변경
> 	1. `Enemy.Initialize(EnemyData, PathData)` 래퍼 메서드 구현
> 	2. `Operator`의 `Deploy` 이후 스탯이 변하는 문제 수정
> 	3. `Opereator`의 `CurrentHP` 초기화 시점 : `Deploy` -> `Initialize`로 이동
> 	4. `Operator`의 퇴각 시 배치 코스트 회복 로직 : 이벤트 기반으로 변경
> 	5. 사망 로직 : 기존의 `Die`에서 `HandleOnDeath -> Despawn()`으로 연결하는 구조로 변경
> 		- `Die`라는 메서드는 아예 제거되었고 `DieWithAnimation`, `DieInstantly`로 애니메이션 실행 여부만 결정한다.
> - **`UnitEntity`의 리팩토링이 거의 끝남**
> 	- 남은 메서드는 스킬 범위, 공격 대상 정도인데 이건 추후에 다른 컨트롤러들 구현하면서 어떻게 처리할지 결정하겠음
> 	- `UnitEntity`가 300줄 정도로 축소된 상태. 테스트는 더 해봐야겠지만 기존 로직이 크게 다르지 않은 것까지는 확인했음



### Buff, Stat 컨트롤러 동작 테스트
- 플레이 테스트를 해보면서 작동하지 않는 부분들 수리하는 중

### Initialize에 적용할 Wrapper 메서드
- `Enemy.Initialize()`에 `pathData`를 어떻게 전달하지?
	- 기존엔 `Initialize(EnemyData, PathData)` 자체로 전달했는데 지금은 별도의 파라미터를 받지는 않는 상태 `Initialize()`임
	- `Enemy`에 별도의 `PathData`를 초기화하는 패턴도 생각해봤는데 이건 보는 쪽에서  "`PathData`를 초기화해야 한다"라는 규칙을 알아야 하기 때문에 바람직한 방식은 아닌 듯.

- 해결) `Initialize(PathData)`를 `Enemy`에서 다시 만들면 됨 - `Wrapper`
	- `PathData`는 필수적인 개념이기 때문임
	- `Wrapper`에선 단순히 `_enemyData, _pathData`만 할당해주면 된다.

> [!note]
> 1. 주석으로 어떤 메서드인지 표시를 잘 해두자. 설명이 없으니까 '?? 왜 있지' 하고 그냥 지워버렸음..
> 2. `Stat`을 별도의 시스템으로 빼면서, **프로퍼티도 어떤 필드를 참고로 하는지 잘 체크할 필요가 있다.** 별도의 오류가 나타나지 않기 때문에 무심코 지나치기 쉬워보임.

#### 이 과정에서 Enemy의 경우
```cs
// Enemy를 위한 Initialize Wrapper
public virtual void Initialize(EnemyData enemyData, PathData pathData)
{
	if (_enemyData == null)
	{
		_enemyData = enemyData;
	}

	if (pathData == null) Logger.LogError("pathData가 전달되지 않음");

	_pathData = pathData; 

	// UnitEntity.Initialize
	base.Initialize();
}

// base.Initialize에서 실행되는 템플릿 메서드 1
protected override void InitializeUnitData()
{
	// 데이터는 Initialize에서 설정하기 때문에 여기선 스탯 초기화만 진행
	_stat.Initialize(_enemyData);
}
```

이런 느낌이 되었다. 원래는 `InitializeUnitData()`에서 SO를 필드에 할당하고 이를 이용한 초기화까지 진행하려고 했는데, 의도한 것과 다르게 됐음

근데 `Initialize()`의 래퍼를 쓸 수밖에 없는 상황이기 때문에, `InitializeUnitData()`의 이름을 `ApplyUnitData()`로 바꾸고 진행해봄. 이건 앞으로도 계속 바뀔 수 있다.
### Operator Deploy 이후 스탯이 변함
- 일단 프로퍼티를 위한 코드부터 줄인다.
```cs
// 변경 전
public override float Defense
{
	get => currentOperatorStats.Defense;
	set
	{
		if (currentOperatorStats.Defense != value)
		{
			currentOperatorStats.Defense = value;
			OnStatsChanged?.Invoke();
		}
	}
}

// 변경 후
public override float Defense { get => Stat.GetStat(StatType.Defense); }

// 복습) 게터는 Modifier가 적용된 스탯을 반환함
// 세터는 AddStatModifier, RemoveStatModifier 등의 StatController 코드로 구현
// 저 안에 스탯 변화로 인한 이벤트 발생 등도 다 들어가 있음
```

> [!note]
> - `StatController`에서 모든 필드를 관리할 수 없는데, 그것들은 일단 보류함
> - 예를 들면 `List<Vector2Int>`으로 관리되는 공격 범위, `enum`으로 관리되는 공격 타입 등등이 있다. 이것들은 나중에 생각해보자. `CombatController`을 구현할 때 다룰 일이 있을 것이다. 

- 이외에도 `DeploymentCost`의 경우 `Stat`으로 관리되고 있긴 한데, 유닛 자체에서 관리되기보다는 `DeploymentState`라는 외부 상태로 관리되는 게 더 좋아보인다. 
	1. 그 객체가 활용할 스탯은 아니라는 점
	2. 객체 외부에서 해당 객체의 퇴각 / 재배치에 따른 코스트 비용 증가를 위해 사용되는 필드

### Operator.Stat의 초기화가 이상한 문제
- UI에서 봤을 때 Box 상태에서는 스탯이 높다가 배치된 후에 스탯이 낮아지는 현상이 있음
- **`Operator`의 스탯 초기화는 `OperatorData`가 아니라  `OwnedOperator`를 이용해야 함**
- `StatController(OperatorData)` 부터 `OwnedOperator`을 받도록 바꾼다. 

```cs
public void Initialize(OwnedOperator ownedOp)
{
	_baseStats.Clear();

	var stats = ownedOp.CurrentStats;

	// 스탯들 초기화
	_baseStats[StatType.MaxHP] = stats.Health;
	_baseStats[StatType.Defense] = stats.Defense;
	_baseStats[StatType.MagicResistance] = stats.MagicResistance;
	_baseStats[StatType.DeploymentCost] = stats.DeploymentCost;
	_baseStats[StatType.RedeployTime] = stats.RedeployTime;
	_baseStats[StatType.AttackPower] = stats.AttackPower;
	_baseStats[StatType.AttackSpeed] = stats.AttackSpeed;
	_baseStats[StatType.MaxBlockCount] = stats.MaxBlockableEnemies;
	_baseStats[StatType.SPRecoveryRate] = stats.SPRecoveryRate;
}
```
> 이 바꾸는 과정이 매우 간단하다 - 이럴 때 설계가 잘 됐다는 느낌이 드니까 좋음


#### HP 초기화 시점
```cs
protected virtual void Awake()
{
	// 메쉬 색상 설정
	propBlock = new MaterialPropertyBlock();

	// 시스템 생성(껍데기만 생성)
	_stat = new StatController();
	_health = new HealthController(_stat);
	_buff = new BuffController(this);
	
	// ...
	
}
```
> - `Health`의 생성자는 `UnitEntity`의 `Awake` 시점에 이미 생성됨
> - `_health`는 별도로 `Initialize()`를 해줘야 함

- `Operator`에 대한 처리만 고민해보자.
	- 기존엔 `Initialize`가 아니라 `Deploy` 시점에 초기화했다. 
	- `MaxHP`는 "스탯" 개념이기 떄문에 `StatController`에서 초기화되는 건 맞아 보임
	- `CurrentHP`라는 값이 의미를 갖는 건 배치된 이후이기 때문에 고민이 되는데..
	- `Initialize` 시점에 초기화해도 별 문제 없지 않나? `IsDeployed`라는 플래그가 별도로 있어서 미리보기가 나타나더라도 공격받지 않으니 괜찮을 것 같기도 한데?

- 잘 모르겠을 때는 일단 테스트 -> **크게 상관 없어 보이므로 `Initialize`에서 초기화**

### 배치 코스트 회수 로직 관련
- `Operator`의 퇴각 처리 시 배치 코스트를 회수하는 로직 관련
	- 기존) 직접 `DeploymentCost`를 회복하는 메서드를 호출함
	- 수정) `Operator` 퇴각 시에 이벤트 발생
		- `DeployableManager`는 `Operator` 배치 시에 이벤트 구독
		- 이 이벤트를 받아서 `Operator`에 대한 배치 코스트를 계산해서 `int` 값에 대한 이벤트를 다시 발생
		- 최종적으로 `StageManager`가 이 이벤트를 받아서 반영함
	- 구조가 더 복잡하지만 `Operator`에서 직접 호출하는 방식이 이상해서 수정

> 참고) 싱글턴 매니저 간의 이벤트 구독은 `Start`에서 하는 게 좋다. `Awake`는 순서가 보장되지 않기 때문에.

### UnitEntity - VisualController 분리
- 모델이 어떻게 보이는가, 유닛이 어떻게 보이는가, VFX 실행할 것인가 등등
- 원본에서 코루틴 관리를 한다는 점, 값 조절의 용이성 등 때문에 이전처럼 일반 C# 클래스로 구현하지 않고 `MonoBehaviour`을 상속한 구조로 구현함

#### 발생 중인 문제
- 색깔 할당이 되지 않음 : `Barricade`, `Operator`만 그렇다
	- `Enemy`는 잘 됨. ??
- 파괴된 유닛이 사라지지 않음
	- 예시) 바리케이드 : 투명해지긴 하는데 비활성화되지 않는다

### Despawn 구현
- `Despawn`이라는 메서드를 `Deployable`과 `Enemy` 양쪽에서 1개씩 구현함
	- `Operator`의 경우 `DespawnReason`은 `Retreat`, `Defeated`으로.
	- `Enemy`의 경우는 `ReachDestination, Defeated`으로 구현함
- `HandleOnDeath`라는 메서드를 `HP`가 0이 될 때의 메서드로 구현함
- `HandleOnDeath`는 일반적으로 `Despawn(DespawnReason.Defeated)`으로 연결시킴

#### 발생한 문제
- `Operator, Enemy`가 죽고 나서 정상적으로 사라지지 않는 문제
	- `HandleOnDeath()` 메서드는 `UnitEntity`에서는 비어 있다. 이 메서드가 `Despawn(Reason)`을 연결해주는 역할을 함.
	- 이렇게 구현한 이유는 `Operator`와 `Enemy`의 `DespawnReason`을 별도로 구현했기 때문에, `Operator`는 퇴각, 사망 으로 디스폰되고, `Enemy`는 도착, 사망으로 디스폰된다.



## 260102
>[!done]
>- God Class 개편 계속
>	1. 스탯은 `StatController`로 통합.
>		- 상태 스탯 vs "능력치" 스탯의 관리법이 다르다
>	2. `BuffController`까지 구현해서 `Stat, Buff, Health` 컨트롤러 간의 상호작용을 구현하는 게 목표

### StatController 구현
- 일단 지금의 스탯 구조는 아래와 같음
```cs
// UnitStats
[SerializeField] private float _health;
[SerializeField] private float _defense;
[SerializeField] private float _magicResistance;

// DeployableUnitStats
[SerializeField] private UnitStats _baseStats;
[SerializeField] private int _deploymentCost;
[SerializeField] private float _redeployTime;

// OperatorStats
[SerializeField] private DeployableUnitStats _deployableUnitStats;
[SerializeField] private float _attackPower;
[SerializeField] private float _attackSpeed;
[SerializeField] private int _maxBlockableEnemies;
[SerializeField] private float _spRecoveryRate;

// EnemyStats
[SerializeField] private UnitStats _baseStats;
[SerializeField] private float _movementSpeed;
[SerializeField] private float _attackPower;
[SerializeField] private float _attackSpeed;
[SerializeField] private float _attackRange;
```

`StatController`을 구현한다면 이들을 어떻게 반영할 수 있을까?

---
제미나이와의 질답

- `nullable` 필드들을 넣는 걸 생각했는데, 아래의 단점들이 있다고 함
1. `Null` 체크 지옥 : 값을 쓸 때마다 `.HasValue`나 `?? 0` 처리가 필요함
2. 확장성 부족 : 새로운 유닛 타입이 생겨서 새로운 스탯이 필요해지면 `StatController`을 계속 수정해야 함
3. 버프 시스템과의 연동 : `공격력 증가 버프`를 적용하겠다고 한다면 `StatController` 내에 `AttackPower`가 있는지 없는지 타입 체크를 하거나 리플렉션을 써야 하는 복잡함이 생김

### 스탯 구조에 대해 : State와 On-Demand
- 지금까지도 몰랐던(!) 부분이라 정리해둔다.

- **상태로 관리해야 하는 필드와, 필요할 때마다 계산되는 필드를 구분한다.**
- **`CurrentHealth`는 상태로 관리하지만 `MaxHealth`는 필요할 때마다 계산해서 보여주는 방식**을 취한다. 심지어 `MaxHealth`가 변할 수 있는 값이라고 하더라도.

- **`상태 / 자원`**
	- **소모된다.** 전투 중에 계속 값이 변할 수 있다.
	- **누적된다.**
	- 지금 얼마 남았는지를 기억하기 위한 저장 공간이 필요하다.
- `능력치 / 계수`
	- 소모되지 않는다. 100번 맞아도 방어력은 그대로이다.
	- 계산식의 상수다. 대미지 공식`Damage - Defense`에서 `Defense`는 계속 똑같이 적용되는 규칙이다.
	- 버프를 받아 변할 수 있으나, 이는 규칙이 바뀐 것이며 자원이 쓰인 건 아니다.
	- 따라서 계산식으로 존재하는 게 자연스럽다. 

- 그래서 `StatController`의 맨 위 주석을 달아뒀다.
```cs
// 능력치(즉 소모되지 않는 값이나 규칙)를 다루는 컨트롤러
// - currentHP는 "상태"라서 여기서 관리하지 않지만, MaxHP는 "능력치"라서 여기서 관리한다.
// - 상태와 능력치의 차이 : 상태는 소모되고 누적된다. 능력치는 소모되지 않는다.
public class StatController
```

### 초기화 관련
- 스탯들이 `UnitData`를 상속받는 구조가 아니라 전부 개별이다. 
- 그래서 `Initialize()`를 별도로 둔다. 각 클래스는 자신이 가진 데이터 타입을 아니까(`OperatorData, DeployableUnitData, EnemyData` 등등) 각 클래스에 해당하는 `StatController`의 `Initialize`를 별도로 구현한다
	- 번거롭지만 데이터 구조를 뜯어서 수정하는 것보단 (지금 시점에서는) 싸게 먹힌다. 
	- SO를 수정하면 필드값들도 전부 다시 집어넣어야 하니까...


---
- 일단 `StatSystem`을 구현하고 별도의 `IReadable` 인터페이스도 구현했음
- 그런데 `StatSystem`은 `Buff`로 인한 `Modifier`의 증감을 받기 때문에 `BuffSystem`도 곧바로 구현해야 할 듯.

### BuffController 구현
- 그대로 옮기면 된다..라고 생각했는데 또 어떤 건 로직을 적용하는 방식이 달라지고 해서 복잡해졌다. 흠.
- 예를 들면 `float`로 관리하는 값은 `statController`에서 `Modifier`만 합 연산으로 갖고 있다가 `modifier`가 필요해지면 1을 더하고 곱해서 반환하면 됨
- `StatModifierBuff`에도 여러 가지 상황이 있음 
	- `MaxBlockableEnemies`처럼 값을 곱하는 게 아니라 뒤집어쓴다거나
	- `List<Vector2Int>`로 관리되는 타입이라든가
	- `AttackType`처럼 버프가 걸렸을 때 공격 타입이 변하는 등등

- **모든 데이터를 `StatController`에 억지로 넣을 필요는 없다.**

1. `int`로 관리되는 값들
- 실제로 저지수가 변하는 버프가 있진 않지만 처리해본다.
- 자신이 차지하는 저지 수, 최대로 저지 가능한 적의 수 등인데, 기존에 `Buff`에 값을 넣을 때 "해당 값으로 변한다"는 개념으로 설정했음
- 기존의 `StatSystem`은 `baseStats * modifier` 개념으로 적용되는데, 이런 경우는 어떻게 처리해야 할까?

- **`Override Dict`을 별도로 관리하는 방법이 있다.** 
	1. 버프가 적용될 때 <StatType, float> 값으로 들어감
	2. 값이 필요할 때, 게터는 `Override Dict`을 먼저 체크하고 `StatType` 키값이 있으면 이를 우선으로 해서 반환함. `Override Dict`에 값이 없으면 자신의 스탯을 반환함.
	3. 버프가 끝날 때 Override Dict에서 StatType도 삭제함

### `Restriction`의 중첩 문제 관련
```cs
public void AddRestriction(ActionRestriction restirction)
{
	Restrictions |= restirction; // 비트 OR 연산으로 플래그 추가
}
public void RemoveRestriction(ActionRestriction restirction)
{
	Restrictions &= ~restirction; // AND, NOT 연산으로 플래그 제거
}
```

> - `Buff`에 의해 위처럼 제약이 걸린다고 가정함
> - 2개의 `StunBuff`가 들어와서 적용된다고 하면, 2번째 `StunBuff`가 들어온 후의 스턴 시간만큼 유지되는 게 일반적일 거임
> - 하지만 위처럼만 관리된다면, 1번째 `StunBuff`가 풀리는 시점에 스턴이 풀리게 된다. 비트 연산이기 때문임.

- 이걸 방지하려면 **버프 추가 / 제거할 때마다 현재 활성화된 모든 버프를 돌아서 제약을 재계산**하는 방식이 가장 안전하다.

지금 이걸 쓰는 로직이 딱 하나 있음 : `StunBuff`.
```cs
public override void OnApply(UnitEntity owner, UnitEntity caster)
{
	base.OnApply(owner, caster);
	owner.AddRestriction(ActionRestriction.Stunned);
}

public override void OnRemove()
{
	owner.RemoveRestriction(ActionRestriction.Stunned);
	base.OnRemove();
}
```
적용될 때마다 명령하는 방식인데, 직관적이지만 여러 효과 처리를 계산할 때 복잡한 카운팅 로직이 발생한다.

#### 재계산 패턴
- 버프는 자신이 가진 제한에 대한 정보만 든다
- `BuffController`는 버프들을 순회하면서 자신에게 활성화된 버프를 보고 상태를 갱신한다.

```cs
public abstract class Buff
{
    // ... 기존 필드들 ...

    // 기본적으로는 아무 제약도 없음. 오버라이드해서 사용.
    public virtual ActionRestriction Restriction => ActionRestriction.None;
}
```

```cs
public class StunBuff : Buff
{
    public override bool IsDebuff => true;
    
	// 제약 선언
    public override ActionRestriction Restriction => ActionRestriction.Stunned;

    public StunBuff(float duration)
    {
        buffName = "stun";
        this.duration = duration;
    }

    // OnApply, OnRemove는 비워두거나 VFX용으로만 사용
}
```

```cs
// 모든 버프를 순회하며 제약을 합침(OR 연산)
private void RecalculateRestrictions()
{
	Restrictions = ActionRestriction.None; // 초기화

	foreach (var buff in _activeBuffs)
	{
		Restrictions |= buff.Restriction;
	}

	// 유닛의 영구적인 제약이 있다면 추가로 OR 연산
	// Restrictions |= _owner.PermanentRestrictions;
}
```

- 이제 `AddRestriction, RemoveRestriction` 등은 다 필요 없어짐
- `HasRestriction`은 혹시 조회할 수도 있으니 남겨둠

- 일단 구현은 다 했는데 테스트는 못해봄. 
- **컴파일했을 때 눈에 띄는 오류들만 다 잡고 오늘은 여기까지 진행함.** 피곤하다..

> 리팩토링이 겁나 빡센데 구조적으로 지식이 는다는 느낌이라 재밌긴 하다
> 너무 오래 걸리긴 하는데 기존에 찝찝했던 것들을 해소한다는 느낌으로 접근 중


