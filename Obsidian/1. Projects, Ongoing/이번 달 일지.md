
## 개요

>[!note]
>
>  **"흐름"으로 설명하는 것 외에도 "원리"도 곁들이면 좋다**
> - 지금은 "어떤 이슈가 발생해서 어떻게 해결했더라"로 정리했다면
> - 추가로 **이슈가 '왜' 발생했는지**까지 정리해두면 나중에 볼 때 다시 헷갈리지 않을 수 있음
> 
> 모든 코드를 일일이 기억하는 건 불가능함! 나중에 봤을 때 '이러면 되겠다'는 감이 바로 잡히도록 메모해보자.

>[!objective]
>- 프로젝트가 계속 늘어지는 관계로 완료 기준을 정해놓기로 한다.
>- [[프로젝트 완료 기준에 대해]]
> 	- 소리 추가(BGM 2~3개 + SFX 5개 정도? 링크 참조)
> 	- 1-3 스테이지 구현 및 밸런스 조정
> 	- 진행에 치명적인 버그 수정
> - 완료 후에는 프로젝트에 관한 글도 적어두면 좋을 듯
> 	- 무엇을 구현했는지
> 	- 왜 늘어졌는지 등등

>[!wip]
>0. `UnitEntity` 관련 리팩토링 시작 : 모놀로직 -> 기능을 컴포넌트 단위로 분리
>1. 스테이지 밸런싱 진행하면서 
>2. 경로 로직 관련 현재 간헐적으로 발생하는 이슈들 보이면 처리
>	- 경로가 막혔을 때 바리케이드를 제거하지 않고 그대로 지나가는 현상
>	- 경로가 바뀔 때 살짝 뒤로 빼는 현상. 
>		- 최단 경로를 찾기 때문에 뒤로 빼는 현상이 나오면 안됨.

>[!issue]
> 간헐적인 이슈들
> - 적이 이미 사라졌는데 계속 해당 위치를 공격하는 현상
> - `ArcaneFieldSkill` : 스킬을 썼음에도 효과가 제대로 적용되지 않는 현상
> 	- 위치가 애매하게 걸쳐지는 경우가 있나? 의심은 있는데 상황을 재현하기 어려움
> - `Enemy`가 사라질 때 풀 태그의 키가 없다는 오류 

## 현재 진행 중
>[!wip]
>- `UnitEntity : HealthSystem` 분리
>	- 테스트 : `Die` 같은 부분 구현

# 251231 - 짭명방
>[!done]
>- `HealthSystem` 다듬기 
>	- `Die` 메서드 동작하지 않는 문제 수정
>	- `TakeHeal` 관련 세부사항 수정
>- 프로그램 구조에 관해
>	- [[Csharp - 읽기 전용 인터페이스]]
>	- [[Csharp - 상속 vs 구현]]

>[!wip]

## HealthSystem 테스트 및 버그 수정

### `Die()`가 동작하지 않음
```cs
	// 사망 체크
	if (CurrentHealth < 0)
	{
		OnDeath?.Invoke();
	}
```
> 여기서 `CurrentHealth` 체크 조건은 `<= 0`이다. `0`부터 죽은 거니까.

### 기타 이슈
- `TakeHeal`에서 힐을 받았을 때 최대 체력을 넘기지 않게 수정
- `TakeHeal`이 동작한 후 `OnHealthChanged` 이벤트 발생

### 구현하면서 든 궁금증
>[!question]
>1. 지금처럼 `UnitEntity` 내부의 `HealthSystem`을 별도로 구분한 상태일 때, 외부에서 `HealthSystem`의 값들을 가져가거나 새로 쓰게 만들어야 하는 경우가 있을 것이다. 이런 동작을 구현하기 위해, **`UnitEntity.HealthSystem.Health` 같은 식으로 접근해서 사용하게 해야 할까? 아니면 `UnitEntity.Health`로 접근하게 만드는 별도의 게터 프로퍼티를 하나 만들어야 할까?** 
>2. 또, 지금처럼 `HealthSystem`에 `public` 세터 메서드를 만들었다면 **외부에서는 `UnitEntity`의 세터 메서드에 접근할 수도 있지만 `UnitEnity.HealthSystem`의 세터 메서드에 접근할 수도 있다.** 일반적으로 `UnitEntity`의 세터 메서드에 접근해야 그 자체의 동작이 수행되도록 할 수 있겠는데, 이거는 개발자들끼리 별도의 규칙으로 정해야 하나?

1. 값을 변경하는 행위는 `UnitEntity`에 별도의 `Wrapper` 메서드를 만드는 게 좋고, 값을 읽는 행위는 상황에 따라 `UnitEntity.Health`로 직접 접근하거나 프로퍼티를 열어두는 방식을 혼용한다.

- **세터는 별도의 메서드**를 구현하는 게 좋다.
예를 들어서 외부 객체가 `UnitEntity`의 체력을 깎는 경우, `UnitEntity`에서는 단순히 체력만 깎이는 게 아니다. 피격 애니메이션, 사운드, 이펙트, AI 상태 변경 등의 동작이 함께 들어간다. 

근데 외부 객체가 `UnitEntity.HealthSystem.TakeDamage()` 같은 메서드를 실행시킨다면, 단순히 체력이 깎이는 동작만 들어갈 뿐 이외의 재생되어야 할 메서드들이 재생되지 않는다.

변경 메서드의 경우, 인터페이스로 추출하는 것도 방법이다.

- **게터는 프로퍼티를 열어두는 게 좋다.**
`UnitEntity`에 세부 시스템의 게터 프로퍼티나 게터 메서드를 일일이 만드는 것은 `보일러플레이트 코드`(반복적이고 지루한 코드)를 늘린다. 

따라서 `HealthSystem`에 대한 게터 프로퍼티를 `public`으로 열고, 외부에서 데이터를 읽어가는 건 허용하는 편이 생산성에 좋다.

예외적으로, `IsDead` 같은 자주 쓰이는 상태는 `UnitEntity`에 별도의 프로퍼티로 둬도 좋다. 

2. **읽기 전용 인터페이스를 추천한다.**

- [[Csharp - 읽기 전용 인터페이스]]에도 정리해뒀다. 내용은 비슷함.

즉 **`HealthSystem` 자체는 `private`으로 두되, `HealthSystem`에서 `public`으로 노출해도 되는 요소를 별도의 인터페이스로 분리해서 구현**하라는 것이다.

```cs
// 읽기 전용 인터페이스
public interface IReadOnlyHealth
{
    float CurrentHealth { get; }
    float MaxHealth { get; }
    event Action<float, float, float> OnHealthChanged;
    
    // 변경 메서드(ProcessDamage 등)는 여기에 포함하지 않음!
}

// 인터페이스가 적용되는 원본 클래스
public class HealthSystem : IReadOnlyHealth
{
    public float CurrentHealth { get; private set; }
    public float MaxHealth { get; private set; }
    // ... 나머지 구현
    
    // 이 메서드는 public이지만 인터페이스에는 없으므로,
    // 인터페이스로 접근하는 사람은 이 메서드의 존재를 모름
    public float ProcessDamage(AttackSource source) { /* ... */ }
}

// 최상위 클래스에서는
public class UnitEntity: MonoBehaviour
{
	// UnitEntity만이 알고 있는 실제 알맹이
	private HealthSystem _healthSystem;
	
	// 외부에 보여주는 껍데기
	public IReadOnlyHealth Health => _healthSystem;
	
	// 이제 외부 사용자는 실제 대미지 계산 로직에 접근할 방법이 없다.
	// UnitEntity에 있는 TakeDamage만 실행시킬 수 있음.
	public void TakeDamage(AttackSource source)
	{
		_healthSystem.ProcessDamage(source);
	}
}
```

이외에도 
- `HealthSystem`을 완전히 숨기고 필요한 정보만 프로퍼티로 `UnitEntity`에서 노출하기
	- 프로퍼티가 늘어날 때마다 `UnitEntity`에도 코드를 추가해야 해서 번거롭다.
- 개발 규칙으로 통제하기(주석, 메서드 이름 등으로 경고하기)
	- 실수를 100% 통제할 수 없다는 단점이 있다

> 참고 : 문법상 비슷해 보이지만 `인터페이스 -> 클래스`는 `구현Implementation`이라고 한다. 상속과의 차이라면 인터페이스의 구현은 자식 클래스에서 인터페이스에 명시된 메서드의 기능을 다 구현해야 한다는 것.

뭔가 애매한 지점들이 있어서 [[Csharp - 상속 vs 구현]]에도 정리했다.

- 요약
- **추상 클래스 vs 인터페이스 : 자체적으로 함수 기능 정의 가능 여부**
	- 추상 클래스는 자체적인 메서드를 정의할 수 있음. `new`로 정의할 수 없음 + 추상 메서드를 가질 수 있다는 게 일반적인 클래스와의 차이점.
	- 인터페이스는 자체적인 메서드를 정의할 수 없음. 메서드, 프로퍼티 이름과 타입을 정의할 수 있고 세부적인 내용은 무조건 다 자식에서 정의해야 함.
- **추상 메서드 vs 인터페이스 메서드 : 접근자**
	- 추상 메서드는 `protected`을 가질 수 있음
	- 인터페이스 메서드는 무조건 `public`이어야 함


# 251230 - 짭명방
- 어제 책 읽으면서 가장 뜨끔한 부분이면서 실제로도 고칠 필요가 있다고 생각한 부분이 있어서 그것부터 수정을 시도해본다.
	- 너무 빡세다 싶으면 하지 않는 것도 방법이다. 서비스를 목적으로 하는 프로젝트가 아니므로 이러한 리팩토링을 하더라도 향후에 큰 이익이 될 가능성이 적으며, 실제 게임의 진행에는 거의 영향이 없기 때문임.
	- 그래도 실력을 끌어올리겠다고 굳이 늘어지면서도 붙잡고 있는 프로젝트니까 이런 걸 해봐야 한다고 생각한다.
	- AI에게 맡겨도 되겠지만 내가 생각한 거 이상으로 작업하면 프로젝트가 내 머릿속에서 놀고 있다는 생각이 들지 않아서..


- **`Operator, Enemy`가 너무 `Monolithic(거대한 덩어리)` 구조다.**
	- 물론 모든 기능이 들어가 있지는 않다. 일부는 `pathNavigator`나 자식 오브젝트로 `Collider`를 별도로 빼두는 등의 작업은 되어 있음.
	- 그럼에도 `Operator`는 1100줄, `Enemy`는 800줄이며, 한 스크립트가 너무 많은 역할을 하고 있으며, 그 중에는 중복된 로직도 있음(대미지 처리)
		- 물론 차이점도 염두에 두면서 작업해야함

## 구현 과정
- 빡시다 빡셔~
> [!issue]
> 1. 시스템에 전달할 값들을 어디서 초기화하는가..
> 	- 어제 공부했듯 **중요한 건 자식 클래스는 부모 클래스가 하는 일을 몰라야 함**
> 	- 맥락보다는 단순한 기능만 수행하는 쪽에 가깝다고 생각하면 됨

- 일단 `HealthSystem`부터 구현 시작
	- 역시 이전에 짜놓은 유닛에 관한 `SO` 구조가 발목을 잡는다. 어렵다 어려버~
	- **메인 컨트롤러, 혹은 오브젝트에 구속되는 컴포넌트들은 `MonoBehaviour`을 상속받아서 만들 필요는 없다.** 메인 컨트롤러가 `new` 생성자로 만들어서 드는 형태가 좋음.

### 스탯 관련 구현하는 지점들
- 방어적인 역할을 하는 컴포넌트라면 방어 스탯만 전달하면 된다. 
- **모든 스탯을 한 곳에서 가지지 않아도 된다.** 각자가 필요한 곳에 위치하고 관리되면 됨
- 예를 들어 `HealthSystem`에서 `Attack`을 가질 필요는 없다. `StatSystem`을 구현하고 거기서 값들을 가져오는 방법도 있겠지만..


- `UnitData`의 초기화 관련 - `HealthSystem`에 값을 전달할 수만 있다면 상관없고, `UnitEntity` 자체는 `abstract`이기 때문에 `UnitData`로 값을 전달할 필요조차 없다. `HealthSystem`에 값을 어떻게 전달할지는 자식 클래스들에서만 고민하면 됨.





# 251229 - 독서
- (완) `읽기 쉬운 코드가 좋은 코드다`
	- 아이패드에 정리해뒀음.
- `게임 프로그래밍 패턴` - 로버트 나이스트롬
	- [[게임 프로그래밍 패턴 - 참고]]
	- 위 파일이 있는 폴더에 폴더별로 정리해뒀다. 20개라서 일일이 링크는 안해둠.

# 251228 - 독서
-  `읽기 쉬운 코드가 좋은 코드다`

# 251226

## 경로 로직 관련 테스트
- 경로가 바뀔 때 이전 위치로 돌아가는 현상이 신경쓰여서 이걸 해결해봄

`PathFindingManager`의 경로 탐색 로직은 현재 위치에 해당하는 그리드 위치를 찾은 다음 이후의 계산을 수행하는 방식이다. 여기서 "현재 위치에 해당하는 그리드 위치"라는 로직 때문에 뒤로 물러나는 현상이 발생하는 것으로 보인다. 

크게 2가지 방법이 떠오르는데
1. 받은 경로의 0번째 인덱스를 사용하지 않는 것
2. 경로 탐색 알고리즘을 아예 고치는 것
	- 현재는 `GridPosition`을 기반으로 한 알고리즘이다.

1번부터 시도해봤다. 기존 방식도 시작하자마자 인덱스를 다음으로 넘기는 방식이어서 비슷한 맥락이었는데, 잘 동작하는 것 같음.

> 대각선 진행 시에 한쪽에 언덕 타일이 있는 경우에 움직임이 부자연스러울 것 같았는데 생각보다 그런 현상이 발생하지 않아서 이대로 진행함

## 기타 이슈 수정
- `Enemy`가 사라질 때 딕셔너리에 풀 태그의 키가 없다는 오류
	- 이거도 간헐적인 이슈..

- 체력 회복 시에 `healthBar` 게이지가 이상하게 보이는 현상
	- 체력바 색깔을 반투명하게 바뀌었기 때문인 것으로 보임. 다시 불투명으로 바꿨다.


# 251224

>[!done]
>- `pathNavigator`로 코드를 옮기는 과정에서 발생한 이슈 처리 완료
>	- 기타 오류도 계속 나타나고 있음. 그건 테스트하면서 수정해야 할 듯
>- `statItem` 게이지 갱신 안되는 문제 수정

## 경로 계산 로직 이슈
1.  `UpdatePath`에 들어가는 현재 위치가 `currentStartPosition`이라는 변수로 되어 있는데, `(0, 0, 0)`으로 출력된다. 
	- 해당 좌표값을 따로 설정할 필요 없이 `owner.transform.position`을 필요할 때마다 가져오는 방식이 더 나아 보임

2. 이미 배치된 경우는 바리케이드 배치 시 돌아가지만 새로 나타났을 때는 영향이 없음
	- `IsPathBlocked`은 동작하는데 경로 업데이트가 안되는 듯
	- `pathNavigator` 자체의 로직도 잘 동작하는 듯 


3. `nextNodeIndex`의 관리
	- 지금은 상위 오브젝트에서 어떤 노드에 닿으면 `nextNodeIndex`를 업데이트하고 그걸 `pathNavigator`에 전달하는 방식임
	- 양쪽이 정보를 주고 받는 지금 구조는 이상함. 이것도 수정이 필요해보인다.

### 결국 또 리팩토링이 됨
- 기존 로직이 정상적으로 동작하고 있지 않기 때문에 어차피 해야 할 일이 됐다. 
- 다시 알아보기도 힘들기 때문에 이 참에 구조 정리를 싹 다시해본다.

> [!question]
> - 하위 클래스 `pathNavigator`는 상위 클래스의 계산기 역할을 할지, 아니면 경로에 관한 필드 / 메서드 보관소가 되어야 할지에 대한 생각이 든다. 
> 	- 전자 역할만 한다면 굳이 하위 클래스로 구현하지 않고 `static`으로 구현하는게 더 나아 보이기도 하고.

> 인스턴스화의 장점은 상위 클래스가 어떤 것인지 전달받을 수 있다는 것에 있음 
> - `Enemy`라면 `Barricade`를 부술 수 있지만, `PathIndicator`라면 굳이 그걸 전달받을 필요는 없음

#### 이벤트 등록 타이밍
```cs
navigator = new PathNavigator(this, pathData.Nodes);
navigator.OnPathUpdated += HandlePathUpdated;
```
`navigator`에서 데이터를 전달받고 `path`를 계산해서 다시 이 클래스로 전달하는 상황

경로가 업데이트 될 때마다 **`OnPathUpdate`를 `Invoke`하겠다면, 생성자와 실행 메서드는 별도로 구분하는 게 좋다.** 즉, 생성자에서는 상태만 전달하고 실제로 그 값들을 어떻게 이용할지는 `Initialize()`에 별도로 구현하라는 것.

대체로 정상적으로 작동하지만 여전히 버그가 있음
- (가끔) 모든 경로가 막혔음에도 바리케이드를 그대로 뚫고 지나가는 현상
- 경로 변경 시에 최단 경로가 아닌, 뒤로 한 번 빠꾸하는 현상


> - 정상 작동 상황
> 	- 진행 경로가 막혔을 때 `Enemy`가 바리케이드를 부수고 목적지까지 진행하는가?
> 	- 진행 경로 변경 시 엉뚱한 방향으로 새지 않는가?
> 		- 뒤로 한 번 빠꾸되는 경우가 가끔씩 발생한다. 왜 그런지는 모르겠음.
## 기타 이슈
- `StatisticItem` : 게이지가 업데이트에 반영되지 않는 현상
	- 값 추적은 잘 됨
	- 짐작이 가는 부분이 있음 : 이전에 `SquareSprite`를 지웠는데 이걸 지웠을 때 `Slider`가 제대로 동작하지 않는 현상이 있었음
	- 지금은 다시 새로 텍스쳐를 넣어둔 게 있어서 그거에 연결해봄

# 251223
- 잠깐 진행해봤는데 경로 탐색 로직이 제대로 동작하지 않음
- 바리케이드를 설치했을 때 경로가 변경되지 않는다든가
- 바리케이드를 그대로 뚫고 지나가버린다든가

이런저런 문제가 있어서 내일 만져봄

# 251222
>[!done]
>1. `MeteorSkill`의 태그를 찾지 못하는 현상
>	- 컨트롤러 태그를 못 찾아서 컨트롤러가 풀 회수가 안되는 현상이 있었음
>2. 동일한 경로를 쓰는 `PathIndicator`와 `Enemy`의 경로가 달라지는 현상
>	- 경로 탐색 로직의 `IsPathBlocked`의 이슈, 더 나아가서는 `Tile`의 `IsWalkable` 상태 관리에 관한 이슈가 있었다.
## 스테이지 1-3 및 기타 발생하는 이슈 수정

## 기타 이슈 수정

### MeteorSkill이 `HitTag`를 찾지 못하는 현상
```cs
private void CreateMeteor(Operator caster, Enemy target, float height)
{
	if (target != null)
	{
		Vector3 spawnPos = target.transform.position + Vector3.up * height;
		GameObject meteorObj = Instantiate(meteorPrefab, spawnPos, Quaternion.identity, target.transform);

		MeteorController? controller = meteorObj.GetComponent<MeteorController>();

		if (controller != null)
		{
			float actualDamage = caster.AttackPower * damageMultiplier;
			controller.Initialize(caster, target, actualDamage, fallSpeed, stunDuration, hitVFXPrefab, HitVFXTag);
		}
	}
}
```

크게 2가지 문제가 있다.
> 1. `meteorObj`를 풀에서 가져오지 않고 `Instantiate`로 즉각 생성한다는 점
	 - 큰 프로젝트가 아니니까 성능상 이슈는 아니고, 구조적인 일관성에 관한 문제.
> 2. `Controller` 자체에 대한 풀도 생성하지 않고 있음

1번은 아래처럼 해결 가능
```cs
GameObject meteorObj = ObjectPoolManager.Instance.SpawnFromPool(MeteorTag, spawnPos, Quaternion.identity, target.transform);
// GameObject meteorObj = Instantiate(meteorPrefab, spawnPos, Quaternion.identity, target.transform);
```
> 기존 `SpawnFromPool`이 `Transform parent`를 받지 않았기 때문에, 해당 메서드들에 `Transform? parent = null`을 추가로 넣어줌

2번 이슈의 경우 `Controller` 자체에 `ReturnToPool`이 있으나 정작 컨트롤러의 태그를 전달하지 않아서 발생한 문제였다. `Initialize`에 `ObjectPoolTag`을 전달하고 초기화 로직에 추가해서 해결함.

### PathIndicator가 지정된 경로와 다르게 움직이는 현상
- 추적해보면
```cs
public bool IsPathSegmentValid(Vector3 start, Vector3 end)
{
	if (MapManager.Instance == null) throw new InvalidOperationException("맵 매니저 인스턴스가 초기화되지 않음");

	Vector3 direction = end - start;
	float distance = direction.magnitude;
	RaycastHit hit;

	if (Physics.Raycast(start, direction.normalized, out hit, distance, LayerMask.GetMask("Deployable")))
	{
		// 레이캐스트 위치의 타일 확인
		Vector2Int tilePos = MapManager.Instance.ConvertToGridPosition(hit.point);
		Tile? tile = MapManager.Instance.GetTile(tilePos.x, tilePos.y);

		if (tile != null && tile.IsWalkable == false)
		{
			Logger.Log("[IsPathSegmentValid]목표 위치까지의 직선 거리 - Deployable이 있는 타일을 지나갈 수 없음");
			return false;
		}
	}

	// 타일 기반 검사 추가
	List<Vector2Int> tilesOnPath = GetTilesOnPath(start, end);
	foreach (Vector2Int tilePos in tilesOnPath)
	{
		Tile? tile = MapManager.Instance.GetTile(tilePos.x, tilePos.y);

		if (tile != null && tile.IsWalkable == false)
		{
			Logger.Log($"[IsPathSegmentValid]목표 위치까지의 직선 거리 - 지나갈 수 없는 타일이 있음 : ({tilePos.x}, {tilePos.y})");
			return false;
		}
	}

	return true;
}
```
여기서 아래 로직에 걸림 - 체크해보면 `StartTile`인데 `IsWalkable`이 `false`가 아닌데?

- 옛날에 구현해둔 `Tile`의 로직을 보면 크게 아래처럼 구성되어 있음
	1. `SetTileData` : 에디터에서 동작할 때 할당되는 요소들
	2. `Initialize` : 스테이지가 시작할 때 동작하는 요소들, `OnEnable`에 들어감.

적이 해당 타일을 지나갈 수 있는지 여부인 `IsWalkable`이라는 인게임 중에서만 동작하는 프로퍼티를 데이터에서 관리하겠다면, `Initialize`에서 해당 요소를 관리해야 함. 

### 경로 탐색 로직 자체의 이슈
>- 경로 탐색 로직 자체의 이슈
>	- 바리케이드를 배치했음에도 별도의 경로를 찾지 않는 문제. 그냥 뚫고 지나가버린다.
>	- 바리케이드의 위치를 마지막 노드로 취급해버리는 이슈도 있다.


내일 ㄱㄱ



# 251219 

## 어제 이슈
> [!done]
>1. `PathNavigator` 고치기
>	- 바리케이드가 경로에 있을 때 최초 경로가 리셋되어야 함
>2. `SO`의 태그 관리법 : `Stateless -> LazyLoading`으로 변경
>	- `SO`에서 `string`으로 선언하고 값 할당을 안했는데 `string.Empty`로 들어가는 이슈가 있어서 그것도 고침

### 해결
- 주로 `IsPathBlocked` 로직의 이슈였다. 이거 
```cs
for (int i = nextNodeIndex; i <= currentPath.Count - 1; i++)
{
	// 경로가 막힌 상황 : 기존 경로 데이터들을 정리한다
	if ((i == nextNodeIndex && PathfindingManager.Instance!.IsPathSegmentValid(owner.transform.position, currentPath[i]) == false) ||
		PathfindingManager.Instance!.IsPathSegmentValid(currentPath[i], currentPath[i + 1]) == false)
	{
		// pathData = null;
		currentPath.Clear();
		return true;
	}
}
```

조건문이 크게 2가지임
1. 현재 위치에서 다음 노드 위치
2. 다음 노드 ~ 그 다음 노드 위치

지금 조건문 자체도 직관적이지 않고, `currentPath.Count - 1`이라는 조건을 쓰면 `[i, i+1]`에서 걸릴 여지가 있음

그래서 아래처럼 수정

```cs
for (int i = nextNodeIndex; i < currentPath.Count; i++)
{
	// 1. 현재 위치에서 다음 노드 체크 (첫 번째 루프에서만)
	if (i == nextNodeIndex)
	{
		if (!PathfindingManager.Instance!.IsPathSegmentValid(owner.transform.position, currentPath[i]))
			return true;
	}

	// 2. 노드와 노드 사이 체크 (마지막 노드가 아닐 때만)
	if (i < currentPath.Count - 1)
	{
		if (!PathfindingManager.Instance!.IsPathSegmentValid(currentPath[i], currentPath[i + 1]))
			return true;
	}
}
```

> 너무 오래 걸렸다. 오늘 발견한 것까지만 하고 리팩토링은 그만 하자..


## 새로 발견한 이슈
> [!issue]
> - SO에서의 태그 관리법에 관해

오브젝트 풀링을 관리하는 방법은 다양하다. **지금의 `string` 기반으로 관리하는 것도 문자열 비교로 인한 비용을 생각하면 프로젝트가 커졌을 때는 부적합할 수 있다**고 함.

하지만 **그것까지 또 싹 바꾸는 건 비용이 많이 들기 때문에 보류한다.**

대신 지금의 태그가 필요할 때마다 생성해서 뱉는 방식은 수정하려고 함 : `Lazy Caching`

### Lazy Caching
- 필요할 때 한 번 생성하고, 그 뒤로는 계속 접근해서 사용하는 방식임
```cs
private string _projectileTag;
public string ProjectileTag 
{
    get
    {
        if (string.IsNullOrEmpty(_projectileTag))
            _projectileTag = $"{entityID}_Projectile";

        return _projectileTag;
    }
}

// C# 8.0부터는 프로퍼티를 이렇게 정의할 수도 있음
public string ProjectileTag => _projectileTag ??= $"{entityID}_Projectile";
```
>- `entityID`가 변경되지 않는 이상 안전 : 내 프로젝트에서도 대부분의 경우 이러함
>- **`Setter`를 쓰지 않는 이유** : 외부에서 바꿀 수 없는 + 시스템의 규칙으로만 결정되기 때문이다. 외부에서 임의로 바꿀 수 없기 때문에 세터를 별도로 정의하지 않는다.


#### SO에서 이런 식으로 정의해도 괜찮은 건가?
- 유니티의 `SO`는 2가지 특징이 있다.
1. **데이터 애셋** : 디스크에 저장되는 정적인 설정값
2. **매모리 객체** : **게임 실행 중 힙 메모리에 존재하는 객체**
- 데이터 애셋인 `entityID`를 건드리지 않으면서 메모리 객체로서의 성능을 최적화하는 기법이다. 즉, 원본과 런타임 성능을 위한 데이터를 분리하는 것이므로 객체지향적 관점에서도 맞다.

### 진행 중 이슈

#### 1. Skill에서의 ownerData 의존성

- `OperatorData, EnemyData`에서 정의되는 요소는 상관 없음
- `Skill`등에서 기존 설정이 아래와 같았음
```cs
public string GetMeleeAttackVFXTag(OperatorData ownerData) => $"{ownerData.EntityID}_{skillName}_MeleeVFX";
```

이런 패턴의 경우 `ownerData`에 의존하기 때문에 지금 같은 패턴을 사용할 수 없음

이거는 프로젝트의 상황에 따라 달라지겠지만, **내 프로젝트의 경우 오퍼레이터 A가 쓰는 스킬과 오퍼레이터 B가 쓰는 스킬이 똑같더라도 이펙트가 달라질 필요는 없음**

따라서 `ownerData`에 의존하는 방식을 제외할 수 있음

단, 이것도 생각해야 함 : 오브젝트 풀을 만들 때 이미 있는 풀에 새로운 풀을 추가하는 경우에 대한 처리
```cs
public void CreatePool(string tag, GameObject prefab, int size = 3)
{
	// 이미 풀이 존재한다면 생성하지 않음
	if (IsPoolExist(tag)) return;

	Queue<GameObject> objectPool = new Queue<GameObject>();
	poolInfos[tag] = new Pool { tag = tag, prefab = prefab, size = size };

	for (int i = 0; i < size; i++)
	{
		GameObject obj = Instantiate(prefab);
		objectPool.Enqueue(obj);
		obj.SetActive(false);
	}

	poolDictionary[tag] = objectPool;
}
```

기존에는 이미 있다면 생성하지 않았는데, 이미 있는 풀에 새로 생성하겠다는 요청이 들어오면 `size` 만큼 이미 있는 풀에 추가해줌
```cs
if (IsPoolExist(tag))
{
	Queue<GameObject> existingPool = poolDictionary[tag];
	for (int i = 0; i < size; i++)
	{
		GameObject obj = Instantiate(prefab);
		existingPool.Enqueue(obj);
		obj.SetActive(false);
	}
	return;
}
```

#### 2. Pool 클래스 수정
- `ObjectPoolManager`의 `Pool`을 보면
```cs
public class Pool
{
	public string? tag;
	public GameObject? prefab;
	public int size;
}
```
...으로, 정작 실제 풀인 `Queue<GameObject>`는 별도로 정의되어 있음.

얘도 통합해준다. `ObjectPoolManager`의 기능을 거의 다 여기로 옮기고, 매니저는 풀과 연결만 해주는 방식으로 수정됨. 기능은 `Pool(지금은 ObjectPool)` 내에 다 구현하는 방식임.

### 테스트하고 마무리
- `Operator` 태그만 동작하지 않음. `DeployableUnitEntity`나 `Enemy`는 잘 동작함.
	- `DeployableInfo`의 `poolTag`에 할당하는 값 이슈로 보인다.

- `SO` 태그들 조정한 건 아래 조건문에 걸렸다.
```cs
if (tag == string.Empty)
{
	Logger.LogError("[ObjectPoolManager.CreatePool]비어 있는 태그 값이 들어옴");
	return;    
}
```

그러면 프로퍼티들이 제대로 할당되지 않는다는 의미임;
위에서 `??=` 연산자를 썼고, `string`으로 선언했다.
**값을 할당하지 않았음에도 상태가 `string.Empty`로 나타나고 있다.**
그래서 `SO`가 조금 더 길어질 예정.

```cs
// 기존 방식 - 왜인지 몰라도 null이 아닌 string.Empty로 초기화되고 있음
protected string _projectileTag;
public string ProjectileTag => _projectileTag ??= $"{entityID}_Projectile";

// 이렇게 바꿈
public string UnitTag
{
	get
	{
		// _unitTag가 null이거나 ""(빈 문자열)이면 기본값 할당
		if (string.IsNullOrEmpty(_unitTag))
		{
			_unitTag = $"Operator_{entityID}";
		}
		return _unitTag;
	}
}
```

- 다 수정하고 오류 안 뜨는 거 확인했음
- 물론 혹시나가 있을 수 있지만 오늘은 여기까지

12시 20분이넹;;
# 251218
>[!done]
>- 어제 발생한 `Spawner`가 제대로 시작되지 않는 문제 수정
>- `Logger.Log("fieldName : {fieldName}")`처럼 값과 이름을 함께 출력하기 위한 디버깅용 어트리뷰트`[CallerArgumentExpression]` & 메서드 정의
>- `Enemy`의 길 찾기 기능 `PathNavigator`로 분리
## 어제 발생했던 문제 수정
- `Spawner` 맵 시작시 제대로 초기화되지 않는 문제
	- **그냥 `EnemySpawnerConfig`에 필드 할당이 안 되어 있어서 발생한 문제다.** 
	- 어제 수정하면서 여기 할당됐던 요소들도 다 초기화된 것 같음. 
## 디버깅 기능 추가 및 CallerArgumentExpressionAttribute 정의
>너무 늦게 추가하는 감이 있지만, 계속 반복해서 설정하는 요소이기도 했기에 이 참에 정의해둔다.

- 디버깅용 : 필드 이름과 상태를 함께 출력하기 위한 메서드 추가
```cs
// 특정 필드의 이름과 값 확인하는 메서드
[System.Diagnostics.Conditional("UNITY_EDITOR")]
public static void LogFieldStatus(object fieldValue, [CallerArgumentExpression("fieldValue")] string fieldName = "")
{
	// Debug.LogError(message);
	Debug.Log($"{fieldName} : {fieldValue}");
}
```

> AI가 던져준 코드인데, 이 자체로는 `CallerArgumentExpression`을 사용할 수 없음

- 유니티 6.3버전의 C#은 9.0버전이다. 컴파일러 `Roslyn`은 최신 버전이라 해당 기능을 알지만, 유니티의 `.NET` 라이브러리에 해당하는 기능의 이름표`Attribute`이 없다.

그래서 아래처럼 `CallerArgumentExpressionAttribute`를 정의해서 어떤 기능을 쓰라는 의미인지 전달해줘야 함

```cs
namespace System.Runtime.CompilerServices
{
    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    internal sealed class CallerArgumentExpressionAttribute : Attribute
    {
        public CallerArgumentExpressionAttribute(string parameterName)
        {
            ParameterName = parameterName;
        }

        public string ParameterName { get; }
    }
}
```

- `Attribute` 및 이 기능을 어떻게 사용할지 정의하고 이어붙이는 과정 자체가 낯설어서 좀 파고들어봤다. [[Unity - Attribute 정의]]

> 1. `CallerArgumentExpression`은 변수를 그 변수의 이름 자체로 출력시키는 어트리뷰트.
> 	- 해당 기능은 라이브러리에서 자체적으로 다 구현되어 있고, `CallerArgumentExpression`이라는 어트리뷰트가 붙는 경우에만 실행되도록 이미 설정되어 있음
> 2. **지금 없었던 건 `CallerArgumentExpressionAttribute`라는 클래스임.**
> 	- 라이브러리 내부에 있는 함수를 실행시키기 위한 스위치 개념
> 3. 그래서 `[CallerArgumentExpression]`으로 파라미터에 들어가는 변수를 이름으로 출력시킬 수 있게 구현한 것이다. 기능이 아니라 스위치를 구현했다고 생각하면 됨
> 4. 위에서 `string name = ""`으로 설정한 건 기본값을 달아둬서 일일이 인자를 전달시키지 않게 하기 위함이다. 

이제 `Logger.LogFieldStatus(number)`를 집어넣으면 `number : 1`으로 출력된다.

> 이미 있는 기능인데 빠져 있어서 채워넣는 방식을 `PolyFill`이라고 한다.

## Barricade에 따른 PathIndicator 이동 경로 반영하기
- 기존에는 경로 탐색 로직이 `Enemy` 내에 있었다.
- 경로를 탐색하는 로직은 `PathNavigator`라는 별도의 클래스를 만들어두고, `Enemy`와 `PathIndicator`에서 이를 이용하는 방식으로 수정하겠음

> 이 부분이 완료되지 않음

# 251217

## 세부 사항 수정
- `TestManager` : 빠른 테스트를 위해 **인스펙터에서 입력할 수 있는 스테이지 클리어, 레벨업, 스쿼드 편성 및 스킬 지정 등의 기능**을 구현
- `Stage1-3` : 카메라 위치 수정

## 기타 이슈 수정

### PathIndicator 관련
>[!issue]
>- `Barricade`가 배치된 상황에서, 경로를 보여주는 `PathFinder`가 진행하는 경로도 달라져야 하는데 변경된 경로가 반영되지 않는 현상

1. 일단 `PathIndicator`의 태그 관리하는 부분
	- 별도의 `SO`가 없기 때문에 일단 `ObjectPoolManager`에서 관리한다.
	- [[Unity - 필드 초기화 vs Awake에서 할당]] 참고.
		- 필드 값 할당을 어디서 해야 하는 게 적절한가?
	- `ObjectPoolManager.PathIndicatorTag`로 쓸 수 있다. `const`는 `static`으로 설정되어서 `Instance`를 생략할 수 있음.



### EnemySpawner의 Instantiate를 오브젝트 풀링 기반으로 변경
>[!issue]
> `EnemySpawner`에서 적 생성은 `Instantiate`로 되고 있었음

- 기존 `spawnData`를 보면 아래 구성인데
```cs
[System.Serializable]
public class EnemySpawnData
{
    public SpawnType spawnType;
    public float spawnTime = 0f;
    public PathData pathData = default!; // StageData에서는 경로 데이터를 직접 참조하도록 수정
    public GameObject prefab = default!; // 스폰되는 종류가 다양할 수 있기 때문에 EnemyData를 사용하지 않음

    [Tooltip("spawnType = Enemy일 때만 사용")]
    public EnemyType enemyType;
}
```
> - 여기서 `prefab`을 지우고 `EnemyData`를 할당하는 식으로 변경하면 될 듯
> - 저 주석 내용에 해당하는 경우가 `PathIndicator`밖에 없어서 괜찮을 것 같기도?


---
`spawnData`의 구조, 접근자 수정 및 프로퍼티 구현, 오브젝트 풀링 기반으로 변경하면서 발생하는 이슈들 수정하는 중..




# 251216

## 스테이지 1-3 구현

### 경로 구현
- 크게 5가지의 경로를 구현했다. 각 스폰 지점마다 2개씩 + 보스 경로는 별도로 구현
- `PathData`에는 기다리는 시간도 있는데, 지금처럼 `Barricade`로 처리하는 경우에는 경로가 다시 초기화되기 때문에 기다리는 시간을 설정하는 것에 큰 의미는 없어 보임.
	- 대신 이전 스테이지에서 사용해야겠다. 
	- `Tanker` 같은 캐릭터들이 바로 진행되지 않게 하는 느낌으로. 




# 251215

>[!done]
>- 테스트 용
>	- 어디까지 클리어했는지에 대한 기능 구현

>[!wip]
>- 스테이지 밸런스 수정 / 1-3 스테이지 구현

## 스테이지 밸런스 수정 / 1-3 스테이지 구현
- 1-3에 구현할 요소들이라면 바리케이드 + 복수의 스폰 장소 + 보스 인데
- 보스 패턴은 이미 구현을 해놨고
- **바리케이드를 활용시키기 위한 맵 디자인?** 이게 좀 고민임
	- 오퍼레이터가 8명 뿐이라서 맵 크기를 키우는 데 한계가 있어보임
	- 맵이 너무 클 수가 없어서 바리케이드를 활용시키기 위한 빙글빙글 돌리는 구성이 어려움
	- 맵이 너무 커지면 카메라도 멀어져야 하는 점도 별로고.

- 일단은 이런 느낌으로 시작해보겠음. `1-3New`라는 이름으로 만들어놨다.
![[Pasted image 20251215231134.png]]

## 기타 이슈 수정
### `Caster - ArcaneFieldSkill` 
- 스킬을 썼는데 위치가 나타나지 않는 이슈가 있음

### 테스트용 - 어디까지 클리어했는지 TestManager에 구현

#### 접근 1. enum 타입으로 스테이지들을 정의, 재귀함수로 클리어된 스테이지들 처리
- 이 프로젝트는 스테이지가 4개니까 이렇게 접근해도 상관은 없는데, 추후에 더 큰 프로젝트를 한다면 이 방법은 `enum`타입이 늘어진다는 단점이 있음.

딱 떠오르는 게 없어서 제미나이에게 물어봄

#### 접근 2. 스테이지들을 관리하고 있다면 `List.IndexOf`를 활용
- 내 프로젝트의 경우 `GameManagement.StageDatabase`라는 오브젝트에서 `StageData`들을 갖고 있다. 이는 `List`이며 Index 순서대로 `1-0` ~ `1-3` 순서대로 집어넣은 방식임.

이걸 활용한다. `TestManager`에서는 `string stageId` 값을 받아서 해당 스테이지까지는 플레이된 것으로 처리할 수 있음.

```cs
// targetStageId 까지의 스테이지들을 클리어한 것으로 처리함
private void InitializeStageProgressForTest(string? targetStageId)
{
	List<StageData> allStages = GameManagement.Instance.StageDatabase.StageDatas.ToList();

	// 목표 스테이지의 리스트에서의 인덱스를 찾음(StageDatabase에 StageData들이 순서대로 정렬되어 있다는 전제에서만 성립하는 코드)
	int targetIndex = allStages.FindIndex(stage => stage.stageId == targetStageId);

	if (targetIndex == -1)
	{
		Logger.LogError($"[TestManager] {targetStageId}에 해당하는 stage를 찾지 못함");
		return;
	}

	for (int i=0; i < allStages.Count; i++)
	{
		StageClearAndGetRewards(allStages[i].stageId, 3);
	}

	// Gemini가 던져준 코드에는
	// List.TakeWhile로 targetStageId에 해당하지 않는 스테이지들의 리스트를 만들어서 클리어 처리하는 방법도 있음
	// 하지만 저 방식은 나중에 봤을 때 직관적이진 않고 targetStageId에 오타가 있다면 모든 스테이지를 클리어 처리한다는 단점이 있음
}
```

![[Pasted image 20251215174741.png]]
> 이렇게 관리되고 있기 때문에 성립하는 코드임




# 251212

>[!done]
>- 스테이지 밸런스 수정
>	- 오퍼레이터 재배치 시간 : 60초 -> 40초
>	- 뱅가드 재배치 시간 : 30초 -> 20초
>	- 1-2까지 얼추 된 듯
>- 충돌 로직 이슈 수정
>	- `OverlapSolver`가 없는 `DeployableUnitEntity`의 미리보기 중에 오류 발생하는 현상
>	- `Enemy_Ghost`는 저지당하지 않아야 하는데 `DeployableUnitEntity`와 부딪혔을 때 통과하지 않고 멈추는 현상
>		- 저지 로직이 작동한 게 아니라 부딪혀서 진행을 못한 현상임
>- 기타 이슈 수정
>	- 배속 / 일시정지 / 저속 관련 꼬이는 현상 수정

## 스테이지 밸런스 수정
- 오퍼레이터 재배치 시간 60초 -> 40초
- 뱅가드 재배치 시간 30초 -> 20초

## 기타 이슈 수정

### `Barricade` 미리보기 중에 `Enemy`와 충돌 시 오류 발생하는 현상 수정
```cs
UnitOverlapSolver otherUnit = other.GetComponentInParent<UnitOverlapSolver>();

// 기존 위치
// if (otherUnit.gameObject == gameObject) continue;

if (otherUnit != null)
{
	// 이동 위치
	if (otherUnit.gameObject == gameObject) continue;
```
> - 콜라이더가 있는 유닛 중, 부모 오브젝트에 `UnitOverlapSolver` 컴포넌트를 넣지 않은 것들이 있음 - 이런 조건들은 `otherUnit != null`에서 걸러지도록 설정함
> - 자기 자신을 판단하는 로직도 `otherUnit != null` 안에서 실행되어야 함


### `Enemy_Ghost`의 저지 무시하고 통과하는 로직 동작 안 함
- 어제 충돌 로직 구현하면서 발생하는 현상인 듯?
```cs
private bool CheckConditionAboutDeployable(UnitOverlapSolver otherUnit)
{
	DeployableUnitEntity otherDeployable = otherUnit.GetComponent<DeployableUnitEntity>();
	if (otherDeployable != null && otherDeployable.IsPreviewMode) return true; // 미리보기 중에는 이 스크립트로 인한 처리 진행 X
	return false;
}
```

상대가 그냥 `Deployable`이기만 하면 충돌 로직을 처리할 수 있도록 구현되어 있음
그런데 실제로 자신이 저지당하는 중일 때에만 동작하도록 수정해야 함

- [[짭일방주 - 겹쳤을 때 충돌 구현]]
```cs

if (otherUnit != null)
{
	// 자기 자신은 제외
	if (otherUnit.gameObject == gameObject) continue;

	// 충돌 처리 조건 체크 - false일 때는 처리하지 않음
	if (!CheckCollideCondition(otherUnit)) continue;

// ...


// true일 때 충돌 처리 진행, false일 때 진행하지 않음
private bool CheckCollideCondition(UnitOverlapSolver otherUnit)
{
	if (selfEnemy == null) return false;

	// 1. 상대가 Deployable일 때의 처리
	DeployableUnitEntity otherDeployable = otherUnit.SelfDeployable; 
	if (otherDeployable != null)
	{
		// 날 저지하는 중일 때에만 처리
		if (selfEnemy.BlockingOperator == otherDeployable) return true;
		return false; 
	}

	// 2. 상대가 Enemy일 때의 처리
	Enemy otherEnemy = otherUnit.SelfEnemy;
	if (otherEnemy != null)
	{
		// 두 Enemy가 모두 저지당할 때에만 동작함
		if (selfEnemy.BlockingOperator != null && otherEnemy.BlockingOperator != null) return true;
		return false;
	} 

	return false; 
}
```

이런 식으로 처리해놨음. `Ghost`가 `Deployable`과 부딪혔을 때 멈추는 현상이 수정됨.

### 2배속 중 오퍼레이터 선택 -> 취소 동작 시 배속이 풀리는 현상
- `IsSpeedUp` 상태의 이슈보다는 `Time.timeScale`을 직접 건드리면서 발생하는 문제 같음

- `DeployableUnitEntity.OnClick`에서 배치된 유닛을 클릭할 때 `Time.timeScale = 1f`으로 설정하는 부분이 있음 - 이게 문제인 것으로 보인다.

> - 원본 명방을 체크해봤는데 배치된 오퍼레이터를 선택했을 때는 저속으로 작동함
> - 스킬 발동 타이밍이 중요하기 때문인데, **프로퍼티의 세터로만 시간을 컨트롤하도록 수정**함

```cs
private bool _isSpeedUp = false; 
public bool IsSpeedUp
{
	get => _isSpeedUp;
	set
	{
		if (_isSpeedUp != value)
		{
			_isSpeedUp = value;
			Time.timeScale = _isSpeedUp ? 2f : 1f; 
			// 시간 변화 이벤트 발생
			OnSpeedChanged?.Invoke(_isSpeedUp, _slowState);
		}
	}
}

private bool _slowState = false; 
public bool SlowState 
{
	get => _slowState;
	set
	{
		if (_slowState != value)
		{
			_slowState = value;

			if (_slowState) 
			{
				Time.timeScale = 0.2f;
			}
			else
			{
				Time.timeScale = _isSpeedUp ? 2f : 1f; 
			}

			OnSpeedChanged?.Invoke(_isSpeedUp, _slowState);
		}
	}
}
```
더 좋은 방법이 있는지는 모르겠다. 일단 이렇게 구현해둠

> 추가 : `DeployableUnitEntity.Onclick`하자마자 시간 속도를 느리게 만들었는데, 카메라 전환 속도도 느려져서 어색해보이는 곳이 있다. 

1. 오퍼레이터를 클릭했을 때는 카메라 회전 후 느리게 만들기
2. 클릭 해제 시에는 원래 속도로 되돌린 후 카메라 원위치

코루틴을 사용하기 때문에 처음에는 메서드를 분리했는데, 제미나이에게 물어보니 **콜백을 활용할 수 있다고 함.**
```cs
private IEnumerator LerpPositionAndRotation(Transform transform, Vector3 targetPosition, Quaternion targetRotation, float duration, Action onStart = null, Action onComplete = null)
{
	onStart?.Invoke();

	Vector3 startPosition = transform.position;
	Quaternion startRotation = transform.rotation;

	float time = 0;
	while (time < duration)
	{
		transform.position = Vector3.Lerp(startPosition, targetPosition, time / duration);
		transform.rotation = Quaternion.Slerp(startRotation, targetRotation, time / duration);

		time += Time.deltaTime;
		yield return null;
	}
	transform.position = targetPosition;
	transform.rotation = targetRotation;

	onComplete?.Invoke();
}
```

실제 사용은 아래처럼 한다. 할당되지 않은 Action들에 대해선 null 오류가 발생하지 않음 (`?`때문에)
```cs

	_currentCoroutine = StartCoroutine(LerpPositionAndRotation(MainCamera.transform, newPosition, infoRotation, animationDuration, 
		onComplete: () => StageManager.Instance.SlowState = true));
}

else
{
	// 카메라 이동 및 회전 (시작 시에 Slow 해제)
	_currentCoroutine = StartCoroutine(LerpPositionAndRotation(MainCamera.transform, originalPosition, baseRotation, animationDuration,
		onStart: () => StageManager.Instance.SlowState = false ));
```


### Pause를 풀었을 때 속도가 돌아오지 않음
- ~~시간 매니저 냅둘 걸 괜히 지웠다..~~
- `Battle`로 `GameState`가 바뀔 때 `Time.timeScale` 주석처리했는데 그게 문제가 됐던 걸로 보임
- `StageManager`에 `HandleTimeScale`을 새로 만듦
```cs
private void HandleTimeScale()
{
	if (currentState == GameState.Battle)
	{
		if (_slowState) 
		{
			Time.timeScale = 0.2f;
		}
		else
		{
			Time.timeScale = _isSpeedUp ? 2f : 1f; 
		}
	}
	else
	{
		Time.timeScale = 0f;
	}
}
```
> - 이제 `Time.timeScale`을 쓰는 부분들은 다 이 메서드를 호출함
> - 이 메서드는 `public`으로 쓰이는 프로퍼티들`CurrentGameState, IsSpeedUp, SlowState`의 **세터가 동작할 때 함께 호출됨**

이런 메서드들도 축약 가능해짐
```cs
// 게임의 상태를 변경하고 그에 맞는 시간 속도 지정
public void SetGameState(GameState gameState)
{
	CurrentGameState = gameState; // 프로퍼티로 써야 세터가 동작함

	// switch (gameState)
	// {
	//     case GameState.Battle:
	//         break;

	//     case GameState.Paused:
	//     case GameState.GameOver:
	//     case GameState.GameWin:
	//         break;
	// }
	
	// HandleTimeScale();
	StageUIManager.Instance!.UpdatePauseButtonVisual();
	// 다른 필요한 상태 관련 로직...
}
```
> `UpdatePauseButtonVisual`도 사실 `CurrentGameState` 세터에서 발생하는 이벤트를 구독하는 방식으로 작업하는 게 더 나을 것 같긴 한데 지금도 잘 동작하니까 유지함




# 251211

>[!done]
>- 기타 이슈 수정
>	1. 마법 대미지가 제대로 반영되지 않는 현상
>		- 수정 완료 : 대미지 타입 불러오는 부분의 이슈
>		- 기타 `enum` 타입으로 정의된 타입들의 `0`번은 다 `None`으로 설정
>		- 버프가 켜졌을 때 공격 타입이 물리로 바뀌는 현상도 있었음 : 수정 완료.
>	2. `DualBlade`의 2번째 스킬에서 VFX를 찾지 못하는 문제 수정
>		- `PreloadObjectPools` 메서드에서 상속이 제대로 되지 않던 이슈 수정
## 스테이지 조정 : 1-2
- 지금 전체적으로 답답해지는 부분은 `Enemy_Tanker` 때문인 것 같음
- `Caster`나 `DualBlade`의 마법 공격으로 공략하라는 기믹이긴 한데 정작 `Tanker`에게 대미지가 들어갔을 때 별로 티가 안 남

### 마법 대미지가 제대로 반영되지 않는 현상
`UnitEntity.TakeDamage`에서 아래 로그를 찍어봤다.
```cs
if (source.Type == AttackType.Magical)
{
	Logger.Log($"들어간 마법 대미지 : {remainingDamage}");
}
```

근데 로그가 안 나타남. 
#### 구조 수정
- **`_currentAttackType`에 반영이 안 되어 있고, `enum AttackType`의 디폴트값이 `Physical`이기 떄문에 발생하는 문제** 였던 것으로 보임
	- 구조상 **`enum` 타입의 0번에 두는 값은 사용하지 않는 값**으로 두는 게 좋아보인다. 

> 근데 `enum` 한 번 고치니까 기존에 짜놨던 거 다 꼬였다. 배운 값이 좀 비싸네..

#### 스킬 켜졌을 때 다시 물리 대미지로 돌아가는 현상 발생
- 이거도 위에서 `AttackType` 관련 설정 때문에 발생하는 현상임
- `AttackType`의 0번을 `None`으로 뒀고, 설정이 없을 때는 `Operator`에 설정된 `AttackType`을 따라가도록 구현함

## 기타 이슈
### `DualBlade` 2번째 스킬 - VFX 못 찾는 문제
- `PreloadObjectPools(OperatorData opData)`의 상속 방식이 이상했음. 
- `OperatorSkill -> ActiveSkill -> ...`으로 이어져야 하는데 부모에서 정의해 놓은 걸 자식에서 이용하지 않는다든지 하는 이슈 등이 있었다.
```cs
// OperatorSkill.cs
public virtual void PreloadObjectPools(OperatorData ownerData)
{
	// 근접 공격 VFX 변경
	if (meleeAttackVFXOverride != null)
	{
		ObjectPoolManager.Instance.CreatePool(GetMeleeAttackVFXTag(ownerData), meleeAttackVFXOverride, 2);
		Logger.Log($"{name}의 풀 : {GetMeleeAttackVFXTag(ownerData)} 등록 완료");
	}
}

// 자식 : ActiveSkill.cs
public override void PreloadObjectPools(OperatorData opData)
{
	base.PreloadObjectPools(opData);

	if (durationVFXPrefab != null)
	{
		ObjectPoolManager.Instance.CreatePool(GetDurationVFXTag(opData), durationVFXPrefab, 1);
	}
}

// 실사용 : Operator.PlayMeleeAttackEffect
protected virtual void PlayMeleeAttackEffect(Vector3 targetPosition, AttackSource attackSource)
{

	string effectTag = _operatorData.GetMeleeAttackVFXTag();

	var vfxBuff = activeBuffs.FirstOrDefault(b => b.MeleeAttackVFXOverride != null);
	if (vfxBuff != null)
	{
		effectTag = vfxBuff.SourceSkill.GetMeleeAttackVFXTag(_operatorData);
	}
        
        if (!string.IsNullOrEmpty(effectTag))
        {
	        // 이제 스킬 스크립트에서 풀을 생성하므로 이것도 정상적으로 동작함
            GameObject? effectObj = ObjectPoolManager.Instance!.SpawnFromPool(
                   effectTag,
                   transform.position,
                   Quaternion.identity
           );
```




# 251210

>[!done]
>1. 고장난 Slider 기반 컴포넌트 고치기
>2. 충돌로 인한 살짝의 위치 변화 구현

> [!wip]
> - 스테이지 조정
> 	- `1-2` 진행 중

## 고장난 Slider 기반 컴포넌트들 고치기
- 현재 발생 중인 이슈
	- `SPBar`의 로그를 찍어보면 상태값은 정상적으로 추적되는 상태인데 유니티의 이미지 갱신이 되지 않음

- 수정 완료
	- 이전에 `square_sprite`를 지우면서 기존 `Source Image`들의 `Texture`가 `None`이 됐는데 그거 관련 이슈로 보인다
		- 근데 `HealthBar`는 없이도 잘 작동하는데 얘는 왜 그러는지 모르겠다.
	- `SPBar`는 `Slider` 기반으로 동작하도록 수정, `AmmoMode` 활성화 시 `Slider`는 비활성화

- 비슷한 이슈가 코스트 회복 게이지에서도 발생, 수정 완료

## 스테이지 밸런스 조정


## Enemy 완전히 겹칠 경우 살짝 이동하도록 수정
- 겹칠 때 `UI`가 보이지 않아서 헷갈린다. 아군이 적을 치더라도 누굴 치는지 헷갈리는 상황이 있음

> 원본은 배치될 때 적 유닛을 살짝 밀어내는 로직이 들어가 있을 거다
> 	- 이걸 이용한 테크닉으로 두 타일에 걸치게 만들어서 양쪽에서 동시에 타격 가능하게 하는 방법도 있음

- 원래는 UI만 살짝 이동시키려고 했는데, 하는 김에 제대로 구현해보자.

일단 무지성으로 제미나이에게 질문하고 받은 스크립트에서 시작함. [[짭일방주 - 겹쳤을 때 충돌 구현]]

```cs
hitCount = Physics.OverlapSphereNonAlloc(transform.position, bodyRadius * 2, hitColliders, unitLayer);
```
위 스크립트를 이용해서  레이어 기반으로 콜라이더 판정을 이용해서 밀어내는 기능만 있는 상태다.


![[MovementEarthQuake.gif]]
>ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 지진났네

### 떨리는 현상 발생 및 수정

- 개요
스크립트 이름은 `UnitOverlapSolver`이며, `Enemy, Operator`의 가장 부모 스크립트 위치와 동일한 오브젝트의 컴포넌트로 위치해 있다. 이 스크립트가 동작하는 조건은 `Overlap`을 쳤을 때 범위 내에 동일한 스크립트가 있는 것.

- 문제 상황
**등장부터 신나게 흔들린다. 다른 오브젝트가 없어도 흔들림.**

- 아래처럼 로그를 찍어봄
```cs
for (int i = 0; i < hitCount; i++)
{
	Collider other = hitColliders[i];

	if (other.gameObject == gameObject) continue;

	// 유닛 콜라이더는 자식 오브젝트로 둠 -> 부모에서 이 스크립트를 찾아야 함
	UnitOverlapSolver otherUnit = other.GetComponentInParent<UnitOverlapSolver>();

	if (otherUnit != null)
	{
		Logger.Log($"다른 오브젝트 {otherUnit.gameObject.name}를 찾아서 충돌 로직 계산 시작");
		
		// ...
```

> 여기서 `otherUnit.gameObject.name`이 자기 자신의 오브젝트가 나타나고 있음 
> - 콜라이더의 위치는 자식 오브젝트라서 위의 `continue` 조건문이 제대로 동작하지 않음. 
> - 왜냐하면 `other.gameObject`는 콜라이더가 위치한 자식 오브젝트인데 `gameObject`는 이 스크립트가 위치한 부모 오브젝트이기 때문임
> - 따라서 `if`문을 아래로 이동시키고, `otherUnit.gameObject == gameObject` 조건으로 수정해주면 된다. 고 생각해서 수정

```cs
	UnitOverlapSolver otherUnit = other.GetComponentInParent<UnitOverlapSolver>();
	
	// 위치 이동 및 조건 수정
	if (otherUnit.gameObject == gameObject) continue;
```

> 일단 이거는 의도한 대로 잘 동작한다. 계속 테스트 ㄱㄱ
### 계속 테스트

- `Enemy` 1개가 저지 당하는 중에 다른 `Enemy`가 비슷한 위치로 진입할 때 고정된 `Enemy`가 스윽 밀려버리는 현상이 있음
	- 반지름을 줄이면 되지 않을까? `0.2` 정도인데 `0.05`로 수정해봄
	- **이거 갖고는 부족한 듯**

- `Deployable`, `Enemy` 관련 조건들을 추가함
	- `Deployable`는 배치된 후에만 동작함.
	- `Enemy`의 경우는 이 스크립트를 갖고 있는 자신과 상대가 모두 저지 당하는 중일 때에만 동작함.
```cs
    // 충돌한 상대가 Deployable일때 조건 체크
    private bool CheckConditionAboutDeployable(UnitOverlapSolver otherUnit)
    {
        DeployableUnitEntity otherDeployable = otherUnit.GetComponent<DeployableUnitEntity>();
        if (otherDeployable != null && otherDeployable.IsPreviewMode) return true; // 미리보기 중에는 이 스크립트로 인한 처리 진행 X
        return false;
    }

    // Enemy의 경우, 저지당할 때만 동작함
    // 이동 중에도 동작하게끔 구현하면 멈춰있는 오브젝트 A의 위치로 이동하는 오브젝트 B가 진입할 때 B가 A를 밀어넣어버리는 현상이 발생함
    private bool CheckConditionAboutEnemy(UnitOverlapSolver otherUnit)
    {
        Enemy thisEnemy = GetComponent<Enemy>();
        Enemy otherEnemy = otherUnit.GetComponent<Enemy>();
        
        // 스크립트의 동작 조건 : 두 Enemy가 모두 저지당한 상태에서만 동작
        if (thisEnemy != null && 
            otherEnemy != null && 
            thisEnemy.BlockingOperator != null && 
            otherEnemy.BlockingOperator != null)
        {
            return true; 
        }

        return false;
    }
```

이 스크립트들을 아래처럼 넣어줌

```cs
	if (otherUnit != null)
	{
		// 상대가 배치 요소인데 미리보기 모드일 때는 처리하지 않음
		if (CheckConditionAboutDeployable(otherUnit)) continue;
		if (CheckConditionAboutEnemy(otherUnit)) continue;
		
		Logger.Log($"다른 오브젝트 {otherUnit.gameObject.name}를 찾아서 충돌 로직 계산 시작");

		// ...
	}
```

하드코딩이라 마음에 들진 않는데 일단 원하는 대로 구현은 되고 있으니 냅둔다. 밀어넣는 현상이 발생하지 않는 건 아닌데 납득할 수 있는 수준으로 움직임.
# 251209

>[!done]
>1. 프로젝트 유니티 버전 업데이트 : `6000.0.41f1` -> `6000.3.0f1(LTS)`
>2. 1. 에 의해 이미지 깨지는 현상들 수정
>
## 버전 업데이트에 따른 이슈들
### UI 이미지나 스프라이트가 깨짐
1. 스테이지 선택 패널 - 사이드 패널
	- 패널 자체의 텍스쳐에서 문제가 발생한 것으로 보임(근데 기가 막히게 버튼 주위만 검은 박스가 나타남)
	- 해당 텍스쳐를 제거하고 새로운 텍스쳐를 만들어 넣음
![[TransparentToWhite.png]]
> 1. 30% 지점에서 알파 255를 가짐
> 2. 기존엔 텍스쳐 자체가 검정색이었는데 색은 유니티에서 바꾸면 되니까 흰색으로 구현
> 3. 기존 패널 너비 600은 경계선 부분이 하얗게 뜨는 현상이 발생했음(`Repeat`가 아님에도)
> 	- 너비를 넓혀주니까 경계선이 사라짐

2. "현재 선택 중인 스킬 버튼" 이미지 관련
	- 방향이 이상하게 돌아갔는데 원래대로 돌아왔다. ??

3. 결과 패널 관련
	- 옛날에 `None`으로 둬도 되는 부분을 흰 단색 이미지인 `square_sprite`로 채워넣은 부분이 있었는데, 해당 부분이 차지하는 영역의 가장자리가 부드럽게 처리되면서 발생한 이슈로 보임
	- `square_sprite` 이미지를 삭제했음

### 오퍼레이터 SP 게이지 상태 반영 안되는 문제
- `SPBar`에 한정한 이슈 - `HealthBar`는 체력 변화가 잘 나타남;
	- 배치하자마자 SP가 만땅인 상태를 유지함
	- 실제 상태가 고정되는 이슈는 아니다. 오퍼레이터 클릭 시 보이는 SP값은 변화되고 있음
	- 스크립트를 추적해봐도 값 자체는 잘 나타남
- 이거 해결 못했음


# 251208
- 간헐적인 이슈 - 적이 이미 사라졌는데 계속 해당 위치를 공격하는 현상
	- 왜 발생하는지 모르겠음. 적이 죽으면 계속 해당 위치를 때리는 것도 아닌데 가끔 저 이슈가 발생함. 
	- 아마 살아있다고 인식하는 것 같은데 죽는 시점(비활성화)에 이벤트를 발생시키고 있는데..



# 251204

>[!done]
>- 플레이 테스트 및 밸런스 조정
>	- 코스트 회복 속도 관련

## 플레이 테스트 및 밸런스 조정
### 코스트 회복 속도 관련

전반적으로 게임이 무겁게 느껴진다. 돌발 상황이 생겼을 때 그거에 대응할 자원이 없는 경우가 많다. 지금까지는 코스트가 없는 경우가 많음(오퍼레이터를 배치할 수 있음에도)

여기에 영향을 주는 요소가 크게 아래와 같은데,
- 적의 이동 속도
- 배치 코스트 자연 회복 속도
- 초기 코스트

이 수치들을 만져가면서 적합한 지점을 찾아봐야겠음

- 적 이동속도 : 약 70%로 설정
- 투사체 속도 : 5 -> 3
		- (모든 투사체 속도가 동일했다)

이동속도 낮춘 게 많이 괜찮아 보인다. 


> 일단 지금 포커스를 두고 있는 건 '**뱅가드 육성 없이 게임을 깰 수 있는가?**'이다.



## 기타 이슈 수정

### 스테이지 클리어 로직 중
- 3성 이하로 클리어한 스테이지를 다시 깼는데 기존보다 수치가 같거나 낮을 때에 대한 처리가 작성되어 있지 않았음
```cs
	// 기존 기록보다 더 잘 클리어했을 때
	if (resultInfo.stars < stars)
	{
		if (resultInfo.stars == 1)
		{
			if (stars == 2) return 0.25f;
			if (stars == 3) return 0.75f;
		}
		else if (resultInfo.stars == 2)
		{
			if (stars == 3) return 0.5f;
		}
	}
	// 추가
	else 
	{
		// 기존 기록과 같거나 더 못 깼을때
		return 0f;
	}

	throw new InvalidOperationException("FirstClearItemRate의 예상치 못한 동작");
```
> `stars`가 이번에 클리어한 스테이지의 기록, `resultInfo.stars`가 기존 기록이라고 할 때, 여기까지만 작성하면 "기존 기록보다 더 못 깼을 때"에 오류가 발생함
> 단순하게 `else` 문에 `return 0f`만 달아주면 해결되는 이슈였다. 최초 클리어 보상에 관한 메서드이기 떄문.

### AreaHasteHeal 스킬에서 힐이 안 나감
- `AreaHasteHealController`에는 `Initialize`가 없었다. 상위 클래스를 보면 
```cs
public virtual void Initialize(
	UnitEntity caster,
	IReadOnlyCollection<Vector2Int> skillRangeGridPositions,
	float fieldDuration,
	float tickDamageRatio,
	float interval,
	GameObject hitEffectPrefab,
	string hitEffectTag
	)
{
	this.caster = caster;
	this.skillRangeGridPositions = skillRangeGridPositions;
	this.fieldDuration = fieldDuration;
	this.interval = interval;
	this.tickDamageRatio = tickDamageRatio;
	this.hitEffectPrefab = hitEffectPrefab;
	this.hitEffectTag = hitEffectTag;
	
	// 이 아래 부분 추가
	if (_currentCoroutine != null)
	{
		StopCoroutine(_currentCoroutine);
		_currentCoroutine = null;
	}

	_currentCoroutine = StartCoroutine(FieldRoutine(fieldDuration, interval));
}
```
이런 구조인데, 기존엔 필드 설정하는 부분만 있었고 아래의 if문 부터는 방금 추가한 부분이다.

> - **그래서 기존에 어떻게 동작한 건지가 더 궁금하다.** 이거 없으면 틱으로 들어가는 동작이 아예 작동을 안 할텐데?
> - `ArcaneField`의 경우는 별도의 `Initialize`를 사용해서 상관 없는 이슈

#### 조금 더 개선해봄
- 부모 클래스의 `Initialize`에서 코루틴까지 한꺼번에 실행시키는 대신, `Initialize`는 구현해놓되 세부 내용은 자식 클래스에서 다시 설정하도록 하면 됨
- 대신 필드를 할당하는 메서드, 코루틴을 실행하는 메서드를 따로따로 만들고 `Initialize`에서 해당 메서드들을 실행시키는 방식
- 필드가 늘어지는 건 지금 수정하기 귀찮으니까 냅둠(..)


# 251203

>[!done]
>
>- 플레이 테스트 및 밸런스 조정
>- 기타 이슈 수정
>	- `Enemy`에 누락된 `ID, Localization Key` 등등 추가
>	- 범위 이펙트 관련 이슈 수정(텍스쳐 누락, 조건문 등등)
>	- `Artillery`의 타격 이펙트 오브젝트가 풀로 돌아가지 않는 현상 수정

## 플레이 테스트와 밸런스 조정


## 기타 이슈 수정

- `Entity`에 누락되었던 `ID, Localization Key` 값 설정

### AreaHasteHealSkill - 범위 이펙트 나타나지 않음
- 크게 2가지 문제가 있었다.
1. 텍스쳐가 사라졌음.
2. 이펙트의 경우 셰이더로만 구현한 것도 있고, 파티클 시스템으로 구현한 것도 있음 
	- 벽 이펙트가 안 나타나는 현상도 수정 완료

### Artillery - Hit VFX
1. 범위 공격에 맞은 적들 모두에게 피격 이펙트가 나타나는데 부자연스러워 보임
	- 폭발 지점은 1개여야 하는데 피격된 객체 수만큼 이펙트가 나타남
	-  `Projectile`에 붙어 있는 `CreateAreaOfDamage` 메서드를 실행할 때, 이펙트를 여기서 1회만 실행시키는 방식으로 구현했다.
		- 원래는 `UnitEntity.TakeDamage` 안에 `PlayGetHitVFX()`가 있다. 피격 로직 안에 피격 이펙트 실행 로직을 붙여놨는데, 위에서 수정한 로직과 겹치기 떄문에 `TakeDamage`에는 피격 이펙트를 실행할 지 여부를 판단하는 `bool` 파라미터를 추가해뒀다.

> 여기도 교통 정리가 필요해보이긴 하는데, **일단 게임을 완성한 다음에 시간이 있을 때 수정**하기로 하겠음. 앞으로도 부족한 부분은 계속 보일 건데, 이거 일일이 수정하다 보면 너무 시간을 많이 쓰게 된다.

2. 오브젝트 풀링 문제 
- 이펙트의 재생 시간을 초과했는데도 풀로 돌아가지 않고, 새로운 오브젝트가 풀에 계속 생성됨.
	- 이거 좀 재밌는 부분인 게 **1번을 수정하니까 2번도 고쳐졌다.**
	- 이전 코루틴 실행을 멈추는 로직도 추가했지만,
	- 처음에 생각한 오브젝트 풀에 있는 오브젝트 갯수를 초과해서 **한꺼번에 여러 개가 생겨서 실행되어서 그런 걸까? 정확한 원인은 모르겠음.**

# 251201

>[!done]
>- 스테이지 밸런스 수정
>	- `Tanker` 방어력 550 -> 400 -> 350으로 하향
>	- 스테이지 1-1 몹 생성 타이밍 수정
>	- 스테이지 1-2 맵 크기 축소 
>		- 밸런스는 더 만져야 할 듯
>- 기타 이슈 수정
>	- 바리케이드 이름 한글로 나타나지 않는 현상 수정

## 스테이지 밸런스 수정

### 1-1
- 탱커 방어력 500에서 350으로 하향
- 탱커 생성 시간 간격 조정

### 1-2 
- 맵 크기 축소(비슷한 구조의 맵을 새로 만듦)
- `Default` 몹들 전반적으로 하향해야 할 듯? `Ghost`도 이속이나 체력 깎아야 할 것 같다.





## 기타 이슈 수정
### 바리케이드 이름 한글로 나타나지 않는 현상
```cs
private void UpdateDeployableInfo()
{
	HideOperatorPanels();
	// nameText.text = currentDeployableInfo.deployableUnitData?.EntityID ?? string.Empty;
	nameText.text = GameManagement.Instance!.LocalizationManager.GetText(currentDeployableInfo.deployableUnitData?.EntityNameLocalizationKey) ?? string.Empty;
}
```

### `RetreatButton` 입력 시 천천히 사라지는 현상
- 바리케이드에서 보였던 이슈다. 퇴각 버튼은 바로 사라지게끔 구현해야 할 듯
- 버튼을 입력했을 때 `deployable.Retreat()`이 있는데 막상 `deployableUnitEntity.Retreat()`의 디버깅 로그는 관찰이 안 됨.

- 아 **`Barricade`에 `Retreat` 메서드가 따로 있었다. ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ**
```cs
public override void Retreat()
{
	UndeployBarricade();
	base.Retreat();
}

protected override void Die()
{
	UndeployBarricade();
	base.Die();
}

private void UndeployBarricade()
{
	CurrentTile!.ToggleWalkable(true); // 현재 타일 이동 가능으로 변경
	PathfindingManager.Instance!.RemoveBarricade(this); // 바리케이드 리스트에서 제거
	OnBarricadeRemoved?.Invoke(this); // 제거 이벤트 발생
}
```

바리케이드에는 경로 관련 요소가 있기 때문에 이걸 별도의 메서드로 구분하고 그 외에는 `DeployableUnitEntity`의 로직이 동작하도록 수정했음.


- `Guard - SlashSkill` 버튼 입력시 오류 발생
	- 스킬 태그를 못 찾는다고 함
```cs
            GameObject effectObj = ObjectPoolManager.Instance.SpawnFromPool(GetSlashControllerTag(caster.OperatorData), caster.transform.position, caster.transform.rotation);
```
> `SO`자체가 `string skillTag`로 갖고 있는 구현이 안 좋아서 이전에 수정했는데, 이 부분은 메서드를 만들어놓고 그냥 지나간 듯.

## 발견했으나 간헐적이라 수정하지 않음
- `Guard`가 저지하는 적이 없는데도 적이 `Guard`에 의해 저지되지 않고 그냥 진행하는 현상




