#게임프로그래밍패턴

1. [[#책 내용|책 내용]]
	1. [[#책 내용#문제 상황 - 하드 코딩의 한계|문제 상황 - 하드 코딩의 한계]]
	2. [[#책 내용#해결책 : 가상 머신VM 과 바이트코드|해결책 : 가상 머신VM 과 바이트코드]]
	3. [[#책 내용#스택 머신|스택 머신]]
	4. [[#책 내용#장점|장점]]
2. [[#유니티에서|유니티에서]]
	1. [[#유니티에서#Lua 스크립트(MoonSharp, XLua)|Lua 스크립트(MoonSharp, XLua)]]
	2. [[#유니티에서#비주얼 스크립팅(Unity Visual Scripting / Bolt)|비주얼 스크립팅(Unity Visual Scripting / Bolt)]]
	3. [[#유니티에서#기초적인 가상 머신 예제|기초적인 가상 머신 예제]]
3. [[#유니티에서 사용 시 주의할 점|유니티에서 사용 시 주의할 점]]
	1. [[#유니티에서 사용 시 주의할 점#바이트코드는 C# 네이티브 코드보다 느리다.|바이트코드는 C# 네이티브 코드보다 느리다.]]
	2. [[#유니티에서 사용 시 주의할 점#IL2CPP와 AOT(Ahead Of Time)|IL2CPP와 AOT(Ahead Of Time)]]
	3. [[#유니티에서 사용 시 주의할 점#요약|요약]]

> 설계 패턴 찾다가 뜻밖의 지식을 얻었다.

- 바이트코드는 게임 개발에서 `모딩Modding`, 유저 제작 콘텐츠, 기획자를 위한 스크립팅 시스템을 만들 때에 사용할 수 있다.
- 유니티에겐 생소할 수 있으나 `Lua`나 비주얼 스크립팅`Bolt`이 어떻게 돌아가는지 이해하는 데 도움이 된다.
## 책 내용
### 문제 상황 - 하드 코딩의 한계
- 마법 시스템을 만드는 상황
	- `Fireball` : 데미지 10, 범위 5
	- `IceBolt` : 데미지 5, 슬로우
	- `Heal` : 체력 회복 20

이걸 전부 코드로 짜면?

1. **컴파일 시간 :** 마법 하나 고칠 때마다 게임을 끄고 코드를 수정해서 다시 빌드해야 함
2. **유연성 부족** : 체력 50 이하에만 발동하는 마법을 만들고 싶다면 기획자가 프로그래머를 불러야 함
3. **보안** : 유저들이 모드를 만들게 하고 싶은데, C++ 코드를 직접 짜게 하면 바이러스를 심을 수도 있음

### 해결책 : 가상 머신VM 과 바이트코드
- 데이터 파일에 명령어를 적어두고, 게임이 명령어를 읽어 실행하게 만드는 방식이다.
```text
LITERAL 10 (숫자 10을 꺼낸다)
SET_HEALTH (체력을 설정한다)
PLAY_SOUND (소리를 낸다)
```

이런 류의 **명령어 목록을 바이트코드**라고 한다. 보통 1바이트 숫자로 표현된다 : `0x01, 0x05 등`

### 스택 머신
- 책에선 가장 구현하기 쉬운 스택 기반의 가상 머신을 만든다.
- 명령어 : `Add, Push, Pop`
- 스택 : 데이터를 잠시 저장하는 공간
	- `Push 3` -> `[3]`
	- `Push 5` -> `[3, 5]`
	- `Add` -> 3, 5를 꺼내 더한 뒤 다시 넣음 -> `[8]`

### 장점
- 안전함(샌드박스) : VM은 정해진 명령어만 수행하므로 유저가 시스템 파일을 건드리거나 해킹하는 걸 막을 수 있음
- 빠른 수정 : 코드를 컴파일할 필요 없이, 텍스트 파일만 고치고 게임에서 새로고침을 누르면 바로 적용됨

## 유니티에서
- 유니티 개발자가 바이트코드 패턴을 직접 구현할 일은 거의 없다.
- **대신 만들어진 솔루션을 사용**한다.

### Lua 스크립트(MoonSharp, XLua)
- 게임 업계 표준 스크립팅 언어다.

- 용도 : 퀘스트 로직, NPC 대사, 스킬 효과 등을 Lua 파일로 작성한다.
- 작동 : 유니티가 Lua VM을 돌리고, Lua 파일을 읽어서 실행한다.
- 장점 : 프로그래머 도움 없이 기획자가 퀘스트를 짤 수 있다. 모바일 게임에서도 앱 업데이트 없이`Hot Update` 로직을 패치할 때 주로 쓴다.

### 비주얼 스크립팅(Unity Visual Scripting / Bolt)
- 유니티에 내장된 비주얼 스크립팅 = 그래픽으로 된 바이트코드이다.

- 노드 : 명령어(Add, Set Variable 등)
- 선 : 실행 흐름
- 작동 : 유니티는 노드 그래프를 내부적으로 데이터로 변환, 런타임에 해석해서 사용한다.

### 기초적인 가상 머신 예제
```cs
public enum OpCode {MoveForward, TurnLeft, Attack, Wait}

public class SimpleVM : MonoBehaviour
{
	public List<OpCode> instructions; // 바이트 코드(명령어 목록)
	
	public void Run()
	{
		foreach (var op in instructions)
		{
			switch (op)
			{
				case OpCode.MoveForward: transform.Translate(Vector3.forward); break;
				case OpCode.TurnLeft: transform.Rotate(0, -90, 0); break;
				case OpCode.Attack: Debug.Log("공격!"); break;
			}
		}
	}
}
```

## 유니티에서 사용 시 주의할 점

### 바이트코드는 C# 네이티브 코드보다 느리다.
- `switch`문을 일일이 돌기 떄문이다.
- 매 프레임 실행되는 `Update` 문이나 물리 연산 등의 무거운 작업은 스크립트로 짜면 안 된다. 퀘스트 진행, 대화, 일회성 이벤트 등에만 써야 한다.

### IL2CPP와 AOT(Ahead Of Time)
- 유니티의 빌드 방식 IL2CPP는 C#의 중간 언어(IL, 바이트 코드의 일종)를 C++로 바꿔버린다.

- 그래서 iOS 같은 플랫폼에서는 런타임에 코드를 생성하는 JIT 방식의 스크립팅 엔진을 쓰기가 까다롭다.
- 따라서 Lua나 비주얼 스크립팅처럼 미리 해석기(인터프리터)가 포함된 방식을 선호한다.

### 요약
- 직접 만들지 말 것. Lua나 Visual Scripting을 사용할 것.
- 퀘스트, 스킬 시스템이 너무 복잡해진다면 도입을 고려해볼 것.
- 모딩 지원 : 유저가 게임의 모드를 만들게 하고 싶다면 C# 코드를 열지 말고 Lua 같은 스크립팅 환경을 제공해주는 게 훨씬 안전하다.


