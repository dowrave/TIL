#게임프로그래밍패턴

1. [[#책 내용|책 내용]]
	1. [[#책 내용#문제 상황 - 몬스터의 종류가 너무 많다|문제 상황 - 몬스터의 종류가 너무 많다]]
	2. [[#책 내용#해결책 : 타입을 객체로 만들자|해결책 : 타입을 객체로 만들자]]
	3. [[#책 내용#결과|결과]]
2. [[#유니티에서|유니티에서]]
	1. [[#유니티에서#유니티의 타입 객체 : SO|유니티의 타입 객체 : SO]]
	2. [[#유니티에서#상속의 대체|상속의 대체]]
3. [[#유니티에서 사용 시 주의할 점|유니티에서 사용 시 주의할 점]]
	1. [[#유니티에서 사용 시 주의할 점#데이터 주도 설계|데이터 주도 설계]]
	2. [[#유니티에서 사용 시 주의할 점#프리팹과의 관계|프리팹과의 관계]]
	3. [[#유니티에서 사용 시 주의할 점#요약|요약]]

## 책 내용

### 문제 상황 - 몬스터의 종류가 너무 많다
```cpp
class Monster { ... };
class Dragon : public Monster { ... };
class Troll : public Monster { ... };
class Goblin : public Monster { ... };
// ... 클래스 파일만 수백 개 ...
```
- 문제 1. 기획자가 불 뿜는 고블린을 만들고 싶다면 프로그래머가 `FireGoblin` 클래스를 코딩하고 컴파일해야 한다.
- 문제 2. `Dragon`과 `Troll`의 차이는 체력, 공격력, 공격 방식 데이터 뿐인데 별도의 클래스로 만들어야 할 필요가 있을까?

### 해결책 : 타입을 객체로 만들자
- 몬스터의 `종족Breed`을 나타내는 클래스를 따로 만든다.

1. `Monster`(실체) : 실제 게임 월드에 돌아다니는 몬스터 객체
2. `Breed` (타입) : 몬스터의 종족 정보를 담은 객체

```cs
class Breed {
    int maxHealth;
    int attackDamage;
    // ...
    Monster* newMonster() { return new Monster(this); }
};

class Monster {
    Breed& breed; // 나는 어떤 종족인가?
    int currentHealth;
    
    int getAttack() { return breed.attackDamage; } // 종족 정보를 참조해서 행동
};
```

### 결과
- 이제 `Dragon` 클래스, `Troll` 클래스가 필요없어졌다.
- 대신 `Breed` 객체를 2개 만들고, `Monster`를 생성할 때 연결하면 된다.

## 유니티에서

### 유니티의 타입 객체 : SO
- **유니티 개발자들은 `SO`로 이 패턴을 매일 쓰고 있다.**
- 책의 `Breed` 클래스가 유니티에서는 `MonsterData`가 된다.
```cs
// 몬스터 데이터 저장소
[CreateAssetMenu]
public class MonsterData : ScriptableObject
{
    public string monsterName;
    public int maxHealth;
    public int attackDamage;
    public GameObject modelPrefab;
}

// 런타임 중 동작하는 객체
public class Monster : MonoBehaviour
{
    // 타입 객체를 참조 (이 몬스터가 무슨 종류인지)
    public MonsterData data; 
    
    private int currentHealth;

    void Start()
    {
        // 타입 객체에서 데이터를 가져와 초기화
        currentHealth = data.maxHealth;
        name = data.monsterName;
    }

    public void Attack(Player player)
    {
        // 공격력도 타입 객체에서 가져옴
        player.TakeDamage(data.attackDamage);
    }
}
```

### 상속의 대체
- 책에서는 상속을 통해 공격 방식이 다른 몬스터를 구현하는 법도 나오는데, **유니티에선 이를 전략 패턴과 결합**해서 해결한다.
- `MonsterData` 내에 `AttackStrategy`라는 `SO` 변수를 두면, 애셋만 갈아끼우면 몬스터 클래스를 바꾸지 않고도 공격 방식이 바뀐다.
## 유니티에서 사용 시 주의할 점

### 데이터 주도 설계
- 타입 객체 패턴의 핵심은 코드를 데이터로 옮기는 것이다.
- 장점 : 재컴파일 없이 몬스터 밸런스 조절 가능. 에디터에서 수치만 바꾸면 된다.
- 활용 : **몬스터, 아이템, 스킬, 퀘스트, 업적 등 종류는 많고 로직은 비슷한 모든 시스템에 적용할 수 있다.** 

### 프리팹과의 관계
- 프리팹 또한 일종의 타입 객체 패턴이다.
- `Goblin.prefab`은 고블린이라는 타입을 정의하고, `Instantiate`으로 실체 인스턴스를 만든다. 
	- 하지만 프리팹 자체는 무겁기 때문에 순수한 데이터(수치)만 관리하기에는 `SO`가 훨씬 가볍고 효율적이다.

### 요약
- `FireSword`, `IceSword`를 만드는 대신 `Sword`와 `FireData, IceData`로 구현해라.
- 아래 둘을 명확히 구분하는 게 핵심이다.
	- `SO` : 변하지 않는 데이터(이름, 공격력, 아이콘, 설명)
	- `MonoBehaviour` : 변하는 데이터(현재 체력, 쿨타임, 위치)