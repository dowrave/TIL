#게임프로그래밍패턴

1. [[#명령|명령]]
	1. [[#명령#실행 취소(Undo) 기능 구현하기|실행 취소(Undo) 기능 구현하기]]
2. [[#유니티에 적용하기|유니티에 적용하기]]
	1. [[#유니티에 적용하기#키 설정 변경이 필요한 경우|키 설정 변경이 필요한 경우]]
	2. [[#유니티에 적용하기#액터에게 지시하는 경우|액터에게 지시하는 경우]]
	3. [[#유니티에 적용하기#실행 취소Undo나 리플레이가 필요한 경우|실행 취소Undo나 리플레이가 필요한 경우]]


> 책이 2010년 경에 웹 연재를 시작했음
> - 그래서 일급 함수가 없던 시절의 C++ 기준으로 설명이 되었다. 현대의 C#이나 최신 C++에서는 굳이 이 기능을 안 써도 됨
> - 단 **히스토리 / 리플레이가 필요한 경우는 여기서 설명하는 명령 패턴으로 구현**해야 한다. 

## 명령
- **요청 자체를 객체로 캡슐화한 것.** 
	- 메서드를 "굳이" 클래스 안에 들어가도록 만들었다는 것이다. 
	- 핵심은 **"행동"을 "데이터화"할 수 있다**는 것임.

- 게임에서는 특정 입력 버튼에 들어가는 동작을 바꾸는 데에 사용할 수 있다.
```cs
// 인터페이스 정의
public interface ICommand {
    void Execute(Transform actor); 
}

// 구체적인 명령
public class JumpCommand : ICommand {
    public void Execute(Transform actor) {
        actor.GetComponent<Rigidbody>().AddForce(Vector3.up * 5, ForceMode.Impulse);
    }
}

// 입력 처리
public class InputHandler : MonoBehaviour {
    private ICommand buttonA;

    void Start() {
	    // 명령 패턴이 아니었다면 buttonA는 여기서 Jump()라는 메서드로 들어가도 무방했음
        buttonA = new JumpCommand(); // 키 세팅 시 이 부분만 교체하면 됨
    }

    void Update() {
        if (Input.GetKeyDown(KeyCode.Space)) {
            buttonA.Execute(this.transform);
        }
    }
}
```
> **명령들에 대한 인터페이스를 정의하고, 각 명령은 `ICommand`로 전달하고 있다는 것만 파악해도 충분**함
> 팁 1. `Transform actor`를 받는 이유는 그 명령이 들어가는 객체를 전달하기 위함이다. 
> 	- 이렇게 구성하면 똑같은 명령을 캐릭터 외의 다른 객체에도 사용할 수 있음.

명령을 `Queue`나 `Stream`으로 만드는 것도 생각해볼 수 있다.
즉 `Enemy`가 어떤 행동을 할지에 대한 명령 객체를 Stream에 밀어 넣고, 디스패처/액터에서 명령 객체를 받아 호출하는 방식이다.

### 실행 취소(Undo) 기능 구현하기
1. 명령을 취소하기 위한 기능 `Undo`를 `Command`에 추가함
```cs
public abstract class Command 
{
	// 실행
	public abstract void Execute();
	
	// 취소
	public abstract void Undo();
}
```

2. 이동 명령
	- 이동하기 전의 위치를 변수에 저장해두는 게 핵심.
```cs
public class MoveCommand : Command 
{
	private Transform _actorTransform; // 누가 움직였는가
	private Vector3 _direction; // 어디로 움직였는가
	private Vector3 _previousPosition; // 기억용 움직이기 전 위치
	
	public moveCommand(Transform actor, Vector3 direction)
	{
		_actorTransform = actor;
		_direction = direction; 
	}
	
	public override void Execute() 
	{
		// 1. 움직이기 전 위치를 기억해둔다(스냅샷)
		_previousPosition = _actorTransform.position;
		
		// 2. 실제로 이동한다
		_actorTransform.Translate(_direction);
	}
	
	public override void Undo() 
	{
		// 기억해둔 위치로 되돌린다
		_actorTransform.position = _previousPosition;
	}
}
```

3. 명령 관리자 - 히스토리 관리
	- 실행될 명령들을 쌓아둘 스택이 필요하다.
```cs
using System.Collections.Generic; // 스택 사용

public class CommandInvoker: MonoBehaviour 
{
	// 명령 히스토리를 저장하는 스택
	private stack<Command> _commandHistory = new Stack<Command>();
	
	// 명령을 받아서 실행하고 기록하는 함수
	public void ExecuteCommand(Command command) 
	{
		command.Execute();
		_commandHistory.Push(command); // 히스토리에 기록
	}
	
	// 실행 취소 함수
	public void UndoCommand() 
	{
		if (_commandHistory.Count > 0) 
		{
			Command lastCommand = _commandHistory.Pop();
			lastCommand.Undo();
			Debug.Log("실행 취소됨");
		}
		else 
		{
			Debug.Log("취소될 명령이 없음");
		}
	}
	
}
```

4. 입력 처리
- 입력을 받아 명령 객체를 생성해서 관리자에게 넘긴다.
```cs
public class PlayerInput: MonoBehaviour 
{
	public Transform playerTransform; // 움직일 대상
	public CommandInvoker invoker; // 명령 관리자
	
	void Update 
	{
		if (Input.GetKeyDown(KeyCode.UpArrow))
		{
			Command moveUp = new MoveCommand(playerTransform, Vector3.forward);
			invoker.ExecuteCommand(moveUp); // Command의 실행 및 히스토리에 저장
		}
		// ...
	}
}
```

## 오늘날 유니티에 적용하기

### 키 설정 변경이 필요한 경우
- **명령 패턴이 필요하지 않다.** 너무 무겁고 번거롭기 때문이다.

- 방식 1 : 델리게이트를 이용해 `Action jumpButton = jump` 처럼 함수만 갈아끼운다.
- **방식 2 : Unity New Input System을 사용한다.** 
	- 유니티가 제공하는 입력 시스템 패키지로, **에디터 화면에서 코딩 없이 버튼을 설정할 수 있고, 실행 중에 바꿀 수 있는 기능도 자체적으로 제공**한다.
	- **개발자는 `OnJump` 이벤트에 함수만 연결**하면 된다.

> `Action`이 상위 클래스의 역할을 완벽히 대체했다고 생각해도 된다. 게다가 자기한테 어떤 함수가 연결됐는지 알 필요도 없다. 실행되어야 하는 함수 쪽만 알면 된다.

### 액터에게 지시하는 경우
- 명령 객체에 액터를 인자로 넘겨야 할까?
- 공통된 로직을 공유한다면 유용하지만, 보통은 AI 스크립트와 플레이어 스크립트가 다른 경우가 많다.
	- 내 프로젝트의 `Operator`와 `Enemy`의 공격 범위 / 타겟 선정 로직이 다른 걸 생각해보자.

### 실행 취소Undo나 리플레이가 필요한 경우
- **명령 패턴이 필요하다.**
- 상태를 저장하는 로직이 들어간다면 명령 패턴을 활용하는 게 좋다.

