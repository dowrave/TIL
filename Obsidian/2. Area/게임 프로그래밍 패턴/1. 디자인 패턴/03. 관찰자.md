#게임프로그래밍패턴

1. [[#관찰자Observer|관찰자Observer]]
	1. [[#관찰자Observer#업적 달성 예제|업적 달성 예제]]
	2. [[#관찰자Observer#해결책|해결책]]
	3. [[#관찰자Observer#"너무 느려"|"너무 느려"]]
	4. [[#관찰자Observer#"동적 할당을 너무 많이 해"|"동적 할당을 너무 많이 해"]]
	5. [[#관찰자Observer#남은 문제점들|남은 문제점들]]
2. [[#오늘날 유니티에서는|오늘날 유니티에서는]]
	1. [[#오늘날 유니티에서는#3가지 관찰자 방식|3가지 관찰자 방식]]
	2. [[#오늘날 유니티에서는#책에서 제기한 문제점들의 현재|책에서 제기한 문제점들의 현재]]

## 관찰자Observer
- 이벤트 처리의 근간이 되는 패턴.

### 업적 달성 예제
- "다리에서 떨어지기"라는 업적이 있을 때, 이 업적을 달성했는지 체크하기 위해 물리 엔진의 어딘가에 코드를 넣어둬야 한다.
- 그런데 이 경우 물리 엔진이 업적 시스템을 알고 있어야 한다는 의존성이 발생한다.

### 해결책
- 관찰자 패턴은 `관찰 대상Subject`과 `관찰자Observer`로 나뉜다.
- `관찰 대상` : 자신에게 무슨 일이 생기면 알려주는 쪽(물리 엔진)
- `관찰자` : 무슨 일이 생기면 연락을 해달라고 등록하는 쪽(업적 시스템)

관찰 대상은 알림만 보내며, 일은 관찰자들이 알아서 한다.

### "너무 느려"
많은 개발자들이 "이벤트 알림은 함수 직접 호출보다 느리지 않나?"라는 걱정을 했다.

하지만 관찰자 패턴은 보통 `가상 함수Virtual Function` 호출을 통해 구현된다. 현대 CPU에서 가상 함수 호출 비용은 무시할 수 있을 정도로 작다.

진짜 성능 저하의 원인은 `캐시 미스Cache Miss`인데 관찰자 패턴에 의해 유발될 수도 있지만 대부분의 게임 로직에선 큰 원인이 되지 않는다.

### "동적 할당을 너무 많이 해"
관찰자가 등록될 때마다 리스트에 노드를 추가해야 하므로 메모리 할당이 발생한다는 지적이다.

`C++`에서는 `침투형 리스트Intrusive List`를 사용해서 관찰자 객체 자체가 리스트의 노드 역할을 하게 해서 추가적인 메모리 할당을 막을 수 있다(C#에서 쓰이는 방식은 아니다.)

### 남은 문제점들
- `좀비 리스너Lapsed Listener` : 삭제된 관찰자가 대상의 명단에 남은 경우. 대상의 알림이 죽은 객체를 건드리면 크래시 / 에러가 발생한다.
- `순서 문제` : 여러 관찰자 중 누가 먼저 알림을 받을지 보장할 수 없다.
## 오늘날 유니티에서는
책에선 `Observer` 인터페이스를 만들고 상속했지만, `C#`에서는 `event, delegate`를 쓴다.

```cs
using UnityEngine;
using System;

// 관찰 대상
public class Player : MonoBehaviour
{
    // C#의 event 키워드를 사용하면 관찰자 패턴을 한 줄로 구현 가능
    // Action은 반환값이 없는 함수 형태를 의미
    public event Action OnFellOffBridge;

    void Update()
    {
        if (CheckFallCondition())
        {
            // "떨어졌다!"고 알림을 보냄 (구독자가 있을 때만)
            OnFellOffBridge?.Invoke();
        }
    }

    bool CheckFallCondition() { /* ... */ return false; }
}

// 관찰자
public class AchievementSystem : MonoBehaviour
{
    public Player player;

    void OnEnable()
    {
        // 구독 (Subscribe): += 연산자 사용
        player.OnFellOffBridge += UnlockFallAchievement;
    }

    void OnDisable()
    {
        // 구독 취소 (Unsubscribe): -= 연산자 사용
        // *매우 중요* : 이걸 안 하면 '좀비 리스너' 문제가 발생함!
        player.OnFellOffBridge -= UnlockFallAchievement;
    }

    void UnlockFallAchievement()
    {
        Debug.Log("업적 달성: 번지 점프!");
    }
}
```

### 3가지 관찰자 방식
1. `C# Native`(위 예제)
	- 장점 : 가장 빠르고, 깔끔하고, 타입 안전성이 보장된다.
	- 단점 : 유니티 인스펙터에서 직접 할당할 수 없다. 
	- 용도 : 게임 로직, 시스템 간의 통신
2. `UnityEvent`
	- 장점 : 인스펙터에서 할당할 수 있다. `UI Button`의 `OnClick` 등.
	- 단점 : C#보다 느리고 GC가 발생할 수 있다.
	- 용도 : UI 상호작용, 디자이너가 세팅하는 간단한 이벤트 등.
3. `SO Event Architecture`
	- 개념 : 이벤트를 코드 내에 두지 않고 SO 파일로 만든다.
	- 장점 : 플레이어 프리팹과 UI 프리팹이 서로를 몰라도 통신할 수 있다.
	- 용도 : 대규모 프로젝트의 모듈 간 통신

> 3번쨰 방식은 아예 처음 듣는 내용이다.

### 책에서 제기한 문제점들의 현재
1. 너무 느리다
	- **C# 이벤트는 매우 빠르다.** `Update`에서 수천 번 호출하는 게 아니라면 걱정 ㄴ
	- `UnityEvent`는 조금 무겁지만 UI 클릭 같은 일회성 이벤트에는 문제 없다.
2. 동적 할당이 너무 많다.
	- `C#`의 이벤트는 구독할 때 내부적인 델리게이트 체인을 만들기 위해 소량의 GC Garbage가 발생한다.
	- 게임 실행 중에 `+=, -=`을 너무 많이 반복하면 GC 스파이크가 튈 수 있다. 일반적으로는 `Start`나 `OnEnable`에서 1번만 연결하기 때문에 괜찮다.
3. 좀비 리스너
	- 반드시 `OnDisable`이나 `OnDestroy`에서 구독을 해제하는 습관을 들이자.

- 이외) 데이터 바인딩, 함수 반응형 프로그래밍은 유니티에서 `UniRx`나 `R3(Reactive Extensions for Unity)` 등으로 활용되고 있다.

