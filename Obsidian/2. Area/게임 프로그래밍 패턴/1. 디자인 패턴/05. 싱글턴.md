#게임프로그래밍패턴

1. [[#책 내용|책 내용]]
	1. [[#책 내용#싱글턴 패턴|싱글턴 패턴]]
	2. [[#책 내용#왜 사용하는가?|왜 사용하는가?]]
	3. [[#책 내용#왜 나쁜가?|왜 나쁜가?]]
	4. [[#책 내용#대안|대안]]
2. [[#유니티에서|유니티에서]]
	1. [[#유니티에서#구현|구현]]
	2. [[#유니티에서#제네릭 싱글턴|제네릭 싱글턴]]
	3. [[#유니티에서#활용 및 주의점|활용 및 주의점]]
		1. [[#활용 및 주의점#싱글턴을 써야 하나 말아야 하나|싱글턴을 써야 하나 말아야 하나]]
		2. [[#활용 및 주의점#싱글턴의 대안 : 의존성 주입(Dependency Injection)|싱글턴의 대안 : 의존성 주입(Dependency Injection)]]
		3. [[#활용 및 주의점#다른 방식 : SO 활용하기|다른 방식 : SO 활용하기]]
		4. [[#활용 및 주의점#추가 질문) SO를 싱글턴처럼 쓴다면 어떤 정보들이 들어가는가?|추가 질문) SO를 싱글턴처럼 쓴다면 어떤 정보들이 들어가는가?]]
		5. [[#활용 및 주의점#추추가 질문|추추가 질문]]

> 싱글턴을 대체하는 게 어렵다..

## 책 내용

### 싱글턴 패턴
- 아래 2가지 조건을 만족하는 패턴이다.
1. **오직 하나만 존재한다** : 클래스의 인스턴스가 전역적으로 하나만 생성되도록 강제한다.
2. **어디서든 접근 가능하다** : 전역 변수처럼 코드 어디에서든 `Manager.Instance`로 접근할 수 있다.

예시) 파일 시스템 래퍼, 오디오 관리자 등 하드웨어 리소스, 유일한 시스템 관리 등에 쓰인다.

### 왜 사용하는가?
- 편리함 : 어디서든 바로 호출할 수 있다. 인자로 객체를 계속 넘겨줄 필요가 없다.
- 유일성 보장
- 지연 초기화 : 게임 시작 시가 아닌, 처음 쓸 때 로딩할 수 있어 초기 구동 속도에 도움이 된다.

### 왜 나쁜가?
저자는 싱글턴을 객체 지향의 탈을 쓴 전역 변수라고 비판한다.

- **전역 변수의 문제점** : 코드를 이해하기 어렵게 만든다. 강한 커플링이 생긴다.
- **동시성 문제** : 멀티 스레드 환경이라면 여러 곳에서 동시에 싱글턴에 접근하면 `교착 상태Deadlock`나 레이스 컨디션 버그가 발생하기 쉽다.
- **게으른 초기화의 배신** : 사전에 로딩이 안 되고 불러올 때 로딩하다가 렉이 걸리면 UX가 망가진다. 게임에서는 로딩 화면에서 미리 다 로딩하는 게 낫다. 

### 대안
- 매개변수로 넘기기 : 필요한 객체를 함수 인자로 계속 넘겨준다
- 상위 클래스에 둔다 : `Game` 클래스 내에 `Audio`를 멤버로 두고, 하위 객체들이 접근하게 한다.
- 서비스 중개자 : 싱글턴과 비슷하지만 인터페이스를 통해 접근해서 유연성을 높인다.

## 유니티에서
- 필요악 취급을 받는다. 편해서 안 쓸 수는 없는데, 잘못 쓰면 프로젝트를 망칠 수 있다.

- 선요약
	- 싱글턴은 편해서 자주 쓰지만 나중에 대가를 치르게 된다.
	- 개인/소규모면 개발 속도가 중요하기 때문에 상관 없지만, 큰 규모일수록 제한해야 한다.
	- `DontDestroyOnLoad` : 씬 이동 시 싱글턴 객체가 중복 생성되거나 엉뚱한 씬에 남는 문제가 발생하므로 초기화 로직을 짤 때 주의해야 한다
	- 프로젝트 규모가 커진다면 `DI(VContainer)`나 `SO 아키텍쳐`를 공부해보자.
		- 근데 일단 뇌 빼고 싱글턴이 편하긴 해..

### 구현
```cs
public class GameManager: MonoBehaviour
{
	public static GameManager Instance { get; private set; }
	
	void Awake() 
	{
		if (Instance != null && Instance != this) 
		{
			Destroy(gameObject);
			Return;
		}
		Instance = this;
		
		DontDestroyOnLoad(gameObject); //선택 사항
	}
}
```

### 제네릭 싱글턴
- 일일이 `Instance`와 `Awake` 로직을 짜기 귀찮기 때문에 제네릭으로 부모 클래스를 만든다.
```cs
public class SignleTon<T> : MonoBehaviour where T : MonoBehaviour
{
	private static T _instance;
	public static T Instance
	{
		get 
		{
			if (_instance == null)
			{
				// 씬에 없으면 만듦 - Lazy Initialization
				_instance = FindObjectOfType<T>();
				if (_instance == null) 
				{
					GameObject obj = new GameObject(typeof(T).Name);
					_instance = obj.AddComponent<T>();
				}
			}
			return _instance;
		}
	}
	
	protected virtual void Awake()
	{
		if (_instance == null) 
		{
			_instance = this as T;
			DontDestroyOnLoad(gameObject);
		}
		else
		{
			Destroy(gameObject);
		}
	}
}
```

이렇게 만들어 놓으면 `public class GameManager : Singleton<GameManager>`로 쓰면 자동으로 싱글턴이 된다.

### 활용 및 주의점

#### 싱글턴을 써야 하나 말아야 하나
- 소규모/개인 프로젝트 
	- 개발 속도가 중요하므로 마음껏 써도 된다. `GameManager, SoundManager, UIManager` 정도는 싱글턴으로 만들어도 큰 문제 없다.
- 중/대규모 프로젝트
	- 싱글턴 사용을 엄격히 제한해야 한다. 모든 코드가 `GameManager.Instance`를 참조하기 시작하면 스파게티 코드가 된다.

#### 싱글턴의 대안 : 의존성 주입(Dependency Injection)
- 현대 유니티 개발, 특히 기업 환경에서는 `DI` 프레임워크를 사용하는 경우가 많다.

- 도구 : `VContainer`, `Zenject`(Extenject)
- 개념
	- `Player` 클래스 내에서 `SoundManager.Instance.Play()`를 호출하지 않는다.
	- 대신 `ISoundManager`를 생성자 / 초기화 함수로 주입받는다.
	- 누가 주입하는가? : DI 컨테이너가 알아서 연결해준다.
- 장점 : `Player` 테스트 시 실제 사운드 매니저 대신 가짜`Mock` 사운드 매니저를 끼워 넣어서 테스트하기 쉽다. 결합도가 낮아진다.

#### 다른 방식 : SO 활용하기
- **SO를 싱글턴처럼 사용**하는 방식도 있다.

- 방법 : `GameSettings`라는 SO 애셋을 하나 만든다.
- 사용 : 필요한 컴포넌트의 인스펙터에 이 애셋을 드래그해서 연결한다.
- 효과 : 코드상에선 `static`, 싱글턴 모두 없지만 모든 객체가 하나의 데이터를 공유하게 된다. 훨씬 안전하게 유연하다. 

> 위 방식`DI`보다는 이쪽이 더 눈에 띈다. 

#### 추가 질문) SO를 싱글턴처럼 쓴다면 어떤 정보들이 들어가는가?

1. **전역 설정값** : 플레이어의 최대 체력, 플레이어의 이동 속도, 전체 소리 크기 등
2. **게임 상태 데이터** : 현재 플레이어의 체력, 점수, 남은 시간 등의 런타임 중에 변하는 데이터도 SO에 넣을 수 있다.
3. **이벤트 채널** : 싱글턴을 쓰는 가장 큰 이유 중 하나인 `이벤트 통신`을 SO로 대체한다.
4. **리소스 관리** 

3번은 예를 들어봄
- 기존 싱글턴 : `UIManager.Instance.ShowGameOver()` - 플레이어가 `UI 매니저`를 알아야 함
- SO 대체(GameEvent.asset)
```cs
[CreateAssetMenu]
public class GameEvent: ScriptableObject
{
	private List<GameEventListener> listeners = new List<GameEventListener>();
	
	public void Raise() 
	{
		for (int i = listeners.Count - 1; i >= 0; i--)
		{
			listeners[i].OnEventRaised();
		}
	}
	
	public void RegisterListener(GameEventListener listener) { listeners.Add(listener); }
	public void UnregisterListener(GameEventListener listener) { listeners.Remove(listener); }
}
```

이제 `GameOverEvent`라는 애셋을 만들었다고 가정하면, 플레이어가 죽을 때 `GameOverEvent.Raise()`를 호출시키고 `UIManager`는 `GameOverEvent`를 구독하고 있다가 알림 오면 게임 오버 창을 띄우면 됨

#### 추추가 질문
>[!question]
>1. 이전에는 런타임 변수를 SO에서 관리하면 안된다고 배웠는데, 어떻게 해야 하나?
>2. 예제에서 `UIManager`가 `GameOverEvent`를 구독하는 시점과 어떤 객체/클래스에 대해 구독해야 하는가?

1. **SO는 에디터에서는 값이 저장되고, 빌드된 게임에서는 저장되지 않는다**는 특성이 있다. 또, **에디터 플레이 모드에서 바뀐 값은 플레이를 꺼도 남아있다**는 점 떄문에 혼란이 생긴다.

- `ISerializationCallbackReceiver`를 상속받게 해서 게임이 켜지거나 에디터에서 컴파일될 때 초기화되는 로직을 추가해주자.
- 저장될 값과 런타임 중에 사용할 값을 분리해야 하고
- 런타임 변수로 쓸 경우 게임 시작 시에 초기값으로 설정하는 로직이 들어가야 한다.

```cs
[CreateAssetMenu]
public class FloatVariable: ScriptableObject, ISerializationCallbackReceiver 
{
	public float InitialValue; // 에디터 설정 초기값
	
	[System.NonSerialized] 
	public float RuntimeValue;
	
	// 게임이 켜지거나 에디터에서 컴파일될 때 호출됨
	public void OnAfterDeserialize()
	{
		RuntimeValue = InitialValue; // 항상 초기값으로 리셋
	}
	
	public void OnBeforeSerialize() { }
}
```

2. `GameEventListener`을 `UIManager`에 추가하고, 아래처럼 구현한다.
```cs
using UnityEngine;
using UnityEngine.Events;

public class GameEventListener : MonoBehaviour
{
    [Tooltip("구독할 SO 이벤트 에셋")]
    public GameEvent Event; 

    [Tooltip("이벤트가 발생하면 실행할 실제 행동 (인스펙터 연결)")]
    public UnityEvent Response;

    private void OnEnable()
    {
        // 게임 오브젝트가 켜질 때 구독
        Event.RegisterListener(this);
    }

    private void OnDisable()
    {
        // 꺼질 때 구독 해제 (필수!)
        Event.UnregisterListener(this);
    }

    // SO가 이 함수를 호출해줍니다.
    public void OnEventRaised()
    {
        Response.Invoke(); // 연결된 UnityEvent 실행
    }
}
```

> 2번은 솔직히 이해가 안된다.. 너무 복잡하고 커지는데?


