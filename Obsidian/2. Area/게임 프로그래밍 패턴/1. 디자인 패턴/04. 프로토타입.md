#게임프로그래밍패턴

1. [[#프로토타입|프로토타입]]
2. [[#프로토타입 언어 패러다임|프로토타입 언어 패러다임]]
3. [[#데이터 모델링을 위한 프로토타입|데이터 모델링을 위한 프로토타입]]
4. [[#Prefab, Instantiate|Prefab, Instantiate]]
5. [[#데이터 모델링 - 원본을 상속받아 수정하기|데이터 모델링 - 원본을 상속받아 수정하기]]
	1. [[#데이터 모델링 - 원본을 상속받아 수정하기#Prefab Variant(프리팹 변형)|Prefab Variant(프리팹 변형)]]
	2. [[#데이터 모델링 - 원본을 상속받아 수정하기#SO|SO]]
6. [[#주의점|주의점]]
7. [[#질문이 생겨서 추가 질문|질문이 생겨서 추가 질문]]
	1. [[#질문이 생겨서 추가 질문#상속 중심의 접근|상속 중심의 접근]]
	2. [[#질문이 생겨서 추가 질문#컴포넌트 중심의 접근|컴포넌트 중심의 접근]]
	3. [[#질문이 생겨서 추가 질문#데이터 주도 접근|데이터 주도 접근]]

# 책 내용

## 프로토타입
- 일반적인 객체 생성은 클래스에서 인스턴스를 찍어내는 것이다.
- 하지만 몬스터의 종류가 수백 가지라면 클래스를 수백 개 만들어야 할까?
- `프로토타입Prototype` 패턴은 **원본 객체를 하나 만든 뒤, 복사해서 쓰는 패턴**이다. 

- 작동 방식
1. `Monster`라는 부모 클래스에 `clone()`이라는 가상 함수를 만듦.
2. **`Ghost` 객체를 하나 생성해 원본이라고 저장**해둠.
3. 유령이 **필요할 때는 `new Ghost()`로 만들지 않고, `originalGhost.Clone()`을 호출한다.**

## 프로토타입 언어 패러다임
- 초기의 JS나 Lua 등은 클래스라는 개념이 없고 객체 자체가 클래스 역할을 한다.
- 이런 겨우 상속은 "A 객체는 B 객체를 닮았다"는 방식으로 상속을 구현하고, 생성은 "이 객체를 복사해달라"는 식으로 새 객체를 만든다.

게임 개발자는 C#이나 C++ 등의 클래스 기반 언어를 쓰므로 그러려니 하고 넘기면 됨.

## 데이터 모델링을 위한 프로토타입
- 이 패턴은 `데이터 기반Data-Driven` 시스템을 만들때 빛을 발한다.

- 예시) 몬스터를 일일이 코딩할 수는 없다. 대신 아래처럼 구현할 수 있음.

```json
{
	"name" : "Goblin Grunt",
	"health" : 20,
	"damage" : 3
},
{
	"name" : "Goblin Archer",
	"prototype" : "Goblin Grunt", // 원본을 참조함
	"damage" : 5 // 달라진 부분은 재정의
}
```
이런 식으로 데이터 파일에서 어떤 원본을 복사한 뒤, 이 부분만 고쳐서 써라는 식으로 정의하면 코드 수정 없이 수천 가지의 변종 몬스터를 만들어낼 수 있다.

# 유니티에서
- 태생부터 프로토타입 패턴을 기반으로 설계되었다.

## Prefab, Instantiate
- **`Instantiate()`은 프로토타입 패턴의 `Clone()`과 동일하다.**
- **`Prefab` : 유니티가 제공하는 `원본 객체Prototype`** 로, 컴포넌트 세팅이나 자식 오브젝트 구조 등을 모두 만들어놓은 뒤 파일로 저장한 형태.

- 참고) `ICloneable`이라는 인터페이스가 C#에 있는데, 유니티 개발에서는 깊은 복사 vs 얕은 복사 문제로 잘 쓰지 않는다. 대신 데이터 클래스를 복제해야 한다면 직접 `Clone()` 메서드를 만드는 게 좋다.
```cs
public ItemData Clone()
{
	return new ItemData
	{
		itemName = this.itemName,
		damage = this.damage
	}
}
```

## 데이터 모델링 - 원본을 상속받아 수정하기

### Prefab Variant(프리팹 변형)
1. `Goblin` 프리팹을 만듦.
2. `Goblin` 프리팹 우클릭 - `Create > Prefab Variant`로 `Goblin Archer`를 만듦
3. 이 때 `Goblin Archer`는 `Goblin`의 모든 것을 물려받고 활을 들고 있다는 점만 다르다.
4. 원본 Goblin의 체력을 바꾸면 `Archer`도 바뀐다.

### SO
- 몬스터의 스탯 데이터를 `SO`로 만든다.
- 코드 없이 애셋 파일 복사만으로 새로운 몬스터 데이터를 양산할 수 있다.

## 주의점
1. `Instantiate`은 비싸다
- 오브젝트 풀링 패턴을 함께 사용하는 게 좋다.

2. `직렬화Serialization` 시스템
- 유니티의 모든 오브젝트는 엔진 내부의 직렬화 시스템에 의해 저장되고 복제된다.
- 게임 중 `Instantiate`를 호출하면 해당 객체를 메모리 상에서 직렬화(데이터화)했다가 다시 역직렬화(객체화)하는 과정을 거쳐 복제본을 만드는데, 이 과정이 무겁다는 것이다. 실시간으로 너무 복잡한 프리팹을 복제하는 건 피해야 한다. 

## 질문이 생겨서 추가 질문
> [!question]
> - 어떤 몬스터를 구현한다면 클래스로 구현하는 경우가 많은데, `Prefab Variant`를 써서 변종을 만들겠다는 건 원본 오브젝트 대비 어떤 변형을 가해주겠다는 것이다.
> - 그런데 공격 패턴이 근거리 -> 원거리로 바뀐다든가 하는 경우, 별도의 스크립트 수정이 함께 들어갈 것 같은데, 이런 경우에는 클래스 수정이 들어가니까 `Prefab Variant`가 크게 의미가 없는 게 아닐까?

- 구조에 따라 다르다. 

### 상속 중심의 접근
- `Monster`
	- `MeleeMonster`
	- `RangedMonster`

이런 경우 `Prefab Variant`로 `Goblin Archer`을 만든다면 원본 대비 공격하는 방식이 달라진다.
**`Prefab Variant`를 사용하기 적합한 상황은 단순히 값을 바꾸는 정도의 상황**이며, 스크립트를 갈아끼우는 건 베리언트의 장점을 해칠 수 있다. 그래서 이런 경우는 **클래스 수정/교체가 더 낫다.**

> **내가 해 온 프로젝트는 이런 방식을 취했다. 
> 다른 방식에는 어떤 것들이 있는지 공부해가는 느낌으로 접근해보자.**

### 컴포넌트 중심의 접근

- 유니티에서 권장하는 방식으로, **기능을 조각내서 붙인다**는 개념이다. 

- 구조
- `MonsterController` (메인 두뇌)
	- `MeleeAttack` (근접 공격 기능 컴포넌트)
	- `RangedAttack` (원거리 공격 기능 컴포넌트)
	- `MonsterStats` (체력, 공격력 데이터)

이 때 `Prefab Variant`를 적용하게 되면
- 원본 : `MonsterController, MonsterStats`만 붙어 있고 공격은 비어 있거나 기본값
- A : `Golbin` : 원본을 `Variant`로 생성한 다음 `MeleeAttack` 컴포넌트를 추가, `Monster Stats`의 공격력을 10으로 설정
- B : `Archer` : 원본을 `Variant`로 생성하고 `RangedAttack` 컴포넌트를 추가, 활 모델링을 교체, `MonsterStats`의 사거리를 20으로 설정

### 데이터 주도 접근
- `Monster` 클래스 하나만 존재
- 공격 로직은 `AttackStrategy`라는 `SO`로 분리

- `Prefab Variant` 적용 시
	- `Goblin` : `AttackStrategy` 슬롯에 `SwordAttackData` 애셋을 드래그해서 넣는다.
	- `Archer` : `AttackStrategy` 슬롯에 `BowAttackData` 애셋을 드래그해서 넣는다.

여기서 `AttackStrategy`는 동작 같은 게 들어가겠다. 

