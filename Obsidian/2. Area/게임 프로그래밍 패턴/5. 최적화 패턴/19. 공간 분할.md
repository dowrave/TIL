#게임프로그래밍패턴 


- 가까운 것들끼리 검사하자는 최적화 패턴.
- 충돌 감지, AI 시야 처리, 렌더링 최적화 등 위치가 중요한 모든 곳에 쓰인다.
## 책 내용
### 문제 상황 : N^2 의 저주
- 유닛이 전장에 100명 있을 때, 누가 누구랑 부딪혔는지 확인하려면 1만번 확인해야 함.
- 근데 모든 유닛을 일일이 검사하는 건 낭비다. 

### 해결책 : 격자(Grid)
- 맵을 바둑판Grid처럼 잘게 쪼갠다.
- 각 유닛은 자신이 속한 칸에 등록된다. 충돌 검사 시, 인접한 칸의 유닛들하고만 검사한다.

--> 유닛이 아무리 많더라도 내 주변 몇 명만 검사하면 되니까 연산량이 확 줄어든다.

### 다른 자료 구조들
- `쿼드트리Quadtree` : 2D 공간을 4등분씩 재귀적으로 나눈다. 유닛이 몰린 곳은 잘게 놔두고 빈 곳은 크게 둔다.
- `옥트리Octree` : 3D 공간을 8등분씩 나눈다.
- `BSP Binary Space Partitioning` : 공간을 임의의 평면으로 반씩 자른다.
	- 둠, 퀘이크 시절의 맵 데이터 저장용
- `BVH Bounding Volume Hierarchy` : 물체를 감싸는 박스들을 계층적으로 묶는다.
## 유니티에서
- 공간 분할을 직접 구현할 수도 있지만, **대부분 엔진의 기능을 믿고 쓴다.**

### 유니티 물리 엔진 (PhysX / Box2D)
- `Collider`를 붙이고 충돌 처리를 할때, 유니티 내부에서는 이미 `BVH` 같은 고성능 공간 분할 알고리즘이 돌아가고 있다.
	- 물론 `Collider`가 엄청 많아지면 느려지는 건 똑같다.

### 직접 구현해야 할 때 - RTS, 탄막 슈팅
- 물리 엔진`Rigidbody`은 무겁다. 
- 스타크래프트나 뱀서 같은 게임에서 수천 마리의 적을 다룰 때는 직접 `그리드Grid`나 `쿼드트리QuadTree`를 구현하는 게 빠르다.

#### 간단한 그리드 구현 아이디어
```cs
public class SpatialGrid : MonoBehaviour
{
	// 맵을 10x10으로 나눔
	private List<Unit>[,] cells = new List<Unit>[100, 100];
	private float cellSize = 5.0f;
	
	public void Add(Unit unit)
	{
		int x = (int)(unit.transform.position.x / cellsize);
		int y = (int)(unit.transform.position.y / cellsize);
		cells[x, y].Add(unit);
	}
	
	public List<Unit> GetNearby(Unit unit)
	{
		// 내 좌표에 해당하는 셀의 리스트만 리턴 - 실제로는 8개의 셀을 같이 봐야 함
	}
}
```

### 렌더링 최적화 - Occlusion Culling
- 유니티의 `오클루전 컬링` 기능도 공간 분할의 일종이다.
- 맵을 여러 구역`Cell`으로 나누고, "이 구역에서는 저 구역에 벽에 가려 보이지 않는다"는 데이터를 미리 구워둔다`Bake`
- 실행 중에 카메라가 있는 구역을 파악, 보이지 않는 구역의 오브젝트의 렌더링을 꺼버린다.

## 유니티에서 사용 시 주의할 점

### 언제 직접 구현하나?
- 일반적인 게임 : 유니티 `Collider`와 `Physics.OverlapSphere`만으로 충분히 빠르다.
- 최적화가 필요한 경우
	- 객체가 많을 때 - 수천 개 이상
	- 물리 엔진을 쓰지 않고 직접 충돌 로직을 짤 때
	- `Boids(군집 시뮬레이션)` - 물고기, 새 떼가 서로를 피해 움직이게 할 때, 주변 이웃을 찾기 위해 그리드나 쿼드 트리가 필수적이다.

### 동적 객체 처리
- 공간 분할의 단점 : 움직일 때마다 업데이트 비용이 든다.
- 유닛이 이동하면 이전 칸에서 빼서 새로운 칸에 넣어야 한다. 유닛이 너무 빨리, 많이 움직이면 업데이트 비용 < 충돌 검사 비용일 수 있다.

### 요약 - 유니티 개발자를 위한 가이드
1. 엔진 기능을 믿기 - 이미 최첨단임
2. 직접 구현 시 - 복잡한 쿼드트리보다는 단순한 그리드가 구현도 쉽고 성능도 좋다
3. 레이어 활용 - 유니티의 `Layer Collision Matrix`도 일종의 공간 분할(논리 분할)이다. "아군 끼리는 충돌 안 함" 같은 설정을 넣어두면 물리 엔진 성능이 올라간다.