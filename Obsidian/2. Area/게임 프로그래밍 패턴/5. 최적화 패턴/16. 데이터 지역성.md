#게임프로그래밍패턴 

1. [[#책 내용|책 내용]]
	1. [[#책 내용#문제 상황 : CPU는 빠르지만 메모리는 느리다|문제 상황 : CPU는 빠르지만 메모리는 느리다]]
	2. [[#책 내용#캐시 미스(Cache Miss)|캐시 미스(Cache Miss)]]
	3. [[#책 내용#해결책 : 데이터 붙여놓기|해결책 : 데이터 붙여놓기]]
2. [[#유니티에서|유니티에서]]
	1. [[#유니티에서#Class vs Struct|Class vs Struct]]
	2. [[#유니티에서#유니티의 DOTS(Data-Oriented Technology Stack)|유니티의 DOTS(Data-Oriented Technology Stack)]]
3. [[#유니티에서 사용 시 주의할 점|유니티에서 사용 시 주의할 점]]
	1. [[#유니티에서 사용 시 주의할 점#언제 신경써야 하나?|언제 신경써야 하나?]]
	2. [[#유니티에서 사용 시 주의할 점#배열 vs 리스트 vs 링크드 리스트|배열 vs 리스트 vs 링크드 리스트]]
	3. [[#유니티에서 사용 시 주의할 점#2D 배열 순회 순서|2D 배열 순회 순서]]
	4. [[#유니티에서 사용 시 주의할 점#요약|요약]]

## 책 내용

### 문제 상황 : CPU는 빠르지만 메모리는 느리다
- **CPU가 메모리에서 데이터를 가져오는 속도**는 CPU의 처리 속도에 비해 엄청 느리다.
- 그래서 CPU는 캐시라는 창고를 둔다.
- 메모리에서 데이터를 가져올 때, 딱 필요한 만큼만 가져오지 않고 **그 옆에 있는 데이터들(캐시 라인, 보통 64바이트)를 한꺼번에 가져와서 캐시에 저장**한다. 

### 캐시 미스(Cache Miss)
- 좋은 상황 : 함께 처리하려는 데이터가 캐시 라인에 딸려온 경우
- 나쁜 상황 : 캐시 라인에 딸려오지 않은 경우, CPU가 기다리는 시간이 발생함`Stall`

### 해결책 : 데이터 붙여놓기
- 데이터가 메모리 상에 연속적으로 붙어 있으면 캐시 적중률이 올라간다.

- 나쁜 예 : 포인터 체이싱
	- `GameEntity* entities[1000]`(포인터 배열)
	- 각 `Entity`는 `new`로 여기저기 흩뿌려져 있음
	- 루프 돌 때마다 메모리 여기저기를 점프해야 함 : 캐시 미스 폭발.
- 좋은 예 : 연속 배열
	- `GameEntity entities[1000]` (객체 배열)
	- 모든 데이터가 한 덩어리로 붙어 있음
	- 루프 돌 때 캐시가 미리 다음 데이터를 가져옴 : 성능 최적화
## 유니티에서
- C#은 `관리되는 언어Managed Language`이므로, 개발자가 메모리 배치를 통제하기 어렵다. 그래도 방법은 있다.

### Class vs Struct
- `Class(참조 타입)` : `new`할 때마다 힙 메모리의 랜덤한 위치에 생성된다. 배열에 넣어도 주소값만 연속적이지 실제 데이터는 흩어져 있다.
- `Struct(값 타입)` : 배열에 넣으면 데이터가 연속적으로 박힌다.

- 최적화를 위해선) 수천 개의 총알이나 파티클 관리 시, `class Bullet` 대신 `struct BulletData`를 사용하고 배열로 관리하면 성능이 빨라진다.

### 유니티의 DOTS(Data-Oriented Technology Stack)
- 유니티가 이 패턴을 극단적으로 적용하기 위해 만든 기술이 `DOTS`와 `ECS Entity-Controller-System`이다.

- 기존 방식 : `MonoBehaviour` - 게임 오브젝트와 컴포넌트들이 메모리에 흩어져 있음
- ECS 방식 
	- 모든 데이터를 `NativeArray<T>` 같은 연속된 메모리에 넣음
	- `IJobEntity`로 병렬 처리
	- 결과 - 기존 방식보다 훨씬 빠름

## 유니티에서 사용 시 주의할 점

### 언제 신경써야 하나?
- 일반적인 게임 로직(UI, 퀘스트, 소규모 전투) - 신경 꺼도 된다. 가독성이 더 중요하다.
- 대규모 연산(탄막 슈팅, 군중 시뮬레이션, 복셀 월드) - 데이터 지역성이 생명이다.

### 배열 vs 리스트 vs 링크드 리스트
- 배열, 리스트 : 메모리가 연속적이다. 순회 속도가 빠르다.
- 링크드 리스트 : 노드들이 메모리에 흩어져 있다. 포인터를 따라가야 하므로 캐시 미스가 많이 난다. **게임 개발에선 특별한 이유가 없다면 링크드 리스트를 피하는 게 좋다.**

### 2D 배열 순회 순서
```cs
// 좋은 예 (Row-major): 메모리 순서대로 읽음
for (int y = 0; y < height; y++)
    for (int x = 0; x < width; x++)
        Process(grid[y, x]);

// 나쁜 예 (Column-major): 메모리를 띄엄띄엄 읽음 (캐시 미스 유발)
for (int x = 0; x < width; x++)
    for (int y = 0; y < height; y++)
        Process(grid[y, x]);
```
> 이해가 안 된다면 위의 배열, 리스트가 갖는 "메모리의 연속성"을 생각해보자.


### 요약
- 기본 : `LinkedList` < `List, Array`
- 중급 : 대량의 데이터를 다룰 때는 `class` 대신 `struct` 배열을 고려해볼 것
- 고급 : 극한의 성능이 필요하다면 DOTS(ECS) 및 Burst Compiler을 공부할 것

