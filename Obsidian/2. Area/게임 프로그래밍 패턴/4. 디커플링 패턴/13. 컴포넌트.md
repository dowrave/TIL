#게임프로그래밍패턴

1. [[#책 내용|책 내용]]
	1. [[#책 내용#문제 상황 - 상속의 늪|문제 상황 - 상속의 늪]]
	2. [[#책 내용#해결책 : "가지는Has-a" 관계|해결책 : "가지는Has-a" 관계]]
	3. [[#책 내용#컴포넌트 간 통신|컴포넌트 간 통신]]
2. [[#유니티에서|유니티에서]]
	1. [[#유니티에서#컴포넌트 간 통신|컴포넌트 간 통신]]
3. [[#유니티에서 사용 시 주의할 점|유니티에서 사용 시 주의할 점]]
	1. [[#유니티에서 사용 시 주의할 점#너무 잘게 쪼개지 말기|너무 잘게 쪼개지 말기]]
	2. [[#유니티에서 사용 시 주의할 점#RequireComponent|RequireComponent]]
	3. [[#유니티에서 사용 시 주의할 점#ECS(Entity Component System) - 미래의 컴포넌트|ECS(Entity Component System) - 미래의 컴포넌트]]
	4. [[#유니티에서 사용 시 주의할 점#요약|요약]]

## 책 내용

### 문제 상황 - 상속의 늪

- `Bjorn`이라는 클래스를 만든다고 하자.
1. 입력 처리가 필요해 -> InputComponent 상속.
2. 물리가 필요해 -> PhysicsComponent 상속.
3. 그림을 그려야 해 -> GraphicsComponent 상속.

문제 
1. 다중 상속의 복잡함 - C#은 지원하지 않고, C++도 골치 아픈 문제가 생김
2. 거대 클래스 : 물리, 입력, 렌더링 코드가 다 섞여서 5000줄짜리 괴물이 된다.
3. 재사용 불가 : `Bjorn`의 물리 코드만 떼어서 `Monster`에게 주고싶은데 입력 코드랑 엉켜 있어서 분리되지 않는다.

### 해결책 : "가지는Has-a" 관계
```cs
class Bjorn {
    InputComponent* input;
    PhysicsComponent* physics;
    GraphicsComponent* graphics;

    void update() {
        input->update(*this);
        physics->update(*this);
        graphics->update(*this);
    }
};
```
이제 클래스는 껍데기(컨테이너)일 뿐이고, 실제 기능은 각 부품이 담당한다.

### 컴포넌트 간 통신
- 컴포넌트끼리의 대화가 필요한 경우가 있다.
- 예) 입력 컴포넌트가 점프 키를 받으면 물리 컴포넌트가 위로 힘을 가함

- 이럴 때는 컨테이너를 통해 메시지를 전달시킨다.
	- 컨테이너를 통해 : `bjorn.physics -> jump()` (직접 참조)
	- 메시지 전달 : `bjorn.send("JUMP")` (모든 컴포넌트가 메시지를 받고 알아서 처리)
## 유니티에서
- `GameObject`가 컨테이너, `MonoBehaviour`가 컴포넌트가 된다. 
	- `MonoBehaviour`는 우리가 만드는 대부분의 스크립트에 상속되는 요소임
- 나쁜 예시
```cs
public class Player : MonoBehaviour {
    void Update() {
        HandleInput();
        MovePhysics();
        PlayAnimation();
        PlaySound();
    }
}
```

- 좋은 예시
```text
PlayerInput.cs: 입력만 받음.
PlayerMovement.cs: 이동만 담당 (Rigidbody 제어).
PlayerAnimation.cs: 애니메이션만 담당.
PlayerAudio.cs: 소리만 담당.
```

### 컴포넌트 간 통신
- 유니티에서의 대화법은 크게 3개다.
1. `GetComponent` - 직접 참조
2. `SendMessage` - 메시지 방식 : 비추천
	- 느리고 에러 찾기가 힘들다.
3. `UnityEvent / Action` - 관찰자 패턴
	- `PlayerInput`은 `OnJump` 이벤트만 날리고, `PlayerMovement`가 이를 구독한다.
	- 서로의 존재를 몰라도 되기에 가장 유연하다.
## 유니티에서 사용 시 주의할 점

### 너무 잘게 쪼개지 말기
- `Jump, Walk, Run` 까지 너무 잘게 쪼갤 필요는 없다.
- 판단 기준) 이 기능을 다른 오브젝트에서도 재사용할 것인가?
- `Health` 컴포넌트의 경우 플레이어, 몬스터, 파괴 가능한 상자 모두 쓰니까 분리해주는 게 좋다.
### RequireComponent
- 스크립트가 다른 컴포넌트를 반드시 필요로 한다면 반드시 명시해주는 게 좋다.
```cs
[RequireComponent(typeof(Rigidbody))]
public class PlayerMovement: MonoBehaviour { ... }
```
### ECS(Entity Component System) - 미래의 컴포넌트
- 유니티가 밀고 있는 `DOTS(Data-Oriented Technology Stack)`의 핵심인 ECS는 컴포넌트 패턴의 진화형이다.

- 기존 : 컴포넌트가 `데이터 int hp`와 `행동 void TakeDamage`을 모두 가짐
- ECS
	- `Entity` : ID만 있는 껍데기
	- `Component` : 오직 데이터만 가짐 `struct Health {int value; }`
	- `System` : 행동만 가짐 `class DamageSystem`
- 장점 : 메모리 효율과 성능이 극대화되어 수만 개의 오브젝트를 처리할 수 있다.

### 요약
1. 사고방식 전환 : "플레이어 클래스를 만든다"가 아니라, "플레이어 게임 오브젝트에 사용할 부품을 조립한다"고 생각하기.
2. 단일 책임 원칙 : 1개의 스크립트는 1개의 역할만 하면 된다. `PlayerController`에 체력 관리, 인벤토리, 이동 코드가 다 들어 있다면 리팩토링 대상이다.
3. 재사용성 : 잘 만든 컴포넌트는 다음 프로젝트에서도 그대로 가져다 쓸 수 있다.

