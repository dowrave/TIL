

뷰는 웹 요청을 받아 **최종 응답 데이터를 웹 클라이언트로 반환하는 함수(호출 가능한 객체 = Callable)** 이다. 웹 요청을 분석하고 데이터베이스 처리 등 필요한 로직을 수행하고, 템플릿을 통해 화면에 표시할 데이터를 만들어 최종 데이터를 웹 클라이언트에게 응답해준다.  
장고에서는 뷰를 작성할 때, 함수와 클래스 모두 사용할 수 있다. 간단한 프로젝트라면 함수가 좋지만, **복잡해질수록 클래스가 효율적**이다. 클래스형 제네릭 뷰가 잘 준비되어 있기도 하다.
이번 장에서는 클래스형 뷰의 핵심 원리를 설명한다. `오버라이딩`, 내부 처리과정을 이해할 수 있는 `Method Flowchart`, 다중 상속에 필요한 `MRO` 등이 설명된다. 이외에도 `페이징 처리`와` 단축 함수`도 살펴본다.

## 제네릭 뷰 선택
- 클래스형 뷰를 작성하기 위해 필요한 속성과 메소드를 오버라이딩해야 한다. 이를 위해선 제네릭 뷰의 내용을 알고 있어야 한다.

### 제네릭 뷰 요약
- `제네릭 뷰` : 웹 프로그램 개발 시 공통적으로 사용하는 로직이 들어 있는 기본 클래스.

#### BaseView
- `View` : 가장 기본적인 최상위 제네릭 뷰.
- `TemplateView` : 템플릿이 주어지면 렌더링해준다.
- `RedirectView` : URL이 주어지면 해당 URL로 리다이렉트해준다.

#### GenericDisplayView
- `DetailView` : 객체 하나에 대한 상세한 정보를 보여준다.
- `ListView` : 조건에 맞는 여러 개의 객체를 보여준다.


#### GenericEditView
- `FormView` : 폼이 주어지면 해당 폼을 보여준다.
- `CreateView` : 객체를 생성하는 폼을 보여준다.
- `UpdateView` : 기존 객체를 수정하는 폼을 보여준다.
- `DeleteView` : 기존 객체를 삭제하는 폼을 보여준다.

#### GenericDateView
- `YearArchiveView` : 연도에 해당하는 객체를 보여준다.
- `MonthArchiveView` : 연, 월에 해당하는 객체를 보여준다.
- `WeekArchiveView` : 연, 주에 해당하는 객체를 보여준다.
- `DayArchiveView` : 연, 월, 일에 해당하는 객체를 보여준다.
- `TodayArchiveView` : 오늘에 해당하는 객체를 보여준다.
- `DateDetailView` : 연, 월, 일, 기본 키(or 슬러그)가 주어지면 그에 해당하는 특정 객체 `하나`에 대한 상세한 정보를 보여준다.

### View
- 최상위 뷰로, 모든 클래스형 뷰는 이를 상속받는다.
- 직접 상속받을 일은 잘 없으나, 필요한 경우 이 뷰를 상속받아 스스로 클래스형 뷰를 작성할 수 있다.
- 예시) `Hello, World!`를 화면에 출력하는 `TestView` 구현
```python
class TestView(View):
	def get(self, request, *args, **kwargs):
		return HttpResponse("Hello, World!")
```

### TemplateView
- 단순하게 화면에 보여줄 템플릿 파일을 처리한다. 가장 기본은 템플릿 파일만을 지정한다.
- 예시) `HomeView는` TemplateView를 상속받아 `home.html` 템플릿 파일을 렌더링해서 화면에 보여준다.
```python
class HomeView(TemplateView):
	template_name = 'home.html'
```

### RedirectView
- 주어진 URL로 리다이렉트시켜주는 제네릭 뷰로, URL 속성이 반드시 필요하다.
- URL 패턴명이 주어져도 알 수 있으며, URL을 알 수 없다면 HttpResponseGone(410) 에러 응답을 발생시킨다. 가장 간단하게는 리다이렉트만을 지정할 수도 있다.
```python
class TestRedirectView(RedirectView):
	url = 'blog/posts/'
	# pattern_name = 'blog:post_list' # URL 대신 패턴명을 지정해도 무방하다.
```

### DetailView
- `ListView`와 함께 가장 많이 사용되는 제네릭 뷰이다.
- 특정 객체 하나에 대한 정보를 보여주는 뷰로, 가장 많이 쓰이는 예시는 테이블에서 `기본 키(PK)`로 지정된 레코드 하나에 대한 정보들을 보여주는 뷰이다.

- -- 예시) 3장에서 작성한 `PostDV` 뷰.
```python
class PostDV(DetailView):
	model = Post
```
- Post 테이블에서 특정 레코드 하나를 읽은 뒤, 해당 레코드를 `object` 컨텍스트 변수에 담아서 템플릿에 넘겨준다. 템플릿 파일에서는 `{{ object }}` 변수를 이용해 레코드 정보를 출력한다.

- 그렇다면 모델만 지정했는데 어떻게 특정 레코드를 읽을 수 있을까? : `urls.py`를 보면 아래처럼 지정되어 있다.
```python
# /post/django-example/
re_path(r'^post/(?P<slug>[-\w]+)/$', PostDV.as_view(), name="post_detail")
```
>- `/blog/post/django-example` 이라는 URL이 들어오면, `PostDV.as_view()`를 호출 시 
	- 인자로 사전 데이터 `{'slug' : 'django-example'}`을 넘겨준다. 
	- 이 `slug` 인자로 `Post` 테이블을 검색, `slug` 컬럼이 `django-example`인 레코드를 찾는다.

- 즉, `DetailView` 제네릭 뷰를 사용 시, 테이블은 `View`의 클래스에서, 레코드 검색용 키는 `URLconf`에서 지정하는 것이다. 
	- 검색용 키는 일반적으로 `<pk>`를 쓰기도 하지만, `<slug>`를 쓰는 경우도 있다.

### ListView
- 여러 객체의 리스트를 보여주는 뷰. 주로 테이블의 모든 레코드를 리스트로 보여준다.
```python
class PostLV(ListView):
	model = Post
```
> Post 테이블에서 모든 레코드를 읽은 뒤, `object_list` 컨텍스트 변수에 담아 템플릿에 넘겨준다. 템플릿에서는 `{{ object_list }}` 변수를 사용해 레코드 리스트를 출력한다.

### FormView
- 폼을 보여주는 제네릭 뷰. 아래 3가지가 `주요 속성`이다.
	- 폼을 지정하는 `form_class`
	- 렌더링에 필요한 `template_name`
	- (안 쓸 수도 있음) 폼 처리 성공 후에 리다이렉트 목적지를 지정하는 `success_url` 

- 폼을 처리하는 작업은 꽤 복잡한 편이다. 
	- `get()`, `post()`를 구분하므로 처리하는 내용이 다름
	- 사용자가 폼에 입력한 데이터가 유효한지에 대한 검사
	- 처리 완료 후 페이지 이동
- 위 과정은 모두 `FormView`가 알아서 처리하고, 개발자는 주요 속성 등 필요한 속성과 메소드를 오버라이딩하면 된다.

- 예시) 9장의 `SearchFormView`
```python
class SearchFormView(FormView):
	form_class = PostSearchForm
	template_name = 'blog/post_search.html'

	def form_valid(self, form):
		schWord = '%s' % self.request.POST['search_word']
		post_list = Post.objects.filter(Q(title__icontains=schWord) | Q(description__icontains=schWord) | Q(content__icontains=schWord)).distinct()
		
		context = {}
		context['form'] = form
		context['search_form'] = schWord
		context['object_list'] = post_list
		
		return render(self.request, self.template_name, context) # No redirection
```
> - `form_valid()` 메서드는 제출된 폼이 유효성 검사를 통과하면 호출되는 메서드다.
> - 사용자가 폼에 검색용 단어를 입력하고 제출하면, 검색하는 작업은 `form_valid()` 메소드 내부에 정의되어 있다.
> - 여기선 `success_url` 속성은 지정되지 않았는데, 검색 처리 완료 후 새로운 페이지로 이동하지 않고 검색 결과를 같은 페이지에 보여주기 때문에 리다이렉트를 하지 않는다.


### CreateView
- 새로운 레코드를 생성해서 테이블에 저장하는 뷰이다.
- 따라서 새로운 레코드를 생성하기 위한 정보를 입력받는 폼이 필요하다. 그래서 **`FormView`의 기능이 포함되어 있다.** 
	- 추가로, `모델 정의로부터 폼을 자동으로 만들어주는 기능`과, `DB에 레코드를 저장하는 기능`이 더 추가되어 있다.
	- 즉, `CreateView`는 작업 대상이 되는 테이블의 정의로부터 폼을 만들 수 있고, 최종적으로는 그 테이블에 레코드를 저장하는 것이 주 역할이다. 

- 예제 ) 12장의 `PostCreateView`
```python
class PostCreateView(LoginRequiredMixin, CreateView):
	model = Post
	fields = ['title', 'slug', 'description', 'content', 'tag']
	initial = {'slug' : 'auto-filling-do-not-input'}
	success_url = reverse_lazy('blog:index')
	
	def form_valid(self, form):
		form.instance_owner = self.request.user
		return super(PostCreateView, self).form_valid(form)
```
> 1. `fields` : 폼을 만들 때 사용할 필드
> 2. `success_url` : 처리가 성공한 뒤 이동할 URL
> 3. `form_valid` 내부에는 `form.instance_owner`에 현재 로그인한 사용자`self.request.user`를 자동으로 채워준다. 그 다음은 유효성 검사 처리.

### UpdateView
- 테이블의 레코드를 수정하는 뷰로, `CreateView`와 매우 유사하다. 수정한다는 차이만 있음

- 예제) `PostUpdateView`
```python
class PostUpdateView(LoginRequiredMixin, UpdateView):
	model = Post
	fields = ['title', 'slug', 'description', 'content', 'tag']
	success_url = reverse_lazy('blog:index')
```
> 여기서도 유의할 점으로, 수정할 레코드는 `urlconf`에서 지정한다. (`detailview`와 비슷)
```python
# Example : /99/update/
re_path(r'^(?P<pk>[0-9]+/update/$', PostUpdateView.as_view(), name = 'update')
```
> `blog/99/update/`라는 URL이 들어오면, `PostUpdateView.as_view()`를 호출할 떄 인자로 사전 데이터 `{'pk' : 99}`를 넘겨준다. 


### DeleteView
- 기존 객체를 삭제하기 위한 제네릭 뷰.
- `UpdateView`와 처리 과정이 비슷하나, 폼 모습만 다르다.
	- 삭제 확인용 폼만 필요하므로 입력 항목이 불필요하고 모델 정의를 참조하지도 ㅇ낳ㄴㄴ다.

- 예제)`PostDeleteView`
```python
class PostDeleteView(LoginRequiredMixin, DeleteView):
	model = Post
	success_url = reverse_lazy('blog:index')
```
> 마찬가지로, 수정할 레코드는 `urlconf`에서 지정한다.
```python
re_path(r'^(?P<pk>[0-9]+/delete/$', PostDeleteView.as_view(), name='delete')
```


### ArchiveIndexView
- 여러 개의 객체를 대상으로 날짜를 기준으로 리스팅한다.
- 날짜 기반 제네릭 뷰의 촤싱위 뷰로, 모든 객체를 날짜 기준 내림차순으로 보여준다. 
	- `date_field` : 날짜 관련 필드 중 어느 필드를 기준으로 정렬할지를 결정한다.
```python
class PostAV(ArchiveIndexView):
	model = Post
	date_field = "modify_date"
```
> 디폴트가 내림차순이므로 '-'를 붙이지는 않는듯.
- 템플릿에 넘겨주는 컨텍스트 변수 중, `object_list`는 객체들의 리스트를 담고, `date_list`는 객체들의 `연도`를 담고 있다.

### YearArchiveView
- 연도가 주어지면 여러 객체를 대상으로 가능한 `월Month`을 알려준다.
	- 디폴트 동작이 객체 출력이 아니라 `월` 추출임을 유의!
	- 객체를 알고 싶다면 `make_object_list = True`를 지정해야 한다. 
	- 이외에도 `model`, `date_field` 속성을 지정해준다.

```python
class PostYAV(YearArchiveView):
	model = Post
	date_field = 'modify_date'
	make_object_list = True
```
> 인자를 URLconf에서 추출한다. 여기서는 연도 인자를 추출함.
```python
re_path(r'^(?P<year>\d{4})/$', PostYAV.as_view(), name = 'post_year_archive')
```
> `blog/2012/`라는 URL이 들어오면,   
> 사전형 데이터 `{'year':'2012'}`를 `PostYAV.as_view()` 메소드에 넘겨주고,  
> `PostYAV` 뷰는 `modify_date` 컬럼의 연도가 2012인 레코드를 찾아준다.  

- 템플릿에 넘겨주는 변수
	- `object_list` : 인자로 주어진 연도에 해당하는 객체들의 리스트. `make_object_list = True`일 때만 생성된다.
	- `date_list` : 그 객체들의 `월Month`
### MonthArchiveView
- 주어진 연/월에 해당하는 객체를 보여준다. 
- `연/월`은 URLconf에서 지정한다.
- `make_object_list` 속성은 없다.
```python
class PostMAV(MonthArchiveView):
	model = Post
	date_field = 'modify_date'
```
> 연, 월 2개의 인자가 필요하며, 이들은 URLConf에서 추출한다.
```python
re_path(r'^(P?<year>\d{4})/(?P<month>[a-z]{3})/$', PostMAV.as_view(), name = 'post_month_archive')
```
- 템플릿에 넘겨주는 변수
	- `object_list` : 연/월에 해당하는 객체들의 리스트
	- `date_list` : 그 객체들의 `일Day`

### WeekArchiveView
- 주어진 연/주에 해당하는 객체를 보여준다. 
- `주Week` 인자는 1년을 주차로 표현하며, 1부터 53까지의 값을 가진다.
- `ArchiveIndexView`가 갖는 속성인 `model`, `date_field` 속성을 지정한다.
```python
class TextWeekArchiveView(WeekArchiveView):
	model = Post
	date_field = 'modify_date'
```
> 연도, 주차는 URLconf에서 추출한다.
```python
re_path(r'^(?<year>\d{4})/week/(?P<week>\d{1,2})/$', TestWeekArchiveView.as_view(), name='post_week_archive')
```
- `object_list` : 연/주에 해당하는 객체 리스트
- `date_list` : 그 객체들의 연도`year`

### DayArchiveView
- 계속 동일한데, `re_path` 구성만 보자.
```python
re_path(r'^(?P<year>\d{4})/(?P<month>[a-z]{3}/(?P<day>\d{1,2}/$', PostDAV.as_view(), name = 'post_day_archive')
```
- 연월일을 받는데, 월의 경우 `jan, feb, mar` 같이 영어로 3글자를 받는다.

### TodayArchiveView
- 오늘 날짜에 해당하는 객체만 보여준다. 나머지는 `DayArchiveView`와 동일하며, 연/월/일 인자가 필요하지 않다.
```python
re_path(r'^today/$', PostTAV.as_view(), name='post_today_archive')
```

### DateDetailView
- 날짜 기준으로 특정 객체를 찾아 상세 정보를 보여주는 뷰이다.
- `DetailView`와 동일하지만, 인자로 `연/월/일` 정보를 추가로 사용한다. 
	- 기본 키나 slug 인자도 사용하므로 `연/월/일/pk` 4개의 인자가 필요하며, 이들은 URLconf에서 추출한다.
	- `model`과 `date_field` 속성을 지정한다.
```python
re_path(r'^(?P<year>[0-9]{4})/(?P<month>[-\w]+)/(?P<day>[0-9]+)/(?P<pk>[0-9]+)/$', TestDateDetailView.as_view(), name = 'post_archive_detail')
```
- 단일 객체를 출력하므로 `object_list, date_list`를 사용하지 않는다.
	- `object`는 쓰지만 `date`는 사용하지 않는다.
	- `object` : `연/월/일/pk`로 찾은 객체 1개가 들어 있다.

### 제네릭 뷰의 작업 대상 객체
- 제네릭 뷰의 작업 대상이 반드시 테이블일 필요는 없다. 
- 일반 객체들이 들어있는 `QuerySet` 객체라면 제네릭 뷰의 작업 대상이 된다.
- 따라서, 대부분의 제네릭 뷰는 작업 대상 객체를 지정하기 위해 `model` 속성, `queryset` 속성 or `get_queryset()` 메소드를 제공한다.
- 작업 대상을 지정할 필요 없는 `View, TemplateView, RedirectView, FormView` 등은 `model`이나 `queryset` 속성을 사용하지 않는다.

## 제네릭 뷰 오버라이딩
- 제네릭 뷰를 선택했다면, 해당 제네릭뷰의 속성과 메소드 중 무엇을 오버라이딩할지 결정해야 한다.
- 모든 걸 알긴 어렵고 자주 사용되는 것들 위주로 설명한다.

### 속성 오버라이딩

#### model
- 기본 뷰 3개(View, TemplateView, RedirectView)를 제외하고는 모든 제네릭 뷰에서 사용하는 속성이다. 
- 뷰가 출력할 데이터가 들어 있는 모델을 지정한다.
- 아래 2개는 동일한 의미이다.
```python
model = Bookmark
queryset = Bookmark.objects.all()
```

#### queryset
- 기본 뷰 3개를 제외한 모든 제네릭 뷰에서 사용하는 속성이다. 
- 출력 대상이 되는 QuerySet 객체를 지정한다.
	- 지정될 경우, `model` 속성은 무시된다.

#### template_name
- 모든 제네릭 뷰에서 사용되며, 템플릿 파일명을 문자열로 지정한다.

#### context_object_name
- 기본 뷰 3개를 제외한 모든 제네릭 뷰에서 사용한다.
- 템플릿 파일에서 사용할 컨텍스트 변수명을 지정한다.

#### paginate_by
- `ListView` 및 날짜 기반 뷰에서 사용된다. 
- 페이지 당 몇개의 항목을 출력할 것인지 정수로 지정한다.

#### date_field
- 날짜 기반 뷰에서 사용한다.
- 기준이 되는 필드를 지정한다. `DateField, DateTimeField`에만 지정할 수 있다.

#### make_object_list
- `YearArchiveView` 사용 시, 해당 년에 맞는 객체를 생성할지 여부를 지정한다.
- `False`일 경우 `queryset` 속성에 `None`이 된다.

#### form_class
- `FormView, CreateView, UpdateView`
- 폼을 만드는 데 사용할 클래스를 지정한다.

#### initial
- `FormView, CreateView, UpdateView`
- 폼에 사용할 초기 데이터를 `dict` 형태로 지정한다.

#### fields
- `CreateView, UpdateView`
- 폼에 사용할 필드를 지정한다.
- `ModelForm` 클래스의 `Meta.fields` 속성과 동일한 의미이다.

#### success_url
- `FormView, CreateView, UpdateView`
- 폼에 대한 처리가 성공적일 때 리다이렉트될 URL을 지정한다.

### 메소드 오버라이딩

#### get_queryset()
- 기본 뷰 3개를 제외한 모든 제네릭 뷰에서 사용하는 메소드.
- 출력 객체를 검색하기 위한 대상 QuerySet 객체 또는 출력 대상인 객체 리스트를 반환한다.
- 디폴트는 `queryset` 속성값을 반환한다.
- 지정되지 않은 경우, 모델 매니저 클래스의 `all()` 메소드를 호출해 `QuerySet` 객체를 생성한 후 반환한다.

#### get_context_data()
- 모든 제네릭 뷰에서 사용하는 메소드로, 템플릿에서 사용할 컨텍스트 데이터를 반환한다.

#### form_valid(form)
- `FormView, CreateView, UpdateView`
- `get_success_url()` 메소드가 반환하는 URL로 리다이렉트를 수행한다.

### 본문의 예제
- `Blog` 엡에서 진행한다.
#### queryset 속성
```python
# urls.py
    # Example: /test/
    re_path(r'^test/$', TestPostLV.as_view(), name='post_test'),
```
```python
# views.py
#--- ListView
class PostLV(ListView):
    model = Post # PostLV 클래스의 대상 테이블
    template_name = 'blog/post_all.html' # 지정 X 시 blog/post_list.html
    context_object_name = 'posts' # 템플릿에 넘겨주는 컨텍스트 변수명. 디폴트인 object_list도 여전히 사용 가능
    paginate_by = 2 # 한 페이지에 보여주는 객체 리스트의 숫자. 페이징 기능 활성화 & 이동 버튼 자동 활성화.

class TestPostLV(ListView):
    # model = Post
    queryset = Post.objects.all()[:5]
    template_name = 'blog/post_all.html'
    context_object_name = 'posts'
    paginate_by = 2
```
>- 모든 포스트 리스트가 아닌 앞 5개의 객체만을 꺼내고 싶을 경우, 새롭게 `queryset`을 지정한 다음 `model`은 주석처리한다.


#### get_queryset() 메소드
- `get_queryset()`메소드 오버라이딩 방식으로 출력 대상을 변경한다.
- 포스트 글에 특정 단어가 들어 있는 객체들만 보여주는 로직으로 변경하는데, 특정 단어는 URL에 지정한다.
- 이를 위해 `urls.py`와 `views.py`를 아래처럼 수정한다.
```python
# blog/urls.py

# ex)blog/test/검색어(글에 포함되어도 검색 가능)
re_path(r'^test/(?P<word>[\w]+/$', TestPostLV.as_view(), name='post_test')


# views.py
class TestPostLV(ListView):
    # model = Post
    queryset = Post.objects.all()[:5]
    # template_name = 'blog/post_all.html'
    template_name = 'blog/post_test.html'
    context_object_name = 'posts'
    paginate_by = 2

    def get_queryset(self):
        return Post.objects.filter(Q(content__icontains = self.kwargs['word'])).distinct()
```

- 또한, `post_test.html`도 `post_all.html`에서 가져오되, 아래 부분만 바꾼다.
```html
<h1>Blog List - test</h1>
```

#### get_context_data() 메소드
- 뷰에서 템플릿 파일에 넘겨주는 컨텍스트 데이터를 추가하거나 변경할 수 있다.
- 제네릭 뷰에서 디폴트로 사용하는 컨텍스트 변수가 있다.
	- `object_list` : `ListView`에서 사용
	- `object` : `DetailView`에서 사용
- 이외에 추가하고 싶은 컨텍스트 변수가 있을 때, `get_context_data()` 메소드를 오버라이딩한다.

- 만약 URL에 지정된 검색 단어를 페이지에 출력하고자 한다면, 검색 단어를 컨텍스트 객체에 담아서 템플릿 파일에 넘겨주면 된다.
```python
# views.py
class TestPostLV(ListView):

	# ...
	
	def get_context_data(self, **kwargs):
        context = super(TestPostLV, self).get_context_data(**kwargs)
        context['SearchWord'] = self.kwargs['word']
        return context
```
> 이후, `post_test.html`에서 아래 항목처럼 수정한다.
```html
<h1>Blog List - contains the word '{{ SearchWord }}'</h1>
```
- 여기서 보이듯 `context`에 `key`로 지정한 항목이 컨텍스트 변수로 들어간다.

## Method FlowChart
- 제네릭 뷰의 메소드는 단위 기능으로 잘게 나눠 메소드의 응집도를 높이고, 템플릿 메소드 디자인 패턴을 적용해 개발자가 제네릭 뷰의 처리 흐름을 쉽게 예상할 수 있도록 했다.
- 이러한 제네릭 뷰의 처리 흐름을 `Method Flowchart`라 표기하고 있다.

> `템플릿 메소드 디자인 패턴`
> 자바 언어에서 많이 사용되는 디자인 패턴으로, 소프트웨어 설계 시 공통적으로 반복해서 발생하는 문제와 해법을 유형화하여 정리한 것이다. `GoF : Gang of Four`로 불리는 4명이 정리한 23개의 디자인 패턴이 유명하다.  
> 그 중, 템플릿 메소드 패턴은 상위 클래스에서 처리 흐름의 뼈대를 결정하고 하위 클래스에서 구체적인 내용을 결정하는 디자인 패턴이다. 
> 따라서 상위 클래스의 프로그램만 보면, 주요 메소드들의 호출 순서 및 처리 흐름을 짐작할 수 있게 된다.

### ListView
- `ListView`의 처리 흐름은 아래처럼 진행된다. 
- 소스를 보지 않더라도 처리 흐름을 짐작할 수 있다.
- 따라서 하위 클래스형 뷰를 제작할 때는 이 Method Flowchart 흐름에 맞춰 설계하고, 어느 메소드를 오버라이딩할지를 결정하고 코딩하면 된다.

1. `dispatch(request, *args, **kwargs)`
- 클라이언트 요청의 HTTP 메소드를 검사하여 뷰 클래스에 정의된 적절한 처리 메소드를 호출한다.
	- `GET` -> `get()` 호출
	- `POST` -> `post()` 호출
- HTTP 메소드 단어의 소문자에 해당하는 메소드를 호출한다.

2. `http_method_not_aloowed(request, *args, **kwargs)`
-  `dispatch()` 메소드에 의해 호출되는 메인 처리 메소드를 찾지 못하는 경우 호출된다.

3. `get_template_names()`
- 템플릿 파일명을 담은 리스트를 반환한다.
- `template_name` 속성이 지정된 경우 지정된 `template_name`을 리스트에 담아 반환한다.

4. `get_queryset()`
- 뷰에서 출력할 항목들의 리스트를 반환한다. 
- 리스트는 `QuerySet` 객체와 같이, `iterable` 객체여야 한다.

5. `get_context_object_name(object_list)`
- 출력 대상이 되는 리스트에 대한 컨텍스트 변수명을 리턴한다.
- 따로 `context_object_name`이 지정되지 않았다면, `모델명소문자_list`로 해서 컨텍스트 변수명으로 사용한다. ex) bookmark_list

6. `get_context_data(**kwargs)`
- 템플릿에서 사용할 컨텍스트 데이터를 리턴한다.

7. `get()`
- 메인 처리 메소드

8. `render_to_response(context, **response_kwargs)`
- `self.response_class` 객체를 리턴한다.

### DetailView
- 동일한 내용은 설명하지 않음

1. `dispatch(request, *args, **kwargs)`
2. `http_method_not_allowed(request, *args, **kwargs)`
3. `get_template_names()`
4. `get_slug_field()`
	- `slug` 필드명을 반환한다. 디폴트는 `slug_field` 속성값을 반환한다.
5. `get_queryset()`
	- 출력 객체 검색을 위한 대상 `QuerySet` 객체를 반환한다. 디폴트는 `queryset` 속성값 반환.
	- `queryset` 속성이 지정되지 않은 경우 모델 매니저 클래스의 `all()` 메소드를 호출해 `QuerySet` 객체를 생성한 뒤 반환한다.
6. `get_object(queryset=None)`
	- 뷰가 출력할 1개 객체를 리턴한다.
	- `queryset` 속성이 지정되었다면 `queryset`에서 객체를 검색한다.
	- `queryset` 속성이 지정되지 않았다면 `get_queryset()`을 호출해 검색 대상 객체 리스트를 얻는다.
7. `get_context_object_name(object)`
	- 컨텍스트 변수명을 리턴한다. `Bookmark -> bookmark`
8. `get_context_data(**kwargs)`
9. `get()`
10. `render_to_response(context, **response_kwargs)`

## MRO(Method Resolution Order)
- 파이썬은 다중 상속이 되니, 장고도 다중 상속을 쓴다.
- 다중 상속에서는 같은 이름을 갖는 메소드가 둘 이상의 부모 클래스에 존재한다면 어느 메소드를 사용해야 할지 결정해야 한다. 파이썬에서는 클래스마다 메소드를 찾는 순서를 정한 `MRO: Method Resolution Order` 속성을 제공한다.

- 장고의 제네릭 뷰를 쓸 때는 크게 상관 없지만, 다른 개발자가 직접 작성한 클래스를 상속받은 경우에는 MRO에 따른 메소드 순서를 잘 따져봐야 한다.

- 예시) `ListView` : [[ListView 상속계층도.canvas|ListView 상속계층도]]
	- MRO는 자신에서부터 시작되어 하위 -> 상위 클래스 순서로 정해진다. 
	- `class(A, B)` 같은 다중 상속의 경우, 정의된 순서에 따라 `A` 클래스 다음 `B` 클래스 순서로 MRO가 정해진다.
	- DFS보다는 BFS에 가깝다.

- 사실, MRO 순서는 매우 복잡하기 떄문에 계층도 그림으로 정확히 알 수 없다. 파이썬의 디폴트 메소드로 `__mro__`가 있다. 모든 클래스마다 mro 순서를 보여준다.

- ListView의 상위 클래스 설명

| 상위 클래스명                       | 설명                                                                                                    |
| ----------------------------------- | ------------------------------------------------------------------------------------------------------- |
| MultipleObjectTemplateResponseMixin | 여러 개의 객체를 렌더링하는 믹스인 클래스이다. 객체 리스트를 템플릿 엔진에 넘겨줘 렌더링한다.           |
| TemplateResponseMixin               | 컨텍스트 데이터가 주어지면 이 데이터를 렌더링해 HTTP 응답으로 사용될 TemplateResponse  객체를 생성한다. |
| BaseListView                        | 객체 리스트를 출력하는 용도의 Generic Display Views 뷰들에 대한 베이스 뷰                               |
| MultipleObjectMixin                 | 객체 리스트를 출력하는 믹스인 클래스                                                                    |
| View                                | 모든 클래스형 뷰에 대한 베이스 뷰                                                                       |
| object                              | 모든 파이썬 클래스에 대한 베이스 클래스                                                                                                        |


> `믹스인Mixin 클래스`
> 자신의 인스턴스를 만들기보다는 다른 클래스에 부가적인 기능을 제공하기 위한 용도로 사용되는 클래스. 
> 꼭 필요한 단위 기능들을 믹스인 클래스로 만든 뒤, 제네릭 뷰에서 믹스인 클래스들을 상속받는 방식으로 제네릭 뷰를 설계했다.
> 예를 들어 모든 제네릭 뷰에서 템플릿 처리 기능은 필수인데, 1개의 객체와 여러 개의 객체일 때 처리 과정이 다르기 떄문에 이를 별도의 믹스인 클래스로 만드는 방식이다.
> 이렇게 설계하면 `ListView`와 `DetailView`에서 템플릿 처리를 위해 자신에게 필요한 믹스인 클래스만 상속받게 해서, 코드의 중복을 줄이고 재사용 효과를 키운다.

- [클래스형 뷰 참고 사이트](https://ccbv.co.uk/)