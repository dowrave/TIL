
## 모델
테이블을 정의하는 장고의 클래스로, `models.py`에 테이블 관련 사항들을 정의한다. 클래스로 정의하므로 테이블 외에도 속성이나 메소드를 추가로 정의할 수 있다. 
이렇게 **테이블을 클래스로 정의하는 방식**을 `ORM(Object Relational Mapping) 방식`이라고 한다.

## 모델 정의
`models.py`에서 정의하는 모델 클래스는 속성과 메서드를 갖게 된다.
- `컬럼`은 모델 클래스의 `속성`으로 정의한다.

10장에서 정의한 `Album` 모델은 아래와 같다.
```python
class Album(models.Model):
    name = models.CharField(max_length = 50)
    description = models.CharField('One Line Description', max_length = 100, blank = True)

    class Meta:
        ordering = ['name']

    def __str__(self):
        return self.name
    
    def get_absolute_url(self):
        return reverse('photo:album_detail', args = (self.id, ))
```
### 모델 속성
1. `변수`에는 테이블의 `필드 이름, 필드 타입, 필드 옵션`을 지정한다. 이를 모델의 `속성`이라고도 한다.
- `필드 타입` : `CharField`의 경우, 컬럼의 `VARCHAR` 타입으로 변환된다.
	- 폼으로 렌더링될 때, HTML 위젯을 지정한다. `CharField` 필드 타입은 폼으로 사용될 시 `<input type='text'>` HTML 태그로 변환되고, 그에 상응되는 위젯을 지정한다.
	- 필드 또는 폼에 대한 유효성 검사 시 최소 기준이 된다.

**Django의 커스텀 필드 타입**
- 장고는 컬럼 표현을 위해 `Field` 추상 클래스를 제공하고, `CharField` 등의 타입은 `Field` 추상 클래스를 상속받아 정의한다.
- 장고는 약 30여가지의 필드 타입과, 모든 타입에 공통으로 사용할 수 있는 필드 옵션 17가지를 제공한다. 개발자가 커스텀으로 코딩하는 것도 `Field` 추상 클래스나 기존 장고 필드 클래스를 상속받아 관련 로직을 코딩할 수 있다.

### 모델 메소드 - 객체 메소드
모델 메소드를 정의할 때 중요한 것은, `클래스 메소드`와 `객체 메소드`를 구분하는 것이다. 일반적으로 별개 설정을 하지 않으면, `객체 메소드`가 디폴트.
- `클래스 메소드`는 테이블 레벨에서 동작한다.
- `객체 메소드`는 레코드 레벨(객체 레벨)에서 동작한다. 

그렇다면 테이블 레벨에서 동작하는 메서드는 어떻게 작성하는가? : 장고는 **별도의 Manager 클래스를 정의하고, Manager 클래스의 메소드를 통해 테이블에 대한 CRUD 동작을 수행**한다.
- 예를 들면 `테이블의 모든 레코드 수를 센다` 같은 메소드가 있을 수 있음.

이번 장에서는 `객체 메소드`를 다룬다.

#### `__str__()`
- 객체의 문자열 표현을 리턴한다. 객체는 모두 파이썬의 내부 포맷으로 저장되므로 읽을 수 없다. 이를 읽을 수 있는 문자열로 표현할 때 이 메소드를 정의한다.
- **이 메소드는 항상 정의하는 게 좋다** : 디폴트 문자열(ex : bookmark object)는 보는 사람이 이해하기 어렵기 때문이다.

#### `get_absolute_url()`
- 이 메소드가 정의된 객체를 지칭하는 URL을 반환한다. 
- 이 예제의 경우 `photo:album_detail`을 사용하는데, 이 때 `photo/urls.py`에 정의되어 있는 `name='album_detail'`의 URL을 반환하게 된다.
- **이 메소드 또한 항상 정의하는 게 좋다** : 특정 객체의 URL을 구하는 기능은 많이 필요하기 때문이다.
- 또한, 이 메소드를 정의하면 Admin 사이트에서 해당 객체 수정 화면에는 `[View on Site]` 버튼이 우측 상단에 보이게 된다.
- 이 메소드는 **템플릿에서도 자주 사용하는데, 가장 큰 장점은 URL을 표현하기 위해 하드 코딩을 하지 않아도 된다**는 것이다.

#### `get_next_by_FOO(**kwargs)`
- `FOO` 필드 기준으로 다음 객체를 반환한다. 다음 객체가 없다면 `DoesNotExist` 예외가 발생한다.
 - 필드 타입이 `DateField`, `DateTimeField`이면서 `null=True`가 아닌 경우 이 메소드를 쓸 수 있다.


#### `get_FOO_display()`
- `FOO` 필드의 설명 문자열을 반환한다.
- 필드에 `choices` 인자가 있을 경우, 그 모델 객체는 다음 메소드를 제공한다. 

### Meta 내부 클래스 속성
- 장고에서는 필드는 아니지만 모델 클래스에 필요한 항목을 `Meta` 내부 클래스에 정의한다.
- 다음은 많이 사용하는 Meta 내부 클래스 속성이다.

#### `ordering`
- 모델 객체의 리스트 출력 시, 정렬하기 위해 사용하는 필드명을 지정한다.
- 디폴트는 오름차순이며, `-`를 붙이면 내림차순으로 정렬한다.
- 예시) `ordering = ['-pub_date', 'author]'` : 보이는 대로 해석하면 됨.

#### `db_table`
- DB에 저장되는 테이블명을 지정한다. 디폴트 저장 이름은 `앱명_클래스명(소문자)`.
- 예시) `blog` 어플의 모델 클래스 이름이 `post`라면, 디폴트 테이블명은 `blog_post`가 된다.

#### `verbose_name`
- 사용자가 이해하기 쉽게끔 하는 모델 객체의 별칭으로, 디폴트는 모델 클래스명을 변형한다.
- 예시) 모델 클래스명 : `FavoritePost` -> 디폴트 verbose_name : `favorite post`

#### `verbose_name_plural`
- `verbose_name`에 대한 복수 명칭을 지정한다. 디폴트는 `verbose_name` + `s`

### Manager 속성
- 모델 속성 중, 테이블의 컬럼이 아닌 속성.
- 모든 모델은 반드시 `Manager` 속성을 갖는다. 명시되지 않는 경우 디폴트 이름은 `objects`가 된다.
- `Manager` 속성은 **모델 클래스를 통해서만 액세스될 수 있다. 모델 객체로는 액세스될 수 없다.**

- `Manager` 속성은 `models.Manager` 타입으로 정의된다. 
- **`Manager` 클래스를 통해 데이터베이스 쿼리가 이뤄진다.**
	즉, 테이블 레벨에서의 `Read` 동작은 `Manager` 클래스의 메소드를 통해 이뤄진다.

> - 예시) `Album.objects.all()` 문장은 Manager 클래스가 사용된 것이다.
		- `Album`은 모델 객체가 아닌 클래스
		- `objects`는 `Manager`의 속성
		- `all()`은 `Manager` 클래스의 메서드
		- 이 문장은 `QuerySet` 객체를 반환한다.  `QuerySet` 클래스의 메소드와 `Manager` 클래스의 메소드는 동일하다(완전히는 아님). 따라서 `QuerySet` 메소드는 모두 `Manager` 메소드로도 사용이 가능하다 : `all(), filter(), exclude(), get(), count()` 등

- 추가로 알아둘 내용으로, 모델 클래스에서 `Manager` 속성을 여러 개 정의할 수 있는데, 1번째로 정의된 `Manager` 속성을 `디폴트 Manager`라고 한다. 

> 예시)
```python
class Album(models.Model):
    name = models.CharField(max_length = 50, unique= True)
    description = models.CharField('One Line Description', max_length = 100, blank = True)
    owner = models.ForeignKey(User, on_delete = models.SET_NULL, null = True)

    class Meta:
        ordering = ['name']

    def __str__(self):
        return self.name
    
    def get_absolute_url(self):
        return reverse('photo:album_detail', args = (self.id, ))
```
- 이 코드에 2개의 `Manager` 속성을 정의하면 아래와 같다.

```python
class SecondAlbumManager(models.Manager):
	def get_queryset(self):
		return super(SecondAlbumManager, self).get_queryset().filter(owner__username='~~')

class Album(models.Model):
    name = models.CharField(max_length = 50, unique= True)
    description = models.CharField('One Line Description', max_length = 100, blank = True)
    owner = models.ForeignKey(User, on_delete = models.SET_NULL, null = True)

	objects = models.Manager() # 디폴트 매니저
	second_objects = SecondAlbumManager() # 추가 매니저
```
- `objects`와 `second_objects`라는 2개의 `Manager`를 정의했고, `objects`가 디폴트가 된다.
- `Album.objects.all()`이라는 문장은 테이블의 모든 앨범 레코드를 반환하고(디폴트로 저장된 메소드가 있겠죠?)
- `Album.second_objects.all()` 문장은 소유가 `owner__username`인 것만 반환한다.

## 모델 간 관계
-  장고에서는 테이블 간 관계로 `1:N(one-to-many)`, `N:N(many-to-many)`, `1:1(one-to-one)` 3가지로 분류해 제공한다.

> 시작하기 전에 유념할 사항이 2가지 있다.
> 1. **관계는 양방향 개념이다.** 따라서 양쪽 모델에서 모두 정의를 해줘야 하지만, 장고는 한쪽 클래스에서 관계를 정의하면 상대편에서의 정의는 자동으로 정의해준다. 따라서 개발자는 한쪽 클래스에서 관계를 정의했을 때, 반대 방향의 정의는 명시적으로 보이지 않더라도 이해할 수 있어야 한다.
> 2. 한쪽 방향으로 관계를 생성하거나 변경하면, 반대 방향으로의 관계도 그에 따라 변한다.

### 1:N 관계
- `ForeignKey` 필드 타입을 사용한다. 
- 필수 인자로, 관계를 맺고자 하는 모델 클래스를 지정해야 한다. 즉, **`N` 모델에서 `ForeignKey` 필드를 정의하면서, 해당 필드의 필수 인자로 `1` 모델을 지정**한다.

- 예제) `User:Album`도 `1:N` 관계이다. 그래서 `Album`에서 `ForeignKey`를 정의했다.
```python
class Album(models.Model):
	owner = models.ForeignKey(User, null = True)
```

#### 실습
- `User`와 `Album`이라는 2개의 모델을 이용, `ForeignKey` 관계에서 사용할 수 있는 API 들이다.

- 실행
	- 파일에 만들어서 정리하려 했으나, 이런 저런 이유로 제대로 실행되지 않음. 
```sh
python manage.py shell
```

- 쉘 명령어 입력
```python
from photo.models import User, Album

User.objects.all()
# <QuerySet [<User: dowrave>, <User: dowrave1>]>

Album.objects.all()
# <QuerySet [<Album: 스게>, <Album: 아이콘>, <Album: 예시 이미지>]>
# --- Album 클래스의 Meta 서브 클래스에서 ordering=['name'] 으로 인해 가나다순으로 출력

a1 = Album.objects.all()[1]
# <Album: 아이콘>

Album.objects.all()[0].owner
# <User: dowrave>

Album.objects.all()[0].owner.username
# 'dowrave'

u1 = User.objects.get(username='dowrave')
u2 = User.objects.get(username='dowrave1')


# --- 앨범을 만들고 소유자 지정하기
# --- 1. 새 앨범을 만들고 소유자를 u1 사용자로 지정한다.
newa1 = Album(name='TestAlbum1')
u1.album_set.add(newa1, bulk=False) # bulk=False 를 지정하지 않으면 저장해야 한다는 메시지가 뜸

u1.album_set.all() # <QuerySet [<Album: TestAlbum1>, <Album: 스게>]>

# --- 2. 새 앨범을 만들 때마다 u2 사용자를 지정한다.
newa2 = u2.album_set.create(name = 'TestAlbum2')
newa2 # <Album: TestAlbum2>
u2.album_set.all() # <QuerySet [<Album: TestAlbum2>]>

# - 소유자 변경하기
# -- newa1 앨범의 소유자를 u1 -> u2로 변경한다.
u2.album_set.add(newa1) 


# 모델 간 관계에서도 필드 검색 오퍼레이션이 가능하다.
u1.album_set.filter(name__startswith='Any')
# <QuerySet []> / 소유자가 바뀜

Album.objects.filter(owner__username='dowrave')
# <QuerySet [<Album: 스게>]>

## 조건이 2개 이상이라면 AND 오퍼레이션 수행
Album.objects.filter(owner__username='dowrave', owner__is_superuser=True)
# <QuerySet [<Album: 스게>]>


# 앨범의 소유자를 지정하는 여러가지 방법
Album.objects.filter(owner__pk=1)
Album.objects.filter(owner=1)
Album.objects.filter(owner__in=[1]).distinct()
Album.objects.filter(owner__in=[u1]).distinct()
Album.objects.filter(owner__in=User.objects.filter(username='dowrave')).distinct()
# <QuerySet [<Album: 스게>]>


# 소유자의 앨범을 지정하는 여러가지 방법
User.objects.filter(album__pk=6) # pk는 Album.objects.all()[n].pk로 찾는다
User.objects.filter(album=6)
User.objects.filter(album=newa1)


# 반대 방향으로 필드 검색 오퍼레이션 사용
User.objects.filter(album__name__startswith='스게')
User.objects.filter(album__name__startswith='스게').distinct()
User.objects.filter(album__name__startswith='스게').distinct().count()


# 순환방향 필드 검색
User.objects.filter(album__owner=u1) # <QuerySet [<User: dowrave>]>
Album.objects.filter(owner__album=newa1) # <QuerySet [<Album: TestAlbum1>, <Album: TestAlbum2>]>


# 1:N에서 1쪽 객체를 지우면 CASCADE 동작을 해서 N쪽 객체도 삭제된다.
u3 = User.objects.get(username='dowrave1') # u3 = dowrave1
u3.album_set.create(name='TestAlbum3') # <Album: TestAlbum3>
u3.album_set.all() # <QuerySet [<Album: TestAlbum1>, <Album: TestAlbum2>, <Album: TestAlbum3>]>
u3.delete() 
```
- 마지막의 삭제 시 매칭되는 예제는 `models.py`에서 해당 필드(여기서는 `Album.owner`)를 어떻게 설정했느냐에 따라 다르다. 
- `on_delete = models.CASCADE`일 경우 유저를 지우면 앨범도 삭제됨
	- 내 경우 `models.SET_NULL`로 지정했기 떄문에 앨범이 삭제되지 않았다.

### N:N 관계