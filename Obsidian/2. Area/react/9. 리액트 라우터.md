1. [[#리액트 라우터|리액트 라우터]]
2. [[#리액트 라우터의 기본 사용법|리액트 라우터의 기본 사용법]]
	1. [[#리액트 라우터의 기본 사용법#예제 프로젝트 생성 및 라우팅 컴포넌트 기초|예제 프로젝트 생성 및 라우팅 컴포넌트 기초]]
	2. [[#리액트 라우터의 기본 사용법#기초 예제 작성|기초 예제 작성]]
3. [[#라우팅된 컴포넌트로 속성 전달하기|라우팅된 컴포넌트로 속성 전달하기]]
	1. [[#라우팅된 컴포넌트로 속성 전달하기#속성을 전달하는 법|속성을 전달하는 법]]
	2. [[#라우팅된 컴포넌트로 속성 전달하기#복잡한 객체를 속성으로 전달하기|복잡한 객체를 속성으로 전달하기]]
4. [[#URI 파라미터 이용|URI 파라미터 이용]]
	1. [[#URI 파라미터 이용#URI 파라미터란?|URI 파라미터란?]]
	2. [[#URI 파라미터 이용#URI 파라미터 적용하기|URI 파라미터 적용하기]]
	3. [[#URI 파라미터 이용#클래스 컴포넌트에 URI 파라미터 적용하기|클래스 컴포넌트에 URI 파라미터 적용하기]]
5. [[#중첩 라우트|중첩 라우트]]
	1. [[#중첩 라우트#중첩 라우트란?|중첩 라우트란?]]
	2. [[#중첩 라우트#중첩 라우트 적용하기|중첩 라우트 적용하기]]
	3. [[#중첩 라우트#index 라우트 설정|index 라우트 설정]]
6. [[#리액트 라우터가 제공하는 훅|리액트 라우터가 제공하는 훅]]
	1. [[#리액트 라우터가 제공하는 훅#useMatch|useMatch]]
	2. [[#리액트 라우터가 제공하는 훅#useSearchParams|useSearchParams]]
	3. [[#리액트 라우터가 제공하는 훅#useNavigate, useLocation|useNavigate, useLocation]]
	4. [[#리액트 라우터가 제공하는 훅#useOutletContext|useOutletContext]]
7. [[#라우터 관련 컴포넌트|라우터 관련 컴포넌트]]
	1. [[#라우터 관련 컴포넌트#Router 컴포넌트|Router 컴포넌트]]
	2. [[#라우터 관련 컴포넌트#fallback UI가 없는 웹 서버에서의 에러 확인|fallback UI가 없는 웹 서버에서의 에러 확인]]
	3. [[#라우터 관련 컴포넌트#404 라우트와 리디렉션 구성|404 라우트와 리디렉션 구성]]
	4. [[#라우터 관련 컴포넌트#NavLink 컴포넌트|NavLink 컴포넌트]]
8. [[#리액트 라우터와 레이지 로딩 기법|리액트 라우터와 레이지 로딩 기법]]
	1. [[#리액트 라우터와 레이지 로딩 기법#레이지 로딩이란?|레이지 로딩이란?]]
	2. [[#리액트 라우터와 레이지 로딩 기법#적용 방식|적용 방식]]
	3. [[#리액트 라우터와 레이지 로딩 기법#Suspense 컴포넌트|Suspense 컴포넌트]]
	4. [[#리액트 라우터와 레이지 로딩 기법#레이징 로딩 적용하기|레이징 로딩 적용하기]]
	5. [[#리액트 라우터와 레이지 로딩 기법#마무리 글|마무리 글]]


## 리액트 라우터
- 리액트 기반의 라이브러리로, 화면에 렌더링하는 컴포넌트와 URI 경로를 동기화하면서 새로운 화면과 흐름을 앱에 빠르게 추가할 수 있는 기능을 제공한다.
- `SPA : Single Page Application`를 손쉽게 작성할 수 있다. 
	- 하나의 HTML 페이지로 여러 개의 화면을 전환할 수 있는 내비게이션 기법이다.
	- 하나의 HTML 페이지에서 요청된 URI 경로를 이용해 화면을 전환하기 떄문에, **화면의 전환을 위해 웹 서버로부터 새로운 페이지를 로딩하지 않는다.** 첫 화면을 로딩할 때 한꺼번에 서버에서 로딩한다.

- 리액트 라우터를 사용하려면 2개의 패키지를 추가한다. 여기선 `리액트 라우터 6.0`버전을 사용한다.
```sh
npm install react-router react-router-dom

// 6버전 명시적 설치
npm install react-router@6.x.x react-router-dom@6.x.x
```
> 리액트 라우터는 **버전별로 적용법이 많이 달라서 버전을 꼭 확인**해야 한다.

> URL 대신 URI 라는 명칭을 사용하는 이유?
> - `URI : Uniform Resource Identifier`의 약자로, 식별자(Identifer)를 의미한다. 
> - `URL : Uniform Resource Locator`은 이 식별자 중의 하나인 위치 표시자이다. 즉, URL은 URI의 서브셋(부분집합)이다.
> - URI라는 말을 쓰는 이유는, 리액트 라우터를 적용한 앱에서 사용하는 경로에는 HTML 문서와 같은 리소스가 위치하지 않기 때문이다. 즉, **위치 표시자의 의미가 아니라 어떤 컴포넌트를 화면에 렌더링할지 구분하기 위한 식별자**로써 경로가 사용된다. URL이라는 이름을 못 쓰는 상황은 아니나, 글을 쓰신 분이 `식별자`의 의미를 강조하기 위해 URI라는 말을 쓴다.

## 리액트 라우터의 기본 사용법

### 예제 프로젝트 생성 및 라우팅 컴포넌트 기초
- `Foxes and Fossils`라는 음악 밴드에 관한 앱을 리액트 라우터의 기능을 적용하면서 완성한다.
```sh
npm init vite router-test-app -- --template react-ts
cd router-test-app
npm install bootstrap@5.x.x react-router@6.x.x react-router-dom@6.x.x
```

- 예제의 컴포넌트 계층 구조
```
- App
	- Header
	- Router / Routes
		- Route 
			- / 
				- Home
		- Route
			- /about
				- About
		- Route
			- /members
				- Members
		- Route
			- /songs
				- SongList
```
> Router 컴포넌트에는 자식 컴포넌트로 URI 경로 정보를 처리하는 Routes, Route 컴포넌트를 배치할 수 있으며 라우팅하는 방법을 결정한다.
> 여러 방법의 `Router`가 있지만, 일단 `BrowserRouter`를 사용한다.

- `Router, Routes, Route` 컴포넌트의 작성 예시 
```tsx
<Router>
	...
		<Routes>
			<Route path = "/" element={ <Home /> }>
		</Routes>
	...
</Router>
```

### 기초 예제 작성
- `Home, About, Members, SongList.tsx`를 작성한다.
```tsx
import React from 'react'

type Props = {}

const Home = (props: Props) => {
  return (
    <div className="card card-body">
        <h2>Home</h2>
    </div>
  )
}

export default Home;
```
> 나머지 컴포넌트인 `About, Members, SongList`도 위 코드에서 `Home` 부분만 바꾸면 됨.

- 이후, 전체 화면에서 내비게이션을 위한 메뉴 버튼을 제공하는 `Header` 컴포넌트를 작성한다.
	- 리액트 라우터가 제공하는 `Link` 컴포넌트를 사용하는데, `<Link />` 컴포넌트는 내비게이션을 위한 링크를 생성해준다.
```tsx
<Link to={이동시킬 경로}>링크로 보여줄 요소</Link>
```
- `Header.tsx`
```tsx
import { Link } from 'react-router-dom'

const Header = (props: Props) => {
  return (
    <div className="card bg-light">
        <div className="card-heading">
            <h2 className="text-center m-3">Foxes and Fossils</h2>
            <p>
                <a href="http://foxesandfossils.com">https://foxesandfossils.com</a>
            </p>
            <div className="row">
                <div className="col-12">
                    <Link className="btn btn-success menu" to="/">
                        Home
                    </Link>
                    <Link className="btn btn-success menu" to="/about">
                        About
                    </Link>
                    <Link className="btn btn-success menu" to="/members">
                        Members
                    </Link>
                    <Link className="btn btn-success menu" to="/songs">
                        Songs
                    </Link>
                </div>
            </div>
        </div>
    </div>
  )
}

export default Header;
```

- `App` 컴포넌트
	- 화면 전체의 레이아웃을 담고 있고, 라우팅 컴포넌트를 배치할 `App` 컴포넌트를 작성한다.
	- `Router, Routes, Route`컴포넌트를 이용해 요청된 URI 경로에 따라 각기 다른 컴포넌트가 렌더링되도록 구성한다.
- `App.tsx`
```tsx
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom'

import Header from './Header'
import Home from './Home'
import About from './About'
import SongList from './SongList'
import Members from './Members'

const App = () => {
  return (
    <Router>
      <div className="container">
        <Header />
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/members" element={<Members />} />
          <Route path="/songs" element={<SongList />} />
        </Routes>
      </div>
    </Router>
  )
}

export default App
```

- 마지막으로 `index.css`와 `main.tsx`를 변경한다.
```css
body {
  margin: 0;
  padding: 0;
  font-family: sans-serif;
}

.container { 
  text-align: center;
  margin-top: 20px;
}

.menu {
  width: 25%;
  border-radius: 0 !important;
}
```

- `main.tsx`
```tsx
import 'bootstrap/dist/css/bootstrap.css' // 이거만 추가
```

## 라우팅된 컴포넌트로 속성 전달하기

### 속성을 전달하는 법
- `element`로 렌더링되는 컴포넌트에 속성을 전달하는 방법
- `JSX`요소에 직접 속성을 전달할 수 있다.

- `App.tsx`
```tsx
        <Routes>
		...
		{% 요기만 추가 %}
          <Route path="/about" element={<About title={'여우와 늙다리들'} />} /> 

        </Routes>
```

- `About.tsx`
```tsx
import React from 'react'

type Props = { title: string };

const About = (props: Props) => {
  return (
    <div className="card card-body">
        <h2>About {props.title}</h2>
    </div>
  )
}

export default About;
```
> `App.tsx`의 `element`에 있는 `title` 부분이 렌더링되는 걸 볼 수 있음.


### 복잡한 객체를 속성으로 전달하기
- `App.tsx`
```tsx
import { useState } from 'react'

export type MemberType = { name: string; photo: string; }

const App = () => {
  const [members] = useState<Array<MemberType>>([
    { name: "Maggie Adams", photo : "photos/Mag.png"},
    { name: "Sammie Purcell", photo : "photos/Sam.png"},
    { name: "Tim Purcell", photo : "photos/Tim.png"},
    { name: "Scott King", photo : "photos/King.png"},
    { name: "Johny Pike", photo : "photos/JPike.jpg"},
    { name: "Toby Ruckert", photo : "photos/Toby.jpg"},
  ])

  return (
			  ...
            <Route path="/members" element={<Members members={members}/>} />
            ...
  )
```
> 1. `MemberType`을 정의한다. 다른 컴포넌트에서도 쓸 거라 `export`해둔다.
> 2. `MemberType`의 배열 형태로 `useState` 훅을 이용해 상태를 정의한다. `Members` 컴포넌트에 `members` 속성으로 전달한다.


- 사전 준비 : `Members` 컴포넌트를 작성하기에 앞서, [요기](https://github.com/stepanowon/react-ts-quickstart)에서 `photos.zip`을 다운받는다. `pubilc/photos`에  넣어둠.
- `Members.tsx`
```tsx
import { MemberType } from '../App'

type Props = { members: Array<MemberType> };

const Members = (props: Props) => {
  
  let imgstyle = { width: 90, height: 80};
  let list = props.members.map((member) => {
    return (
      <div key={member.name} className="col-6 col-md-4 col-lg-3">
        <img src="{member.photo}" alt="{member.name}" 
        className = "img-thumbnail" style={imgstyle}/>
        <br />
        <h6>{member.name}</h6>
        <br />
        <br />
      </div>
    )
  })

  return (
    <div>
      <h2 className="m-4">Members</h2>
      <div className="container">
        <div className="row">{list}</div>
      </div>
    </div>
  )
}

export default Members;
```
> 사진이 잘 뜨면 됨
> - 사진 링크는 `App.tsx`에서 보이듯, 기본적으로 `public` 폴더로 지정되어 있음

## URI 파라미터 이용

### URI 파라미터란?
- URI 경로에 **동적으로 매번 다른 값**이 포함되고, 컴포넌트를 실행할 떄 URI 경로의 동적인 값을 이용해야 하는 경우가 있다. 이 떄 `동적 파라미터`를 쓸 수 있다.
- 사용법
```tsx
<Route path="/songs/:id" element={<SongDetail songs={songs} />} />
```

```tsx
type SongParam = { id? : string };
const SongDetail = (...) => {
	...
	const { id } = useParams<SongParam>();
	... 
}
```

- `Route path`에는 `:id`처럼 URI 경로의 파라미터 이름을 지정한다. 이 파라미터 값은 `element`로 렌더링하는 컴포넌트에서 받아낼 수 있다.
- 컴포넌트에서는 파라미터의 타입을 `type SongParam = ` 처럼 정의할 수 있다. `id` 파라미터가 전달되지 않는 경우를 처리하기 위해 `id?`처럼 선택적 파라미터로 정의한다.
- 마지막으로 `id` 파라미터를 받을 때는 `useParams` 훅을 쓴다. URI 경로로 전달되는 값은 기본적으로 문자열이므로, `type SongParams`처럼 문자열 타입으로 파라미터 타입을 지정한다.
- URI 파라미터는 여러 개를 쓸 수 있다. 와일드카드`*`를 이용할 수도 있다.
```
예시)
/orders/:id/:date
/groups/*
```
> 참고) 리액트 라우터 버전 5.x 까지는 `profiles/:userid([0-9]{10})`처럼 **정규표현식**으로 경로를 표현할 수 있지만, **6부터는 지원하지 않는다.**
> - 리액트 라우터 팀은 정규식 이용 경로가 라우트 매칭 우선순위 적용에 문제가 있다고 판단하여 외부 의존성 라이브러리`path-to-regexp`를 없애고, 브라우저에 로딩되는 패키지 무게를 줄이기 위해 적용하지 않기로 했다.
> - 따라서 경로를 표현할 때 경로 파라미터 값을 받은 뒤 코드 수준에서 조건이나 분기처리해야 한다.

### URI 파라미터 적용하기
- `router-test-app`에 URI 파라미터 기능을 적용한다.
- `App` 컴포넌트에 곡 정보 상태를 추가하고, 추가한 상태를 속성으로 `SongList`와 `SongDetail` 컴포넌트에 전달하도록 작성한다.
- [여기](https://github.com/stepanowon/react-ts-quickstart)에서 `song.json` 파일을 다운받는다.
- `App.tsx`
```tsx
import SongDetail from './pages/SongDetail'

export type SongType = { id: number, title: string; musician: string; youtube_link: string;}

const App = () => {
	  const [songs] = useState<Array<SongType>>([
      { "id": 1, "title": "Fallin' for you", "musician": "Colbie callet", "youtube_link": "PABUl_EX_hw" },
      { "id": 2, "title": "Can't hurry love", "musician": "The supremes", "youtube_link": "EJDPhjQft04" },
      { "id": 3, "title": "Landslide", "musician": "Dixie chicks", "youtube_link": "V2N7gYom9-A" },
      { "id": 4, "title": "Can't let go", "musician": "Linda ronstadt", "youtube_link": "P-EpGKXmoe4" },
      { "id": 5, "title": "Doctor my eyes", "musician": "Jackson Browne", "youtube_link": "7JlFKS_1oZk" },
      { "id": 6, "title": "We gotta get you a woman", "musician": "Todd Rundgren", "youtube_link": "EyUjbBViAGE" },
      { "id": 7, "title": "Hip to my heart", "musician": "Band Perry", "youtube_link": "vpLCFnD9LFo" },
      { "id": 8, "title": "Rolling in the deep", "musician": "Adele", "youtube_link": "EvK8pDK6IQU" },
  
  ])

  return (
          <Route path="/songs" element={<SongList songs={songs} />} />
          <Route path="/songs/:id" element={<SongDetail songs={songs} />} />
  )
```

- `SongList` 컴포넌트
	- `songs` 속성으로 전달받은 데이터를 목록으로 출력한다
```tsx
import { Link } from 'react-router-dom'
import { SongType } from '../App'

type Props = { songs: Array<SongType> };

const SongList = (props: Props) => {
    let list = props.songs.map((song) => {
        return (
            <li className="list-group-item" key={song.id}>
                <Link to={`/songs/${song.id}`}
                style={{ textDecoration: "none" }}>
                    {song.title} ( {song.musician} )
                </Link>
            </li>
        );
    });

    return (
        <div>
            <h2 className="mt-4 mb-2">Song List</h2>
            <ul className="list-group">{list}</ul>
        </div>
    )
}

export default SongList;
```

- `SongDetail.tsx`
	- 속성으로 전달된 `songs` 정보 중, 한 곡만을 찾아 상세 정보와 링크 정보를 보여준다.
	- 한 곡만 찾기 위해 `/songs/:id`의 `:id`에 해당하는 URI 경로 문자열을 받아내야 하는데, 이 때 `useParams` 훅을 이용한다.
```tsx
import React, { useEffect, useState } from 'react'
import { Link, useParams, useNavigate } from 'react-router-dom'
import { SongType } from '../App'

type Props = { songs: Array<SongType> };
type SongParam = { id?: string };

const SongDetail = (props: Props) => {
    const { id } = useParams<SongParam>();
    const navigate = useNavigate();
    const [title, setTitle] = useState<string>("");
    const [musician, setMusician] = useState<string>("");
    const [link, setLink] = useState<string>("");
    const YOUTUBE_LINK = "https://m.youtube.com/watch?v=";
}

useEffect(() => {
    const song = props.songs.find((song) => song.id === parseInt(id ? id : "", 10);)
    if (song) {
        setLink(song?.youtube_link ? YOUTUBE_LINK + SongDetail.youtube_link : "");
        setTitle(song?.title ? song.title : "");
        setMusician(song?musician ? song?.musician : "");
    } else {
        navigate("/songs");
    }
}, []);

return (
    <div className="mt-5">
        <h2>{title}</h2>
        <p>Original Musician : {musician}</p>
        <p>
            <a href={link} target="new">View Youtube</a>
        </p>
        <Link to="/songs">Return SongList</Link>
    </div>
)

export default SongDetail;
```
> - `useParams` 훅을 이용해 URI 파라미터로 전달된 id값을 받아내고, `useEffect` 훅을 이용해 컴포넌트가 마운트된 후 `id`를 이용해 한 곡 정보를 찾아낸다.
> - 찾아낸 곡의 정보는 `title, link, musician` 등의 상태를 담아 화면에 출력한다.
> - 만약 `id`가 일치하는 정보가 없다면, `useNavigate` 훅으로 만든 `navigate` 함수를 이용해 다시 `/songs` 경로로 이동시킨다. 경로를 이동시켜주는 기능을 제공한다.

1. `App`에 있는 정보가 `element` 속성을 통해 `SongList`와 `SongDetail`에 전달된다
2. 하위 컴포넌트에서는 `props`로 받아서 사용하면 됨. 동일함

### 클래스 컴포넌트에 URI 파라미터 적용하기
- 클래스 컴포넌트에서는 훅을 이용할 수 없기 떄문에, 고차함수를 만들어서 `useParams` 훅으로 획득한 `params` 객체를 클래스 컴포넌트에 속성으로 전달하는 방법을 사용할 수 있다.

- `SongDetail2.tsx`
```tsx

import React, { Component } from 'react'
import { useParams, useNavigate } from 'react-router'
import { Link } from 'react-router-dom'
import { SongType } from '../App'

type Props = { songs: Array<SongType> };
type SongParam = { id?: string };
type SongDetailProps = { navigate: Function; params: SongParam; songs: Array<SongType> }
type SongDetailState = {title: string; musician: string; link: string;}

// 고차함수
const withSongParams = (Component : React.ComponentType<SongDetailProps>) => {
    return (props: props) => <Component {...props} params={useParams<SongParam>()} navgiate={useNavigate()} />
}
const YOUTUBE_LINK = "https://m.youtube.com/watch?v=";

class SongDetail2 extends Component<SongDetailProps, SongDetailState> {
    constructor(props: SongDetailProps) {
        super(props);
        this.state = {title: "", link: "", musician:""};
    }

    componentDidMount() {
        const id = this.props.params.id;
        const song = this.props.songs.find((song) => song.id === parseInt(id ? id : ""));

        if (song) {
            this.setState({
                link: song?.youtube_link ? YOUTUBE_LINK + song?.youtube_link : "",
                musician: song?.musician ? song.musician : "",
                title: song?.title ? song.title : "",
            });
        } else {
            this.props.navigate('/songs');
        }
    }
    render() {
        return (
            <div className="mt-5">
                <h2>{this.state.title}</h2>
                <p>Original Musician : {this.state.musician}</p>
                <p>
                    <a href="{this.state.link}" target="new">
                        View Youtube
                    </a>
                </p>
                <Link to="/songs">Return SongList</Link>
            </div>
        );
    }
}

export default withSongParams(SongDetail2);
```
> 1. `SongDetailProps, State`에서  전달할 속성의 형식을 정의한다. 클래스 컴포넌트가 사용할 수 없는 `useParams, useNavigate` 훅의 리턴값을 전달해준다. 
> 2. 고차함수를 작성한다. `Component` 클래스 컴포넌트가 인자로 전달되면 클래스 컴포넌트에 `params, navigate` 속성을 추가하여 리턴함으로써 클래스 컴포넌트에서 27, 36행처럼 속성으로 이용할 수 있다.
> 3. 클래스 컴포넌트를 고차 함수의 인자로 전달하여 실행한 후, 리턴 받은 컴포넌트를 익스포트한다.

- `App.tsx` 변경
```tsx
import SongDetail from './pages/SongDetail2'
```


## 중첩 라우트

### 중첩 라우트란?
- `중첩 라우트Nested Route`는 `<Route />` 컴포넌트에 의해 렌더링된 컴포넌트에 기존 `Route`의 중첩인 `<Route />`의 컴포넌트가 나타나도록 구성하는 `<Route />` 컴포넌트의 적용 방법이다.
- 기존에서 이 프로젝트의 라우팅은 이렇게 작성했다.
	- `/songs` : `SongList` 컴포넌트 렌더링
	- `/songs/:id` : `SongDetail` 컴포넌트 렌더링
- 여기서 `/songs/:id`를 렌더링할 때, `SongList` 컴포넌트와 `Player` 컴포넌트 렌더링으로 바꾸고 싶다면, 중첩 라우트를 작성하면 쉽게 해결할 수 있다.
```tsx
<Route path="/songs" element={<SongList songs={songs} />}>
	<Route path=":id" element={<Player songs={songs} />} />
</Route>
```
> 이렇게 작성하면 중첩 라우트는 경로가 일치하는지 확인하기 위해 `<Route />` 컴포넌트의 중첩 구조를 따라 진입하면서 경로의 매칭 여부를 확인한다.
> 마지막으로 중첩 라우트의 바깥쪽 `<Route />` 컴포넌트에 의해 렌더링되는 컴포넌트에는 중첩된 내부 `<Route />`에 의해 렌더링되는 컴포넌트에 담을 컨테이너로써, `<Outlet />` 컴포넌트를 작성해야 한다.
> `/songs/:id` 경로 패턴에 매칭되면 `Player` 컴포넌트가 `SongList` 내부의 `Outlet` 컴포넌트에 렌더링된다.


### 중첩 라우트 적용하기
- 이전엔 `/songs/:id`를 요청하면 `SongDetail` 컴포넌트를 렌더링했으나, 이번에는 `SongList` 컴포넌트와 `Player` 컴포넌트를 함께 렌더링한다.
	- `Player` 컴포넌트는 CSS 레이어로 `SongList` 컴포넌트 위에 모달 창처럼 나타나게 구성한다.

- 패키지 설치
```sh
npm install react-youtube @types/youtube-player
```

- `src/pages/songs` 디렉터리를 추가하고, `Player` 컴포넌트를 작성한다.
	- `Player` 컴포넌트는 속성으로 전달받은 `songs` 정보에서 `:id` 파라미터값으로 한 곡의 정보를 획득해 플레이어를 렌더링한다.
```tsx
import { useEffect, useState } from 'react'
import { useParams, Navigate, useNavigate } from 'react-router'
import { Link } from 'react-router-dom'
import Youtube from 'react-youtube'
import { SongType } from '../../App'

type Props = { songs: Array<SongType> };
type SongIdParam = { id: string }; 

const Player = (props: props) => {
    const params = useParams<SongIdParam>();
    const navigate = useNavigate();
    const [title, setTitle] = useState<string>('');
    const [youtubeLink, setYoutubeLink] = useState<string>('');

    useEffect(() => {
        const id = params.id ? parseInt(params.id, 10) : 0;
        const song = props.songs.find((song) => song.id === id);
        if (song) {
            setTitle(song?.title ? song.title : "");
            setYoutubeLink(song?.youtube_link ? song.youtube_link : "");
        } else {
            navigate ("/songs");
        }
    });
    return (
        <div className="modal">
            <div className='box'>
                <div className='heading'>
                    <Link className='menu' to="/songs">
                            <span className='float-start badge bg-secondary pointer'>X</span>
                    </Link>
                    <span className="title">&nbsp;&nbsp;&nbsp;{title}</span>
                </div>
                <div className='palyer'>
                    <div>
                        <Youtube videoId={youtubeLink}
                        opts={{ width:"320", height:"240", playerVars: { autoplay: 1} }}/>
                    </div>
                </div>
            </div>
        </div>
    )
}

export default Player;
```

- `SongList.tsx` 컴포넌트도 변경한다.
	- 중첩된 내부의 `<Route />`가 렌더링하는 컴포넌트를 렌더링하기 위한 `Outlet /` 컴포넌트를 추가한다.
	- 곡마다 재생 버튼 아이콘을 보여주는데, `font-awesome`이라는 CSS 기반의 아이콘 라이브러리를 사용한다.
```tsx
import { Link, Outlet } from 'react-router-dom'
import { SongType } from '../App'

type Props = { songs: Array<SongType> };

const SongList = (props: Props) => {
    let list = props.songs.map((song) => {
        return (
            <li className="list-group-item" key={song.id}>
                <Link to={`/songs/${song.id}`} style={{ textDecoration: "none" }}>
                    {song.title} ( {song.musician} )
                    <span className="float-end badge bg-secondary">
                        <i className="fa fa-play"></i>
                    </span>
                </Link>
            </li>
        );
    });

    return (
        <div>
            <h2 className="mt-4 mb-2">Song List</h2>
            <ul className="list-group">{list}</ul>
            <Outlet />
        </div>
    )
}

export default SongList
```

- 별도의 css 스타일을 추가한다. `src/index.css`
```css
@import "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css";

/* 모달 창과 Youtube 플레이어를 위한 스타일 추가 */
.modal { display: block; position: fixed; z-index: 1;
left: 0; top: 0; width: 100%; height: 100%; overflow: auto;
background-color: rgb(0, 0, 0); background-color: rgba(0, 0, 0, 0.4);}

.box{ background-color: white; margin: 100px auto; max-width: 330px;
min-width: 100px; min-height: 250px; font: 12px "verdana"; padding: 5px 5px 5px 5px;}

.box div{
  padding: 0;
  display: block;
  margin: 5px 0 0 0;
}

.box .heading {background: #33A17F; font-weight:300; text-align: left; color: #fff; margin: 0px;
padding: 10px 10px 10px 10px; min-width: 200px; max-width:360px;}

.box .player { background:white; }
.pointer { cursor: pointer; }
.play-button { width:15px; height:15px; }
.play-button-disabled { opacity: 0.3 }
```

- `src/App.tsx` 변경
```tsx
// import SongDetail from './pages/SongDetail2'
import Player from './pages/songs/Player'

		{/* <Route path="/songs" element={<SongList songs={songs} />} />
          <Route path="/songs/:id" element={<SongDetail songs={songs} />} /> */}
          <Route path="/songs" element={<SongList songs={songs} />}>
            <Route path=":id" element={<Player songs={songs} />} />
          </Route>
```

### index 라우트 설정
- 중첩 라우트에서 상위 경로까지만 매칭이 되는 경우에는 부모 경로의 `<Route />` 컴포넌트의 `element`만 렌더링했지만, `index` 라우트를 설정하면 부모 경로까지만 매칭되어도 자식 컴포넌트를 렌더링할 수 있다.
```tsx
<Route path = "/parents" element = { <Parent /> }>
	<Route index element = { <Defaultchild /> } />
	<Route path=":param" element = { <Child1 /> } />
</Route>
```

- 위 예시는 
	- `parents` 요청 -> `Parent`, `ParentChild` 컴포넌트 렌더링
	- `parents/:param` 요청 -> `Parent, Child1` 컴포넌트 렌더링

- 이를 `router-test-app`에 적용해보자.
- `src/pages/songs/index.tsx`
```tsx
import React from 'react'

const index = () => {
  return (
    <>
    <hr />
    <h3>현재 재생 중인 곡 없음</h3>
    </>
  )
}

export default index
```

- `App.tsx`
```tsx
import SongIndex from './pages/songs/Index'

          <Route path="/songs" element={<SongList songs={songs} />}>
            <Route index element = {<SongIndex />} />  // 여기만 추가
            <Route path=":id" element={<Player songs={songs} />} />
          </Route>
```

- `npm run dev` 를 실행, 유튜브 플레이어를 실행 중일 때와 아닐 때를 비교하면 되겠다.

## 리액트 라우터가 제공하는 훅
| 리액트 라우터 훅     | 설명                                                                                                             |
| -------------------- | ---------------------------------------------------------------------------------------------------------------- |
| `useMatch()`         | 현재 요청 경로가 지정한 경로 패턴에 매칭되면 `PathMatch` 객체를 리턴한다. 해당 객체는 매칭된 경로 정보를 담는다. |
| `useParams()`        | URI 파라미터 값을 포함하는 `Params` 객체를 리턴한다.                                                               |
| `useSerachParams()`  | 현재 요청의 쿼리 문자열을 읽거나 수정할 수 있다. `?a=1&b=2`처럼 URL 뒤에 붙는 정보를 의미함.                     |
| `useLocation()`      | 현재 요청된 경로 정보를 포함하는 `Location` 객체를 리턴한다.                                                     |
| `useNavigate()`      | 화면 전환을 위한 `Navigate` 함수를 리턴한다.                                                                       |
| `useOutletContext()` | 상위 경로에 상태를 저장, `Outlet` 컴포넌트에 렌더링하는 자식 컴포넌트에서 상태에 접근할 수 있도록 한다.                                                                                                                 |

### useMatch
- 현재 요청된 URI 경로가 인자로 전달한 경로 패턴과 매칭하는지 확인하고, `PathMatch` 객체를 리턴한다.
```tsx
const pathMatch = useMatch(경로 패턴);
```
> 응답 객체의 속성
> `params` : URI 경로 파라미터
> `pathname` : 요청된 경로
> `pattern` : 요청된 경로 패턴

- 적용 예시 : 현재 재생 중인 영상을 목록에서 식별할 수 있도록 스타일을 지정한다.
- `SongList.tsx`
```tsx
import { Link, Outlet, useMatch } from 'react-router-dom'

const SongList = (props: Props) => {
    const pathMatch = useMatch('/songs/:id'); // PathMatch 객체 반환
    let param_id: number = pathMatch?.params?.id ? parseInt(pathMatch.params.id, 10) : -1;
	let list = props.songs.map((song) => {
        let cn = "list-group-item";
        cn += param_id === song.id ? " list-group-item-secondary" : "";
        return (
            <li className={cn} key={song.id}>
```
> `SongList`에서 `useMatch` 훅을 이용해 현재 요청된 경로에 매칭되는 `PathMatch` 객체를 받고, 여기서 `id` 파라미터를 알 수 있다.
> 이후 이 `id`를 반복적으로 렌더링할 때, 각 곡의 `id`와 비교하여 `param_id === song_id`일 때만 `list-group-item-secondary`라는 CSS 클래스가 적용되도록 한다.
> 참고) `useMatch` 훅을 쓸 때, 상대경로`'./songs/:id'`를 쓰면 안된다. 나도 모르게 입력했다가 스타일 적용 안돼서 한참 헤맴;

### useSearchParams
- 요청 시 전달하는 쿼리 문자열 정보를 읽어내거나 설정하는 기능을 제공한다.
```tsx
const [searchParams, setSerachParams] = useSearchParams();
```
> `searchParams` : 쿼리 문자열을 읽을 수 있는 전용 객체.
> 	`?a=1&b=2`처럼 요청했다면, `searchParams.get('a')`처럼 접근할 수 있다.
> `setSearchParams` : 쿼리 문자열을 설정할 수 있는 기능을 제공하는 함수.
> 	`setSearchParams({ a:3, b:4 })`처럼 설정할 수 있다.

- 예시 : `About` 컴포넌트에 적용하며, 페이징을 할 때 쿼리 문자열을 자주 사용하는 걸 이용해 페이징 기능만을 `About` 컴포넌트에 추가한다.
- `About.tsx`
```tsx
import { useEffect, useState } from 'react'
import { useSearchParams, useNavigate } from 'react-router-dom'


type Props = { title: string };

const About = (props: Props) => {
  let [searchParams, setSearchParams] = useSearchParams();
  const [page, setPage] = useState<number>(1);
  const navigate = useNavigate()

  useEffect(() => {
    const strPage = searchParams.get("page");
    setPage(parseInt(strPage !== null ? strPage : "1", 10));
  }, [searchParams]);

  const goPrev = () => {
    if (page > 1) navigate(location.pathname + "?page=" + (page - 1));
  };

  const goNext = () => {
    navigate(location.pathname + "?page=" + (page + 1));
  };

  return (
    <div className="card card-body">
        <h1>About {props.title}</h1>
        <div className="m-2">현재 페이지 : {page}
	        <button className="btn btn-secondary m-1" onClick={goPrev}>prev</button>
	        <button className="btn btn-secondary m-1" onClick={goNext}>next</button>
        </div>
    </div>
  )
}

export default About;
```

> - 리액트의 `Provider`와 `Context API`
> - 위 코드를 실행한 후 `Components` 탭을 보면, `Route.Provider, Navigation.Provider`처럼 Provider들이 보인다. 
> - 리액트 라우터는 자체적으로 `Context API`를 사용한다. 그리고 `Context` 정보에 접근해서 필요한 정보를 획득하는 것이 리액트 라우터의 훅들이다. 기억해두자.

### useNavigate, useLocation

- `useNavigate` 훅을 호출하면 URI 경로를 이동할 수 있는 `navigate` 함수가 리턴된다.
```tsx
const navigate = useNavigate();
```
> `navigate(to, options)`
> 	- `to` : 이동하려는 경로
> 	- `options` : 이동 시 지정할 수 있는 옵션
> 		- `replace` : 내부적으로 이용하는 브라우저 히스토리의 현재 항목을 교체할 것인지를 `true/false`로 지정한다. 디폴트는 `false`
> 		- `state` : 내비게이션할 때의 상태 정보이다. 경로 이동이 완료된 후 `location` 객체의 `state` 속성을 이용해 접근할 수 있다.

- `navigate` 함수 대신, `JSX 구문`에 포함시켜서 선언적으로 쓸 수 있는 `<Navigate />` 컴포넌트도 있다. `isLoggined` 값이 `false`라면 `/login` 경로로 바로 이동시킨다.
```jsx
import { Navigate } from 'react-router-dom'

return (
	<div>
		{ isLoggined ? <App /> : <Navigate to="/login" replace={true} /> }
	</div>
)
```

- 예시) `useNavigate`훅을 `Members` 컴포넌트의 `go Home` 버튼을 추가하여 구현하기
	- 어디에서 `Home`으로 이동했는지 식별할 수 있게 `state` 정보를 전달한다.
```tsx
import { useNavigate } from 'react-router'
import { MemberType } from '../App'

type Props = { members: Array<MemberType> };

const Members = (props: Props) => {
  const navigate = useNavigate();
  const goHome = () => {
    if (window.confirm("정말로 홈으로 이동할까요?")) {
      navigate('/', { state: { from:'/members' }});
    }
  }

  ...

  return (
    <div>
      <h2 className="m-4">Members</h2>
      <div className="container">
        <div className="row">{list}</div>
      </div>
      <button className="btn btn-secondary" onClick={goHome}>
        Go Home
      </button>
    </div>
  )
}

export default Members;
```
> `state : { from:'/members' }` 정보에 액세스하려면 `useLocation` 훅을 사용하면 된다.

- `useLocation` 훅의 사용법
```tsx
const location = useLocation();
```
> - `location` 객체가 제공하는 속성
> 		`pathname` : 현재 요청된 경로
> 		`search` : 쿼리 문자열
> 		`state` : `navigate()`로 이동 시 전달된 `state` 정보

- `Home.tsx` 정보를 변경한다. `state` 정보를 이용한다.
```tsx
import React from 'react'
import { useLocation } from 'react-router'

type Props = {}
type LocationStateType = {
  from: string;
};

const Home = (props: Props) => {
  const location = useLocation();
  const state = location.state as LocationStateType;
  const from = state ? state.from : "";

  return (
    <div className="card card-body">
        <h2>Home</h2>
        {from !== "" ? <h4>state.from : {from}</h4> : ""}
    </div>
  )
}

export default Home;
```
> `useLocation()` 을 통해 `location` 객체를 획득한 후, 미리 정의해둔 `LocationStateType`으로 타입을 변환한다. 
> `state`가 존재하면 `state.from`을 받고, 아니라면 빈 문자열을 받는다. `state.from` 정보는 있을 때만 출력한다.

### useOutletContext
- 중첩된 라우트를 사용할 때 상위 경로의 `<Outlet />` 컴포넌트를 이용해 상태 정보를 저장해두고, 하위 경로에 접근할 수 있도록 하는 기능을 제공한다.
- 사용법은 크게 2단계로 이뤄진다.
	1. 상위 라우트가 렌더링하는 컴포넌트(`<Outlet />`  컴포넌트를 렌더링하는 컴포넌트)에서 상태 또는 속성을 `<Outlet />` 컴포넌트의 `context`에 지정하여 전달한다.
	2. 중첩 라우트의 자식 컴포넌트에서 `useOutletContext()` 훅을 이용해 `context` 객체를 받아서 이용한다.

- 사용법
```tsx
// 상위 라우트 컴포넌트에서 상태를 context로 전달
const parentComponent = () => {
	const [title, setTitle] = React.useState("Hello React!");
	return (
	...
	<Outlet context = {{ title }} />
	)
};

// 중첩 라우트 컴포넌트에서 useOutletContext 훅으로 context 객체를 이용하는 경우
type ContextStateType = { title : string; };
const childComponent = () => {
	const { title } = useOutletContext<ContextStateType>();
	...
}
```

- `router-test-app`에 `useOutletContext` 훅 적용해보기
- 비교
	- 기존에는 `Player` 컴포넌트에도 `songs` 속성을 전달했다.
```tsx
<Route path="/songs" element={<SongList songs={songs} />}>
	<Route index element={<SongIndex />} />
	<Route path=":id" element={<Player songs={songs} />} />
</Route>
```

- `Player` 컴포넌트가 `SongList`와 항상 함께 사용되고, 중첩 라우트로 사용된다고 가정한 뒤, `OutletContext` 속성을 이용해 `songs` 속성을 전달하도록 바꾼다.
```tsx
<Route path="/songs" element={<SongList songs={songs} />}>
	<Route index element={<SongIndex />} />
	<Route path=":id" element={<Player />} />
</Route>
```

- `SongList.tsx`의 `songs` 부분을 `<Outlet context>`를 이용해 전달받도록 변경한다.
```tsx
            <Outlet context={{ songs: props.songs }}/>
```

- 마지막으로 `Player` 컴포넌트에서 속성이 아닌 `useOutletContext` 훅을 이용해 `songs` 데이터를 이용하도록 변경한다.
```tsx
// type Props = { songs: Array<SongType> };
type Props = {};
type SongIdParam = { id: string }; 
type ContextType = { songs: Array<SongType> };

const Player = (props: props) => {
    const { songs } = useOutletContext<ContextType>(); // props 대신 context로 받는다
    ...
    
	useEffect(() => {
        const id = params.id ? parseInt(params.id, 10) : 0;
        // const song = props.songs.find((song) => song.id === id);
        const song = songs.find((song) => song.id === id);
        ...
```

## 라우터 관련 컴포넌트
- 여기까지 `BrowserRouter, Routes, Route, Link, Navigate` 컴포넌트들을 다뤘으며, 여기서는 이외의 다른 컴포넌트를 다룬다.

### Router 컴포넌트

- `BrowserRouter`
	- HTML5 History API를 사용하여 URI와 UI를 동기화한 상태를 유지할 수 있는 기능을 제공한다. `BrowserRouter`는 URI 경로를 사용하여 브라우저의 주소를 저장하고, 브라우저 history 객체의 스택을 사용해 탐색한다. 
	- `BrowserRouter` 사용은 웹 브라우저에서 리액트 라우터를 적용할 때 가장 권장하는 방법이다.
- `HashRouter`
	- URL의 해시 정보를 이용해서 URI 경로와 UI를 동기화한 상태로 유지시킨다. 해시는 `#` 기호로 표시된다. 
	- `BrowserRouter`가 지원되지 않는 환경일 때 사용을 권장한다.
	- `https://localhost:3000/#/about` 같이 `#/about`처럼 라우팅에 사용하는 경로가 브라우저의 주소 입력란에 찍힌다.
- `MemoryRouter`
	- 앱의 메모리 영역에 배열을 만들어 라우팅 정보를 저장하고 UI와 동기화시킨다.
	- URI 경로는 브라우저 주소창에 표시되지 않고, 메모리에만 유지된다. 브라우저 주소 UI를 보여주지 않아도 되는 하이브리드 앱 등에서 이용 가능하다.

**`BrowserRouter`를 쓰려면 리액트 앱을 호스팅하는 웹 서버가 `fallback UI`를 지원**해야 한다. 이는 웹 서버에서 `404 Not Found`가 발생하더라도 정해진 기본 페이지를 응답하는 기능으로, `fallback UI`에 대해 알아야 한다.
  
SPA는 웹 브라우저에서 작동되면서 라우팅한다. 
- 만약 `fallback UI` 를 지원하지 않는 웹 서버에 호스팅된 리액트 라우터 앱을 브라우저에서 실행할 때, 브라우저에 직접 주소를 입력하고 요청하면 `404 Not Found`가 발생한다. 왜냐하면 SPA는 HTML 문서를 `/index.html` 단 1개만 갖고 있기 때문이다. `/about` 경로의 리소스가 존재하지 않는다.
- 한편, **`fallback UI`를 지원한다면 `/about 요청 -> /.index.html 응답 -> /about 경로에 대한 라우팅 수행`의 과정**으로 진행된다. 
	- `server/about`은 존재하지 않는 경로이지만, 일단 `index.html` 문서를 응답한 다음, 웹 브라우저 상에서 리액트 라우터 앱이 `<Route />` 컴포넌트로 매칭된 컴포넌트를 매칭해주는 것이다.

> 웹 서버에 `fallback UI`를 설정하는 방법?
> - 웹 서버마다 `fallback UI`를 지정하는 방법이 다르다. 따라서 직접 찾아보는 게 좋다.
> - [vue.js의 공식 문서 내용](https://v3.router.vuejs.org/kr/guide/essentials/history-mode.html#서버-설정-예제)에는 서버 설정 방법이 공개되어 있다. `Apache, Nginx, Node.js, Express, IIS` 등 주요 웹 서버의 설정 방법이 있다.

### fallback UI가 없는 웹 서버에서의 에러 확인
- `router-test-app` 프로젝트에서 진행한다. 
- 지금까지는 `npm run dev`를 통해 실행한 개발 서버로, `fallback UI`가 `/index.html`로 지정되어 있다. 
- `fallback UI`가 없는 서버를 구동하는 방법은 아래와 같다.
	1. `router-test-app` 빌드
		- 프로젝트 디렉터리에서 `npm run build` 명령을 실행한다. 산출물은 `dist` 디렉터리에 저장됨.
	2. `node` 기반의 웹 서버 구동
		- 프로젝트 디렉터리에서 `npx serve dist --listen 3000` 명령으로 웹 서버를 구동한다.
		- `serve`는 `node` 기반의 웹 서버인데, `fallback UI` 기능이 없다. 위 명령은 `dist` 디렉터리를 웹 서버의 루트 디렉터리로 설정하여 웹 서버를 구동한 것으로, 브라우저에서 확인해보자.
	3. `http://localhost:3000/about` 직접 입력

- `npm run dev`로 들어가면, `/about`으로 들어가도 정상적인 `About` 컴포넌트가 나타난다.

- `fallback UI`를 지원하도록 웹 서버를 설정할 수 없다면, 라우터로 `HashRouter`를 사용할 수 있다. 
	- 웹 서버가 `fallback UI`를 지원하지 않아도 에러가 발생하지 않는다.

- 사용법은 `import`만 다르게 해주면 됨
- `App.tsx`
```tsx
import { HashRouter as Router, Routes, Routes } from 'react-router-dom'
```
- 이 상태에서 `npm run dev`로 개발 서버를 실행하고 `About` 메뉴를 클릭하면 `http://localhost:3000/#/about`으로 나타난다.
	- `#` 기호를 기준으로 앞부분은 웹 서버로 요청하는 경로이고, 뒷부분은 문서 내부의 컨텐츠이다.
	- 따라서 해시 라우터를 사용하면 `https://localhost:3000/`까지만 요청되어 기본 문서인 `/index.html`을 응답하므로, `404` 에러 없이 정상적으로 실행된다.

### 404 라우트와 리디렉션 구성
- 리액트 앱을 배포할 웹 서버가 `fallback UI`를 **지원하는 경우의 문제점**이 있다.
- 다시 `BrowserRouter`로 복원한 다음 개발 서버로 실행한 뒤, URL에 `<Route />`에 매칭되지 않는 경로를 브라우저에 요청하면, `<Route />` 부분에 아무것도 나타나지 않는다.
- 이 때 우리가 사용하는 웹 서버는 `fallback UI`를 지정했기 때문에 `404 에러` 대신 `index.html`을 응답한다. 따라서 **`404 에러` 화면을 리액트 라우터 수준에서 처리하는데, 이를 `404 라우트`라고 부른다.**
	  - `404 라우트`는 App 컴포넌트에서 `Routes /` 내부의 마지막에 `<Route path="*" ... />`처럼 만들어주면 된다.
  - **리액트 라우터의 `<Route />`는 위에서 아래로 내려오면서 경로의 매칭 여부를 확인하다가 매칭되는 것이 발견되면 그 컴포넌트를 렌더링한다. 즉, 매칭된 이후의 `<Route />`는 매칭 여부를 확인하지 않는다.**
  - 따라서 존재하지 않는 경로에 대해서는 레이아웃을 제외하고 아무 것도 나타나지 않는다.
  - 이 문제를 해결하기 위해 **`404 라우트`를 마지막에 배치**하며, 사용법은 아래와 같다.
```tsx
<Routes>
	...
	<Route path='*' element={ <NotFound /> } />
</Routes>
```
> 경로를 `*`으로 지정해서 이전에 매칭된 것이 없다면, `404 라우트`에 지정한 컴포넌트가 렌더링되도록 설정한다.

- 또한, 특정 경로로 요청하면 다른 경로로 강제 이동시켜야 하는 경우가 있다. **이를 `리디렉션Redirection`이라고 하는데, 리액트 라우터 6 버전에서는 `<Navigate />`** 를 쓰면 된다.
```tsx
<Route path="/a" element={<Navigate to="/b" />} />
<Route path="b" element={<BComponent />} />
```

- `router-test-app` 프로젝트에 404 라우트와 리디렉션 기능을 적용해보자.
- `components/NotFound.tsx` 컴포넌트를 새로 추가한다.
```tsx
import React from 'react'
import { useLocation } from 'react-router'

const NotFound = () => {
    const location = useLocation();
  return (
    <div className="m-3">
        <h3>존재하지 않는 경로</h3>
        <p>요청 경로 : {location.pathname}</p>
    </div>
  )
}

export default NotFound
```

- `App.tsx`의 `Route /` 컴포넌트를 설정한다.
```tsx
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom'
import NotFound from './components/NotFound'

...

  return (
            {/* <Route path="/" element={<Home />} /> */}
          <Route path="/" element={<Navigate to="/home" />} />
          <Route path="/home" element={<Home />} />
          </Route>
              <Route path="*" element={<NotFound />} />
		  </Routes>
```
> 리디렉션 기능 : `/`로 요청하면 `/home`으로 리디렉션되며, `/home` 경로에서 `Home` 컴포넌트를 렌더링한다.
> `NotFound` 부분은 `404 라우트` 부분.

- 이렇게 작성하면 존재하지 않는 경로에 대해서는 ![[Pasted image 20231129203335.png]]이 뜬다.

### NavLink 컴포넌트
- 이전에 `Header` 컴포넌트에서 화면 전환 링크를 생성하기 위해 `Link` 컴포넌트를 사용했다.
- `NavLink` 컴포넌트는 `Link` 컴포넌트와 유사해보이나, **현재 요청된 경로와의 일치 여부에 따라 각기 다른 스타일을 부여할 수 있는 `Link` 컴포넌트**이다.
```tsx
// style에 동적으로 부여
<NavLink to="/blog" style={ ({ isActive }) => {
	return isActive ? activeStyle : undefined
}}> Blog </NavLink>

// className에 동적으로 부여
<NavLink to="/catalogs" className={({ isACtive }) => {
return isActive ? activeClassName : undefined
}}> Catalogs </NavLink>
```
> `style`과 `className` 속성에 함수를 바인딩하고 있으며, 함수의 인자로 전달된 객체의 `isActive` 속성에 따라 각기 다른 스타일과 클래스명을 리턴한다. 
> 이 함수는 `NavLink`의 내부에서 사용하며, `isActive` 값으로는 요청된 경로와 `NavLink`의 `to` 속성의 경로가 매칭될 때 `true`가 전달된다.

- 적용
```tsx
                <div className="col-12">
                    <NavLink to="/home" className={({ isActive }) => {
                        return isActive ? "btn menu btn-dark" : "btn menu btn-success";
                    }}>
                        Home
                    </NavLink>
                    <NavLink to="/about" className={({ isActive }) => {
                        return isActive ? "btn menu btn-dark" : "btn menu btn-success";
                    }}>
                        About
                    </NavLink>
                    <NavLink to="/members" className={({ isActive }) => {
                        return isActive ? "btn menu btn-dark" : "btn menu btn-success";
                    }}>
                        Members
                    </NavLink>
                    <NavLink to="/songs" className={({ isActive }) => {
                        return isActive ? "btn menu btn-dark" : "btn menu btn-success";
                    }}>
                        Songs
                    </NavLink>
                    {/* <Link className="btn btn-success menu" to="/">
                        Home
                    </Link>
                    <Link className="btn btn-success menu" to="/about">
                        About
                    </Link>
                    <Link className="btn btn-success menu" to="/members">
                        Members
                    </Link>
                    <Link className="btn btn-success menu" to="/songs">
                        Songs
                    </Link> */}
                </div>
```
> `NavLink`에 지정한 특성으로 인해 현재 요청과 매칭되는 메뉴는 `NavLink`의 스타일로 인해 메뉴 스타일이 다르게 나타난다.


## 리액트 라우터와 레이지 로딩 기법

### 레이지 로딩이란?
- `SPA`는 `index.html` 파일 하나와 다수의 자바스크립트 코드, CSS 파일로 구성된다.
- 이러한 구성 때문에 SPA에는 약간의 문제점이 있다 : 리액트 라우터를 적용한 수백에서 수천 개의 화면과 컴포넌트로 구성된 앱이면 아래처럼 동작한다.
> 1. 브라우저 -> 웹 서버 : `/` 경로 요청
> 2. 웹 서버 -> 브라우저 : 모두 응답
		- `index.html`과 필요한 모든 산출물(`.js` 파일 포함)을 브라우저로 응답합니다.
	3. 브라우저 : `/` 경로의 컴포넌트만 렌더링
	4. 브라우저 : `/about`으로 내비게이션
	5. 브라우저 : `/about`을 라우팅하여 컴포넌트 렌더링
		- 서버에 요청하지 않고, 이미 다운받은 `.js` 파일의 컴포넌트를 이용해 브라우저에서 렌더링한다.
- 수백, 수천 개의 컴포넌트를 작성할 때 만들어진 `ts` 파일은 모두 빌드 과정을 거쳐서 하나 또는 몇 개의 `.js` 파일로 빌드된다. 빌드된 파일은 모든 컴포넌트를 묶은 것으로, 파일의 크기도 클 것으로 예상할 수 있다.
- 빌드된 파일을 웹 서버에 배포할 경우 사용자가 첫 화면을 로딩하는 과정은 위에 설명한 내용과 같다. **브라우저는 첫 화면을 로딩하기 위해 한꺼번에 모든 화면을 위한 `.js` 파일을 다운받는다.** 이것 때문에 첫 화면을 보는 시간이 길어질 수 있는데, 이를 해결하는 방법 중 하나다 `lazy loading` 기법이다.

- `Lazy Loading`은 **리액트 앱의 수많은 화면과 컴포넌트 코드를 적절히 구분해 화면, 컴포넌트 그룹 단위로 여러 개의 `청크Chunk`라 부르는 `.js` 파일로 빌드하고 특정 컴포넌트가 필요한 시점에 서버에 요청해서 청크 파일을 응답받아 렌더링**하는 방법이다.
- 레이지 로딩 기법은 아래와 같다.
> 1. `/` 경로 요청
> 2. `index.html` + `home.js` 응답
> 3. `/` 경로의 컴포넌트 렌더링
> 4. `/about`으로 내비게이션
> 5. `/about` 라우팅을 위한 `.js` 파일 요청
> 6. `about.js` 요청
> 7. `about.js` 응답
> 8. `/about` 경로의 컴포넌트 렌더링

- 즉 간단하게 말하면 전체 덩어리를 첫 화면에서 한꺼번에 받는 게 아니라, 그때그때 필요한 덩어리 단위를 필요할 때마다 받는 방식이라는 것이다.

### 적용 방식
```tsx
// 기존의 정적 import
import Home from './Home'

// React.lazy()와 import 함수 사용
const Home = React.lazy(() => import("./Home"));

// webpackChunkName 지정
const Home = React.lazy(() => import(/* webpackChunkName:"home" */ "./Home"));
const Blog = React.lazy(() => import(/* webpackChunkName:"home" */ "./Blog"));
```
> - `레이지 로딩`을 적용하려면 2번째 방법처럼 `React.lazy()`와 `import` 함수를 쓰면 된다. 앱을 실행할 떄 `Home` 컴포넌트가 필요한 시점이 되면 `React.lazy()`에 등록된 함수가 실행되면서 비동기로 컴포넌트를 임포트해온다.
> - `webpackChunkName` 주석 부분은 이름이 같은 것끼리 모아 청크 파일을 생성하며, 생성된 청크 파일의 이름은 `home.f4cleac5.js` 같은 형태이다. `webpackChunkName`은 함께 사용되는 컴포넌트를 모아 하나의 청크로 생성해주는 기능이다.
> 	- 이 기능은 코드를 여러 조각으로 분할해준다고 하여 `코드 스플리팅Code Splitting`이라고 한다.

> - `webpackChunkName`을 사용하려면 알아둬야 할 사항
> 	- `webpack`이라는 빌드 시스템이 지원하는 기능이다.
> 	- `CRA : Create-React-App` 도구를 이용해 리액트 프로젝트를 생성했다면, `webpack`이 기본으로 지원되므로 별도의 설정 없이 `webpackChunkName` 기능을 사용할 수 있지만, `Vite`으로 생성된 프로젝트인 경우는 별도의 설정이 필요하다.
> 		1. `Vite`에서 쓸 수 있도록 `npm install -D vite-plugin-webpackchunkname`
> 		2. `vite.config.js`에 플러그인의 설정을 추가한다.
```tsx
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { manualChunksPlguin } from 'vite-plugin-webpackchunkname'

// https://vitejs.dev/config/
export default defineConfig({
	plugins: [ react(), manualChunksPlugin() ],
})
```

### Suspense 컴포넌트
- 필요할 때마다 로딩하면 실행 중에 지연 시간이 발생할 수 있다. 
- 따라서 지연 시간이 길어진다면 로딩 중인 화면을 보여주는 게 좋다. 이런 화면을 **`fallback UI`라고 부르며, 이 기능을 쉽게 구현할 수 있도록 도와주는 컴포넌트가 `Suspense` 컴포넌트**이다.
```tsx
// fallback 속성에는 발생한 지연 시간 동안 보여줄 컴포넌트를 지정할 수 있다.
// 1. 특정 컴포넌트를 감싼다.
<React.Suspense fallback={<Loading />}>
	<TestComponent />
</React.Suspense>

// 2. <Router /> 컴포넌트로 감쌀 수도 있다.
<React.Suspense fallback={<Loading />}>
	<Router>
	...
	</Router>
</React.Suspense>
```
- `Suspense` 컴포넌트는 일반적인 컴포넌트를 처리할 수 있지만, `<Router />` 컴포넌트를 자식 컴포넌트로 포함할 수도 있다. 이 경우 라우트 경로가 바뀔 때마다 필요한 청크 파일을 레이지 로딩하게 된다.
### 레이징 로딩 적용하기
- 우선 아래 패키지들을 설치한다.
```sh
npm install react-spinners p-min-delay
npm install -D vite-plugin-webpackchunkname
```
> - `vite-plugin-webpackchunkname`는 개발하고 빌드할 때만 필요하므로, `-D`를 지정해 개발 의존성으로 설치한다.
> - `react-spinners` : 지연 시간 동안 보여줄 컴포넌트를 제공한다.
> - `p-min-delay` : 의도적으로 지연 시간을 발생시키는 기능을 제공한다. 실제 코드에서는 당연히 전혀 필요하지 않다.

- `vite.config.js` 변경
```js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { manualChunksPlugin } from 'vite-plugin-webpackchunkname'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react(), manualChunksPlugin()],
})
```

- `components/Loading.tsx`
```tsx
import React from 'react'
import { ScaleLoader } from 'react-spinners'

const Loading = () => {
  return (
    <div className="w-100 h-75 position-fixed">
        <div className="row w-100 h-100 justify-content-center align-items-center">
            <div className="col-6 text-center">
                <h3>Loading</h3>
                <ScaleLoader height="40px" width="6px" radius="2px" margin="2px" />
            </div>
        </div>
    </div>
  )
}

export default Loading
```

- `App.tsx`
```tsx
import pMinDelay from 'p-min-delay'
import Loading from './components/Loading'

// import Home from './pages/Home'
// import About from './About'
// import SongList from './pages/SongList'
// import Members from './pages/Members'
// // import SongDetail from './pages/SongDetail'
// // import SongDetail from './pages/SongDetail2'
// import Player from './pages/songs/Player'
// import SongIndex from './pages/songs/Index'
// import NotFound from './components/NotFound'

const Home = React.lazy(() => pMinDelay(import("./pages/Home"), 1000));
const About = React.lazy(() => pMinDelay(import("./pages/About"), 1000));
const SongList = React.lazy(() => pMinDelay(import("./pages/SongList"), 1000));
const Members = React.lazy(() => pMinDelay(import("./pages/Members"), 1000));
const Player = React.lazy(() => pMinDelay(import("./pages/songs/Player"), 1000));
const SongIndex = React.lazy(() => pMinDelay(import("./pages/songs/Index"), 1000));
const NotFound = React.lazy(() => pMinDelay(import("./components/NotFound"), 1000));

  return (
    <React.Suspense fallback={<Loading />}>
      <Router>
      ...
      </Router>
    </React.Suspense>
  )
}
```
> 1. `React.lazy()`로 레이지 로딩
> 2. `p-min-delay`와 `Loading` 컴포넌트도 임포트
> 3. `<Router />`를 `Suspense` 컴포넌트로 감싸면서, `fallback UI`로 `Loading` 컴포넌트를 렌더링하도록 지정한다.
> - 여기서는 `webpackChunkName`을 지정하지 않았는데, 지정하고 싶다면 아래처럼 지정한다.
```tsx
const Home = React.lazy(() => pMinDelay(import("./pages/Home"), 1000));

// import 부분부터 아래처럼 바꿀 수 있다.
import(/* webpackChunkName:"home" */ "./pages/Home")
```

- `npm run dev`로 구동하고 첫 화면을 띄웠을 때, 로딩 화면을 볼 수 있다.
- 그러나 이미 컴포넌트를 로딩한 화면으로 다시 간다면, 레이지 로딩이 발생하지 않는다.
- `npm run build`를 입력하면 `dist` 디렉터리에 빌드된 청크 파일들을 확인할 수 있다.

### 마무리 글
- 리액트 라우터는 리액트를 이용해 SPA를 개발하기 위한 중요한 라이브러리로, SPA는 하나의 HTML 페이지에서 수많은 화면을 처리해야 하므로 리액트 라우터 같이 요청 경로에 따라 홤녀을 쉽게 전환할 수 있는 기능을 제공하는 라이브러리가 꼭 필요하다.
- 리액트 라우터가 제공하는 `Router, Routes, Route` 컴포넌트를 조합해 요청 경로에 따라 렌더링할 컴포넌트를 지정할 수 있다. 중첩된 라우트를 이용하면 손쉽게 요청된 URI 경로에 의해 중첩된 컴포넌트 트리를 생성할 수 있다. 중첩된 자식 라우트에 의해 컴포넌트가 렌더링되려면 부모 라우트에 `Outlet` 컴포넌트를 배치해야 한다.
- 라우팅된 자식 컴포넌트로 동적인 값을 전달하기 위해 속성을 이용할 수 있다. `<Route element= />`로 전달할 수 있다. URI 경로의 파라미터를 전달할 떄는 `<Route path=/orders/:id>`처럼 `:` 기호와 함께 사용할 파라미터 이름을 지정한다. 이 위치에 전달된 URI 파라미터는 자식 컴포넌트에서 `useParams` 훅을 통해 접근할 수 있다.
- `BrowserRouter`를 사용할 때는 웹 서버가 `fallback UI`를 지원해야 하며, 존재하지 않는 경로로 요청했을 때 보여줄 404 라우트를 반드시 설정해주자.
- 대규모 앱을 개발할 때는 레이징 로딩 기법을 적용할 수 있다. 프로젝트를 빌드할 때 컴포넌트나 경로 단위로 묶어 여러 개의 `.js` 파일 조각을 생성할 수 있고, `React.lazy(), import()` 함수를 이용해 컴포넌트가 필요한 시점에 로딩할 수 있다. 초기 화면을 더 빠르게 구성할 수 있다.
- 리액트 라우터는 **많은 컴포넌트와 화면으로 구성된 대규모 리액트 앱을 개발할 때 반드시 사용**하는 중요한 라이브러리이므로 반드시 숙지해야 한다.